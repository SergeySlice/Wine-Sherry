commit 6fb7d279b6544e1da858a36c4e2cd4cf380878bb
Author: Sergey Isakov <isakov-sl@bk.ru>
Date:   Tue Feb 12 19:44:14 2019 +0300

    implemented patches for 39816 and 46630
    
    Signed-off-by: Sergey Isakov <isakov-sl@bk.ru>

diff --git a/dlls/bcrypt/bcrypt_main.c b/dlls/bcrypt/bcrypt_main.c
index ca2f274..99fe0e7 100644
--- a/dlls/bcrypt/bcrypt_main.c
+++ b/dlls/bcrypt/bcrypt_main.c
@@ -1150,6 +1150,19 @@ static NTSTATUS key_import_pair( struct algorithm *alg, const WCHAR *type, BCRYP
     ERR( "support for keys not available at build time\n" );
     return STATUS_NOT_IMPLEMENTED;
 }
+
+NTSTATUS key_asymmetric_generate( struct key *key )
+{
+    FIXME( "support for keys not available at build time\n" );
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+NTSTATUS key_asymmetric_init( struct key *key, struct algorithm *alg, const UCHAR *pubkey, ULONG pubkey_len )
+{
+    FIXME( "support for keys not available at build time\n" );
+    return STATUS_NOT_IMPLEMENTED;
+}
+ 
 #endif
 
 NTSTATUS WINAPI BCryptGenerateSymmetricKey( BCRYPT_ALG_HANDLE algorithm, BCRYPT_KEY_HANDLE *handle,
diff --git a/dlls/bcrypt/gnutls.c b/dlls/bcrypt/gnutls.c
index fe6fe9c..1b2905e 100644
--- a/dlls/bcrypt/gnutls.c
+++ b/dlls/bcrypt/gnutls.c
@@ -51,7 +51,6 @@ WINE_DECLARE_DEBUG_CHANNEL(winediag);
 #define GNUTLS_CIPHER_AES_128_GCM 93
 #define GNUTLS_CIPHER_AES_256_GCM 94
 #define GNUTLS_PK_ECC 4
-#define GNUTLS_PK_ECDSA 4
 
 #define GNUTLS_CURVE_TO_BITS(curve) (unsigned int)(((unsigned int)1<<31)|((unsigned int)(curve)))
 
@@ -65,6 +64,10 @@ typedef enum
 } gnutls_ecc_curve_t;
 #endif
 
+#ifndef GNUTLS_PK_ECDSA
+#define GNUTLS_PK_ECDSA 4
+#endif
+
 /* Not present in gnutls version < 3.0 */
 static int (*pgnutls_cipher_tag)(gnutls_cipher_hd_t, void *, size_t);
 static int (*pgnutls_cipher_add_auth)(gnutls_cipher_hd_t, const void *, size_t);
diff --git a/dlls/d3d10/Makefile.in b/dlls/d3d10/Makefile.in
index 0e4cd6a..0c7c63b 100644
--- a/dlls/d3d10/Makefile.in
+++ b/dlls/d3d10/Makefile.in
@@ -1,12 +1,21 @@
 MODULE    = d3d10.dll
 IMPORTLIB = d3d10
 IMPORTS   = dxguid uuid d3d10core d3dcompiler dxgi
+PARENTSRC = ../d3dcompiler_43
 
 C_SRCS = \
 	d3d10_main.c \
+	d3d10_utils.c \
 	effect.c \
+	reflection.c \
 	shader.c \
 	stateblock.c \
 	utils.c
 
+LEX_SRCS = \
+	hlsl.l
+
+BISON_SRCS = \
+	hlsl.y
+
 RC_SRCS = version.rc
diff --git a/dlls/d3d10/d3d10_main.c b/dlls/d3d10/d3d10_main.c
index 9b1e249..76fc4fe 100644
--- a/dlls/d3d10/d3d10_main.c
+++ b/dlls/d3d10/d3d10_main.c
@@ -294,6 +294,7 @@ const char * WINAPI D3D10GetPixelShaderProfile(ID3D10Device *device)
     return "ps_4_0";
 }
 
+/*
 HRESULT WINAPI D3D10ReflectShader(const void *data, SIZE_T data_size, ID3D10ShaderReflection **reflector)
 {
     struct d3d10_shader_reflection *object;
@@ -315,3 +316,4 @@ HRESULT WINAPI D3D10ReflectShader(const void *data, SIZE_T data_size, ID3D10Shad
 
     return S_OK;
 }
+*/
diff --git a/dlls/d3d10/d3d10_private.h b/dlls/d3d10/d3d10_private.h
index e785b8b..ec3919e 100644
--- a/dlls/d3d10/d3d10_private.h
+++ b/dlls/d3d10/d3d10_private.h
@@ -296,7 +296,6 @@ static inline BOOL require_space(size_t offset, size_t count, size_t size, size_
     return !count || (data_size - offset) / count >= size;
 }
 
-void skip_dword_unknown(const char *location, const char **ptr, unsigned int count) DECLSPEC_HIDDEN;
 void write_dword_unknown(char **ptr, DWORD d) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_D3D10_PRIVATE_H */
diff --git a/dlls/d3d10/effect.c b/dlls/d3d10/effect.c
index cd6f4a3..4dd8552 100644
--- a/dlls/d3d10/effect.c
+++ b/dlls/d3d10/effect.c
@@ -41,6 +41,19 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d10);
 
 #define D3D10_FX10_TYPE_MATRIX_COLUMN_MAJOR_MASK 0x4000
 
+static void skip_dword_unknown(const char *location, const char **ptr, unsigned int count)
+{
+    unsigned int i;
+    DWORD d;
+
+    FIXME("Skipping %u unknown DWORDs (%s):\n", count, location);
+    for (i = 0; i < count; ++i)
+    {
+        read_dword(ptr, &d);
+        FIXME("\t0x%08x\n", d);
+    }
+}
+
 static const struct ID3D10EffectTechniqueVtbl d3d10_effect_technique_vtbl;
 static const struct ID3D10EffectPassVtbl d3d10_effect_pass_vtbl;
 static const struct ID3D10EffectVariableVtbl d3d10_effect_variable_vtbl;
diff --git a/dlls/d3d10/shader.c b/dlls/d3d10/shader.c
index c97d8df..31cd19c 100644
--- a/dlls/d3d10/shader.c
+++ b/dlls/d3d10/shader.c
@@ -25,118 +25,6 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d10);
 
-/* IUnknown methods */
-
-static inline struct d3d10_shader_reflection *impl_from_ID3D10ShaderReflection(ID3D10ShaderReflection *iface)
-{
-    return CONTAINING_RECORD(iface, struct d3d10_shader_reflection, ID3D10ShaderReflection_iface);
-}
-
-static HRESULT STDMETHODCALLTYPE d3d10_shader_reflection_QueryInterface(ID3D10ShaderReflection *iface, REFIID riid, void **object)
-{
-    TRACE("iface %p, riid %s, object %p\n", iface, debugstr_guid(riid), object);
-
-    if (IsEqualGUID(riid, &IID_ID3D10ShaderReflection)
-            || IsEqualGUID(riid, &IID_IUnknown))
-    {
-        IUnknown_AddRef(iface);
-        *object = iface;
-        return S_OK;
-    }
-
-    WARN("%s not implemented, returning E_NOINTERFACE\n", debugstr_guid(riid));
-
-    *object = NULL;
-    return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE d3d10_shader_reflection_AddRef(ID3D10ShaderReflection *iface)
-{
-    struct d3d10_shader_reflection *This = impl_from_ID3D10ShaderReflection(iface);
-    ULONG refcount = InterlockedIncrement(&This->refcount);
-
-    TRACE("%p increasing refcount to %u\n", This, refcount);
-
-    return refcount;
-}
-
-static ULONG STDMETHODCALLTYPE d3d10_shader_reflection_Release(ID3D10ShaderReflection *iface)
-{
-    struct d3d10_shader_reflection *This = impl_from_ID3D10ShaderReflection(iface);
-    ULONG refcount = InterlockedDecrement(&This->refcount);
-
-    TRACE("%p decreasing refcount to %u\n", This, refcount);
-
-    if (!refcount)
-        heap_free(This);
-
-    return refcount;
-}
-
-/* ID3D10ShaderReflection methods */
-
-static HRESULT STDMETHODCALLTYPE d3d10_shader_reflection_GetDesc(ID3D10ShaderReflection *iface, D3D10_SHADER_DESC *desc)
-{
-    FIXME("iface %p, desc %p stub!\n", iface, desc);
-
-    return E_NOTIMPL;
-}
-
-static struct ID3D10ShaderReflectionConstantBuffer * STDMETHODCALLTYPE d3d10_shader_reflection_GetConstantBufferByIndex(
-        ID3D10ShaderReflection *iface, UINT index)
-{
-    FIXME("iface %p, index %u stub!\n", iface, index);
-
-    return NULL;
-}
-
-static struct ID3D10ShaderReflectionConstantBuffer * STDMETHODCALLTYPE d3d10_shader_reflection_GetConstantBufferByName(
-        ID3D10ShaderReflection *iface, const char *name)
-{
-    FIXME("iface %p, name %s stub!\n", iface, debugstr_a(name));
-
-    return NULL;
-}
-
-static HRESULT STDMETHODCALLTYPE d3d10_shader_reflection_GetResourceBindingDesc(
-        ID3D10ShaderReflection *iface, UINT index, D3D10_SHADER_INPUT_BIND_DESC *desc)
-{
-    FIXME("iface %p, index %u, desc %p stub!\n", iface, index, desc);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE d3d10_shader_reflection_GetInputParameterDesc(
-        ID3D10ShaderReflection *iface, UINT index, D3D10_SIGNATURE_PARAMETER_DESC *desc)
-{
-    FIXME("iface %p, index %u, desc %p stub!\n", iface, index, desc);
-
-    return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE d3d10_shader_reflection_GetOutputParameterDesc(
-        ID3D10ShaderReflection *iface, UINT index, D3D10_SIGNATURE_PARAMETER_DESC *desc)
-{
-    FIXME("iface %p, index %u, desc %p stub!\n", iface, index, desc);
-
-    return E_NOTIMPL;
-}
-
-const struct ID3D10ShaderReflectionVtbl d3d10_shader_reflection_vtbl =
-{
-    /* IUnknown methods */
-    d3d10_shader_reflection_QueryInterface,
-    d3d10_shader_reflection_AddRef,
-    d3d10_shader_reflection_Release,
-    /* ID3D10ShaderReflection methods */
-    d3d10_shader_reflection_GetDesc,
-    d3d10_shader_reflection_GetConstantBufferByIndex,
-    d3d10_shader_reflection_GetConstantBufferByName,
-    d3d10_shader_reflection_GetResourceBindingDesc,
-    d3d10_shader_reflection_GetInputParameterDesc,
-    d3d10_shader_reflection_GetOutputParameterDesc,
-};
-
 HRESULT WINAPI D3D10CompileShader(const char *data, SIZE_T data_size, const char *filename,
         const D3D10_SHADER_MACRO *defines, ID3D10Include *include, const char *entrypoint,
         const char *profile, UINT flags, ID3D10Blob **shader, ID3D10Blob **error_messages)
diff --git a/dlls/d3d10/tests/Makefile.in b/dlls/d3d10/tests/Makefile.in
index ceabc1f..50b1a3f 100644
--- a/dlls/d3d10/tests/Makefile.in
+++ b/dlls/d3d10/tests/Makefile.in
@@ -3,4 +3,5 @@ IMPORTS   = d3d10
 
 C_SRCS = \
 	device.c \
-	effect.c
+	effect.c \
+	reflection.c
diff --git a/dlls/d3d10/utils.c b/dlls/d3d10/utils.c
deleted file mode 100644
index 223b33a..0000000
--- a/dlls/d3d10/utils.c
+++ /dev/null
@@ -1,234 +0,0 @@
-/*
- * Copyright 2008-2009 Henri Verbeet for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- *
- */
-
-#include "config.h"
-#include "wine/port.h"
-
-#include "d3d10_private.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(d3d10);
-
-#define WINE_D3D10_TO_STR(x) case x: return #x
-
-const char *debug_d3d10_driver_type(D3D10_DRIVER_TYPE driver_type)
-{
-    switch(driver_type)
-    {
-        WINE_D3D10_TO_STR(D3D10_DRIVER_TYPE_HARDWARE);
-        WINE_D3D10_TO_STR(D3D10_DRIVER_TYPE_REFERENCE);
-        WINE_D3D10_TO_STR(D3D10_DRIVER_TYPE_NULL);
-        WINE_D3D10_TO_STR(D3D10_DRIVER_TYPE_SOFTWARE);
-        WINE_D3D10_TO_STR(D3D10_DRIVER_TYPE_WARP);
-        default:
-            FIXME("Unrecognized D3D10_DRIVER_TYPE %#x\n", driver_type);
-            return "unrecognized";
-    }
-}
-
-const char *debug_d3d10_shader_variable_class(D3D10_SHADER_VARIABLE_CLASS c)
-{
-    switch (c)
-    {
-        WINE_D3D10_TO_STR(D3D10_SVC_SCALAR);
-        WINE_D3D10_TO_STR(D3D10_SVC_VECTOR);
-        WINE_D3D10_TO_STR(D3D10_SVC_MATRIX_ROWS);
-        WINE_D3D10_TO_STR(D3D10_SVC_MATRIX_COLUMNS);
-        WINE_D3D10_TO_STR(D3D10_SVC_OBJECT);
-        WINE_D3D10_TO_STR(D3D10_SVC_STRUCT);
-        default:
-            FIXME("Unrecognized D3D10_SHADER_VARIABLE_CLASS %#x.\n", c);
-            return "unrecognized";
-    }
-}
-
-const char *debug_d3d10_shader_variable_type(D3D10_SHADER_VARIABLE_TYPE t)
-{
-    switch (t)
-    {
-        WINE_D3D10_TO_STR(D3D10_SVT_VOID);
-        WINE_D3D10_TO_STR(D3D10_SVT_BOOL);
-        WINE_D3D10_TO_STR(D3D10_SVT_INT);
-        WINE_D3D10_TO_STR(D3D10_SVT_FLOAT);
-        WINE_D3D10_TO_STR(D3D10_SVT_STRING);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE1D);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE2D);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE3D);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURECUBE);
-        WINE_D3D10_TO_STR(D3D10_SVT_SAMPLER);
-        WINE_D3D10_TO_STR(D3D10_SVT_PIXELSHADER);
-        WINE_D3D10_TO_STR(D3D10_SVT_VERTEXSHADER);
-        WINE_D3D10_TO_STR(D3D10_SVT_UINT);
-        WINE_D3D10_TO_STR(D3D10_SVT_UINT8);
-        WINE_D3D10_TO_STR(D3D10_SVT_GEOMETRYSHADER);
-        WINE_D3D10_TO_STR(D3D10_SVT_RASTERIZER);
-        WINE_D3D10_TO_STR(D3D10_SVT_DEPTHSTENCIL);
-        WINE_D3D10_TO_STR(D3D10_SVT_BLEND);
-        WINE_D3D10_TO_STR(D3D10_SVT_BUFFER);
-        WINE_D3D10_TO_STR(D3D10_SVT_CBUFFER);
-        WINE_D3D10_TO_STR(D3D10_SVT_TBUFFER);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE1DARRAY);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE2DARRAY);
-        WINE_D3D10_TO_STR(D3D10_SVT_RENDERTARGETVIEW);
-        WINE_D3D10_TO_STR(D3D10_SVT_DEPTHSTENCILVIEW);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE2DMS);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURE2DMSARRAY);
-        WINE_D3D10_TO_STR(D3D10_SVT_TEXTURECUBEARRAY);
-        default:
-            FIXME("Unrecognized D3D10_SHADER_VARIABLE_TYPE %#x.\n", t);
-            return "unrecognized";
-    }
-}
-
-const char *debug_d3d10_device_state_types(D3D10_DEVICE_STATE_TYPES t)
-{
-    switch (t)
-    {
-        WINE_D3D10_TO_STR(D3D10_DST_SO_BUFFERS);
-        WINE_D3D10_TO_STR(D3D10_DST_OM_RENDER_TARGETS);
-        WINE_D3D10_TO_STR(D3D10_DST_DEPTH_STENCIL_STATE);
-        WINE_D3D10_TO_STR(D3D10_DST_BLEND_STATE);
-        WINE_D3D10_TO_STR(D3D10_DST_VS);
-        WINE_D3D10_TO_STR(D3D10_DST_VS_SAMPLERS);
-        WINE_D3D10_TO_STR(D3D10_DST_VS_SHADER_RESOURCES);
-        WINE_D3D10_TO_STR(D3D10_DST_VS_CONSTANT_BUFFERS);
-        WINE_D3D10_TO_STR(D3D10_DST_GS);
-        WINE_D3D10_TO_STR(D3D10_DST_GS_SAMPLERS);
-        WINE_D3D10_TO_STR(D3D10_DST_GS_SHADER_RESOURCES);
-        WINE_D3D10_TO_STR(D3D10_DST_GS_CONSTANT_BUFFERS);
-        WINE_D3D10_TO_STR(D3D10_DST_PS);
-        WINE_D3D10_TO_STR(D3D10_DST_PS_SAMPLERS);
-        WINE_D3D10_TO_STR(D3D10_DST_PS_SHADER_RESOURCES);
-        WINE_D3D10_TO_STR(D3D10_DST_PS_CONSTANT_BUFFERS);
-        WINE_D3D10_TO_STR(D3D10_DST_IA_VERTEX_BUFFERS);
-        WINE_D3D10_TO_STR(D3D10_DST_IA_INDEX_BUFFER);
-        WINE_D3D10_TO_STR(D3D10_DST_IA_INPUT_LAYOUT);
-        WINE_D3D10_TO_STR(D3D10_DST_IA_PRIMITIVE_TOPOLOGY);
-        WINE_D3D10_TO_STR(D3D10_DST_RS_VIEWPORTS);
-        WINE_D3D10_TO_STR(D3D10_DST_RS_SCISSOR_RECTS);
-        WINE_D3D10_TO_STR(D3D10_DST_RS_RASTERIZER_STATE);
-        WINE_D3D10_TO_STR(D3D10_DST_PREDICATION);
-        default:
-            FIXME("Unrecognized D3D10_DEVICE_STATE_TYPES %#x.\n", t);
-            return "unrecognized";
-    }
-}
-
-#undef WINE_D3D10_TO_STR
-
-void skip_dword_unknown(const char *location, const char **ptr, unsigned int count)
-{
-    unsigned int i;
-    DWORD d;
-
-    FIXME("Skipping %u unknown DWORDs (%s):\n", count, location);
-    for (i = 0; i < count; ++i)
-    {
-        read_dword(ptr, &d);
-        FIXME("\t0x%08x\n", d);
-    }
-}
-
-void write_dword_unknown(char **ptr, DWORD d)
-{
-    FIXME("Writing unknown DWORD 0x%08x\n", d);
-    write_dword(ptr, d);
-}
-
-HRESULT parse_dxbc(const char *data, SIZE_T data_size,
-        HRESULT (*chunk_handler)(const char *data, DWORD data_size, DWORD tag, void *ctx), void *ctx)
-{
-    const char *ptr = data;
-    HRESULT hr = S_OK;
-    DWORD chunk_count;
-    DWORD total_size;
-    unsigned int i;
-    DWORD version;
-    DWORD tag;
-
-    if (!data)
-    {
-        WARN("No data supplied.\n");
-        return E_FAIL;
-    }
-
-    read_dword(&ptr, &tag);
-    TRACE("tag: %s.\n", debugstr_an((const char *)&tag, 4));
-
-    if (tag != TAG_DXBC)
-    {
-        WARN("Wrong tag.\n");
-        return E_FAIL;
-    }
-
-    /* checksum? */
-    skip_dword_unknown("DXBC header", &ptr, 4);
-
-    read_dword(&ptr, &version);
-    TRACE("version: %#x.\n", version);
-    if (version != 0x00000001)
-    {
-        WARN("Got unexpected DXBC version %#x.\n", version);
-        return E_FAIL;
-    }
-
-    read_dword(&ptr, &total_size);
-    TRACE("total size: %#x\n", total_size);
-
-    if (data_size != total_size)
-    {
-        WARN("Wrong size supplied.\n");
-        return E_FAIL;
-    }
-
-    read_dword(&ptr, &chunk_count);
-    TRACE("chunk count: %#x\n", chunk_count);
-
-    for (i = 0; i < chunk_count; ++i)
-    {
-        DWORD chunk_tag, chunk_size;
-        const char *chunk_ptr;
-        DWORD chunk_offset;
-
-        read_dword(&ptr, &chunk_offset);
-        TRACE("chunk %u at offset %#x\n", i, chunk_offset);
-
-        if (chunk_offset >= data_size || !require_space(chunk_offset, 2, sizeof(DWORD), data_size))
-        {
-            WARN("Invalid chunk offset %#x (data size %#lx).\n", chunk_offset, data_size);
-            return E_FAIL;
-        }
-
-        chunk_ptr = data + chunk_offset;
-
-        read_dword(&chunk_ptr, &chunk_tag);
-        read_dword(&chunk_ptr, &chunk_size);
-
-        if (!require_space(chunk_ptr - data, 1, chunk_size, data_size))
-        {
-            WARN("Invalid chunk size %#x (data size %#lx, chunk offset %#x).\n", chunk_size, data_size, chunk_offset);
-            return E_FAIL;
-        }
-
-        hr = chunk_handler(chunk_ptr, chunk_size, chunk_tag, ctx);
-        if (FAILED(hr)) break;
-    }
-
-    return hr;
-}
diff --git a/dlls/d3d11/device.c b/dlls/d3d11/device.c
index 3f83cdd..182d388 100644
--- a/dlls/d3d11/device.c
+++ b/dlls/d3d11/device.c
@@ -6619,6 +6619,7 @@ static HRESULT STDMETHODCALLTYPE d3d11_device_CheckFormatSupport(ID3D11Device2 *
     }
     flag_mapping[] =
     {
+      {WINED3D_RTYPE_TEXTURE_1D, WINED3D_BIND_SHADER_RESOURCE, D3D11_FORMAT_SUPPORT_TEXTURE1D},
         {WINED3D_RTYPE_TEXTURE_2D, WINED3D_BIND_SHADER_RESOURCE, D3D11_FORMAT_SUPPORT_TEXTURE2D},
         {WINED3D_RTYPE_TEXTURE_3D, WINED3D_BIND_SHADER_RESOURCE, D3D11_FORMAT_SUPPORT_TEXTURE3D},
         {WINED3D_RTYPE_NONE,       WINED3D_BIND_RENDER_TARGET,   D3D11_FORMAT_SUPPORT_RENDER_TARGET},
diff --git a/dlls/d3dcompiler_43/reflection.c b/dlls/d3dcompiler_43/reflection.c
index d10d0b1..30da707 100644
--- a/dlls/d3dcompiler_43/reflection.c
+++ b/dlls/d3dcompiler_43/reflection.c
@@ -23,6 +23,8 @@
 
 #include "initguid.h"
 #include "d3dcompiler_private.h"
+#include "d3d10.h"
+#include "d3d10shader.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3dcompiler);
 
@@ -45,6 +47,7 @@ struct d3dcompiler_shader_signature
 struct d3dcompiler_shader_reflection_type
 {
     ID3D11ShaderReflectionType ID3D11ShaderReflectionType_iface;
+    ID3D10ShaderReflectionType ID3D10ShaderReflectionType_iface;
 
     DWORD id;
     struct wine_rb_entry entry;
@@ -65,6 +68,7 @@ struct d3dcompiler_shader_reflection_type_member
 struct d3dcompiler_shader_reflection_variable
 {
     ID3D11ShaderReflectionVariable ID3D11ShaderReflectionVariable_iface;
+    ID3D10ShaderReflectionVariable ID3D10ShaderReflectionVariable_iface;
 
     struct d3dcompiler_shader_reflection_constant_buffer *constant_buffer;
     struct d3dcompiler_shader_reflection_type *type;
@@ -79,6 +83,7 @@ struct d3dcompiler_shader_reflection_variable
 struct d3dcompiler_shader_reflection_constant_buffer
 {
     ID3D11ShaderReflectionConstantBuffer ID3D11ShaderReflectionConstantBuffer_iface;
+    ID3D10ShaderReflectionConstantBuffer ID3D10ShaderReflectionConstantBuffer_iface;
 
     struct d3dcompiler_shader_reflection *reflection;
 
@@ -95,6 +100,7 @@ struct d3dcompiler_shader_reflection_constant_buffer
 struct d3dcompiler_shader_reflection
 {
     ID3D11ShaderReflection ID3D11ShaderReflection_iface;
+    ID3D10ShaderReflection ID3D10ShaderReflection_iface;
     LONG refcount;
 
     DWORD target;
@@ -143,14 +149,32 @@ struct d3dcompiler_shader_reflection
 static struct d3dcompiler_shader_reflection_type *get_reflection_type(struct d3dcompiler_shader_reflection *reflection, const char *data, DWORD offset);
 
 static const struct ID3D11ShaderReflectionConstantBufferVtbl d3dcompiler_shader_reflection_constant_buffer_vtbl;
+static const struct ID3D10ShaderReflectionConstantBufferVtbl d3dcompiler_d3d10_shader_reflection_constant_buffer_vtbl;
 static const struct ID3D11ShaderReflectionVariableVtbl d3dcompiler_shader_reflection_variable_vtbl;
+static const struct ID3D10ShaderReflectionVariableVtbl d3dcompiler_d3d10_shader_reflection_variable_vtbl;
 static const struct ID3D11ShaderReflectionTypeVtbl d3dcompiler_shader_reflection_type_vtbl;
+static const struct ID3D10ShaderReflectionTypeVtbl d3dcompiler_d3d10_shader_reflection_type_vtbl;
 
 /* null objects - needed for invalid calls */
-static struct d3dcompiler_shader_reflection_constant_buffer null_constant_buffer = {{&d3dcompiler_shader_reflection_constant_buffer_vtbl}};
-static struct d3dcompiler_shader_reflection_type null_type = {{&d3dcompiler_shader_reflection_type_vtbl}};
-static struct d3dcompiler_shader_reflection_variable null_variable = {{&d3dcompiler_shader_reflection_variable_vtbl},
-    &null_constant_buffer, &null_type};
+static struct d3dcompiler_shader_reflection_constant_buffer null_constant_buffer =
+{
+    { &d3dcompiler_shader_reflection_constant_buffer_vtbl },
+    { &d3dcompiler_d3d10_shader_reflection_constant_buffer_vtbl },
+};
+
+static struct d3dcompiler_shader_reflection_type null_type =
+{
+    { &d3dcompiler_shader_reflection_type_vtbl },
+    { &d3dcompiler_d3d10_shader_reflection_type_vtbl },
+};
+
+static struct d3dcompiler_shader_reflection_variable null_variable =
+{
+    { &d3dcompiler_shader_reflection_variable_vtbl },
+    { &d3dcompiler_d3d10_shader_reflection_variable_vtbl },
+    &null_constant_buffer,
+    &null_type
+};
 
 static BOOL copy_name(const char *ptr, char **name)
 {
@@ -702,6 +726,204 @@ static const struct ID3D11ShaderReflectionVtbl d3dcompiler_shader_reflection_vtb
     d3dcompiler_shader_reflection_GetRequiresFlags,
 };
 
+/* ID3D10ShaderReflection */
+
+static struct d3dcompiler_shader_reflection *impl_from_ID3D10ShaderReflection(ID3D10ShaderReflection *iface)
+{
+    return CONTAINING_RECORD(iface, struct d3dcompiler_shader_reflection, ID3D10ShaderReflection_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_QueryInterface(ID3D10ShaderReflection *iface,
+        REFIID riid, void **object)
+{
+    TRACE("iface %p, riid %s, object %p\n", iface, debugstr_guid(riid), object);
+
+    if (IsEqualGUID(riid, &IID_ID3D10ShaderReflection)
+            || IsEqualGUID(riid, &IID_IUnknown))
+    {
+        IUnknown_AddRef(iface);
+        *object = iface;
+        return S_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE\n", debugstr_guid(riid));
+
+    *object = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_AddRef(ID3D10ShaderReflection *iface)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+    return reflection->ID3D11ShaderReflection_iface.lpVtbl->AddRef(&reflection->ID3D11ShaderReflection_iface);
+}
+
+static ULONG STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_Release(ID3D10ShaderReflection *iface)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+    return reflection->ID3D11ShaderReflection_iface.lpVtbl->Release(&reflection->ID3D11ShaderReflection_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_GetDesc(ID3D10ShaderReflection *iface,
+        D3D10_SHADER_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+
+    FIXME("iface %p, desc %p partial stub!\n", iface, desc);
+
+    if (!desc)
+    {
+        WARN("Invalid argument specified\n");
+        return E_FAIL;
+    }
+
+    desc->Version = reflection->version;
+    desc->Creator = reflection->creator;
+    desc->Flags = reflection->flags;
+    desc->ConstantBuffers = reflection->constant_buffer_count;
+    desc->BoundResources = reflection->bound_resource_count;
+    desc->InputParameters = reflection->isgn ? reflection->isgn->element_count : 0;
+    desc->OutputParameters = reflection->osgn ? reflection->osgn->element_count : 0;
+    desc->InstructionCount = reflection->instruction_count;
+    desc->TempRegisterCount = reflection->temp_register_count;
+    desc->TempArrayCount = reflection->temp_array_count;
+    desc->DefCount = 0;
+    desc->DclCount = reflection->dcl_count;
+    desc->TextureNormalInstructions = reflection->texture_normal_instructions;
+    desc->TextureLoadInstructions = reflection->texture_load_instructions;
+    desc->TextureCompInstructions = reflection->texture_comp_instructions;
+    desc->TextureBiasInstructions = reflection->texture_bias_instructions;
+    desc->TextureGradientInstructions = reflection->texture_gradient_instructions;
+    desc->FloatInstructionCount = reflection->float_instruction_count;
+    desc->IntInstructionCount = reflection->int_instruction_count;
+    desc->UintInstructionCount = reflection->uint_instruction_count;
+    desc->StaticFlowControlCount = reflection->static_flow_control_count;
+    desc->DynamicFlowControlCount = reflection->dynamic_flow_control_count;
+    desc->MacroInstructionCount = 0;
+    desc->ArrayInstructionCount = reflection->array_instruction_count;
+    desc->CutInstructionCount = reflection->cut_instruction_count;
+    desc->EmitInstructionCount = reflection->emit_instruction_count;
+    desc->GSOutputTopology = reflection->gs_output_topology;
+    desc->GSMaxOutputVertexCount = reflection->gs_max_output_vertex_count;
+
+    return S_OK;
+}
+
+static struct ID3D10ShaderReflectionConstantBuffer * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_GetConstantBufferByIndex(
+        ID3D10ShaderReflection *iface, UINT index)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+
+    TRACE("iface %p, index %u\n", iface, index);
+
+    if (index >= reflection->constant_buffer_count)
+    {
+        WARN("Invalid argument specified\n");
+        return &null_constant_buffer.ID3D10ShaderReflectionConstantBuffer_iface;
+    }
+
+    return &reflection->constant_buffers[index].ID3D10ShaderReflectionConstantBuffer_iface;
+}
+
+static struct ID3D10ShaderReflectionConstantBuffer * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_GetConstantBufferByName(
+        ID3D10ShaderReflection *iface, const char *name)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+    unsigned int i;
+
+    TRACE("iface %p, name %s\n", iface, debugstr_a(name));
+
+    if (!name)
+    {
+        WARN("Invalid argument specified\n");
+        return &null_constant_buffer.ID3D10ShaderReflectionConstantBuffer_iface;
+    }
+
+    for (i = 0; i < reflection->constant_buffer_count; ++i)
+    {
+        struct d3dcompiler_shader_reflection_constant_buffer *d = &reflection->constant_buffers[i];
+
+        if (!strcmp(d->name, name))
+        {
+            TRACE("Returning ID3D10ShaderReflectionConstantBuffer %p.\n", d);
+            return &d->ID3D10ShaderReflectionConstantBuffer_iface;
+        }
+    }
+
+    WARN("Invalid name specified\n");
+
+    return &null_constant_buffer.ID3D10ShaderReflectionConstantBuffer_iface;
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_GetResourceBindingDesc(
+        ID3D10ShaderReflection *iface, UINT index, D3D10_SHADER_INPUT_BIND_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+
+    TRACE("iface %p, index %u, desc %p\n", iface, index, desc);
+
+    if (!desc || index >= reflection->bound_resource_count)
+    {
+        WARN("Invalid argument specified\n");
+        return E_INVALIDARG;
+    }
+
+    memcpy(desc, &reflection->bound_resources[index], sizeof(*desc));
+
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_GetInputParameterDesc(
+        ID3D10ShaderReflection *iface, UINT index, D3D10_SIGNATURE_PARAMETER_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+
+    TRACE("iface %p, index %u, desc %p\n", iface, index, desc);
+
+    if (!desc || !reflection->isgn || index >= reflection->isgn->element_count)
+    {
+        WARN("Invalid argument specified\n");
+        return E_INVALIDARG;
+    }
+
+    memcpy(desc, &reflection->isgn->elements[index], sizeof(*desc));
+
+    return S_OK;
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_GetOutputParameterDesc(
+        ID3D10ShaderReflection *iface, UINT index, D3D10_SIGNATURE_PARAMETER_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection *reflection = impl_from_ID3D10ShaderReflection(iface);
+
+    TRACE("iface %p, index %u, desc %p\n", iface, index, desc);
+
+    if (!desc || !reflection->osgn || index >= reflection->osgn->element_count)
+    {
+        WARN("Invalid argument specified\n");
+        return E_INVALIDARG;
+    }
+
+    memcpy(desc, &reflection->osgn->elements[index], sizeof(*desc));
+
+    return S_OK;
+}
+
+static const struct ID3D10ShaderReflectionVtbl d3dcompiler_d3d10_shader_reflection_vtbl =
+{
+    /* IUnknown methods */
+    d3dcompiler_d3d10_shader_reflection_QueryInterface,
+    d3dcompiler_d3d10_shader_reflection_AddRef,
+    d3dcompiler_d3d10_shader_reflection_Release,
+    /* ID3D10ShaderReflection methods */
+    d3dcompiler_d3d10_shader_reflection_GetDesc,
+    d3dcompiler_d3d10_shader_reflection_GetConstantBufferByIndex,
+    d3dcompiler_d3d10_shader_reflection_GetConstantBufferByName,
+    d3dcompiler_d3d10_shader_reflection_GetResourceBindingDesc,
+    d3dcompiler_d3d10_shader_reflection_GetInputParameterDesc,
+    d3dcompiler_d3d10_shader_reflection_GetOutputParameterDesc,
+};
+
 /* ID3D11ShaderReflectionConstantBuffer methods */
 
 static inline struct d3dcompiler_shader_reflection_constant_buffer *impl_from_ID3D11ShaderReflectionConstantBuffer(ID3D11ShaderReflectionConstantBuffer *iface)
@@ -791,6 +1013,95 @@ static const struct ID3D11ShaderReflectionConstantBufferVtbl d3dcompiler_shader_
     d3dcompiler_shader_reflection_constant_buffer_GetVariableByName,
 };
 
+/* ID3D10ShaderReflectionConstantBuffer methods */
+
+static struct d3dcompiler_shader_reflection_constant_buffer *impl_from_ID3D10ShaderReflectionConstantBuffer(ID3D10ShaderReflectionConstantBuffer *iface)
+{
+    return CONTAINING_RECORD(iface, struct d3dcompiler_shader_reflection_constant_buffer, ID3D10ShaderReflectionConstantBuffer_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_constant_buffer_GetDesc(
+        ID3D10ShaderReflectionConstantBuffer *iface, D3D10_SHADER_BUFFER_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection_constant_buffer *buffer = impl_from_ID3D10ShaderReflectionConstantBuffer(iface);
+
+    TRACE("iface %p, desc %p\n", iface, desc);
+
+    if (buffer == &null_constant_buffer)
+    {
+        WARN("Null constant buffer specified\n");
+        return E_FAIL;
+    }
+
+    if (!desc)
+    {
+        WARN("Invalid argument specified\n");
+        return E_FAIL;
+    }
+
+    desc->Name = buffer->name;
+    desc->Type = buffer->type;
+    desc->Variables = buffer->variable_count;
+    desc->Size = buffer->size;
+    desc->uFlags = buffer->flags;
+
+    return S_OK;
+}
+
+static ID3D10ShaderReflectionVariable * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_constant_buffer_GetVariableByIndex(
+        ID3D10ShaderReflectionConstantBuffer *iface, UINT index)
+{
+    struct d3dcompiler_shader_reflection_constant_buffer *buffer = impl_from_ID3D10ShaderReflectionConstantBuffer(iface);
+
+    TRACE("iface %p, index %u\n", iface, index);
+
+    if (index >= buffer->variable_count)
+    {
+        WARN("Invalid index specified\n");
+        return &null_variable.ID3D10ShaderReflectionVariable_iface;
+    }
+
+    return &buffer->variables[index].ID3D10ShaderReflectionVariable_iface;
+}
+
+static ID3D10ShaderReflectionVariable * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_constant_buffer_GetVariableByName(
+        ID3D10ShaderReflectionConstantBuffer *iface, const char *name)
+{
+    struct d3dcompiler_shader_reflection_constant_buffer *buffer = impl_from_ID3D10ShaderReflectionConstantBuffer(iface);
+    unsigned int i;
+
+    TRACE("iface %p, name %s\n", iface, debugstr_a(name));
+
+    if (!name)
+    {
+        WARN("Invalid argument specified\n");
+        return &null_variable.ID3D10ShaderReflectionVariable_iface;
+    }
+
+    for (i = 0; i < buffer->variable_count; ++i)
+    {
+        struct d3dcompiler_shader_reflection_variable *v = &buffer->variables[i];
+
+        if (!strcmp(v->name, name))
+        {
+            TRACE("Returning ID3D10ShaderReflectionVariable %p.\n", v);
+            return &v->ID3D10ShaderReflectionVariable_iface;
+        }
+    }
+
+    WARN("Invalid name specified\n");
+
+    return &null_variable.ID3D10ShaderReflectionVariable_iface;
+}
+
+static const struct ID3D10ShaderReflectionConstantBufferVtbl d3dcompiler_d3d10_shader_reflection_constant_buffer_vtbl =
+{
+    /* ID3D10ShaderReflectionConstantBuffer methods */
+    d3dcompiler_d3d10_shader_reflection_constant_buffer_GetDesc,
+    d3dcompiler_d3d10_shader_reflection_constant_buffer_GetVariableByIndex,
+    d3dcompiler_d3d10_shader_reflection_constant_buffer_GetVariableByName,
+};
+
 /* ID3D11ShaderReflectionVariable methods */
 
 static inline struct d3dcompiler_shader_reflection_variable *impl_from_ID3D11ShaderReflectionVariable(ID3D11ShaderReflectionVariable *iface)
@@ -863,6 +1174,58 @@ static const struct ID3D11ShaderReflectionVariableVtbl d3dcompiler_shader_reflec
     d3dcompiler_shader_reflection_variable_GetInterfaceSlot,
 };
 
+/* ID3D10ShaderReflectionVariable methods */
+
+static struct d3dcompiler_shader_reflection_variable *impl_from_ID3D10ShaderReflectionVariable(ID3D10ShaderReflectionVariable *iface)
+{
+    return CONTAINING_RECORD(iface, struct d3dcompiler_shader_reflection_variable, ID3D10ShaderReflectionVariable_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_variable_GetDesc(
+        ID3D10ShaderReflectionVariable *iface, D3D10_SHADER_VARIABLE_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection_variable *variable = impl_from_ID3D10ShaderReflectionVariable(iface);
+
+    TRACE("iface %p, desc %p\n", iface, desc);
+
+    if (variable == &null_variable)
+    {
+        WARN("Null variable specified\n");
+        return E_FAIL;
+    }
+
+    if (!desc)
+    {
+        WARN("Invalid argument specified\n");
+        return E_FAIL;
+    }
+
+    desc->Name = variable->name;
+    desc->StartOffset = variable->start_offset;
+    desc->Size = variable->size;
+    desc->uFlags = variable->flags;
+    desc->DefaultValue = variable->default_value;
+
+    return S_OK;
+}
+
+static ID3D10ShaderReflectionType * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_variable_GetType(
+        ID3D10ShaderReflectionVariable *iface)
+{
+    struct d3dcompiler_shader_reflection_variable *variable = impl_from_ID3D10ShaderReflectionVariable(iface);
+
+    TRACE("iface %p\n", iface);
+
+    return &variable->type->ID3D10ShaderReflectionType_iface;
+}
+
+static const struct ID3D10ShaderReflectionVariableVtbl d3dcompiler_d3d10_shader_reflection_variable_vtbl =
+{
+    /* ID3D10ShaderReflectionVariable methods */
+    d3dcompiler_d3d10_shader_reflection_variable_GetDesc,
+    d3dcompiler_d3d10_shader_reflection_variable_GetType,
+};
+
 /* ID3D11ShaderReflectionType methods */
 
 static inline struct d3dcompiler_shader_reflection_type *impl_from_ID3D11ShaderReflectionType(ID3D11ShaderReflectionType *iface)
@@ -1045,6 +1408,114 @@ static const struct ID3D11ShaderReflectionTypeVtbl d3dcompiler_shader_reflection
     d3dcompiler_shader_reflection_type_ImplementsInterface,
 };
 
+/* ID3D10ShaderReflectionType methods */
+
+static struct d3dcompiler_shader_reflection_type *impl_from_ID3D10ShaderReflectionType(ID3D10ShaderReflectionType *iface)
+{
+    return CONTAINING_RECORD(iface, struct d3dcompiler_shader_reflection_type, ID3D10ShaderReflectionType_iface);
+}
+
+static HRESULT STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_type_GetDesc(
+        ID3D10ShaderReflectionType *iface, D3D10_SHADER_TYPE_DESC *desc)
+{
+    struct d3dcompiler_shader_reflection_type *reflection_type = impl_from_ID3D10ShaderReflectionType(iface);
+
+    TRACE("iface %p, desc %p\n", iface, desc);
+
+    if (reflection_type == &null_type)
+    {
+        WARN("Null type specified\n");
+        return E_FAIL;
+    }
+
+    if (!desc)
+    {
+        WARN("Invalid argument specified\n");
+        return E_FAIL;
+    }
+
+    memcpy(desc, &reflection_type->desc, sizeof(*desc));
+
+    return S_OK;
+}
+
+static ID3D10ShaderReflectionType * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_type_GetMemberTypeByIndex(
+        ID3D10ShaderReflectionType *iface, UINT index)
+{
+    struct d3dcompiler_shader_reflection_type *reflection_type = impl_from_ID3D10ShaderReflectionType(iface);
+
+    TRACE("iface %p, index %u\n", iface, index);
+
+    if (index >= reflection_type->desc.Members)
+    {
+        WARN("Invalid index specified\n");
+        return &null_type.ID3D10ShaderReflectionType_iface;
+    }
+
+    return &reflection_type->members[index].type->ID3D10ShaderReflectionType_iface;
+}
+
+static ID3D10ShaderReflectionType * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_type_GetMemberTypeByName(
+        ID3D10ShaderReflectionType *iface, const char *name)
+{
+    struct d3dcompiler_shader_reflection_type *reflection_type = impl_from_ID3D10ShaderReflectionType(iface);
+    unsigned int i;
+
+    TRACE("iface %p, name %s\n", iface, debugstr_a(name));
+
+    if (!name)
+    {
+        WARN("Invalid argument specified\n");
+        return &null_type.ID3D10ShaderReflectionType_iface;
+    }
+
+    for (i = 0; i < reflection_type->desc.Members; ++i)
+    {
+        struct d3dcompiler_shader_reflection_type_member *member = &reflection_type->members[i];
+
+        if (!strcmp(member->name, name))
+        {
+            TRACE("Returning ID3D10ShaderReflectionType %p.\n", member->type);
+            return &member->type->ID3D10ShaderReflectionType_iface;
+        }
+    }
+
+    WARN("Invalid name specified\n");
+
+    return &null_type.ID3D10ShaderReflectionType_iface;
+}
+
+static const char * STDMETHODCALLTYPE d3dcompiler_d3d10_shader_reflection_type_GetMemberTypeName(
+        ID3D10ShaderReflectionType *iface, UINT index)
+{
+    struct d3dcompiler_shader_reflection_type *reflection_type = impl_from_ID3D10ShaderReflectionType(iface);
+
+    TRACE("iface %p, index %u\n", iface, index);
+
+    if (reflection_type == &null_type)
+    {
+        WARN("Null type specified\n");
+        return "$Invalid";
+    }
+
+    if (index >= reflection_type->desc.Members)
+    {
+        WARN("Invalid index specified\n");
+        return NULL;
+    }
+
+    return reflection_type->members[index].name;
+}
+
+static const struct ID3D10ShaderReflectionTypeVtbl d3dcompiler_d3d10_shader_reflection_type_vtbl =
+{
+    /* ID3D10ShaderReflectionType methods */
+    d3dcompiler_d3d10_shader_reflection_type_GetDesc,
+    d3dcompiler_d3d10_shader_reflection_type_GetMemberTypeByIndex,
+    d3dcompiler_d3d10_shader_reflection_type_GetMemberTypeByName,
+    d3dcompiler_d3d10_shader_reflection_type_GetMemberTypeName,
+};
+
 static HRESULT d3dcompiler_parse_stat(struct d3dcompiler_shader_reflection *r, const char *data, DWORD data_size)
 {
     const char *ptr = data;
@@ -1272,6 +1743,7 @@ static struct d3dcompiler_shader_reflection_type *get_reflection_type(struct d3d
         return NULL;
 
     type->ID3D11ShaderReflectionType_iface.lpVtbl = &d3dcompiler_shader_reflection_type_vtbl;
+    type->ID3D10ShaderReflectionType_iface.lpVtbl = &d3dcompiler_d3d10_shader_reflection_type_vtbl;
     type->id = offset;
     type->reflection = reflection;
 
@@ -1313,6 +1785,7 @@ static HRESULT d3dcompiler_parse_variables(struct d3dcompiler_shader_reflection_
         DWORD offset;
 
         v->ID3D11ShaderReflectionVariable_iface.lpVtbl = &d3dcompiler_shader_reflection_variable_vtbl;
+        v->ID3D10ShaderReflectionVariable_iface.lpVtbl = &d3dcompiler_d3d10_shader_reflection_variable_vtbl;
         v->constant_buffer = cb;
 
         read_dword(&ptr, &offset);
@@ -1487,6 +1960,7 @@ static HRESULT d3dcompiler_parse_rdef(struct d3dcompiler_shader_reflection *r, c
             struct d3dcompiler_shader_reflection_constant_buffer *cb = &constant_buffers[i];
 
             cb->ID3D11ShaderReflectionConstantBuffer_iface.lpVtbl = &d3dcompiler_shader_reflection_constant_buffer_vtbl;
+            cb->ID3D10ShaderReflectionConstantBuffer_iface.lpVtbl = &d3dcompiler_d3d10_shader_reflection_constant_buffer_vtbl;
             cb->reflection = r;
 
             read_dword(&ptr, &offset);
@@ -1671,6 +2145,7 @@ static HRESULT d3dcompiler_shader_reflection_init(struct d3dcompiler_shader_refl
     unsigned int i;
 
     reflection->ID3D11ShaderReflection_iface.lpVtbl = &d3dcompiler_shader_reflection_vtbl;
+    reflection->ID3D10ShaderReflection_iface.lpVtbl = &d3dcompiler_d3d10_shader_reflection_vtbl;
     reflection->refcount = 1;
 
     wine_rb_init(&reflection->types, d3dcompiler_shader_reflection_type_compare);
@@ -1823,7 +2298,46 @@ HRESULT WINAPI D3DReflect(const void *data, SIZE_T data_size, REFIID riid, void
         return hr;
     }
 
-    *reflector = object;
+    *reflector = &object->ID3D11ShaderReflection_iface;
+
+    TRACE("Created ID3D11ShaderReflection %p\n", object);
+
+    return S_OK;
+}
+
+HRESULT WINAPI D3D10ReflectShader(const void *data, SIZE_T data_size, ID3D10ShaderReflection **reflector)
+{
+    struct d3dcompiler_shader_reflection *object;
+    const DWORD *temp = data;
+    HRESULT hr;
+
+    TRACE("data %p, data_size %lu, reflector %p\n", data, data_size, reflector);
+
+    if (!data || data_size < 32)
+    {
+        WARN("Invalid argument supplied.\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    if (temp[6] != data_size)
+    {
+        WARN("Wrong size supplied.\n");
+        return E_FAIL;
+    }
+
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+    if (!object)
+        return E_OUTOFMEMORY;
+
+    hr = d3dcompiler_shader_reflection_init(object, data, data_size);
+    if (FAILED(hr))
+    {
+        WARN("Failed to initialize shader reflection\n");
+        HeapFree(GetProcessHeap(), 0, object);
+        return hr;
+    }
+
+    *reflector = &object->ID3D10ShaderReflection_iface;
 
     TRACE("Created ID3D11ShaderReflection %p\n", object);
 
diff --git a/dlls/dxgi/swapchain.c b/dlls/dxgi/swapchain.c
index 07438f3..5f255e4 100644
--- a/dlls/dxgi/swapchain.c
+++ b/dlls/dxgi/swapchain.c
@@ -351,6 +351,7 @@ static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetDesc(IDXGISwapChain1 *iface,
 {
     struct d3d11_swapchain *swapchain = d3d11_swapchain_from_IDXGISwapChain1(iface);
     struct wined3d_swapchain_desc wined3d_desc;
+  static int once = 0;
 
     TRACE("iface %p, desc %p.\n", iface, desc);
 
@@ -363,8 +364,9 @@ static HRESULT STDMETHODCALLTYPE d3d11_swapchain_GetDesc(IDXGISwapChain1 *iface,
     wined3d_mutex_lock();
     wined3d_swapchain_get_desc(swapchain->wined3d_swapchain, &wined3d_desc);
     wined3d_mutex_unlock();
-
+  if (!once++) {
     FIXME("Ignoring ScanlineOrdering and Scaling.\n");
+  }
 
     desc->BufferDesc.Width = wined3d_desc.backbuffer_width;
     desc->BufferDesc.Height = wined3d_desc.backbuffer_height;
diff --git a/tools/makedep.c b/tools/makedep.c
index b4bf764..1ab584a 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -2616,7 +2616,6 @@ static void output_source_mc( struct makefile *make, struct incl_file *source, c
             output_filename( strmake( "%s/%s.mo", po_dir, linguas.str[i] ));
     }
     output( "\n" );
-  output( "\t@echo [WMC] $@\n" );
     output( "%s.pot: %s\n", obj_dir_path( make, obj ), source->filename );
     output( "\t%s -O pot -o $@ %s", tools_path( make, "wmc" ), source->filename );
     output( "\n" );
