diff --git a/configure b/configure
index 5864761..5f95004 100755
--- a/configure
+++ b/configure
@@ -6127,7 +6127,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6173,7 +6173,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6197,7 +6197,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6242,7 +6242,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6266,7 +6266,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -13302,6 +13302,64 @@ This is an error since --with-tiff was requested." "$LINENO" 5 ;;
 esac
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ltxc_dxtn" >&5
+$as_echo_n "checking for -ltxc_dxtn... " >&6; }
+if ${ac_cv_lib_soname_txc_dxtn+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-ltxc_dxtn  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char tx_compress_dxtn ();
+int
+main ()
+{
+return tx_compress_dxtn ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_txc_dxtn=`$ac_cv_path_LDD conftest.exe | grep "txc_dxtn" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_txc_dxtn=`otool -L conftest$ac_exeext | grep "libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_txc_dxtn=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\\[\\(libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_txc_dxtn:+false} :; then :
+  ac_cv_lib_soname_txc_dxtn=`$LDD conftest$ac_exeext | grep "libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\(libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_txc_dxtn:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_txc_dxtn" >&5
+$as_echo "$ac_cv_lib_soname_txc_dxtn" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBTXC_DXTN "libtxc_dxtn.dylib"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_TXC_DXTN 1
+_ACEOF
+
+
+fi
+
 if test "x$with_mpg123" != "xno"
 then
     if ${MPG123_CFLAGS:+false} :; then :
diff --git a/configure.ac b/configure.ac
index 688ab26..050ba7a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1711,6 +1711,9 @@ fi
 WINE_NOTICE_WITH(tiff,[test "x$ac_cv_lib_soname_tiff" = "x"],
                  [libtiff ${notice_platform}development files not found, TIFF won't be supported.])
 
+dnl **** Check for libtxc_dxtn ****
+WINE_CHECK_SONAME(txc_dxtn,tx_compress_dxtn,,,,[[libtxc_dxtn\\(_s2tc\\)\\{0,1\\}]])
+
 dnl **** Check for mpg123 ****
 if test "x$with_mpg123" != "xno"
 then
diff --git a/dlls/d3d9/device.c b/dlls/d3d9/device.c
index 0b1a77a..2d94085 100644
--- a/dlls/d3d9/device.c
+++ b/dlls/d3d9/device.c
@@ -70,7 +70,9 @@ D3DFORMAT d3dformat_from_wined3dformat(enum wined3d_format_id format)
         case WINED3DFMT_R8G8B8A8_SNORM: return D3DFMT_Q8W8V8U8;
         case WINED3DFMT_R16G16_SNORM: return D3DFMT_V16U16;
         case WINED3DFMT_R10G10B10_SNORM_A2_UNORM: return D3DFMT_A2W10V10U10;
+        case WINED3DFMT_D32_LOCKABLE: return D3DFMT_D32_LOCKABLE;
         case WINED3DFMT_D16_LOCKABLE: return D3DFMT_D16_LOCKABLE;
+        case WINED3DFMT_S8_LOCKABLE: return D3DFMT_S8_LOCKABLE;
         case WINED3DFMT_D32_UNORM: return D3DFMT_D32;
         case WINED3DFMT_S1_UINT_D15_UNORM: return D3DFMT_D15S1;
         case WINED3DFMT_D24_UNORM_S8_UINT: return D3DFMT_D24S8;
@@ -135,7 +137,9 @@ enum wined3d_format_id wined3dformat_from_d3dformat(D3DFORMAT format)
         case D3DFMT_Q8W8V8U8: return WINED3DFMT_R8G8B8A8_SNORM;
         case D3DFMT_V16U16: return WINED3DFMT_R16G16_SNORM;
         case D3DFMT_A2W10V10U10: return WINED3DFMT_R10G10B10_SNORM_A2_UNORM;
+        case D3DFMT_D32_LOCKABLE: return WINED3DFMT_D32_LOCKABLE;
         case D3DFMT_D16_LOCKABLE: return WINED3DFMT_D16_LOCKABLE;
+        case D3DFMT_S8_LOCKABLE: return WINED3DFMT_S8_LOCKABLE;
         case D3DFMT_D32: return WINED3DFMT_D32_UNORM;
         case D3DFMT_D15S1: return WINED3DFMT_S1_UINT_D15_UNORM;
         case D3DFMT_D24S8: return WINED3DFMT_D24_UNORM_S8_UINT;
diff --git a/dlls/d3d9/surface.c b/dlls/d3d9/surface.c
index e5eb11f..e9aa510 100644
--- a/dlls/d3d9/surface.c
+++ b/dlls/d3d9/surface.c
@@ -91,6 +91,12 @@ static ULONG WINAPI d3d9_surface_Release(IDirect3DSurface9 *iface)
         return IDirect3DBaseTexture9_Release(&surface->texture->IDirect3DBaseTexture9_iface);
     }
 
+    if (!surface->resource.refcount)
+    {
+        ERR("Surface doesn't have any references.\n");
+        return 0;
+    }
+
     refcount = InterlockedDecrement(&surface->resource.refcount);
     TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
@@ -349,7 +355,7 @@ void surface_init(struct d3d9_surface *surface, IUnknown *container_parent,
         struct wined3d_surface *wined3d_surface, const struct wined3d_parent_ops **parent_ops)
 {
     struct wined3d_resource_desc desc;
-    IDirect3DBaseTexture9 *texture;
+    IDirect3DBaseTexture9 *texture = NULL;
 
     surface->IDirect3DSurface9_iface.lpVtbl = &d3d9_surface_vtbl;
     d3d9_resource_init(&surface->resource);
@@ -389,6 +395,10 @@ static void STDMETHODCALLTYPE view_wined3d_object_destroyed(void *parent)
 {
     struct d3d9_surface *surface = parent;
 
+  if (!surface) {
+    return;
+  }
+
     /* If the surface reference count drops to zero, we release our reference
      * to the view, but don't clear the pointer yet, in case e.g. a
      * GetRenderTarget() call brings the surface back before the view is
@@ -411,6 +421,10 @@ struct wined3d_rendertarget_view *d3d9_surface_get_rendertarget_view(struct d3d9
 {
     HRESULT hr;
 
+  if (!surface) {
+    return NULL;
+  }
+
     if (surface->wined3d_rtv)
         return surface->wined3d_rtv;
 
diff --git a/dlls/d3d9/tests/device.c b/dlls/d3d9/tests/device.c
index 4d48ea8..51e0778 100644
--- a/dlls/d3d9/tests/device.c
+++ b/dlls/d3d9/tests/device.c
@@ -2199,6 +2199,8 @@ static void test_display_modes(void)
     TEST_FMT(D3DFMT_R8G8_B8G8, D3DERR_INVALIDCALL);
 
     TEST_FMT(D3DFMT_D16_LOCKABLE, D3DERR_INVALIDCALL);
+    TEST_FMT(D3DFMT_D32_LOCKABLE, D3DERR_INVALIDCALL);
+    TEST_FMT(D3DFMT_S8_LOCKABLE, D3DERR_INVALIDCALL);
     TEST_FMT(D3DFMT_D32, D3DERR_INVALIDCALL);
     TEST_FMT(D3DFMT_D15S1, D3DERR_INVALIDCALL);
     TEST_FMT(D3DFMT_D24S8, D3DERR_INVALIDCALL);
diff --git a/dlls/d3dx9_36/Makefile.in b/dlls/d3dx9_36/Makefile.in
index 5958c57..aa387b5 100644
--- a/dlls/d3dx9_36/Makefile.in
+++ b/dlls/d3dx9_36/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = d3dx9_36.dll
 IMPORTLIB = d3dx9
-IMPORTS   = d3d9 d3dcompiler dxguid d3dxof ole32 gdi32 user32
+IMPORTS   = d3d9 d3dcompiler dxguid d3dxof ole32 gdi32 user32 wined3d
 
 C_SRCS = \
 	core.c \
diff --git a/dlls/d3dx9_36/d3dx9_36.spec b/dlls/d3dx9_36/d3dx9_36.spec
index 15d693c..4ae1384 100644
--- a/dlls/d3dx9_36/d3dx9_36.spec
+++ b/dlls/d3dx9_36/d3dx9_36.spec
@@ -159,8 +159,8 @@
 @ stdcall D3DXGetPixelShaderProfile(ptr)
 @ stdcall D3DXGetShaderConstantTable(ptr ptr)
 @ stdcall D3DXGetShaderConstantTableEx(ptr long ptr)
-@ stub D3DXGetShaderInputSemantics(ptr ptr ptr)
-@ stub D3DXGetShaderOutputSemantics(ptr ptr ptr)
+@ stdcall D3DXGetShaderInputSemantics(ptr ptr ptr)
+@ stdcall D3DXGetShaderOutputSemantics(ptr ptr ptr)
 @ stdcall D3DXGetShaderSamplers(ptr ptr ptr)
 @ stdcall D3DXGetShaderSize(ptr)
 @ stdcall D3DXGetShaderVersion(ptr)
diff --git a/dlls/d3dx9_36/d3dx9_36_private.h b/dlls/d3dx9_36/d3dx9_36_private.h
index 79f3b76..832cbca 100644
--- a/dlls/d3dx9_36/d3dx9_36_private.h
+++ b/dlls/d3dx9_36/d3dx9_36_private.h
@@ -67,6 +67,12 @@ struct pixel_format_desc {
     void (*to_rgba)(const struct vec4 *src, struct vec4 *dst, const PALETTEENTRY *palette);
 };
 
+//typedef BOOL (*dxtn_conversion_func)(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+//enum wined3d_format_id format, unsigned int w, unsigned int h);
+
+//dxtn_conversion_func get_dxtn_conversion_func(D3DFORMAT format, BOOL encode);
+
+
 HRESULT map_view_of_file(const WCHAR *filename, void **buffer, DWORD *length) DECLSPEC_HIDDEN;
 HRESULT load_resource_into_memory(HMODULE module, HRSRC resinfo, void **buffer, DWORD *length) DECLSPEC_HIDDEN;
 
diff --git a/dlls/d3dx9_36/mesh.c b/dlls/d3dx9_36/mesh.c
index 746b479..bed4120 100644
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -5171,6 +5171,9 @@ HRESULT WINAPI D3DXCreateTextA(struct IDirect3DDevice9 *device, HDC hdc, const c
 
     len = MultiByteToWideChar(CP_ACP, 0, text, -1, NULL, 0);
     textW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+  if (!textW) {
+    return E_OUTOFMEMORY;
+  }
     MultiByteToWideChar(CP_ACP, 0, text, -1, textW, len);
 
     hr = D3DXCreateTextW(device, hdc, textW, deviation, extrusion,
@@ -7234,3 +7237,59 @@ HRESULT WINAPI D3DXOptimizeFaces(const void *indices, UINT num_faces,
 error:
     return hr;
 }
+
+/*************************************************************************
+ * D3DXComputeTangentFrameEx    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeTangentFrameEx(ID3DXMesh *Mesh, DWORD TextureInSemantic, DWORD TextureInIndex,
+               DWORD UPartialOutSemantic, DWORD UPartialOutIndex, DWORD VPartialOutSemantic, DWORD VPartialOutIndex,
+               DWORD NormalOutSemantic, DWORD NormalOutIndex, DWORD options, const DWORD *adjacency,
+               FLOAT PartialEdgeThreshold, FLOAT SingularPointThreshold, FLOAT NormalEdgeThreshold,
+               ID3DXMesh **MeshOut, ID3DXBuffer **VertexMapping)
+{
+    FIXME("Mesh %p, TextureInSemantic %u, TextureInIndex %u, UPartialOutSemantic %u, UPartialOutIndex %u, "
+            "VPartialOutSemantic %u, VPartialOutIndex %u, NormalOutSemantic %u, NormalOutIndex %u, "
+            "options %x, adjacency %p, PartialEdgeThreshold %f, SingularPointThreshold %f, NormalEdgeThreshold %f, "
+            "MeshOut %p, VertexMapping %p stub.\n",
+            Mesh, TextureInSemantic, TextureInIndex, UPartialOutSemantic, UPartialOutIndex, VPartialOutSemantic,
+            VPartialOutIndex, NormalOutSemantic, NormalOutIndex, options, adjacency, PartialEdgeThreshold,
+            SingularPointThreshold, NormalEdgeThreshold, MeshOut, VertexMapping);
+
+    return E_NOTIMPL;
+}
+
+/*************************************************************************
+ * D3DXComputeNormals    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeNormals(ID3DXBaseMesh *mesh, const DWORD *adjacency)
+{
+    TRACE("mesh %p, adjacency %p.\n", mesh, adjacency);
+
+    return D3DXComputeTangentFrameEx((ID3DXMesh *)mesh, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0,
+                                     D3DDECLUSAGE_NORMAL, 0, D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_CALCULATE_NORMALS,
+                                     adjacency, -1.01f, -0.01f, -1.01f, NULL, NULL);
+}
+
+/*************************************************************************
+ * D3DXComputeNormalMap    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeNormalMap(IDirect3DTexture9 *texture, IDirect3DTexture9 *src_texture,
+        const PALETTEENTRY *src_palette, DWORD flags, DWORD channel, FLOAT amplitude)
+{
+    FIXME("texture %p, src_texture %p, src_palette %p, flags %#x, channel %u, amplitude %f stub.\n",
+            texture, src_texture, src_palette, flags, channel, amplitude);
+
+    return D3D_OK;
+}
+
+/*************************************************************************
+ * D3DXIntersect    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXIntersect(ID3DXBaseMesh *Mesh, const D3DXVECTOR3 *RayPos, const D3DXVECTOR3 *RayDir, BOOL *Hit,
+        DWORD *FaceIndex, FLOAT *U, FLOAT *V, FLOAT *Dist, ID3DXBuffer **AllHits, DWORD *CountOfHits)
+{
+    FIXME("Mesh %p, RayPos %p, RayDir %p, Hit %p, FaceIndex %p, U %p, V %p, Dist %p, AllHits %p, CountOfHits %p stub.\n",
+            Mesh, RayPos, RayDir, Hit, FaceIndex, U, V, Dist, AllHits, CountOfHits);
+
+    return E_NOTIMPL;
+}
diff --git a/dlls/d3dx9_36/shader.c b/dlls/d3dx9_36/shader.c
index cdc470b..347b587 100644
--- a/dlls/d3dx9_36/shader.c
+++ b/dlls/d3dx9_36/shader.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2008 Luis Busquets
  * Copyright 2009 Matteo Bruni
+ * Copyright 2010, 2013 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -2130,3 +2131,112 @@ HRESULT WINAPI D3DXDisassembleShader(const DWORD *shader, BOOL colorcode, const
    FIXME("%p %d %s %p: stub\n", shader, colorcode, debugstr_a(comments), disassembly);
    return E_OUTOFMEMORY;
 }
+
+const DWORD* skip_instruction(const DWORD *byte_code, UINT shader_model)
+{
+    TRACE("Shader model %u\n", shader_model);
+
+    /* Handle all special instructions whose arguments may contain D3DSIO_DCL */
+    if ((*byte_code & D3DSI_OPCODE_MASK) == D3DSIO_COMMENT)
+    {
+        byte_code += 1 + ((*byte_code & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
+    }
+    else if (shader_model >= 2)
+    {
+        byte_code += 1 + ((*byte_code & D3DSI_INSTLENGTH_MASK) >> D3DSI_INSTLENGTH_SHIFT);
+    }
+    else if ((*byte_code & D3DSI_OPCODE_MASK) == D3DSIO_DEF)
+    {
+        byte_code += 1 + 5;
+    }
+    else
+    {
+        /* Handle remaining safe instructions */
+        while (*++byte_code & (1 << 31));
+    }
+
+    return byte_code;
+}
+
+static UINT get_shader_semantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, BOOL input)
+{
+    const DWORD *ptr = byte_code;
+    UINT shader_model = (*ptr >> 8) & 0xff;
+    UINT i = 0;
+
+    TRACE("Shader version: %#x\n", *ptr);
+    ptr++;
+
+    while (*ptr != D3DSIO_END)
+    {
+        if (*ptr & (1 << 31))
+        {
+            FIXME("Opcode expected but got %#x\n", *ptr);
+            return 0;
+        }
+        else if ((*ptr & D3DSI_OPCODE_MASK) == D3DSIO_DCL)
+        {
+            DWORD param1 = *++ptr;
+            DWORD param2 = *++ptr;
+            DWORD usage = param1 & 0x1f;
+            DWORD usage_index = (param1 >> 16) & 0xf;
+            DWORD reg_type = (((param2 >> 11) & 0x3) << 3) | ((param2 >> 28) & 0x7);
+
+            TRACE("D3DSIO_DCL param1: %#x, param2: %#x, usage: %u, usage_index: %u, reg_type: %u\n",
+                   param1, param2, usage, usage_index, reg_type);
+
+            if ((input && (reg_type == D3DSPR_INPUT)) || (!input && (reg_type == D3DSPR_OUTPUT)))
+            {
+                if (semantics)
+                {
+                    semantics[i].Usage = usage;
+                    semantics[i].UsageIndex = usage_index;
+                }
+                i++;
+            }
+
+            ptr++;
+        }
+        else
+        {
+            ptr = skip_instruction(ptr, shader_model);
+        }
+    }
+
+    return i;
+}
+
+HRESULT WINAPI D3DXGetShaderInputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count)
+{
+    UINT nb_semantics;
+
+    TRACE("byte_code %p, semantics %p, count %p\n", byte_code, semantics, count);
+
+    if (!byte_code)
+        return D3DERR_INVALIDCALL;
+
+    nb_semantics = get_shader_semantics(byte_code, semantics, TRUE);
+
+    if (count)
+        *count = nb_semantics;
+
+    return D3D_OK;
+}
+
+
+HRESULT WINAPI D3DXGetShaderOutputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count)
+{
+    UINT nb_semantics;
+
+    TRACE("byte_code %p, semantics %p, count %p\n", byte_code, semantics, count);
+
+    if (!byte_code)
+        return D3DERR_INVALIDCALL;
+
+    nb_semantics = get_shader_semantics(byte_code, semantics, FALSE);
+
+    if (count)
+        *count = nb_semantics;
+
+    return D3D_OK;
+}
diff --git a/dlls/d3dx9_36/surface.c b/dlls/d3dx9_36/surface.c
index 295ef63..f1c90be 100644
--- a/dlls/d3dx9_36/surface.c
+++ b/dlls/d3dx9_36/surface.c
@@ -18,6 +18,7 @@
  *
  */
 
+#include "config.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
 #include "d3dx9_36_private.h"
@@ -26,6 +27,8 @@
 #include "ole2.h"
 #include "wincodec.h"
 
+#include "wine/wined3d.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
 
@@ -1716,6 +1719,27 @@ void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slic
     }
 }
 
+/*typedef BOOL (*dxtn_conversion_func)(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                                     enum wined3d_format_id format, unsigned int w, unsigned int h);
+
+dxtn_conversion_func get_dxtn_conversion_func(D3DFORMAT format, BOOL encode)
+{
+    switch (format)
+    {
+        case D3DFMT_DXT1:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt1_encode : wined3d_dxt1_decode;
+        case D3DFMT_DXT3:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt3_encode : wined3d_dxt3_decode;
+        case D3DFMT_DXT5:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt5_encode : wined3d_dxt5_decode;
+        default:
+            return NULL;
+    }
+}*/
+
 /************************************************************
  * D3DXLoadSurfaceFromMemory
  *
@@ -1757,6 +1781,7 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     D3DSURFACE_DESC surfdesc;
     D3DLOCKED_RECT lockrect;
     struct volume src_size, dst_size;
+    HRESULT ret = D3D_OK;
 
     TRACE("(%p, %p, %s, %p, %#x, %u, %p, %s, %#x, 0x%08x)\n",
             dst_surface, dst_palette, wine_dbgstr_rect(dst_rect), src_memory, src_format,
@@ -1838,8 +1863,15 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     }
     else /* Stretching or format conversion. */
     {
-        if (((srcformatdesc->type != FORMAT_ARGB) && (srcformatdesc->type != FORMAT_INDEX)) ||
-            (destformatdesc->type != FORMAT_ARGB))
+        dxtn_conversion_func pre_convert, post_convert;
+        void *tmp_src_memory = NULL, *tmp_dst_memory = NULL;
+        UINT tmp_src_pitch, tmp_dst_pitch;
+
+        pre_convert  = get_dxtn_conversion_func(srcformatdesc->format, FALSE);
+        post_convert = get_dxtn_conversion_func(destformatdesc->format, TRUE);
+
+        if ((!pre_convert && (srcformatdesc->type != FORMAT_ARGB) && (srcformatdesc->type != FORMAT_INDEX)) ||
+            (!post_convert && (destformatdesc->type != FORMAT_ARGB)))
         {
             FIXME("Format conversion missing %#x -> %#x\n", src_format, surfdesc.Format);
             return E_NOTIMPL;
@@ -1848,26 +1880,86 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
         if (FAILED(IDirect3DSurface9_LockRect(dst_surface, &lockrect, dst_rect, 0)))
             return D3DXERR_INVALIDDATA;
 
+        /* handle pre-conversion */
+        if (pre_convert)
+        {
+            tmp_src_memory = HeapAlloc(GetProcessHeap(), 0, src_size.width * src_size.height * sizeof(DWORD));
+            if (!tmp_src_memory)
+            {
+                ret = E_OUTOFMEMORY;
+                goto error;
+            }
+            tmp_src_pitch = src_size.width * sizeof(DWORD);
+            if (!pre_convert(src_memory, tmp_src_memory, src_pitch, tmp_src_pitch,
+                    WINED3DFMT_B8G8R8A8_UNORM, src_size.width, src_size.height))
+            {
+                ret = E_FAIL;
+                goto error;
+            }
+            srcformatdesc = get_format_info(D3DFMT_A8R8G8B8);
+        }
+        else
+        {
+            tmp_src_memory = (void *)src_memory;
+            tmp_src_pitch  = src_pitch;
+        }
+
+        /* handle post-conversion */
+        if (post_convert)
+        {
+            tmp_dst_memory = HeapAlloc(GetProcessHeap(), 0, dst_size.width * dst_size.height * sizeof(DWORD));
+            if (!tmp_dst_memory)
+            {
+                ret = E_OUTOFMEMORY;
+                goto error;
+            }
+            tmp_dst_pitch = dst_size.width * sizeof(DWORD);
+            destformatdesc = get_format_info(D3DFMT_A8R8G8B8);
+        }
+        else
+        {
+            tmp_dst_memory = lockrect.pBits;
+            tmp_dst_pitch  = lockrect.Pitch;
+        }
+
         if ((filter & 0xf) == D3DX_FILTER_NONE)
         {
-            convert_argb_pixels(src_memory, src_pitch, 0, &src_size, srcformatdesc,
-                    lockrect.pBits, lockrect.Pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+            convert_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, srcformatdesc,
+                    tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
         }
         else /* if ((filter & 0xf) == D3DX_FILTER_POINT) */
         {
             if ((filter & 0xf) != D3DX_FILTER_POINT)
                 FIXME("Unhandled filter %#x.\n", filter);
+  // fixme:d3dx:D3DXLoadSurfaceFromMemory Unhandled filter 0x80004. == D3DX_FILTER_TRIANGLE + D3DX_FILTER_DITHER
+  // fixme:d3dx:D3DXLoadSurfaceFromMemory Unhandled filter 0x5. == D3DX_FILTER_BOX
 
             /* Always apply a point filter until D3DX_FILTER_LINEAR,
              * D3DX_FILTER_TRIANGLE and D3DX_FILTER_BOX are implemented. */
-            point_filter_argb_pixels(src_memory, src_pitch, 0, &src_size, srcformatdesc,
-                    lockrect.pBits, lockrect.Pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+            point_filter_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, srcformatdesc,
+                    tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+        }
+
+        /* handle post-conversion */
+        if (post_convert)
+        {
+            if (!post_convert(tmp_dst_memory, lockrect.pBits, tmp_dst_pitch, lockrect.Pitch,
+                    WINED3DFMT_B8G8R8A8_UNORM, dst_size.width, dst_size.height))
+            {
+                ret = E_FAIL;
+                goto error;
+            }
         }
 
+error:
+        if (pre_convert)
+            HeapFree(GetProcessHeap(), 0, tmp_src_memory);
+        if (post_convert)
+            HeapFree(GetProcessHeap(), 0, tmp_dst_memory);
         IDirect3DSurface9_UnlockRect(dst_surface);
     }
 
-    return D3D_OK;
+    return ret;
 }
 
 /************************************************************
diff --git a/dlls/d3dx9_36/tests/shader.c b/dlls/d3dx9_36/tests/shader.c
index 694540c..728cd86 100644
--- a/dlls/d3dx9_36/tests/shader.c
+++ b/dlls/d3dx9_36/tests/shader.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2008 Luis Busquets
+ * Copyright 2010, 2013 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -299,6 +300,26 @@ static const DWORD fx_shader_with_ctab[] =
     0x0000ffff                                                              /* END                      */
 };
 
+static const DWORD semantics_vs11[] = {
+    0xfffe0101,                                                             /* vs_1_1                       */
+    0x0001fffe, D3DSIO_DCL,                                                 /* Comment                      */
+    0x00000051, 0xa00f0001, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, /* def c1 = dcl, dcl, dcl, dcl  */
+    0x0000001f, 0x80000000, 0x900f0000,                                     /* dcl_position0 v0 (input)     */
+    0x0000001f, 0x80000005, 0x900f0001,                                     /* dcl_texcoord0 v1 (input)     */
+    0x0000001f, 0x80010005, 0x900f0002,                                     /* dcl_texcoord1 v2 (input)     */
+    0x0000001f, 0x8000000a, 0xe00f0000,                                     /* dcl_color0    oD0 (output)   */
+    0x0000ffff};                                                            /* END                          */
+
+static const DWORD semantics_vs30[] = {
+    0xfffe0300,                                                             /* vs_3_0                       */
+    0x0001fffe, D3DSIO_DCL,                                                 /* Comment                      */
+    0x05000051, 0xa00f0001, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, /* def c1 = dcl, dcl, dcl, dcl  */
+    0x0200001f, 0x80000000, 0x900f0000,                                     /* dcl_position0 v0 (input)     */
+    0x0200001f, 0x80000005, 0x900f0001,                                     /* dcl_texcoord0 v1 (input)     */
+    0x0200001f, 0x80010005, 0x900f0002,                                     /* dcl_texcoord1 v2 (input)     */
+    0x0200001f, 0x8000000a, 0xe00f0000,                                     /* dcl_color0    o0 (output)    */
+    0x0000ffff};                                                            /* END                          */
+
 static void test_get_shader_size(void)
 {
     UINT shader_size, expected;
@@ -6489,6 +6510,70 @@ static void test_registerset_defaults(void)
     if (wnd) DestroyWindow(wnd);
 }
 
+static void test_get_shader_semantics(void)
+{
+    HRESULT ret;
+    D3DXSEMANTIC semantics[MAXD3DDECLLENGTH];
+    UINT count;
+
+    /* Test D3DXGetShaderInputSemantics */
+
+    /* Check wrong parameters */
+    ret = D3DXGetShaderInputSemantics(NULL, NULL, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, NULL, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, semantics, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, semantics, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, NULL, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+
+    /* Check null semantics pointer */
+    count = 0xdeadbeef;
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, NULL, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+
+    /* Check null count pointer */
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, semantics, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Check with vs11 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Check with vs30 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs30, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+}
+
 START_TEST(shader)
 {
     test_get_shader_size();
@@ -6502,4 +6587,5 @@ START_TEST(shader)
     test_get_shader_constant_variables();
     test_registerset();
     test_registerset_defaults();
+    test_get_shader_semantics();
 }
diff --git a/dlls/d3dx9_36/tests/surface.c b/dlls/d3dx9_36/tests/surface.c
index 7a4dff8..87c3eb7 100644
--- a/dlls/d3dx9_36/tests/surface.c
+++ b/dlls/d3dx9_36/tests/surface.c
@@ -1103,7 +1103,7 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT3 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT3 format.\n");
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
         }
@@ -1129,7 +1129,7 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT5 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT5 format.\n");
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
         }
@@ -1142,10 +1142,10 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT1 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT1 format.\n");
 
             hr = D3DXLoadSurfaceFromSurface(surf, NULL, NULL, newsurf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels from DXT1 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels from DXT1 format.\n");
 
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
diff --git a/dlls/d3dx9_36/tests/texture.c b/dlls/d3dx9_36/tests/texture.c
index c90e2d5..d0a846a 100644
--- a/dlls/d3dx9_36/tests/texture.c
+++ b/dlls/d3dx9_36/tests/texture.c
@@ -384,6 +384,16 @@ static void test_D3DXCheckTextureRequirements(IDirect3DDevice9 *device)
         ok(height == 4, "Returned height %d, expected %d\n", height, 4);
         ok(mipmaps == 1, "Returned mipmaps %d, expected %d\n", mipmaps, 1);
         ok(format == D3DFMT_DXT5, "Returned format %u, expected %u\n", format, D3DFMT_DXT5);
+
+        format = D3DFMT_DXT5;
+        width = 5; height = 5;
+        mipmaps = 1;
+        hr = D3DXCheckTextureRequirements(device, &width, &height, &mipmaps, 0, &format, D3DPOOL_DEFAULT);
+        ok(hr == D3D_OK, "D3DXCheckTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
+        ok(width == 8, "Returned width %d, expected %d\n", width, 8);
+        ok(height == 8, "Returned height %d, expected %d\n", height, 8);
+        ok(mipmaps == 1, "Returned mipmaps %d, expected %d\n", mipmaps, 1);
+        ok(format == D3DFMT_DXT5, "Returned format %u, expected %u\n", format, D3DFMT_DXT5);
     }
     else
     {
diff --git a/dlls/d3dx9_36/texture.c b/dlls/d3dx9_36/texture.c
index 38349e2..d160882 100644
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -334,10 +334,10 @@ HRESULT WINAPI D3DXCheckTextureRequirements(struct IDirect3DDevice9 *device, UIN
 
     if (fmt->block_width != 1 || fmt->block_height != 1)
     {
-        if (w < fmt->block_width)
-            w = fmt->block_width;
-        if (h < fmt->block_height)
-            h = fmt->block_height;
+        if (w % fmt->block_width)
+            w += fmt->block_width - w % fmt->block_width;
+        if (h % fmt->block_height)
+            h += fmt->block_height - h % fmt->block_height;
     }
 
     if ((caps.TextureCaps & D3DPTEXTURECAPS_POW2) && (!is_pow2(w)))
diff --git a/dlls/d3dx9_36/volume.c b/dlls/d3dx9_36/volume.c
index fae8542..a00cba3 100644
--- a/dlls/d3dx9_36/volume.c
+++ b/dlls/d3dx9_36/volume.c
@@ -16,11 +16,16 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
 #include "wine/debug.h"
 #include "d3dx9_36_private.h"
 
+#include "wine/wined3d.h"
+
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
+
 HRESULT WINAPI D3DXLoadVolumeFromFileA(IDirect3DVolume9 *dst_volume,
                                        const PALETTEENTRY *dst_palette,
                                        const D3DBOX *dst_box,
@@ -183,25 +188,30 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
     }
     else
     {
-        const BYTE *src_addr;
-
-
-        if (((src_format_desc->type != FORMAT_ARGB) && (src_format_desc->type != FORMAT_INDEX)) ||
-            (dst_format_desc->type != FORMAT_ARGB))
+ //       const BYTE *src_addr;
+        dxtn_conversion_func pre_convert, post_convert;
+        void *tmp_src_memory = NULL, *tmp_dst_memory = NULL;
+        UINT tmp_src_pitch, tmp_dst_pitch;
+      
+        pre_convert  = get_dxtn_conversion_func(src_format_desc->format, FALSE);
+        post_convert = get_dxtn_conversion_func(dst_format_desc->format, TRUE);
+      
+        if ((!pre_convert && (src_format_desc->type != FORMAT_ARGB) && (src_format_desc->type != FORMAT_INDEX)) ||
+            (!post_convert && (dst_format_desc->type != FORMAT_ARGB)))
         {
             FIXME("Pixel format conversion is not implemented %#x -> %#x\n",
                     src_format_desc->format, dst_format_desc->format);
+          // D3DFMT_X8R8G8B8 = 22 =0x16,   -> DXT5
             return E_NOTIMPL;
         }
-
-        src_addr = src_memory;
+      hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
+      if (FAILED(hr)) return hr;
+      
+  /*      src_addr = src_memory;
         src_addr += src_box->Front * src_slice_pitch;
         src_addr += src_box->Top * src_row_pitch;
         src_addr += src_box->Left * src_format_desc->bytes_per_pixel;
 
-        hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
-        if (FAILED(hr)) return hr;
-
         if ((filter & 0xf) == D3DX_FILTER_NONE)
         {
             convert_argb_pixels(src_memory, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
@@ -216,12 +226,89 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
             point_filter_argb_pixels(src_addr, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
                     locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, &dst_size, dst_format_desc, color_key,
                     src_palette);
+        } */
+      /* handle pre-conversion */
+      if (pre_convert)
+      {
+        tmp_src_memory = HeapAlloc(GetProcessHeap(), 0, src_size.width * src_size.height * sizeof(DWORD));
+        if (!tmp_src_memory)
+        {
+          hr = E_OUTOFMEMORY;
+          goto error;
+        }
+        tmp_src_pitch = src_size.width * sizeof(DWORD);
+        if (!pre_convert(src_memory, tmp_src_memory, src_row_pitch, tmp_src_pitch,
+                         wined3dformat_from_d3dformat(src_format_desc->format),
+                         src_size.width, src_size.height))
+        {
+          hr = E_FAIL;
+          goto error;
+        }
+        src_format_desc = get_format_info(src_format_desc->format);
+      }
+      else
+      {
+        tmp_src_memory = (void *)src_memory;
+        tmp_src_pitch  = src_row_pitch;
+      }
+      
+      /* handle post-conversion */
+      if (post_convert)
+      {
+        tmp_dst_memory = HeapAlloc(GetProcessHeap(), 0, dst_size.width * dst_size.height * sizeof(DWORD));
+        if (!tmp_dst_memory)
+        {
+          hr = E_OUTOFMEMORY;
+          goto error;
         }
+        tmp_dst_pitch = dst_size.width * sizeof(DWORD);
+        dst_format_desc = get_format_info(dst_format_desc->format);
+      }
+      else
+      {
+        tmp_dst_memory = locked_box.pBits;
+        tmp_dst_pitch  = locked_box.RowPitch;
+      }
+      
+      if ((filter & 0xf) == D3DX_FILTER_NONE)
+      {
+        convert_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, src_format_desc,
+                            tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, dst_format_desc, color_key, src_palette);
+      }
+      else /* if ((filter & 0xf) == D3DX_FILTER_POINT) */
+      {
+        if ((filter & 0xf) != D3DX_FILTER_POINT)
+          FIXME("Unhandled filter %#x.\n", filter);
+        
+        /* Always apply a point filter until D3DX_FILTER_LINEAR,
+         * D3DX_FILTER_TRIANGLE and D3DX_FILTER_BOX are implemented. */
+        point_filter_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, src_format_desc,
+                                 tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, dst_format_desc, color_key, src_palette);
+        
+      }
+      
+      /* handle post-conversion */
+      if (post_convert)
+      {
+        if (!post_convert(tmp_dst_memory, locked_box.pBits, tmp_dst_pitch, locked_box.RowPitch,
+                          wined3dformat_from_d3dformat(dst_format_desc->format), dst_size.width, dst_size.height))
+        {
+          hr = E_FAIL;
+          goto error;
+        }
+      }
+      
+    error:
+      if (pre_convert)
+        HeapFree(GetProcessHeap(), 0, tmp_src_memory);
+      if (post_convert)
+        HeapFree(GetProcessHeap(), 0, tmp_dst_memory);
+
 
         IDirect3DVolume9_UnlockBox(dst_volume);
     }
 
-    return D3D_OK;
+    return hr;
 }
 
 HRESULT WINAPI D3DXLoadVolumeFromFileInMemory(IDirect3DVolume9 *dst_volume,
diff --git a/dlls/dbghelp/path.c b/dlls/dbghelp/path.c
index 5bd260e..94b0e0e 100644
--- a/dlls/dbghelp/path.c
+++ b/dlls/dbghelp/path.c
@@ -541,6 +541,8 @@ static BOOL CALLBACK module_find_cb(PCWSTR buffer, PVOID user)
             struct pdb_lookup           pdb_lookup;
             char                        fn[MAX_PATH];
 
+          memset(&pdb_lookup, 0, sizeof(struct pdb_lookup));
+
             WideCharToMultiByte(CP_ACP, 0, buffer, -1, fn, MAX_PATH, NULL, NULL);
             pdb_lookup.filename = fn;
 
diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index 31ec6bf..b860834 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -3119,46 +3119,97 @@ static HRESULT WINAPI ddraw7_EnumSurfaces(IDirectDraw7 *iface, DWORD Flags,
 {
     struct ddraw *ddraw = impl_from_IDirectDraw7(iface);
     struct ddraw_surface *surf;
-    BOOL all, nomatch;
-    DDSURFACEDESC2 desc;
-    struct list *entry, *entry2;
+    DWORD match_flags = Flags & (DDENUMSURFACES_ALL | DDENUMSURFACES_NOMATCH | DDENUMSURFACES_MATCH);
 
     TRACE("iface %p, flags %#x, surface_desc %p, context %p, callback %p.\n",
             iface, Flags, DDSD, Context, Callback);
 
-    all = Flags & DDENUMSURFACES_ALL;
-    nomatch = Flags & DDENUMSURFACES_NOMATCH;
-
     if (!Callback)
         return DDERR_INVALIDPARAMS;
 
-    wined3d_mutex_lock();
-
-    /* Use the _SAFE enumeration, the app may destroy enumerated surfaces */
-    LIST_FOR_EACH_SAFE(entry, entry2, &ddraw->surface_list)
+    if (Flags & DDENUMSURFACES_CANBECREATED)
     {
-        surf = LIST_ENTRY(entry, struct ddraw_surface, surface_list_entry);
+         IDirectDrawSurface7 *surface;
+         DDSURFACEDESC2 testdesc;
+
+        if (match_flags != DDENUMSURFACES_MATCH)
+            return DDERR_INVALIDPARAMS;
+
+        if (!DDSD)
+            return DDERR_INVALIDPARAMS;
+
+        memcpy(&testdesc, DDSD, sizeof(testdesc));
+
+        if (!(testdesc.dwFlags & DDSD_WIDTH))
+        {
+            testdesc.dwFlags |= DDSD_WIDTH;
+            testdesc.dwWidth = 512;
+        }
 
-        if (!surf->iface_count)
+        if (!(testdesc.dwFlags & DDSD_HEIGHT))
         {
-            WARN("Not enumerating surface %p because it doesn't have any references.\n", surf);
-            continue;
+            testdesc.dwFlags |= DDSD_HEIGHT;
+            testdesc.dwHeight = 512;
         }
 
-        if (all || (nomatch != ddraw_match_surface_desc(DDSD, &surf->surface_desc)))
+        if (IDirectDraw7_CreateSurface(iface, &testdesc, &surface, NULL) == DD_OK)
+        {
+            surf = unsafe_impl_from_IDirectDrawSurface7(surface);
+            Callback(NULL, &surf->surface_desc, Context);
+            IDirectDrawSurface7_Release(surface);
+        }
+        else
+            FIXME("Failed to create surface!\n");
+    }
+    else if (Flags & DDENUMSURFACES_DOESEXIST)
+    {
+        DDSURFACEDESC2 desc;
+        struct list *entry, *entry2;
+        BOOL nomatch, all;
+
+        /* a combination of match flags is not allowed */
+        if (match_flags != 0 &&
+                match_flags != DDENUMSURFACES_ALL &&
+                match_flags != DDENUMSURFACES_MATCH &&
+                match_flags != DDENUMSURFACES_NOMATCH)
+            return DDERR_INVALIDPARAMS;
+
+        all = (Flags & DDENUMSURFACES_ALL) != 0;
+        nomatch = (Flags & DDENUMSURFACES_NOMATCH) != 0;
+
+        if (!all && !DDSD)
+            return DDERR_INVALIDPARAMS;
+
+        wined3d_mutex_lock();
+
+        /* Use the _SAFE enumeration, the app may destroy enumerated surfaces */
+        LIST_FOR_EACH_SAFE(entry, entry2, &ddraw->surface_list)
         {
-            TRACE("Enumerating surface %p.\n", surf);
-            desc = surf->surface_desc;
-            IDirectDrawSurface7_AddRef(&surf->IDirectDrawSurface7_iface);
-            if (Callback(&surf->IDirectDrawSurface7_iface, &desc, Context) != DDENUMRET_OK)
+            surf = LIST_ENTRY(entry, struct ddraw_surface, surface_list_entry);
+
+            if (!surf->iface_count)
             {
-                wined3d_mutex_unlock();
-                return DD_OK;
+                WARN("Not enumerating surface %p because it doesn't have any references.\n", surf);
+                continue;
+            }
+
+            if (all || (nomatch != ddraw_match_surface_desc(DDSD, &surf->surface_desc)))
+            {
+                TRACE("Enumerating surface %p.\n", surf);
+                desc = surf->surface_desc;
+                IDirectDrawSurface7_AddRef(&surf->IDirectDrawSurface7_iface);
+                if (Callback(&surf->IDirectDrawSurface7_iface, &desc, Context) != DDENUMRET_OK)
+                {
+                    wined3d_mutex_unlock();
+                    return DD_OK;
+                }
             }
         }
-    }
 
-    wined3d_mutex_unlock();
+        wined3d_mutex_unlock();
+    }
+    else
+        return DDERR_INVALIDPARAMS;
 
     return DD_OK;
 }
diff --git a/dlls/ddraw/main.c b/dlls/ddraw/main.c
index 2f5d113..0d2a18d 100644
--- a/dlls/ddraw/main.c
+++ b/dlls/ddraw/main.c
@@ -251,6 +251,11 @@ DDRAW_Create(const GUID *guid,
     {
         device_type = WINED3D_DEVICE_TYPE_HAL;
     }
+    else if(guid && guid->Data1 == 0xaeb2cdd4)
+    {
+      FIXME("call to 0xaeb2cdd4\n");
+      device_type = WINED3D_DEVICE_TYPE_HAL;
+    }
     else
     {
         device_type = 0;
@@ -936,8 +941,8 @@ BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
                 desc.dwSize = sizeof(desc);
                 for(i = 0; i <= 1; i++)
                 {
-                    hr = IDirectDraw7_EnumSurfaces(&ddraw->IDirectDraw7_iface, DDENUMSURFACES_ALL,
-                            &desc, ddraw, DestroyCallback);
+                    hr = IDirectDraw7_EnumSurfaces(&ddraw->IDirectDraw7_iface,
+                            DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL, &desc, ddraw, DestroyCallback);
                     if(hr != D3D_OK)
                         ERR("(%p) EnumSurfaces failed, prepare for trouble\n", ddraw);
                 }
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index 0d2d731..6e72453 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -688,6 +688,10 @@ static ULONG WINAPI d3d_texture2_Release(IDirect3DTexture2 *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture2(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p.\n", iface);
 
     return IUnknown_Release(surface->texture_outer);
@@ -697,6 +701,10 @@ static ULONG WINAPI d3d_texture1_Release(IDirect3DTexture *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p.\n", iface);
 
     return IUnknown_Release(surface->texture_outer);
@@ -737,6 +745,10 @@ static HRESULT WINAPI ddraw_surface7_GetAttachedSurface(IDirectDrawSurface7 *ifa
     DDSCAPS2 our_caps;
     int i;
 
+  if (!This) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, Caps, Surface);
 
     wined3d_mutex_lock();
@@ -824,6 +836,10 @@ static HRESULT WINAPI ddraw_surface4_GetAttachedSurface(IDirectDrawSurface4 *ifa
     IDirectDrawSurface7 *attachment7;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     hr = ddraw_surface7_GetAttachedSurface(&surface->IDirectDrawSurface7_iface,
@@ -850,6 +866,10 @@ static HRESULT WINAPI ddraw_surface3_GetAttachedSurface(IDirectDrawSurface3 *ifa
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -881,6 +901,10 @@ static HRESULT WINAPI ddraw_surface2_GetAttachedSurface(IDirectDrawSurface2 *ifa
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -912,6 +936,10 @@ static HRESULT WINAPI ddraw_surface1_GetAttachedSurface(IDirectDrawSurface *ifac
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -1034,6 +1062,10 @@ static HRESULT WINAPI ddraw_surface7_Lock(IDirectDrawSurface7 *iface,
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface7(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1052,6 +1084,10 @@ static HRESULT WINAPI ddraw_surface4_Lock(IDirectDrawSurface4 *iface, RECT *rect
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1072,6 +1108,10 @@ static HRESULT WINAPI ddraw_surface3_Lock(IDirectDrawSurface3 *iface, RECT *rect
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1098,6 +1138,10 @@ static HRESULT WINAPI ddraw_surface2_Lock(IDirectDrawSurface2 *iface, RECT *rect
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1123,6 +1167,10 @@ static HRESULT WINAPI ddraw_surface1_Lock(IDirectDrawSurface *iface, RECT *rect,
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1160,6 +1208,10 @@ static HRESULT WINAPI ddraw_surface7_Unlock(IDirectDrawSurface7 *iface, RECT *pR
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface7(iface);
     HRESULT hr;
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, rect %s.\n", iface, wine_dbgstr_rect(pRect));
 
     wined3d_mutex_lock();
@@ -1175,6 +1227,10 @@ static HRESULT WINAPI ddraw_surface4_Unlock(IDirectDrawSurface4 *iface, RECT *pR
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, rect %p.\n", iface, pRect);
 
     return ddraw_surface7_Unlock(&surface->IDirectDrawSurface7_iface, pRect);
@@ -1184,6 +1240,10 @@ static HRESULT WINAPI ddraw_surface3_Unlock(IDirectDrawSurface3 *iface, void *da
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
@@ -1194,6 +1254,10 @@ static HRESULT WINAPI ddraw_surface2_Unlock(IDirectDrawSurface2 *iface, void *da
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
@@ -1204,6 +1268,10 @@ static HRESULT WINAPI ddraw_surface1_Unlock(IDirectDrawSurface *iface, void *dat
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
@@ -1218,10 +1286,14 @@ static HRESULT WINAPI ddraw_surface7_Flip(IDirectDrawSurface7 *iface, IDirectDra
     struct ddraw_texture *ddraw_texture, *prev_ddraw_texture;
     DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, {0}};
     struct wined3d_texture *texture;
-    IDirectDrawSurface7 *current;
+    IDirectDrawSurface7 *current = NULL;
     struct wined3d_surface *tmp;
     HRESULT hr;
 
+  if (!src_impl || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, src %p, flags %#x.\n", iface, src, flags);
 
     if (src == iface || !(dst_impl->surface_desc.ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_OVERLAY)))
@@ -1337,6 +1409,10 @@ static HRESULT WINAPI ddraw_surface4_Flip(IDirectDrawSurface4 *iface, IDirectDra
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface4(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1348,6 +1424,10 @@ static HRESULT WINAPI ddraw_surface3_Flip(IDirectDrawSurface3 *iface, IDirectDra
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface3(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1359,6 +1439,10 @@ static HRESULT WINAPI ddraw_surface2_Flip(IDirectDrawSurface2 *iface, IDirectDra
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface2(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1370,6 +1454,10 @@ static HRESULT WINAPI ddraw_surface1_Flip(IDirectDrawSurface *iface, IDirectDraw
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
diff --git a/dlls/ddraw/tests/d3d.c b/dlls/ddraw/tests/d3d.c
index ec4197a..457ebbc 100644
--- a/dlls/ddraw/tests/d3d.c
+++ b/dlls/ddraw/tests/d3d.c
@@ -57,6 +57,11 @@ typedef struct {
     int total;
 } D3D7ECancelTest;
 
+typedef struct {
+    UINT found;
+    UINT surfaces;
+} EnumSurfaceTest;
+
 #define MAX_ENUMERATION_COUNT 10
 typedef struct
 {
@@ -85,17 +90,21 @@ static ULONG getRefcount(IUnknown *iface)
 
 static HRESULT WINAPI SurfaceCounter(IDirectDrawSurface7 *surface, DDSURFACEDESC2 *desc, void *context)
 {
-    UINT *num = context;
-    (*num)++;
-    IDirectDrawSurface_Release(surface);
+    EnumSurfaceTest *count = context;
+    count->found++;
+    if (surface)
+    {
+        count->surfaces++;
+        IDirectDrawSurface_Release(surface);
+    }
     return DDENUMRET_OK;
 }
 
 static BOOL CreateDirect3D(void)
 {
     HRESULT rc;
-    DDSURFACEDESC2 ddsd;
-    UINT num;
+    DDSURFACEDESC2 ddsd, ddsd2;
+    EnumSurfaceTest count;
 
     rc = pDirectDrawCreateEx(NULL, (void**)&lpDD,
         &IID_IDirectDraw7, NULL);
@@ -122,9 +131,174 @@ static BOOL CreateDirect3D(void)
     if (FAILED(rc))
         return FALSE;
 
-    num = 0;
-    IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_ALL | DDENUMSURFACES_DOESEXIST, NULL, &num, SurfaceCounter);
-    ok(num == 1, "Has %d surfaces, expected 1\n", num);
+    memset(&ddsd2, 0, sizeof(ddsd2));
+    ddsd2.dwSize = sizeof(ddsd2);
+    ddsd2.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
+    ddsd2.dwWidth = 256;
+    ddsd2.dwHeight = 256;
+
+    /* without search type flags */
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, 0, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, 0, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_ALL, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_MATCH, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_NOMATCH, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    /* search type DDENUMSURFACES_DOESEXIST */
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST, &ddsd2, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL, NULL, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_MATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_NOMATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_MATCH, &ddsd2, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_NOMATCH, &ddsd2, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL | DDENUMSURFACES_MATCH,
+                                   NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL | DDENUMSURFACES_NOMATCH,
+                                   NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_MATCH | DDENUMSURFACES_NOMATCH,
+                                   NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    /* search type DDENUMSURFACES_CANBECREATED */
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_ALL, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_NOMATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_MATCH, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_MATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    /* combination of DDENUMSURFACES_DOESEXIST and DDENUMSURFACES_CANBECREATED */
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_MATCH,
+                                   &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
diff --git a/dlls/dinput/joystick_osx.c b/dlls/dinput/joystick_osx.c
index 6a8926d..d8ce99d 100644
--- a/dlls/dinput/joystick_osx.c
+++ b/dlls/dinput/joystick_osx.c
@@ -702,7 +702,7 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
         for ( idx = 0; idx < cnt; idx++ )
         {
             IOHIDValueRef valueRef;
-            int val, oldVal, newVal;
+            int val, oldVal = 0, newVal;
             IOHIDElementRef element = ( IOHIDElementRef ) CFArrayGetValueAtIndex( device->elements, idx );
             int type = IOHIDElementGetType( element );
 
diff --git a/dlls/gdi32/dibdrv/opengl.c b/dlls/gdi32/dibdrv/opengl.c
index a25da208..a0934d1 100644
--- a/dlls/gdi32/dibdrv/opengl.c
+++ b/dlls/gdi32/dibdrv/opengl.c
@@ -149,7 +149,8 @@ static int dibdrv_wglDescribePixelFormat( HDC hdc, int fmt, UINT size, PIXELFORM
 {
     int ret = sizeof(pixel_formats) / sizeof(pixel_formats[0]);
 
-    if (fmt <= 0 || fmt > ret) return ret;
+    if (!descr) return ret;
+    if (fmt <= 0 || fmt > ret) return ret; /* FIXME: should this be 0? */
     if (size < sizeof(*descr)) return 0;
 
     memset( descr, 0, sizeof(*descr) );
diff --git a/dlls/ieframe/client.c b/dlls/ieframe/client.c
index dadbe13..40a4c2f 100644
--- a/dlls/ieframe/client.c
+++ b/dlls/ieframe/client.c
@@ -297,6 +297,9 @@ static HRESULT WINAPI InPlaceSite_OnInPlaceActivateEx(IOleInPlaceSiteEx *iface,
     TRACE("(%p)->(%p, %x)\n", This, pfNoRedraw, dwFlags);
 
     /* FIXME: Avoid redraw, when possible */
+    if (!pfNoRedraw) {
+      return S_OK;
+    }
     *pfNoRedraw = FALSE;
 
     if (dwFlags) {
diff --git a/dlls/krnl386.exe16/int2f.c b/dlls/krnl386.exe16/int2f.c
index f5b5aaa..383c094 100644
--- a/dlls/krnl386.exe16/int2f.c
+++ b/dlls/krnl386.exe16/int2f.c
@@ -1027,8 +1027,8 @@ static void MSCDEX_Handler(CONTEXT* context)
                ERR("ES:BX==0 ! SEGFAULT ?\n");
                ERR("-->BX=0x%04x, ES=0x%04x, DS=0x%04x, CX=0x%04x\n",
                    BX_reg(context), context->SegEs, context->SegDs, CX_reg(context));
-               driver_request[4] |= 0x80;
-               driver_request[3] = 5;  /* bad request length */
+   //            driver_request[4] |= 0x80;
+   //            driver_request[3] = 5;  /* bad request length */
                return;
            }
 
diff --git a/dlls/ntdll/actctx.c b/dlls/ntdll/actctx.c
index 715a760..558924d 100644
--- a/dlls/ntdll/actctx.c
+++ b/dlls/ntdll/actctx.c
@@ -4431,6 +4431,9 @@ static NTSTATUS find_string(ACTIVATION_CONTEXT* actctx, ULONG section_kind,
 
     switch (section_kind)
     {
+    case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION:
+        FIXME("Unsupported yet section_kind %x\n", section_kind);
+        return STATUS_SXS_KEY_NOT_FOUND;
     case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION:
         status = find_dll_redirection(actctx, section_name, data);
         break;
diff --git a/dlls/secur32/schannel_macosx.c b/dlls/secur32/schannel_macosx.c
index cfd2371..c71189c 100644
--- a/dlls/secur32/schannel_macosx.c
+++ b/dlls/secur32/schannel_macosx.c
@@ -1016,6 +1016,7 @@ BOOL schan_imp_init(void)
     supported_protocols = SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_TLS1_0_CLIENT;
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
+#ifdef   SSLGetProtocolVersionMax
     if(SSLGetProtocolVersionMax != NULL) {
         SSLProtocol max_protocol;
         SSLContextRef ctx;
@@ -1036,6 +1037,7 @@ BOOL schan_imp_init(void)
         }
     }
 #endif
+#endif
 
     return TRUE;
 }
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index b3615e8..5eada21 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -284,12 +284,20 @@ BOOL WINAPI EnumDisplayDevicesA( LPCSTR lpDevice, DWORD i, LPDISPLAY_DEVICEA lpD
 BOOL WINAPI EnumDisplayDevicesW( LPCWSTR lpDevice, DWORD i, LPDISPLAY_DEVICEW lpDisplayDevice,
                                  DWORD dwFlags )
 {
+  if (!lpDisplayDevice) {
+    return FALSE;
+  }
+  
+  if (i) {
     FIXME("(%s,%d,%p,0x%08x), stub!\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
-
-    if (i)
         return FALSE;
+  }
 
+  if (lpDevice) {
+    strcpyW(lpDisplayDevice->DeviceName, lpDevice);
+  } else {
     memcpy(lpDisplayDevice->DeviceName, primary_device_name, sizeof(primary_device_name));
+  }
     memcpy(lpDisplayDevice->DeviceString, primary_device_string, sizeof(primary_device_string));
   
     lpDisplayDevice->StateFlags =
@@ -302,6 +310,9 @@ BOOL WINAPI EnumDisplayDevicesW( LPCWSTR lpDevice, DWORD i, LPDISPLAY_DEVICEW lp
     if(lpDisplayDevice->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(lpDisplayDevice->DeviceKey))
         lpDisplayDevice->DeviceKey[0] = 0;
 
+    TRACE("DeviceName %s DeviceString %s DeviceID %s DeviceKey %s\n", debugstr_w(lpDisplayDevice->DeviceName),
+          debugstr_w(lpDisplayDevice->DeviceString), debugstr_w(lpDisplayDevice->DeviceID), debugstr_w(lpDisplayDevice->DeviceKey));
+
     return TRUE;
 }
 
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 8ff3ebd..fe8c397 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -55,6 +55,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION surfaces_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+/* from dlls/ntdll/actctx.c */
+struct wndclass_redirect_data
+{
+    ULONG size;
+    DWORD res;
+    ULONG name_len;
+    ULONG name_offset;
+    ULONG module_len;
+    ULONG module_offset;
+};
+
 /**********************************************************************/
 
 /* helper for Get/SetWindowLong */
@@ -1292,6 +1303,39 @@ static void dump_window_styles( DWORD style, DWORD exstyle )
 #undef DUMPED_EX_STYLES
 }
 
+static BOOL get_redir_class_name(LPCWSTR className, LPWSTR redirClassName, int len)
+{
+    ATOM classatom;
+    ACTCTX_SECTION_KEYED_DATA askd;
+    WCHAR classNameStr[256];
+    struct wndclass_redirect_data* wcrd;
+
+    classatom = get_int_atom_value(className);
+    if (classatom)
+        GlobalGetAtomNameW(classatom, classNameStr, sizeof(classNameStr) / sizeof(*classNameStr));
+    else
+        strcpyW(classNameStr, className);
+
+    askd.cbSize = sizeof(askd);
+    if (FindActCtxSectionStringW(0, NULL, ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, classNameStr, &askd)) {
+        wcrd = askd.lpData;
+
+        if (wcrd->name_len == 0)
+            return FALSE;
+
+        if (wcrd->name_len > len) {
+            WARN("Redirected class name too long for buffer\n");
+            return FALSE;
+        }
+
+        memcpy(redirClassName, (unsigned char*)askd.lpData + wcrd->name_offset, wcrd->name_len);
+        redirClassName[wcrd->name_len / sizeof(WCHAR)] = 0;
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
 
 /***********************************************************************
  *           WIN_CreateWindowEx
@@ -1308,6 +1352,7 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     MDICREATESTRUCTW mdi_cs;
     CBT_CREATEWNDW cbtc;
     CREATESTRUCTW cbcs;
+    WCHAR redirClassName[256];
 
     TRACE("%s %s ex=%08x style=%08x %d,%d %dx%d parent=%p menu=%p inst=%p params=%p\n",
           unicode ? debugstr_w(cs->lpszName) : debugstr_a((LPCSTR)cs->lpszName),
@@ -1444,6 +1489,23 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
 
     /* Create the window structure */
 
+    wndPtr = NULL;
+
+    if (get_redir_class_name(className, redirClassName, sizeof(redirClassName)))
+    {
+        WNDCLASSW wc;
+
+        TRACE("Redirecting %s to %s\n", debugstr_w(className), debugstr_w(redirClassName));
+
+        wndPtr = create_window_handle( parent, owner, redirClassName, module, unicode );
+
+        if (GetLastError() == ERROR_INVALID_HANDLE && GetClassInfoW( 0, redirClassName, &wc ))
+            wndPtr = create_window_handle( parent, owner, redirClassName, module, unicode );
+
+        if (!wndPtr)
+            WARN("Could not create window of class %s\n", debugstr_w(redirClassName));
+    }
+
     if (!(wndPtr = create_window_handle( parent, owner, className, module, unicode )))
     {
         WNDCLASSW wc;
diff --git a/dlls/windowscodecs/stream.c b/dlls/windowscodecs/stream.c
index f6bfedf..0af9d81 100644
--- a/dlls/windowscodecs/stream.c
+++ b/dlls/windowscodecs/stream.c
@@ -1021,7 +1021,7 @@ HRESULT stream_initialize_from_filehandle(IWICStream *iface, HANDLE file)
     StreamOnFileHandle *pObject;
     IWICStream *stream = NULL;
     HANDLE map;
-    void *mem;
+    void *mem = NULL;
     LARGE_INTEGER size;
     HRESULT hr;
     TRACE("(%p,%p)\n", iface, file);
diff --git a/dlls/wined3d/Makefile.in b/dlls/wined3d/Makefile.in
index 655800b..ee0615f 100644
--- a/dlls/wined3d/Makefile.in
+++ b/dlls/wined3d/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	device.c \
 	directx.c \
 	drawprim.c \
+	dxtn.c \
 	gl_compat.c \
 	glsl_shader.c \
 	nvidia_texture_shader.c \
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 20a0e23..da9dd16 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -3562,12 +3562,15 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
     }
 
     /* Check that both textures have the identical numbers of levels. */
-    level_count = wined3d_texture_get_level_count(src_texture);
+/*    level_count = wined3d_texture_get_level_count(src_texture);
     if (wined3d_texture_get_level_count(dst_texture) != level_count)
     {
         WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
         return WINED3DERR_INVALIDCALL;
-    }
+    } */
+  //hack by Matteo Bruni at bug 38048
+  level_count = min(wined3d_texture_get_level_count(src_texture),
+                    wined3d_texture_get_level_count(dst_texture));
 
     /* Make sure that the destination texture is loaded. */
     context = context_acquire(device, NULL);
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 01048fd..69bd5cd 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -108,10 +108,11 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_APPLE_ycbcr_422",                  APPLE_YCBCR_422               },
 
     /* ARB */
-    {"GL_ARB_blend_func_extended",          ARB_BLEND_FUNC_EXTENDED       },
+    {"GL_ARB_blend_func_extended",          ARB_BLEND_FUNC_EXTENDED       },//ns
     {"GL_ARB_color_buffer_float",           ARB_COLOR_BUFFER_FLOAT        },
     {"GL_ARB_debug_output",                 ARB_DEBUG_OUTPUT              },
     {"GL_ARB_depth_buffer_float",           ARB_DEPTH_BUFFER_FLOAT        },
+    {"GL_ARB_depth_clamp",                  ARB_DEPTH_CLAMP               },
     {"GL_ARB_depth_texture",                ARB_DEPTH_TEXTURE             },
     {"GL_ARB_draw_buffers",                 ARB_DRAW_BUFFERS              },
     {"GL_ARB_draw_elements_base_vertex",    ARB_DRAW_ELEMENTS_BASE_VERTEX },
@@ -134,7 +135,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_point_parameters",             ARB_POINT_PARAMETERS          },
     {"GL_ARB_point_sprite",                 ARB_POINT_SPRITE              },
     {"GL_ARB_provoking_vertex",             ARB_PROVOKING_VERTEX          },
-    {"GL_ARB_sampler_objects",              ARB_SAMPLER_OBJECTS           },
+    {"GL_ARB_sampler_objects",              ARB_SAMPLER_OBJECTS           }, //ns
     {"GL_ARB_shader_bit_encoding",          ARB_SHADER_BIT_ENCODING       },
     {"GL_ARB_shader_objects",               ARB_SHADER_OBJECTS            },
     {"GL_ARB_shader_texture_lod",           ARB_SHADER_TEXTURE_LOD        },
@@ -145,6 +146,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_texture_compression",          ARB_TEXTURE_COMPRESSION       },
     {"GL_ARB_texture_compression_rgtc",     ARB_TEXTURE_COMPRESSION_RGTC  },
     {"GL_ARB_texture_cube_map",             ARB_TEXTURE_CUBE_MAP          },
+    {"GL_ARB_texture_env_add",              ARB_TEXTURE_ENV_ADD           },
     {"GL_ARB_texture_env_combine",          ARB_TEXTURE_ENV_COMBINE       },
     {"GL_ARB_texture_env_dot3",             ARB_TEXTURE_ENV_DOT3          },
     {"GL_ARB_texture_float",                ARB_TEXTURE_FLOAT             },
@@ -153,8 +155,8 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_texture_non_power_of_two",     ARB_TEXTURE_NON_POWER_OF_TWO  },
     {"GL_ARB_texture_rectangle",            ARB_TEXTURE_RECTANGLE         },
     {"GL_ARB_texture_rg",                   ARB_TEXTURE_RG                },
-    {"GL_ARB_timer_query",                  ARB_TIMER_QUERY               },
-    {"GL_ARB_uniform_buffer_object",        ARB_UNIFORM_BUFFER_OBJECT     },
+    {"GL_ARB_timer_query",                  ARB_TIMER_QUERY               },//ns
+    {"GL_ARB_uniform_buffer_object",        ARB_UNIFORM_BUFFER_OBJECT     },//ns
     {"GL_ARB_vertex_array_bgra",            ARB_VERTEX_ARRAY_BGRA         },
     {"GL_ARB_vertex_blend",                 ARB_VERTEX_BLEND              },
     {"GL_ARB_vertex_buffer_object",         ARB_VERTEX_BUFFER_OBJECT      },
@@ -183,6 +185,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_gpu_program_parameters",       EXT_GPU_PROGRAM_PARAMETERS    },
     {"GL_EXT_gpu_shader4",                  EXT_GPU_SHADER4               },
     {"GL_EXT_packed_depth_stencil",         EXT_PACKED_DEPTH_STENCIL      },
+    {"GL_EXT_paletted_texture",             EXT_PALETTED_TEXTURE          },//ns
     {"GL_EXT_point_parameters",             EXT_POINT_PARAMETERS          },
     {"GL_EXT_provoking_vertex",             EXT_PROVOKING_VERTEX          },
     {"GL_EXT_secondary_color",              EXT_SECONDARY_COLOR           },
@@ -191,6 +194,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_texture3D",                    EXT_TEXTURE3D                 },
     {"GL_EXT_texture_compression_rgtc",     EXT_TEXTURE_COMPRESSION_RGTC  },
     {"GL_EXT_texture_compression_s3tc",     EXT_TEXTURE_COMPRESSION_S3TC  },
+    {"GL_EXT_texture_env_add",              EXT_TEXTURE_ENV_ADD           },
     {"GL_EXT_texture_env_combine",          EXT_TEXTURE_ENV_COMBINE       },
     {"GL_EXT_texture_env_dot3",             EXT_TEXTURE_ENV_DOT3          },
     {"GL_EXT_texture_filter_anisotropic",   EXT_TEXTURE_FILTER_ANISOTROPIC},
@@ -202,6 +206,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_vertex_array_bgra",            EXT_VERTEX_ARRAY_BGRA         },
 
     /* NV */
+    {"GL_NV_depth_clamp",                   NV_DEPTH_CLAMP                },
     {"GL_NV_fence",                         NV_FENCE                      },
     {"GL_NV_fog_distance",                  NV_FOG_DISTANCE               },
     {"GL_NV_fragment_program",              NV_FRAGMENT_PROGRAM           },
@@ -612,6 +617,47 @@ static BOOL match_not_dx10_capable(const struct wined3d_gl_info *gl_info, const
     return !match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device);
 }
 
+
+static BOOL match_apple_broken_uniforms(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+                                        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    const char *sysrelease;
+    unsigned int major, minor, ret;
+    void (CDECL *my_wine_get_host_version)(const char **sysname, const char **release);
+
+    /* MacOS dx9 GPU drivers more GLSL vertex shader uniforms than supported by the hardware, and if
+     * more are used it falls back to software. While the compiler can detect if the shader uses all
+     * declared uniforms, the optimization fails if the shader uses relative addressing. So any GLSL
+     * shader using relative addressing falls back to software.
+     *
+     * ARB vp gives the correct amount of uniforms, so use it instead of GLSL.
+     *
+     * In addition, AMD Radeon HD GPUs advertise > 256 constants and can support this in HW, but the
+     * driver nevertheless falls back to software if more than 256 are used. This is fixed in MacOS
+     * 10.8.3 */
+
+    /* Non-Apple GL vendors report uniforms correctly */
+    if (!match_apple(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return FALSE;
+    /* All dx9 cards are overreported on OSX */
+    if (!match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return TRUE;
+    /* Nvidia and Intel DX10 cards support > 256 uniforms */
+    if (card_vendor != HW_VENDOR_AMD) return FALSE;
+
+    /* On OSX 10.8.3 and later, AMD GPUs support more than 256 constants. This OSX version reports
+     * uname -r "12.3.0" */
+    my_wine_get_host_version = (void *)GetProcAddress(GetModuleHandleA("ntdll.dll"), "wine_get_host_version");
+    if (!my_wine_get_host_version) return FALSE;
+
+    my_wine_get_host_version(NULL, &sysrelease);
+    ret = sscanf(sysrelease, "%u.%u", &major, &minor);
+  TRACE("host version %s\n", sysrelease);
+    if (ret != 2) return FALSE; /* String format changed, assume workaround not needed */
+    if (major > 12) return FALSE;
+    if (major == 12 && minor >= 3) return FALSE;
+
+    return TRUE;
+}
+
 /* A GL context is provided by the caller */
 static BOOL match_allows_spec_alpha(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
@@ -766,6 +812,18 @@ static BOOL match_fglrx(const struct wined3d_gl_info *gl_info, const char *gl_re
     return gl_vendor == GL_VENDOR_FGLRX;
 }
 
+static void quirk_arb_constants(struct wined3d_gl_info *gl_info)
+{
+    TRACE("Using ARB vs constant limit(%u->%u) for GLSL.\n", 
+    gl_info->limits.glsl_vs_float_constants,
+    gl_info->limits.arb_vs_native_constants);
+    gl_info->limits.glsl_vs_float_constants = gl_info->limits.arb_vs_native_constants;
+    TRACE("Using ARB ps constant limit(%u->%u) for GLSL.\n",
+    gl_info->limits.glsl_ps_float_constants,
+    gl_info->limits.arb_ps_native_constants);
+    gl_info->limits.glsl_ps_float_constants = gl_info->limits.arb_ps_native_constants;
+}
+
 static BOOL match_r200(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -874,8 +932,18 @@ static void quirk_apple_glsl_constants(struct wined3d_gl_info *gl_info)
     /* MacOS needs uniforms for relative addressing offsets. This can accumulate to quite a few uniforms.
      * Beyond that the general uniform isn't optimal, so reserve a number of uniforms. 12 vec4's should
      * allow 48 different offsets or other helper immediate values. */
-    TRACE("Reserving 12 GLSL constants for compiler private use.\n");
+  //other match_apple quirks
+  if ( wined3d_settings.user_quirks & 1) {
+    gl_info->quirks |= WINED3D_CX_QUIRK_BLIT;
+  }
+  if ( wined3d_settings.user_quirks & 2) {
+    gl_info->quirks |= WINED3D_QUIRK_NO_DXTN;
+  }
+  if ( wined3d_settings.user_quirks & 4) {
+    FIXME("Reserving 12 GLSL constants for compiler private use.\n");
     gl_info->reserved_glsl_constants = max(gl_info->reserved_glsl_constants, 12);
+  }
+  
 }
 
 static void quirk_amd_dx9(struct wined3d_gl_info *gl_info)
@@ -935,7 +1003,7 @@ static void quirk_texcoord_w(struct wined3d_gl_info *gl_info)
      * all radeon cards on Macs and whitelist the good ones. That way we're prepared for the future. If
      * this workaround is activated on cards that do not need it, it won't break things, just affect
      * performance negatively. */
-    TRACE("Enabling vertex texture coord fixes in vertex shaders.\n");
+    FIXME("Enabling vertex texture coord fixes in vertex shaders.\n");
     gl_info->quirks |= WINED3D_QUIRK_SET_TEXCOORD_W;
 }
 
@@ -1201,6 +1269,7 @@ static const struct gpu_description gpu_description_table[] =
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_6600GT,     "NVIDIA GeForce 6600 GT",           DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_6800,       "NVIDIA GeForce 6800",              DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7300,       "NVIDIA GeForce Go 7300",           DRIVER_NVIDIA_GEFORCE6,  256 },
+    {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7300LE,       "NVIDIA GeForce 7300LE",           DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7400,       "NVIDIA GeForce Go 7400",           DRIVER_NVIDIA_GEFORCE6,  256 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7600,       "NVIDIA GeForce 7600 GT",           DRIVER_NVIDIA_GEFORCE6,  256 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7800GT,     "NVIDIA GeForce 7800 GT",           DRIVER_NVIDIA_GEFORCE6,  256 },
@@ -1299,7 +1368,7 @@ static const struct gpu_description gpu_description_table[] =
     {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6400,         "AMD Radeon HD 6400 Series",        DRIVER_AMD_R600,         1024},
     {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6410D,        "AMD Radeon HD 6410D",              DRIVER_AMD_R600,         1024},
     {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6550D,        "AMD Radeon HD 6550D",              DRIVER_AMD_R600,         1024},
-    {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6600,         "AMD Radeon HD 6600 Series",        DRIVER_AMD_R600,         1024},
+    {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6600,         "AMD Radeon HD 6600 Series",        DRIVER_AMD_R600,         2048},
     {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6600M,        "AMD Radeon HD 6600M Series",       DRIVER_AMD_R600,         512 },
     {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6700,         "AMD Radeon HD 6700 Series",        DRIVER_AMD_R600,         1024},
     {HW_VENDOR_AMD,        CARD_AMD_RADEON_HD6800,         "AMD Radeon HD 6800 Series",        DRIVER_AMD_R600,         1024},
@@ -1395,7 +1464,7 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
 {
     OSVERSIONINFOW os_version;
     WORD driver_os_version;
-    enum wined3d_display_driver driver;
+    enum wined3d_display_driver driver = DRIVER_UNKNOWN;
     enum wined3d_driver_model driver_model;
     const struct driver_version_information *version_info;
     const struct gpu_description *gpu_desc;
@@ -1427,6 +1496,10 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
     driver_info->vendor = vendor;
     driver_info->device = device;
 
+    /* Set a default amount of video memory (64MB). In general this code isn't used unless the user
+     * overrides the pci ids to a card which is not in our database. */
+    driver_info->vram_bytes = WINE_DEFAULT_VIDMEM;
+
     memset(&os_version, 0, sizeof(os_version));
     os_version.dwOSVersionInfoSize = sizeof(os_version);
     if (!GetVersionExW(&os_version))
@@ -1795,7 +1868,8 @@ cards_nvidia_binary[] =
     {"7700",                        CARD_NVIDIA_GEFORCE_7600},      /* Geforce 7 - midend */
     {"7600",                        CARD_NVIDIA_GEFORCE_7600},      /* Geforce 7 - midend */
     {"7400",                        CARD_NVIDIA_GEFORCE_7400},      /* Geforce 7 - lower medium */
-    {"7300",                        CARD_NVIDIA_GEFORCE_7300},      /* Geforce 7 - lowend */
+    {"7300 LE",      CARD_NVIDIA_GEFORCE_7300LE},    /* Geforce 7 - lowend */
+    {"7300",        CARD_NVIDIA_GEFORCE_7300},      /* Geforce 7 - go */
     {"6800",                        CARD_NVIDIA_GEFORCE_6800},      /* Geforce 6 - highend */
     {"6700",                        CARD_NVIDIA_GEFORCE_6600GT},    /* Geforce 6 - midend */
     {"6610",                        CARD_NVIDIA_GEFORCE_6600GT},    /* Geforce 6 - midend */
@@ -1844,6 +1918,7 @@ cards_amd_binary[] =
     {"HD 6750M",                    CARD_AMD_RADEON_HD6600M},
     {"HD 6700",                     CARD_AMD_RADEON_HD6700},
     {"HD 6670",                     CARD_AMD_RADEON_HD6600},
+    {"Turks",                     CARD_AMD_RADEON_HD6600},
     {"HD 6630M",                    CARD_AMD_RADEON_HD6600M},
     {"HD 6600M",                    CARD_AMD_RADEON_HD6600M},
     {"HD 6600",                     CARD_AMD_RADEON_HD6600},
@@ -3529,6 +3604,17 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
 
     wined3d_adapter_init_limits(gl_info);
 
+  gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
+  card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
+  TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
+  
+  device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version, gl_renderer_str, &gl_vendor, &card_vendor);
+  TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
+
+  if (match_apple_broken_uniforms(gl_info, gl_renderer_str, gl_vendor, card_vendor, device)) {
+    quirk_arb_constants(gl_info);
+  }
+
     if (gl_info->supported[ARB_VERTEX_PROGRAM] && test_arb_vs_offset_limit(gl_info))
         gl_info->quirks |= WINED3D_QUIRK_ARB_VS_OFFSET_LIMIT;
 
@@ -3630,12 +3716,6 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
         }
     }
 
-    gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
-    card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
-    TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
-
-    device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version, gl_renderer_str, &gl_vendor, &card_vendor);
-    TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
 
     gl_info->wrap_lookup[WINED3D_TADDRESS_WRAP - WINED3D_TADDRESS_WRAP] = GL_REPEAT;
     gl_info->wrap_lookup[WINED3D_TADDRESS_MIRROR - WINED3D_TADDRESS_WRAP] =
@@ -4139,7 +4219,8 @@ static BOOL wined3d_check_pixel_format_depth(const struct wined3d_gl_info *gl_in
     /* Float formats need FBOs. If FBOs are used this function isn't called */
     if (format->flags & WINED3DFMT_FLAG_FLOAT) return FALSE;
 
-    if ((format->id == WINED3DFMT_D16_LOCKABLE) || (format->id == WINED3DFMT_D32_FLOAT))
+    if ((format->id == WINED3DFMT_D16_LOCKABLE) || (format->id == WINED3DFMT_D32_FLOAT) ||
+        (format->id == WINED3DFMT_D32_LOCKABLE) || (format->id == WINED3DFMT_S8_LOCKABLE))
         lockable = TRUE;
 
     /* On some modern cards like the Geforce8/9 GLX doesn't offer some dephthstencil formats which D3D9 reports.
@@ -4492,6 +4573,7 @@ HRESULT CDECL wined3d_check_device_format(const struct wined3d *wined3d, UINT ad
              * an s3tc compressed texture results in an error. While the D3D
              * refrast does support s3tc volumes, at least the nvidia Windows
              * driver does not, so we're free not to support this format. */
+        
             switch (check_format_id)
             {
                 case WINED3DFMT_DXT1:
@@ -4499,11 +4581,13 @@ HRESULT CDECL wined3d_check_device_format(const struct wined3d *wined3d, UINT ad
                 case WINED3DFMT_DXT3:
                 case WINED3DFMT_DXT4:
                 case WINED3DFMT_DXT5:
+                  if (!gl_info->supported[EXT_TEXTURE_COMPRESSION_S3TC] ||
+                    (gl_info->quirks & WINED3D_QUIRK_NO_DXTN)) {
                     TRACE("[FAILED] - DXTn does not support 3D textures.\n");
                     return WINED3DERR_NOTAVAILABLE;
-
+                  }
                 default:
-                    /* Do nothing, continue with checking the format below */
+                    // Do nothing, continue with checking the format below 
                     break;
             }
 
@@ -5763,7 +5847,7 @@ static void wined3d_adapter_init_nogl(struct wined3d_adapter *adapter, UINT ordi
 {
     DISPLAY_DEVICEW display_device;
 
-    memset(adapter, 0, sizeof(*adapter));
+    memset(adapter, 0, sizeof(struct wined3d_adapter));
     adapter->ordinal = ordinal;
     adapter->monitorPoint.x = -1;
     adapter->monitorPoint.y = -1;
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index b1a0f85..46c2b35 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -6009,7 +6009,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
     GLuint vs_id = 0;
     GLuint gs_id = 0;
     GLuint ps_id = 0;
-    struct list *ps_list, *vs_list;
+    struct list *ps_list = NULL, *vs_list = NULL;
 
     if (!(context->shader_update_mask & (1 << WINED3D_SHADER_TYPE_VERTEX)))
     {
@@ -7222,7 +7222,7 @@ void glsl_vertex_pipe_view(struct wined3d_context *context, const struct wined3d
         gl_info->gl_ops.gl.p_glLightfv(GL_LIGHT0 + light->glIndex, GL_SPOT_DIRECTION, light->lightDirn);
         checkGLcall("glLightfv dirn");
     }
-
+  
     gl_info->gl_ops.gl.p_glPopMatrix();
 
     for (k = 0; k < gl_info->limits.clipplanes; ++k)
@@ -7230,7 +7230,7 @@ void glsl_vertex_pipe_view(struct wined3d_context *context, const struct wined3d
         if (!isStateDirty(context, STATE_CLIPPLANE(k)))
             clipplane(context, state, STATE_CLIPPLANE(k));
     }
-
+  
     if (context->swapchain->device->vertexBlendUsed)
     {
         static int warned;
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
index 205f074..3083f0b 100644
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -50,7 +50,7 @@ static DWORD resource_access_from_pool(enum wined3d_pool pool)
 
 static void resource_check_usage(DWORD usage)
 {
-    static const DWORD handled = WINED3DUSAGE_RENDERTARGET
+    static DWORD handled = WINED3DUSAGE_RENDERTARGET
             | WINED3DUSAGE_DEPTHSTENCIL
             | WINED3DUSAGE_WRITEONLY
             | WINED3DUSAGE_DYNAMIC
@@ -66,7 +66,15 @@ static void resource_check_usage(DWORD usage)
      * driver. */
 
     if (usage & ~handled)
+    {
         FIXME("Unhandled usage flags %#x.\n", usage & ~handled);
+        handled |= usage;
+    }
+
+//#define WINED3DUSAGE_SOFTWAREPROCESSING                         0x00000010
+//#define WINED3DUSAGE_DONOTCLIP                                  0x00000020
+//#define WINED3DUSAGE_POINTS                                     0x00000040
+
     if ((usage & (WINED3DUSAGE_DYNAMIC | WINED3DUSAGE_WRITEONLY)) == WINED3DUSAGE_DYNAMIC)
         WARN_(d3d_perf)("WINED3DUSAGE_DYNAMIC used without WINED3DUSAGE_WRITEONLY.\n");
 }
@@ -78,7 +86,12 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
         void *parent, const struct wined3d_parent_ops *parent_ops,
         const struct wined3d_resource_ops *resource_ops)
 {
-    const struct wined3d *d3d = device->wined3d;
+  const struct wined3d *d3d; // = device->wined3d;
+  TRACE(" device %p, resource %p\n", device, resource);
+  if (!device || !resource) {
+    return WINED3DERR_INVALIDCALL;
+  }
+  d3d = device->wined3d;
 
     resource_check_usage(usage);
     if (pool != WINED3D_POOL_SCRATCH && type != WINED3D_RTYPE_BUFFER)
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 2838004..90e06c8 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -764,6 +764,26 @@ static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RE
     return TRUE;
 }
 
+static void prepare_blit_quirks(const struct wined3d_device *device, const struct wined3d_gl_info *gl_info)
+{
+  /* ATI Macs blend blits even though GL_EXT_framebuffer_blit says that this
+   * operation does not blend. This sometimes even happens if GL_BLEND is
+   * disabled, although in my glut test case blending has to be enabled for
+   * the bug to occur. While we're at it, disable blending.
+   *
+   * Tracked by crossover hacks bug 5391. */
+  gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+  gl_info->gl_ops.gl.p_glBlendFunc(GL_ONE, GL_ZERO);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHABLENDENABLE));
+  
+  gl_info->gl_ops.gl.p_glDisable(GL_ALPHA_TEST);
+  gl_info->gl_ops.gl.p_glAlphaFunc(GL_ALWAYS, 0.0);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHATESTENABLE));
+  gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
+  gl_info->gl_ops.gl.p_glStencilFunc(GL_ALWAYS, 0, 0);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+}
+
 static void surface_depth_blt_fbo(const struct wined3d_device *device,
         struct wined3d_surface *src_surface, DWORD src_location, const RECT *src_rect,
         struct wined3d_surface *dst_surface, DWORD dst_location, const RECT *dst_rect)
@@ -846,6 +866,9 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     gl_info->gl_ops.gl.p_glDisable(GL_SCISSOR_TEST);
     context_invalidate_state(context, STATE_RENDER(WINED3D_RS_SCISSORTESTENABLE));
 
+  if (gl_info->quirks & WINED3D_CX_QUIRK_BLIT)
+    prepare_blit_quirks(device, gl_info);
+
     gl_info->fbo_ops.glBlitFramebuffer(src_rect->left, src_rect->top, src_rect->right, src_rect->bottom,
             dst_rect->left, dst_rect->top, dst_rect->right, dst_rect->bottom, gl_mask, GL_NEAREST);
     checkGLcall("glBlitFramebuffer()");
@@ -2340,6 +2363,126 @@ static void convert_yuy2_r5g6b5(const BYTE *src, BYTE *dst,
     }
 }
 
+static void convert_dxt1_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt1_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_dxt1_a4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4A4_UNORM, w, h);
+}
+
+static void convert_dxt1_x4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4X4_UNORM, w, h);
+}
+
+static void convert_dxt1_a1r5g5b5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5A1_UNORM, w, h);
+}
+
+static void convert_dxt1_x1r5g5b5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5X1_UNORM, w, h);
+}
+
+static void convert_dxt3_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt3_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_dxt3_a4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4A4_UNORM, w, h);
+}
+
+static void convert_dxt3_x4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4X4_UNORM, w, h);
+}
+
+static void convert_dxt5_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt5_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a1r5g5b5_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5A1_UNORM, w, h);
+}
+
+static void convert_x1r5g5b5_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5X1_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt3(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt3(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
 struct d3dfmt_converter_desc
 {
     enum wined3d_format_id from, to;
@@ -2356,6 +2499,33 @@ static const struct d3dfmt_converter_desc converters[] =
     {WINED3DFMT_YUY2,           WINED3DFMT_B5G6R5_UNORM,    convert_yuy2_r5g6b5},
 };
 
+static const struct d3dfmt_converter_desc dxtn_converters[] =
+{
+    /* decode DXT */
+    {WINED3DFMT_DXT1,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt1_a8r8g8b8},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt1_x8r8g8b8},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B4G4R4A4_UNORM,  convert_dxt1_a4r4g4b4},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B4G4R4X4_UNORM,  convert_dxt1_x4r4g4b4},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B5G5R5A1_UNORM,  convert_dxt1_a1r5g5b5},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B5G5R5X1_UNORM,  convert_dxt1_x1r5g5b5},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt3_a8r8g8b8},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt3_x8r8g8b8},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B4G4R4A4_UNORM,  convert_dxt3_a4r4g4b4},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B4G4R4X4_UNORM,  convert_dxt3_x4r4g4b4},
+    {WINED3DFMT_DXT5,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt5_a8r8g8b8},
+    {WINED3DFMT_DXT5,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt5_x8r8g8b8},
+
+    /* encode DXT */
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT1,            convert_a8r8g8b8_dxt1},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT1,            convert_x8r8g8b8_dxt1},
+    {WINED3DFMT_B5G5R5A1_UNORM, WINED3DFMT_DXT1,            convert_a1r5g5b5_dxt1},
+    {WINED3DFMT_B5G5R5X1_UNORM, WINED3DFMT_DXT1,            convert_x1r5g5b5_dxt1},
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT3,            convert_a8r8g8b8_dxt3},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT3,            convert_x8r8g8b8_dxt3},
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT5,            convert_a8r8g8b8_dxt5},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT5,            convert_x8r8g8b8_dxt5}
+};
+
 static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_format_id from,
         enum wined3d_format_id to)
 {
@@ -2367,6 +2537,12 @@ static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_fo
             return &converters[i];
     }
 
+    for (i = 0; i < (sizeof(dxtn_converters) / sizeof(*dxtn_converters)); ++i)
+    {
+        if (dxtn_converters[i].from == from && dxtn_converters[i].to == to)
+            return wined3d_dxtn_supported() ? &dxtn_converters[i] : NULL;
+    }
+
     return NULL;
 }
 
@@ -5464,7 +5640,8 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     /* Flags */
     if (flags & WINED3D_SURFACE_DISCARD)
         surface->flags |= SFLAG_DISCARD;
-    if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE)
+    if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE ||
+        desc->format == WINED3DFMT_D32_LOCKABLE || desc->format == WINED3DFMT_S8_LOCKABLE)
         surface->resource.access_flags |= WINED3D_RESOURCE_ACCESS_CPU;
 
     surface->texture_target = target;
@@ -5511,7 +5688,8 @@ HRESULT wined3d_surface_create(struct wined3d_texture *container, const struct w
             debug_d3dusage(desc->usage), desc->usage, debug_d3dpool(desc->pool),
             desc->multisample_type, desc->multisample_quality, target, level, layer, flags, surface);
 
-    if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
+    if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                             sizeof(struct wined3d_surface))))
         return E_OUTOFMEMORY;
 
     if (FAILED(hr = surface_init(object, container, desc, target, level, layer, flags)))
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 34c69d1..f5edb1f 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -1338,6 +1338,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
         return WINED3DERR_INVALIDCALL;
     }
+//hack by Stefan Dösinger
+    if (desc->format == WINED3DFMT_DXT1 || desc->format == WINED3DFMT_DXT2 ||
+        desc->format == WINED3DFMT_DXT3 || desc->format == WINED3DFMT_DXT4 ||
+        desc->format == WINED3DFMT_DXT5) {
+          FIXME("create dxtn texture 0x%x.\n", desc->format);
+          if (gl_info->quirks & WINED3D_QUIRK_NO_DXTN)
+          	return WINED3DERR_INVALIDCALL;
+    }
 
     /* Calculate levels for mip mapping. */
     if (desc->usage & WINED3DUSAGE_AUTOGENMIPMAP)
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 1686e30..cdf1c97 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -112,7 +112,9 @@ static const struct wined3d_format_channels formats[] =
     {WINED3DFMT_R10G11B11_SNORM,           10, 11, 11,  0,   0, 10, 21,  0,    4,   0,     0},
     {WINED3DFMT_R10G10B10_SNORM_A2_UNORM,  10, 10, 10,  2,   0, 10, 20, 30,    4,   0,     0},
     /* Depth stencil formats */
+    {WINED3DFMT_D32_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
     {WINED3DFMT_D16_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
+    {WINED3DFMT_S8_LOCKABLE,                0,  0,  0,  0,   0,  0,  0,  0,    1,   8,     0},
     {WINED3DFMT_D32_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
     {WINED3DFMT_S1_UINT_D15_UNORM,          0,  0,  0,  0,   0,  0,  0,  0,    2,  15,     1},
     {WINED3DFMT_D24_UNORM_S8_UINT,          0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
@@ -132,6 +134,9 @@ static const struct wined3d_format_channels formats[] =
     {WINED3DFMT_ATI1N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
     {WINED3DFMT_ATI2N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
     {WINED3DFMT_NVDB,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
+// hack by Michael Bond bug 23807
+    {WINED3DFMT_DF16,                       0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
+    {WINED3DFMT_DF24,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     0},
     {WINED3DFMT_INST,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
     {WINED3DFMT_INTZ,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
     {WINED3DFMT_RESZ,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
@@ -1169,14 +1174,26 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             | WINED3DFMT_FLAG_BUMPMAP,
             EXT_TEXTURE_SNORM,          NULL},
     /* Depth stencil formats */
-    {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+    {WINED3DFMT_D32_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
+            WINED3DFMT_FLAG_DEPTH,
+            WINED3D_GL_EXT_NONE,        NULL},
+    {WINED3DFMT_D32_LOCKABLE,           GL_DEPTH_COMPONENT32_ARB,         GL_DEPTH_COMPONENT32_ARB,               0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
+            WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_SHADOW,
+            ARB_DEPTH_TEXTURE,          NULL},
+    {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
             WINED3DFMT_FLAG_DEPTH,
             WINED3D_GL_EXT_NONE,        NULL},
     {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT24_ARB,         GL_DEPTH_COMPONENT24_ARB,               0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_SHADOW,
             ARB_DEPTH_TEXTURE,          NULL},
+    {WINED3DFMT_S8_LOCKABLE,            GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_BYTE,                          0,
+            WINED3DFMT_FLAG_DEPTH,
+            WINED3D_GL_EXT_NONE,        NULL},
     {WINED3DFMT_D32_UNORM,              GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
             WINED3DFMT_FLAG_DEPTH,
@@ -1270,6 +1287,28 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING
             | WINED3DFMT_FLAG_COMPRESSED,
             ARB_TEXTURE_COMPRESSION_RGTC, NULL},
+  //bug 23807
+  {WINED3DFMT_DF16,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
+      GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_SHORT,                0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      EXT_PACKED_DEPTH_STENCIL,   NULL},
+    {WINED3DFMT_DF16,                   GL_DEPTH24_STENCIL8,              GL_DEPTH24_STENCIL8,                    0,
+      GL_DEPTH_STENCIL,           GL_UNSIGNED_SHORT,                0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      ARB_FRAMEBUFFER_OBJECT,     NULL},
+    {WINED3DFMT_DF24,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
+      GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_INT_24_8_EXT,         0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      EXT_PACKED_DEPTH_STENCIL,   NULL},
+    {WINED3DFMT_DF24,                   GL_DEPTH24_STENCIL8,              GL_DEPTH24_STENCIL8,                    0,
+      GL_DEPTH_STENCIL,           GL_UNSIGNED_INT_24_8,             0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      ARB_FRAMEBUFFER_OBJECT,     NULL},
+
     {WINED3DFMT_INTZ,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
             GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_INT_24_8_EXT,         0,
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING
@@ -2284,8 +2323,12 @@ const struct wined3d_format *wined3d_get_format(const struct wined3d_gl_info *gl
 
     if (idx == -1)
     {
+        static enum wined3d_format_id old_id;
+        if (old_id != format_id) {
+          old_id = format_id;
         FIXME("Can't find format %s (%#x) in the format lookup table\n",
                 debug_d3dformat(format_id), format_id);
+        }
         /* Get the caller a valid pointer */
         idx = getFmtIdx(WINED3DFMT_UNKNOWN);
     }
@@ -2374,6 +2417,8 @@ const char *debug_d3dformat(enum wined3d_format_id format_id)
         FMT_TO_STR(WINED3DFMT_G8R8_G8B8);
         FMT_TO_STR(WINED3DFMT_R8G8_B8G8);
         FMT_TO_STR(WINED3DFMT_D16_LOCKABLE);
+        FMT_TO_STR(WINED3DFMT_D32_LOCKABLE);
+        FMT_TO_STR(WINED3DFMT_S8_LOCKABLE);
         FMT_TO_STR(WINED3DFMT_D32_UNORM);
         FMT_TO_STR(WINED3DFMT_S1_UINT_D15_UNORM);
         FMT_TO_STR(WINED3DFMT_X8D24_UNORM);
@@ -2476,6 +2521,9 @@ const char *debug_d3dformat(enum wined3d_format_id format_id)
         FMT_TO_STR(WINED3DFMT_B5G5R5A1_UNORM);
         FMT_TO_STR(WINED3DFMT_B8G8R8A8_UNORM);
         FMT_TO_STR(WINED3DFMT_B8G8R8X8_UNORM);
+        //bug 23807
+        FMT_TO_STR(WINED3DFMT_DF16);
+        FMT_TO_STR(WINED3DFMT_DF24);
         FMT_TO_STR(WINED3DFMT_INTZ);
         FMT_TO_STR(WINED3DFMT_RESZ);
         FMT_TO_STR(WINED3DFMT_NULL);
@@ -3427,6 +3475,8 @@ BOOL getDepthStencilBits(const struct wined3d_format *format, BYTE *depthSize, B
     switch (format->id)
     {
         case WINED3DFMT_D16_LOCKABLE:
+        case WINED3DFMT_D32_LOCKABLE:
+        case WINED3DFMT_S8_LOCKABLE:
         case WINED3DFMT_D16_UNORM:
         case WINED3DFMT_S1_UINT_D15_UNORM:
         case WINED3DFMT_X8D24_UNORM:
@@ -3435,6 +3485,8 @@ BOOL getDepthStencilBits(const struct wined3d_format *format, BYTE *depthSize, B
         case WINED3DFMT_S8_UINT_D24_FLOAT:
         case WINED3DFMT_D32_UNORM:
         case WINED3DFMT_D32_FLOAT:
+        case WINED3DFMT_DF16:
+        case WINED3DFMT_DF24:
         case WINED3DFMT_INTZ:
             break;
         default:
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index a79d6a6..bc1129f 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -289,3 +289,11 @@
 @ cdecl wined3d_volume_map(ptr ptr ptr long)
 @ cdecl wined3d_volume_preload(ptr)
 @ cdecl wined3d_volume_unmap(ptr)
+
+@ cdecl wined3d_dxtn_supported()
+@ cdecl wined3d_dxt1_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt1_encode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt3_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt3_encode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt5_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt5_encode(ptr ptr long long long long long)
diff --git a/dlls/wined3d/wined3d_gl.h b/dlls/wined3d/wined3d_gl.h
index 4919cf6..f7f35f1 100644
--- a/dlls/wined3d/wined3d_gl.h
+++ b/dlls/wined3d/wined3d_gl.h
@@ -48,6 +48,7 @@ enum wined3d_gl_extension
     ARB_COLOR_BUFFER_FLOAT,
     ARB_DEBUG_OUTPUT,
     ARB_DEPTH_BUFFER_FLOAT,
+    ARB_DEPTH_CLAMP,
     ARB_DEPTH_TEXTURE,
     ARB_DRAW_BUFFERS,
     ARB_DRAW_ELEMENTS_BASE_VERTEX,
@@ -81,6 +82,7 @@ enum wined3d_gl_extension
     ARB_TEXTURE_COMPRESSION,
     ARB_TEXTURE_COMPRESSION_RGTC,
     ARB_TEXTURE_CUBE_MAP,
+    ARB_TEXTURE_ENV_ADD,
     ARB_TEXTURE_ENV_COMBINE,
     ARB_TEXTURE_ENV_DOT3,
     ARB_TEXTURE_FLOAT,
@@ -117,6 +119,7 @@ enum wined3d_gl_extension
     EXT_GPU_PROGRAM_PARAMETERS,
     EXT_GPU_SHADER4,
     EXT_PACKED_DEPTH_STENCIL,
+    EXT_PALETTED_TEXTURE,
     EXT_POINT_PARAMETERS,
     EXT_PROVOKING_VERTEX,
     EXT_SECONDARY_COLOR,
@@ -125,6 +128,7 @@ enum wined3d_gl_extension
     EXT_TEXTURE3D,
     EXT_TEXTURE_COMPRESSION_RGTC,
     EXT_TEXTURE_COMPRESSION_S3TC,
+    EXT_TEXTURE_ENV_ADD,
     EXT_TEXTURE_ENV_COMBINE,
     EXT_TEXTURE_ENV_DOT3,
     EXT_TEXTURE_FILTER_ANISOTROPIC,
@@ -135,6 +139,7 @@ enum wined3d_gl_extension
     EXT_TEXTURE_SRGB_DECODE,
     EXT_VERTEX_ARRAY_BGRA,
     /* NVIDIA */
+    NV_DEPTH_CLAMP,
     NV_FENCE,
     NV_FOG_DISTANCE,
     NV_FRAGMENT_PROGRAM,
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
index 758ba43..ed24efe 100644
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -85,6 +85,10 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+  FALSE,            /* Override vertex constants? */
+  256,             /* Number of vertex shaders to use */
+  0,
+
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -236,6 +240,7 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
                 wined3d_settings.pci_device_id = pci_device_id;
             }
         }
+        tmpvalue = 0;
         if ( !get_config_key_dword( hkey, appkey, "VideoPciVendorID", &tmpvalue) )
         {
             int pci_vendor_id = tmpvalue;
@@ -292,6 +297,31 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Not always rendering backbuffers offscreen.\n");
             wined3d_settings.always_offscreen = FALSE;
         }
+        if (!get_config_key(hkey, appkey, "OverrideVertexShaders", buffer, size) && !strcmp(buffer,"enabled"))
+        {
+          TRACE("Override Vertex Shader Constants\n");
+          wined3d_settings.override_vertex_constants = TRUE;
+        }
+        if (!get_config_key(hkey, appkey, "VertexShaderConstants", buffer, size))
+        {
+          int TmpVertexShaderConstants = atoi(buffer);
+          if (TmpVertexShaderConstants > 0)
+          {
+            wined3d_settings.vertex_constants_number = TmpVertexShaderConstants;
+            TRACE("Use %i Vertex Shader Constants\n", TmpVertexShaderConstants);
+          }
+        }
+        tmpvalue = 0;
+      if (!get_config_key_dword(hkey, appkey, "UserQuirks", &tmpvalue))
+      {
+        int TmpUserQuirks = tmpvalue;
+        if (TmpUserQuirks > 0)
+        {
+          wined3d_settings.user_quirks = TmpUserQuirks;
+          TRACE("Use %i UserQuirks\n", TmpUserQuirks);
+        }
+      }
+
         if (!get_config_key_dword(hkey, appkey, "MaxShaderModelVS", &wined3d_settings.max_sm_vs))
             TRACE("Limiting VS shader model to %u.\n", wined3d_settings.max_sm_vs);
         if (!get_config_key_dword(hkey, appkey, "MaxShaderModelGS", &wined3d_settings.max_sm_gs))
@@ -309,6 +339,8 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
+    wined3d_dxtn_init();
+
     return TRUE;
 }
 
@@ -340,6 +372,9 @@ static BOOL wined3d_dll_destroy(HINSTANCE hInstDLL)
 
     DeleteCriticalSection(&wined3d_wndproc_cs);
     DeleteCriticalSection(&wined3d_cs);
+
+    wined3d_dxtn_free();
+
     return TRUE;
 }
 
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index acac299..2c33f28 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -68,6 +68,16 @@
 #define WINED3D_QUIRK_LIMITED_TEX_FILTERING     0x00000100
 #define WINED3D_QUIRK_BROKEN_ARB_FOG            0x00000200
 
+#define WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER    0x00010000
+#define WINED3D_CX_QUIRK_COMPRESSED_CUBE_MIP    0x00020000  /* Intel GPU */
+#define WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN       0x00040000
+#define WINED3D_CX_QUIRK_TEXCOORD_FOG           0x00080000  /* old ATI */
+#define WINED3D_CX_QUIRK_BROKEN_ARA             0x00100000  /* Nvidia 8xxx */
+#define WINED3D_CX_QUIRK_BLIT                   0x00200000
+#define WINED3D_CX_QUIRK_RENDER_TO_FBO          0x00800000
+#define WINED3D_QUIRK_NO_DXTN                   0x01000000
+
+
 /* Texture format fixups */
 
 enum fixup_channel_source
@@ -278,6 +288,10 @@ struct wined3d_settings
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+  BOOL override_vertex_constants;
+  int vertex_constants_number;
+  int user_quirks;
+
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1513,6 +1527,7 @@ enum wined3d_pci_device
     CARD_NVIDIA_GEFORCE_6800        = 0x0041,
     CARD_NVIDIA_GEFORCE_7400        = 0x01d8,
     CARD_NVIDIA_GEFORCE_7300        = 0x01d7, /* GeForce Go 7300 */
+    CARD_NVIDIA_GEFORCE_7300LE      = 0x01d1, /* GeForce 7300LE */
     CARD_NVIDIA_GEFORCE_7600        = 0x0391,
     CARD_NVIDIA_GEFORCE_7800GT      = 0x0092,
     CARD_NVIDIA_GEFORCE_8200        = 0x0849, /* Other PCI ID 0x084b */
@@ -3216,6 +3231,9 @@ static inline void context_apply_state(struct wined3d_context *context,
     state_table[rep].apply(context, state, rep);
 }
 
+BOOL wined3d_dxtn_init(void) DECLSPEC_HIDDEN;
+void wined3d_dxtn_free(void) DECLSPEC_HIDDEN;
+
 /* The WNDCLASS-Name for the fake window which we use to retrieve the GL capabilities */
 #define WINED3D_OPENGL_WINDOW_CLASS_NAME "WineD3D_OpenGL"
 
diff --git a/dlls/winemac.drv/cocoa_app.m b/dlls/winemac.drv/cocoa_app.m
index 82925c8..9d0af0d 100644
--- a/dlls/winemac.drv/cocoa_app.m
+++ b/dlls/winemac.drv/cocoa_app.m
@@ -705,11 +705,12 @@ - (CGDisplayModeRef)modeMatchingMode:(CGDisplayModeRef)mode forDisplay:(CGDirect
         NSDictionary* options = nil;
 
 #if defined(MAC_OS_X_VERSION_10_8) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+#ifdef  kCGDisplayShowDuplicateLowResolutionModes     
         if (&kCGDisplayShowDuplicateLowResolutionModes != NULL)
             options = [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:TRUE]
                                                   forKey:(NSString*)kCGDisplayShowDuplicateLowResolutionModes];
 #endif
-
+#endif
         NSArray *modes = [(NSArray*)CGDisplayCopyAllDisplayModes(displayID, (CFDictionaryRef)options) autorelease];
         for (id candidateModeObject in modes)
         {
diff --git a/dlls/winemac.drv/cocoa_window.m b/dlls/winemac.drv/cocoa_window.m
index f68a1c5..33eb5c5 100644
--- a/dlls/winemac.drv/cocoa_window.m
+++ b/dlls/winemac.drv/cocoa_window.m
@@ -197,8 +197,6 @@ @interface WineWindow ()
 
 @property (readonly, copy, nonatomic) NSArray* childWineWindows;
 
-    - (void) updateColorSpace;
-
     - (BOOL) becameEligibleParentOrChild;
     - (void) becameIneligibleChild;
 
@@ -333,15 +331,12 @@ - (void) addGLContext:(WineOpenGLContext*)context
             [pendingGlContexts addObject:context];
             [self setNeedsDisplay:YES];
         }
-
-        [(WineWindow*)[self window] updateColorSpace];
     }
 
     - (void) removeGLContext:(WineOpenGLContext*)context
     {
         [glContexts removeObjectIdenticalTo:context];
         [pendingGlContexts removeObjectIdenticalTo:context];
-        [(WineWindow*)[self window] updateColorSpace];
     }
 
     - (void) updateGLContexts
@@ -350,11 +345,6 @@ - (void) updateGLContexts
             context.needsUpdate = TRUE;
     }
 
-    - (BOOL) hasGLContext
-    {
-        return [glContexts count] || [pendingGlContexts count];
-    }
-
     - (BOOL) acceptsFirstMouse:(NSEvent*)theEvent
     {
         return YES;
@@ -1360,9 +1350,6 @@ - (void) setFrameFromWine:(NSRect)contentRect
                 if (needEnableScreenUpdates)
                     NSEnableScreenUpdates();
 
-                if (!equalSizes)
-                    [self updateColorSpace];
-
                 if (!enteringFullScreen &&
                     [[NSProcessInfo processInfo] systemUptime] - enteredFullScreenTime > 1.0)
                     nonFullscreenFrame = frame;
@@ -1744,38 +1731,6 @@ - (NSArray*) childWineWindows
         return [childWindows objectsAtIndexes:indexes];
     }
 
-    // We normally use the generic/calibrated RGB color space for the window,
-    // rather than the device color space, to avoid expensive color conversion
-    // which slows down drawing.  However, for windows displaying OpenGL, having
-    // a different color space than the screen greatly reduces frame rates, often
-    // limiting it to the display refresh rate.
-    //
-    // To avoid this, we switch back to the screen color space whenever the
-    // window is covered by a view with an attached OpenGL context.
-    - (void) updateColorSpace
-    {
-        NSRect contentRect = [[self contentView] frame];
-        BOOL coveredByGLView = FALSE;
-        for (WineContentView* view in [[self contentView] subviews])
-        {
-            if ([view hasGLContext])
-            {
-                NSRect frame = [view convertRect:[view bounds] toView:nil];
-                if (NSContainsRect(frame, contentRect))
-                {
-                    coveredByGLView = TRUE;
-                    break;
-                }
-            }
-        }
-
-        if (coveredByGLView)
-            [self setColorSpace:nil];
-        else
-            [self setColorSpace:[NSColorSpace genericRGBColorSpace]];
-    }
-
-
     /*
      * ---------- NSResponder method overrides ----------
      */
@@ -2683,7 +2638,6 @@ macdrv_view macdrv_create_view(macdrv_window w, CGRect rect)
                    name:NSApplicationDidChangeScreenParametersNotification
                  object:NSApp];
         [[window contentView] addSubview:view];
-        [window updateColorSpace];
     });
 
     [pool release];
@@ -2702,7 +2656,6 @@ void macdrv_dispose_view(macdrv_view v)
 
     OnMainThread(^{
         NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
-        WineWindow* window = (WineWindow*)[view window];
 
         [nc removeObserver:view
                       name:NSViewGlobalFrameDidChangeNotification
@@ -2712,7 +2665,6 @@ void macdrv_dispose_view(macdrv_view v)
                     object:NSApp];
         [view removeFromSuperview];
         [view release];
-        [window updateColorSpace];
     });
 
     [pool release];
@@ -2737,15 +2689,11 @@ void macdrv_set_view_window_and_frame(macdrv_view v, macdrv_window w, CGRect rec
         BOOL changedWindow = (window && window != [view window]);
         NSRect newFrame = NSRectFromCGRect(rect);
         NSRect oldFrame = [view frame];
-        BOOL needUpdateWindowColorSpace = FALSE;
 
         if (changedWindow)
         {
-            WineWindow* oldWindow = (WineWindow*)[view window];
             [view removeFromSuperview];
-            [oldWindow updateColorSpace];
             [[window contentView] addSubview:view];
-            needUpdateWindowColorSpace = TRUE;
         }
 
         if (!NSEqualRects(oldFrame, newFrame))
@@ -2759,11 +2707,8 @@ void macdrv_set_view_window_and_frame(macdrv_view v, macdrv_window w, CGRect rec
             else
                 [view setFrame:newFrame];
             [view setNeedsDisplay:YES];
-            needUpdateWindowColorSpace = TRUE;
         }
 
-        if (needUpdateWindowColorSpace)
-            [(WineWindow*)[view window] updateColorSpace];
     });
 
     [pool release];
diff --git a/dlls/winemac.drv/display.c b/dlls/winemac.drv/display.c
index 10ecf67..1bed777 100644
--- a/dlls/winemac.drv/display.c
+++ b/dlls/winemac.drv/display.c
@@ -25,6 +25,7 @@
 #include "winuser.h"
 #include "winreg.h"
 #include "ddrawi.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(display);
 
@@ -287,6 +288,7 @@ static CFArrayRef copy_display_modes(CGDirectDisplayID display)
     CFArrayRef modes = NULL;
 
 #if defined(MAC_OS_X_VERSION_10_8) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+#ifdef kCGDisplayShowDuplicateLowResolutionModes
     if (&kCGDisplayShowDuplicateLowResolutionModes != NULL &&
         CGDisplayModeGetPixelWidth != NULL && CGDisplayModeGetPixelHeight != NULL)
     {
@@ -390,6 +392,7 @@ static CFArrayRef copy_display_modes(CGDirectDisplayID display)
     }
     else
 #endif
+#endif
         modes = CGDisplayCopyAllDisplayModes(display, NULL);
 
     return modes;
@@ -410,9 +413,9 @@ LONG CDECL macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
     struct macdrv_display *displays;
     int num_displays;
     CFArrayRef display_modes;
-    CFIndex count, i, safe, best;
+    CFIndex count, i, safe, best = 0;
     CGDisplayModeRef best_display_mode;
-    uint32_t best_io_flags;
+    uint32_t best_io_flags = 0;
 
     TRACE("%s %p %p 0x%08x %p\n", debugstr_w(devname), devmode, hwnd, flags, lpvoid);
 
@@ -669,7 +672,7 @@ BOOL CDECL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode,
     struct macdrv_display *displays = NULL;
     int num_displays;
     CGDisplayModeRef display_mode;
-    int display_mode_bpp;
+    int display_mode_bpp = 24;
     BOOL synthesized = FALSE;
     double rotation;
     uint32_t io_flags;
@@ -935,11 +938,12 @@ done:
  */
 BOOL CDECL macdrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info)
 {
-    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 };
+    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0 }; /* CrossOver Hack 11692 */
     struct macdrv_display *displays;
     int num_displays;
     CGDirectDisplayID display_id;
     int i;
+  BOOL unique_monitor_names = TRUE;
 
     TRACE("%p, %p\n", monitor, info);
 
@@ -965,10 +969,13 @@ BOOL CDECL macdrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info)
         info->dwFlags = (i == 0) ? MONITORINFOF_PRIMARY : 0;
 
         if (info->cbSize >= sizeof(MONITORINFOEXW))
-            lstrcpyW(((MONITORINFOEXW*)info)->szDevice, adapter_name);
+            /* CrossOver Hack 11692: Unique device names from GetMonitorInfo */
+            snprintfW(((MONITORINFOEXW*)info)->szDevice, sizeof(((MONITORINFOEXW*)info)->szDevice) / sizeof(WCHAR),
+                      adapter_name, unique_monitor_names ? i + 1 : 1);
 
-        TRACE(" -> rcMonitor %s rcWork %s dwFlags %08x\n", wine_dbgstr_rect(&info->rcMonitor),
-              wine_dbgstr_rect(&info->rcWork), info->dwFlags);
+        TRACE(" -> rcMonitor %s rcWork %s dwFlags %08x szDevice %s\n", wine_dbgstr_rect(&info->rcMonitor),
+              wine_dbgstr_rect(&info->rcWork), info->dwFlags,
+              info->cbSize >= sizeof(MONITORINFOEXW) ? debugstr_w(((MONITORINFOEXW*)info)->szDevice) : "n/a");
     }
     else
     {
diff --git a/include/config.h.in b/include/config.h.in
index 4d7c7ac..6303fb9 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -1371,6 +1371,9 @@
 /* Define to the soname of the libtiff library. */
 #undef SONAME_LIBTIFF
 
+/* Define to the soname of the libtxc_dxtn library. */
+#undef SONAME_LIBTXC_DXTN
+
 /* Define to the soname of the libv4l1 library. */
 #undef SONAME_LIBV4L1
 
diff --git a/include/d3d9types.h b/include/d3d9types.h
index 3afcf89..57c1374 100644
--- a/include/d3d9types.h
+++ b/include/d3d9types.h
@@ -814,23 +814,36 @@ typedef enum _D3DFORMAT {
     D3DFMT_L16                  =  81,
     D3DFMT_D32F_LOCKABLE        =  82,
     D3DFMT_D24FS8               =  83,
+    /* d3d9ex formats */
+  /* Z-Stencil formats valid for CPU access */  
+    D3DFMT_D32_LOCKABLE         =  84,
+    D3DFMT_S8_LOCKABLE          =  85,
+
 
     D3DFMT_VERTEXDATA           = 100,
     D3DFMT_INDEX16              = 101,
     D3DFMT_INDEX32              = 102,
     D3DFMT_Q16W16V16U16         = 110,
     /* Floating point formats */
+  // s10e5 formats (16-bits per channel) 
     D3DFMT_R16F                 = 111,
     D3DFMT_G16R16F              = 112,
     D3DFMT_A16B16G16R16F        = 113,
     
     /* IEEE formats */
+  // IEEE s23e8 formats (32-bits per channel) 
     D3DFMT_R32F                 = 114,
     D3DFMT_G32R32F              = 115,
     D3DFMT_A32B32G32R32F        = 116,
     
     D3DFMT_CxV8U8               = 117,
-
+    /* d3d9ex formats */
+  // Monochrome 1 bit per pixel format 
+    D3DFMT_A1                   = 118,
+  // 2.8 biased fixed point 
+    D3DFMT_A2B10G10R10_XR_BIAS  = 119,
+  // Binary format indicating that the data has no inherent type 
+    D3DFMT_BINARYBUFFER         = 199,
 
     D3DFMT_FORCE_DWORD          = 0xFFFFFFFF
 } D3DFORMAT;
diff --git a/include/d3dx9shader.h b/include/d3dx9shader.h
index d665f72..f565432 100644
--- a/include/d3dx9shader.h
+++ b/include/d3dx9shader.h
@@ -315,6 +315,7 @@ DWORD WINAPI D3DXGetShaderVersion(const DWORD *byte_code);
 const char * WINAPI D3DXGetVertexShaderProfile(struct IDirect3DDevice9 *device);
 HRESULT WINAPI D3DXFindShaderComment(const DWORD *byte_code, DWORD fourcc, const void **data, UINT *size);
 HRESULT WINAPI D3DXGetShaderSamplers(const DWORD *byte_code, const char **samplers, UINT *count);
+HRESULT WINAPI D3DXGetShaderInputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count);
 
 HRESULT WINAPI D3DXAssembleShaderFromFileA(const char *filename, const D3DXMACRO *defines,
         ID3DXInclude *include, DWORD flags, ID3DXBuffer **shader, ID3DXBuffer **error_messages);
diff --git a/include/windef.h b/include/windef.h
index e914726..47de414 100644
--- a/include/windef.h
+++ b/include/windef.h
@@ -86,10 +86,17 @@ extern "C" {
 
 #ifndef __ms_va_list
 # if defined(__x86_64__) && defined (__GNUC__)
+#   if defined(__APPLE__)
+#     define __ms_va_list __builtin_va_list
+#     define __ms_va_start(list,arg) __builtin_va_start(list,arg)
+#     define __ms_va_end(list) __builtin_va_end(list)
+#     define __ms_va_copy(dest,src) __builtin_va_copy(dest,src)
+#   else  
 #  define __ms_va_list __builtin_ms_va_list
 #  define __ms_va_start(list,arg) __builtin_ms_va_start(list,arg)
 #  define __ms_va_end(list) __builtin_ms_va_end(list)
 #  define __ms_va_copy(dest,src) __builtin_ms_va_copy(dest,src)
+#  endif
 # else
 #  define __ms_va_list va_list
 #  define __ms_va_start(list,arg) va_start(list,arg)
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index d27914a..0433b74 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -5972,6 +5972,6 @@ union generic_reply
     struct terminate_job_reply terminate_job_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 467
+#define SERVER_PROTOCOL_VERSION 468
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index 8bc4c25..bd1b6ec 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -135,7 +135,9 @@ enum wined3d_format_id
     WINED3DFMT_R8G8_SNORM_L8X8_UNORM,
     WINED3DFMT_R10G11B11_SNORM,
     WINED3DFMT_R10G10B10_SNORM_A2_UNORM,
+    WINED3DFMT_D32_LOCKABLE,
     WINED3DFMT_D16_LOCKABLE,
+    WINED3DFMT_S8_LOCKABLE,
     WINED3DFMT_D32_UNORM,
     WINED3DFMT_S1_UINT_D15_UNORM,
     WINED3DFMT_X8D24_UNORM,
@@ -251,6 +253,9 @@ enum wined3d_format_id
     WINED3DFMT_NVDB                         = WINEMAKEFOURCC('N','V','D','B'),
     WINED3DFMT_NVHU                         = WINEMAKEFOURCC('N','V','H','U'),
     WINED3DFMT_NVHS                         = WINEMAKEFOURCC('N','V','H','S'),
+  WINED3DFMT_DF16                         = WINEMAKEFOURCC('D','F','1','6'),
+  WINED3DFMT_DF24                         = WINEMAKEFOURCC('D','F','2','4'),
+
     WINED3DFMT_INTZ                         = WINEMAKEFOURCC('I','N','T','Z'),
     WINED3DFMT_RESZ                         = WINEMAKEFOURCC('R','E','S','Z'),
     WINED3DFMT_NULL                         = WINEMAKEFOURCC('N','U','L','L'),
@@ -2606,4 +2611,24 @@ static inline unsigned int wined3d_log2i(unsigned int x)
 #endif
 }
 
+BOOL wined3d_dxt1_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt1_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt3_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt3_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt5_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt5_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxtn_supported(void);
+
+typedef BOOL (*dxtn_conversion_func)(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+enum wined3d_format_id format, unsigned int w, unsigned int h);
+
+dxtn_conversion_func get_dxtn_conversion_func(D3DFORMAT format, BOOL encode);
+
+
 #endif /* __WINE_WINED3D_H */
diff --git a/tools/Makefile.in b/tools/Makefile.in
index 0f652f0..3ef2484 100644
--- a/tools/Makefile.in
+++ b/tools/Makefile.in
@@ -18,13 +18,15 @@ UPDATE_DESKTOP_DATABASE = update-desktop-database
 all: wineapploader
 
 make_xftmpl$(EXEEXT): make_xftmpl.o
-	$(CC) $(CFLAGS) -o $@ make_xftmpl.o $(LIBPORT) $(LDFLAGS)
+	@$(CC) $(CFLAGS) -o $@ make_xftmpl.o $(LIBPORT) $(LDFLAGS)
+	@echo "[CC] $@"
 
 .PHONY: install install-lib install-dev uninstall
 
 install install-lib::
-	$(INSTALL_DATA) $(srcdir)/wine.desktop $(DESTDIR)$(datadir)/applications/wine.desktop
+	@$(INSTALL_DATA) $(srcdir)/wine.desktop $(DESTDIR)$(datadir)/applications/wine.desktop
 	-$(UPDATE_DESKTOP_DATABASE)
+	@echo "[install-lib] $@"
 
 install install-dev:: install-man-pages
 	$(INSTALL_SCRIPT) $(srcdir)/winemaker $(DESTDIR)$(bindir)/winemaker
diff --git a/tools/makedep.c b/tools/makedep.c
index 54aab45..2353c29 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -1480,7 +1480,7 @@ static char *get_make_variable( struct makefile *make, const char *name )
  */
 static char *get_expanded_make_variable( struct makefile *make, const char *name )
 {
-    char *p, *end, *var, *expand, *tmp;
+    char *p, *end, *var, *expand, *tmp = NULL;
 
     expand = get_make_variable( make, name );
     if (!expand) return NULL;
@@ -1816,7 +1816,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             strarray_add( &res_files, strmake( "%s.res", obj ));
             output( "%s.res: %s %s\n", obj_dir_path( make, obj ),
                     tools_path( make, "wrc" ), source->filename );
-            output( "\t%s -o $@", tools_path( make, "wrc" ) );
+            output( "\t@%s -o $@", tools_path( make, "wrc" ) );
             if (make->is_win16) output_filename( "-m16" );
             else output_filenames( target_flags );
             output_filename( "--nostdinc" );
@@ -1829,6 +1829,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
                 output_filename( strmake( "--po-dir=%s", top_obj_dir_path( make, "po" )));
                 output_filename( source->filename );
                 output( "\n" );
+                output( "\t@echo [WRC] $@\n" );
                 output( "%s.res:", obj_dir_path( make, obj ));
                 output_filenames( mo_files );
                 output( "\n" );
@@ -1838,6 +1839,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             {
                 output_filename( source->filename );
                 output( "\n" );
+                output( "\t@echo [WRC] $@\n" );
             }
             output( "%s.res:", obj_dir_path( make, obj ));
         }
@@ -1878,7 +1880,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             if (source->file->flags & FLAG_IDL_PROXY) strarray_add( &dlldata_files, source->name );
             output_filenames_obj_dir( make, targets );
             output( ": %s\n", tools_path( make, "widl" ));
-            output( "\t%s -o $@", tools_path( make, "widl" ) );
+            output( "\t@%s -o $@", tools_path( make, "widl" ) );
             output_filenames( target_flags );
             output_filenames( includes );
             output_filenames( make->define_args );
@@ -1886,6 +1888,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames( get_expanded_make_var_array( make, "EXTRAIDLFLAGS" ));
             output_filename( source->filename );
             output( "\n" );
+            output( "\t@echo [WIDL] $@\n" );
             output_filenames_obj_dir( make, targets );
             output( ": %s", source->filename );
         }
@@ -1990,7 +1993,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             if (source->file->flags & FLAG_C_IMPLIB) strarray_add( &implib_objs, strmake( "%s.o", obj ));
             strarray_add( &object_files, strmake( "%s.o", obj ));
             output( "%s.o: %s\n", obj_dir_path( make, obj ), source->filename );
-            output( "\t$(CC) -c -o $@ %s", source->filename );
+            output( "\t@$(CC) -c -o $@ %s", source->filename );
             output_filenames( includes );
             output_filenames( make->define_args );
             output_filenames( extradefs );
@@ -2003,11 +2006,12 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames( cpp_flags );
             output_filename( "$(CFLAGS)" );
             output( "\n" );
+            output( "\t@echo [CC] %s\n", source->filename);
             if (crosstarget && need_cross)
             {
                 strarray_add( &crossobj_files, strmake( "%s.cross.o", obj ));
                 output( "%s.cross.o: %s\n", obj_dir_path( make, obj ), source->filename );
-                output( "\t$(CROSSCC) -c -o $@ %s", source->filename );
+                output( "\t@$(CROSSCC) -c -o $@ %s", source->filename );
                 output_filenames( includes );
                 output_filenames( make->define_args );
                 output_filenames( extradefs );
@@ -2015,6 +2019,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
                 output_filenames( cpp_flags );
                 output_filename( "$(CFLAGS)" );
                 output( "\n" );
+              output( "\t@echo [CROSSCC] %s\n", source->filename);
             }
             if (make->testdll && !strcmp( ext, "c" ) && !(source->file->flags & FLAG_GENERATED))
             {
@@ -2043,7 +2048,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output( "%s: %s", obj_dir_path( make, "rsrc.pot" ), tools_path( make, "wrc" ) );
         output_filenames( po_files );
         output( "\n" );
-        output( "\t%s -O pot -o $@", tools_path( make, "wrc" ));
+        output( "\t@%s -O pot -o $@", tools_path( make, "wrc" ));
         if (make->is_win16) output_filename( "-m16" );
         else output_filenames( target_flags );
         output_filename( "--nostdinc" );
@@ -2051,6 +2056,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( make->define_args );
         output_filenames( po_files );
         output( "\n" );
+      output( "\t@echo [WRC] $@\n" );
         strarray_add( &clean_files, "rsrc.pot" );
     }
 
@@ -2059,9 +2065,10 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output( "%s: %s", obj_dir_path( make, "msg.pot" ), tools_path( make, "wmc" ));
         output_filenames( mc_files );
         output( "\n" );
-        output( "\t%s -O pot -o $@", tools_path( make, "wmc" ));
+        output( "\t@%s -O pot -o $@", tools_path( make, "wmc" ));
         output_filenames( mc_files );
         output( "\n" );
+        output( "\t@echo [WMC] $@\n" );
         strarray_add( &clean_files, "msg.pot" );
     }
 
@@ -2069,9 +2076,10 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
     {
         output( "%s: %s %s\n", obj_dir_path( make, "dlldata.c" ),
                 tools_path( make, "widl" ), src_dir_path( make, "Makefile.in" ));
-        output( "\t%s --dlldata-only -o $@", tools_path( make, "widl" ));
+        output( "\t@%s --dlldata-only -o $@", tools_path( make, "widl" ));
         output_filenames( dlldata_files );
         output( "\n" );
+        output( "\t@echo [WIDL] $@\n" );
     }
 
     if (make->module && !make->staticlib)
@@ -2108,7 +2116,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames_obj_dir( make, object_files );
         output_filenames_obj_dir( make, res_files );
         output( "\n" );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2124,6 +2132,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
 
         if (spec_file && make->importlib)
         {
@@ -2256,7 +2265,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         strarray_add( &all_targets, strmake( "%s%s", testmodule, dll_ext ));
         strarray_add( &clean_files, strmake( "%s%s", stripped, dll_ext ));
         output( "%s%s:\n", obj_dir_path( make, testmodule ), dll_ext );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2267,8 +2276,9 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
         output( "%s%s:\n", obj_dir_path( make, stripped ), dll_ext );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2280,6 +2290,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
         output( "%s%s %s%s:", obj_dir_path( make, testmodule ), dll_ext,
                 obj_dir_path( make, stripped ), dll_ext );
         output_filenames_obj_dir( make, object_files );
@@ -2302,7 +2313,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames_obj_dir( make, crossobj_files );
             output_filenames_obj_dir( make, res_files );
             output( "\n" );
-            output( "\t%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
+            output( "\t@%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
             output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
             if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
             output_filename( "--lib-suffix=.cross.a" );
@@ -2311,6 +2322,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames( all_libs );
             output_filename( "$(LDFLAGS)" );
             output( "\n" );
+            output( "\t@echo [WINEGCC] $@\n" );
             strarray_add( &phony_targets, obj_dir_path( make, "crosstest" ));
             if (make->obj_dir) output( "crosstest: %s\n", obj_dir_path( make, "crosstest" ));
         }
