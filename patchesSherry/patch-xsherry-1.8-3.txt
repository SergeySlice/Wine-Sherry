commit 12e8271003cf8cd4e9b50293c96bb4154f2b878c
Author: Sergey Isakov <sergey.slice@gmail.com>
Date:   Tue Nov 24 00:49:10 2015 +0300

    add files for dxtn support

diff --git a/dlls/d3d9/surface.c b/dlls/d3d9/surface.c
index 833c1f4..47615d5 100644
--- a/dlls/d3d9/surface.c
+++ b/dlls/d3d9/surface.c
@@ -18,7 +18,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #include "d3d9_private.h"
 
@@ -361,7 +361,7 @@ void surface_init(struct d3d9_surface *surface, struct wined3d_texture *wined3d_
         struct wined3d_surface *wined3d_surface, const struct wined3d_parent_ops **parent_ops)
 {
     struct wined3d_resource_desc desc;
-    IDirect3DBaseTexture9 *texture;
+    IDirect3DBaseTexture9 *texture = NULL;
 
     surface->IDirect3DSurface9_iface.lpVtbl = &d3d9_surface_vtbl;
     d3d9_resource_init(&surface->resource);
@@ -403,6 +403,10 @@ static void STDMETHODCALLTYPE view_wined3d_object_destroyed(void *parent)
 {
     struct d3d9_surface *surface = parent;
 
+  if (!surface) {
+    return;
+  }
+
     /* If the surface reference count drops to zero, we release our reference
      * to the view, but don't clear the pointer yet, in case e.g. a
      * GetRenderTarget() call brings the surface back before the view is
@@ -425,6 +429,10 @@ struct wined3d_rendertarget_view *d3d9_surface_get_rendertarget_view(struct d3d9
 {
     HRESULT hr;
 
+  if (!surface) {
+    return NULL;
+  }
+
     if (surface->wined3d_rtv)
         return surface->wined3d_rtv;
 
diff --git a/dlls/d3d9/tests/device.c b/dlls/d3d9/tests/device.c
index 326e789..fc68de6 100644
--- a/dlls/d3d9/tests/device.c
+++ b/dlls/d3d9/tests/device.c
@@ -10352,6 +10352,113 @@ static void test_swapchain_parameters(void)
     DestroyWindow(window);
 }
 
+static void test_mipmap_memory(void)
+{
+    IDirect3DDevice9 *device;
+    IDirect3D9 *d3d;
+    UINT refcount;
+    HWND window;
+    HRESULT hr;
+    unsigned int lvl, pool, fmt, mem_size, tex_size, levels;
+    IDirect3DTexture9 *texture;
+    D3DLOCKED_RECT lr;
+    BYTE *next;
+    static const struct
+    {
+        D3DPOOL pool;
+        const char *name;
+    }
+    pools[] =
+    {
+        {D3DPOOL_MANAGED,       "D3DPOOL_MANAGED"},
+        {D3DPOOL_SYSTEMMEM,     "D3DPOOL_SYSTEMMEM"},
+        {D3DPOOL_SCRATCH,       "D3DPOOL_SCRATCH"},
+        /*{D3DPOOL_DEFAULT,       "D3DPOOL_DEFAULT"}, doesn't have the address relation */
+    };
+    static const struct
+    {
+        D3DFORMAT format;
+        const char *name;
+        unsigned int size;
+    }
+    formats[] =
+    {
+        {D3DFMT_A8R8G8B8,       "D3DFMT_A8R8G8B8",      4},
+        /* A8 is not supported everywhere(e.g. r200), use L8 instead.
+         * I'm not sure if L8 is supported on all GPUs, so test both
+         * to make sure one 8 bit format is tested. */
+        {D3DFMT_A8,             "D3DFMT_A8",            1},
+        {D3DFMT_L8,             "D3DFMT_L8",            1},
+    };
+
+    static const unsigned int alignment = 8, create_size = 256;
+
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, NULL)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        IDirect3D9_Release(d3d);
+        DestroyWindow(window);
+        return;
+    }
+
+    for (pool = 0; pool < sizeof(pools) / sizeof(*pools); pool++)
+    {
+        DWORD usage;
+
+        if (pools[pool].pool == D3DPOOL_DEFAULT)
+            usage = D3DUSAGE_DYNAMIC;
+        else
+            usage = 0;
+
+        for (fmt = 0; fmt < sizeof(formats) / sizeof(*formats); fmt++)
+        {
+            hr = IDirect3D9_CheckDeviceFormat(d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
+                    D3DFMT_X8R8G8B8, usage, D3DRTYPE_TEXTURE, formats[fmt].format);
+            if (FAILED(hr))
+            {
+                skip("Format %s is not supported, skipping texture pointer test for this format\n",
+                        formats[fmt].name);
+                continue;
+            }
+
+            hr = IDirect3DDevice9_CreateTexture(device, create_size, create_size, 0,
+                    usage, formats[fmt].format, pools[pool].pool, &texture, NULL);
+            ok(SUCCEEDED(hr), "Failed to create %s %s texture, hr %#x.\n",
+                    pools[pool].name, formats[fmt].name, hr);
+
+            next = NULL;
+            levels = IDirect3DTexture9_GetLevelCount(texture);
+            for (lvl = 0; lvl < levels; lvl++)
+            {
+                hr = IDirect3DTexture9_LockRect(texture, lvl, &lr, NULL, 0);
+                ok(SUCCEEDED(hr), "Failed to lock level %u, hr %#x.\n", lvl, hr);
+
+                if (next)
+                {
+                    ok(next + mem_size == lr.pBits, "%s, %s, lvl %u: Expected pointer %p, got %p\n",
+                            pools[pool].name, formats[fmt].name, lvl, next + mem_size, lr.pBits);
+                }
+                tex_size = create_size >> lvl;
+                mem_size = (tex_size * tex_size * formats[fmt].size + (alignment - 1)) & ~(alignment - 1);
+                next = lr.pBits;
+
+                hr = IDirect3DTexture9_UnlockRect(texture, lvl);
+                ok(SUCCEEDED(hr), "Failed to unlock level %u, hr %#x.\n", lvl, hr);
+            }
+            IDirect3DTexture9_Release(texture);
+        }
+    }
+
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
+}
+
 START_TEST(device)
 {
     WNDCLASSA wc = {0};
@@ -10463,6 +10570,7 @@ START_TEST(device)
     test_lost_device();
     test_resource_priority();
     test_swapchain_parameters();
+    test_mipmap_memory();
 
     UnregisterClassA("d3d9_test_wc", GetModuleHandleA(NULL));
 }
diff --git a/dlls/d3dx9_36/Makefile.in b/dlls/d3dx9_36/Makefile.in
index 5958c57..fd710c2 100644
--- a/dlls/d3dx9_36/Makefile.in
+++ b/dlls/d3dx9_36/Makefile.in
@@ -1,8 +1,9 @@
 MODULE    = d3dx9_36.dll
 IMPORTLIB = d3dx9
-IMPORTS   = d3d9 d3dcompiler dxguid d3dxof ole32 gdi32 user32
+IMPORTS   = d3d9 d3dcompiler dxguid d3dxof ole32 gdi32 user32 wined3d
 
 C_SRCS = \
+	animation.c \
 	core.c \
 	d3dx9_36_main.c \
 	effect.c \
diff --git a/dlls/d3dx9_36/animation.c b/dlls/d3dx9_36/animation.c
new file mode 100644
index 0000000..37c2036
--- /dev/null
+++ b/dlls/d3dx9_36/animation.c
@@ -0,0 +1,472 @@
+/*
+ * Animation Controller operations specific to D3DX9.
+ *
+ * Copyright (C) 2015 Christian Costa
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "wine/debug.h"
+#include "d3dx9_36_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
+
+struct d3dx9_animation_controller
+{
+    ID3DXAnimationController ID3DXAnimationController_iface;
+    LONG ref;
+
+    UINT max_outputs;
+    UINT max_sets;
+    UINT max_tracks;
+    UINT max_events;
+};
+
+static inline struct d3dx9_animation_controller *impl_from_ID3DXAnimationController(ID3DXAnimationController *iface)
+{
+    return CONTAINING_RECORD(iface, struct d3dx9_animation_controller, ID3DXAnimationController_iface);
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_QueryInterface(ID3DXAnimationController *iface, REFIID riid, void **out)
+{
+    TRACE("iface %p, riid %s, out %p.\n", iface, debugstr_guid(riid), out);
+
+    if (IsEqualGUID(riid, &IID_IUnknown) || IsEqualGUID(riid, &IID_ID3DXAnimationController))
+    {
+        IUnknown_AddRef(iface);
+        *out = iface;
+        return D3D_OK;
+    }
+
+    WARN("%s not implemented, returning E_NOINTERFACE\n", debugstr_guid(riid));
+
+    *out = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI d3dx9_animation_controller_AddRef(ID3DXAnimationController *iface)
+{
+    struct d3dx9_animation_controller *This = impl_from_ID3DXAnimationController(iface);
+    ULONG refcount = InterlockedIncrement(&This->ref);
+
+    TRACE("%p increasing refcount to %u.\n", This, refcount);
+
+    return refcount;
+}
+
+static ULONG WINAPI d3dx9_animation_controller_Release(ID3DXAnimationController *iface)
+{
+    struct d3dx9_animation_controller *This = impl_from_ID3DXAnimationController(iface);
+    ULONG refcount = InterlockedDecrement(&This->ref);
+
+//    TRACE("%p decreasing refcount to %u.\n", This, refcount);
+
+    if (!refcount)
+    {
+        HeapFree(GetProcessHeap(), 0, This);
+    }
+
+    return refcount;
+}
+
+static UINT WINAPI d3dx9_animation_controller_GetMaxNumAnimationOutputs(ID3DXAnimationController *iface)
+{
+    struct d3dx9_animation_controller *This = impl_from_ID3DXAnimationController(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    return This->max_outputs;
+}
+
+static UINT WINAPI d3dx9_animation_controller_GetMaxNumAnimationSets(ID3DXAnimationController *iface)
+{
+    struct d3dx9_animation_controller *This = impl_from_ID3DXAnimationController(iface);
+
+    TRACE("iface %p.\n", iface);
+
+    return This->max_sets;
+}
+
+static UINT WINAPI d3dx9_animation_controller_GetMaxNumTracks(ID3DXAnimationController *iface)
+{
+    struct d3dx9_animation_controller *This = impl_from_ID3DXAnimationController(iface);
+
+    FIXME("iface %p.\n", iface);
+
+    return This->max_tracks;
+}
+
+static UINT WINAPI d3dx9_animation_controller_GetMaxNumEvents(ID3DXAnimationController *iface)
+{
+    struct d3dx9_animation_controller *This = impl_from_ID3DXAnimationController(iface);
+
+    FIXME("iface %p.\n", iface);
+
+    return This->max_events;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_RegisterAnimationOutput(ID3DXAnimationController *iface,
+        const char *name, D3DXMATRIX *matrix, D3DXVECTOR3 *scale, D3DXQUATERNION *rotation, D3DXVECTOR3 *translation)
+{
+    FIXME("iface %p, name %s, matrix %p, scale %p, rotation %p, translation %p stub.\n", iface, wine_dbgstr_a(name),
+            matrix, scale, rotation, translation);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_RegisterAnimationSet(ID3DXAnimationController *iface,
+        ID3DXAnimationSet *anim_set)
+{
+    FIXME("iface %p, anim_set %p stub.\n", iface, anim_set);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_UnregisterAnimationSet(ID3DXAnimationController *iface,
+        ID3DXAnimationSet *anim_set)
+{
+    FIXME("iface %p, anim_set %p stub.\n", iface, anim_set);
+
+    return E_NOTIMPL;
+}
+
+static UINT WINAPI d3dx9_animation_controller_GetNumAnimationSets(ID3DXAnimationController *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return 0;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_GetAnimationSet(ID3DXAnimationController *iface,
+        UINT index, ID3DXAnimationSet **anim_set)
+{
+    FIXME("iface %p, index %u, anim_set %p stub.\n", iface, index, anim_set);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_GetAnimationSetByName(ID3DXAnimationController *iface,
+        const char *name, ID3DXAnimationSet **anim_set)
+{
+    FIXME("iface %p, name %s, anim_set %p stub.\n", iface, wine_dbgstr_a(name), anim_set);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_AdvanceTime(ID3DXAnimationController *iface, DOUBLE time_delta,
+        ID3DXAnimationCallbackHandler **callback_handler)
+{
+    FIXME("iface %p, time_delta %g, callback_handler %p stub.\n", iface, time_delta, callback_handler);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_Reset(ID3DXAnimationController *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static DOUBLE WINAPI d3dx9_animation_controller_GetTime(ID3DXAnimationController *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return 0.0;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetTrackAnimationSet(ID3DXAnimationController *iface,
+        UINT track, ID3DXAnimationSet *anim_set)
+{
+    FIXME("iface %p, track %u, anim_set %p stub.\n", iface, track, anim_set);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_GetTrackAnimationSet(ID3DXAnimationController *iface,
+        UINT track, ID3DXAnimationSet **anim_set)
+{
+    FIXME("iface %p, track %u, anim_set %p stub.\n", iface, track, anim_set);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_GetTrackPriority(ID3DXAnimationController *iface,
+        UINT track, D3DXPRIORITY_TYPE *priority)
+{
+    FIXME("iface %p, track %u, priority %p stub.\n", iface, track, priority);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetTrackSpeed(ID3DXAnimationController *iface,
+        UINT track, FLOAT speed)
+{
+    FIXME("iface %p, track %u, speed %f stub.\n", iface, track, speed);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetTrackWeight(ID3DXAnimationController *iface,
+        UINT track, FLOAT weight)
+{
+    FIXME("iface %p, track %u, weight %f stub.\n", iface, track, weight);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetTrackPosition(ID3DXAnimationController *iface,
+        UINT track, DOUBLE position)
+{
+    FIXME("iface %p, track %u, position %g stub.\n", iface, track, position);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetTrackEnable(ID3DXAnimationController *iface,
+        UINT track, BOOL enable)
+{
+    FIXME("iface %p, track %u, enable %u stub.\n", iface, track, enable);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetTrackDesc(ID3DXAnimationController *iface,
+        UINT track, D3DXTRACK_DESC *desc)
+{
+    FIXME("iface %p, track %u, desc %p stub.\n", iface, track, desc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_GetTrackDesc(ID3DXAnimationController *iface,
+        UINT track, D3DXTRACK_DESC *desc)
+{
+    FIXME("iface %p, track %u, desc %p stub.\n", iface, track, desc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_SetPriorityBlend(ID3DXAnimationController *iface,
+        FLOAT blend_weight)
+{
+    FIXME("iface %p, blend_weight %f stub.\n", iface, blend_weight);
+
+    return E_NOTIMPL;
+}
+
+static FLOAT WINAPI d3dx9_animation_controller_GetPriorityBlend(ID3DXAnimationController *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return 0.0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_KeyTrackSpeed(ID3DXAnimationController *iface,
+        UINT track, FLOAT new_speed, DOUBLE start_time, DOUBLE duration, D3DXTRANSITION_TYPE transition)
+{
+    FIXME("iface %p, track %u, new_speed %f, start_time %g, duration %g, transition %u stub.\n", iface,
+            track, new_speed, start_time, duration, transition);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_KeyTrackWeight(ID3DXAnimationController *iface,
+        UINT track, FLOAT new_weight, DOUBLE start_time, DOUBLE duration, D3DXTRANSITION_TYPE transition)
+{
+    FIXME("iface %p, track %u, new_weight %f, start_time %g, duration %g, transition %u stub.\n", iface,
+            track, new_weight, start_time, duration, transition);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_KeyTrackPosition(ID3DXAnimationController *iface,
+        UINT track, DOUBLE new_position, DOUBLE start_time)
+{
+    FIXME("iface %p, track %u, new_position %g, start_time %g stub.\n", iface,
+            track, new_position, start_time);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_KeyTrackEnable(ID3DXAnimationController *iface,
+        UINT track, BOOL new_enable, DOUBLE start_time)
+{
+    FIXME("iface %p, track %u, new_enable %u, start_time %g stub.\n", iface,
+            track, new_enable, start_time);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_KeyTrackBlend(ID3DXAnimationController *iface,
+        FLOAT new_blend_weight, DOUBLE start_time, DOUBLE duration, D3DXTRANSITION_TYPE transition)
+{
+    FIXME("iface %p, new_blend_weight %f, start_time %g, duration %g, transition %u stub.\n", iface,
+            new_blend_weight, start_time, duration, transition);
+
+    return 0;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_UnkeyEvent(ID3DXAnimationController *iface, D3DXEVENTHANDLE event)
+{
+    FIXME("iface %p, event %u stub.\n", iface, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_UnkeyAllTrackEvents(ID3DXAnimationController *iface, UINT track)
+{
+    FIXME("iface %p, track %u stub.\n", iface, track);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_UnkeyAllPriorityBlends(ID3DXAnimationController *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return E_NOTIMPL;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_GetCurrentTrackEvent(ID3DXAnimationController *iface,
+        UINT track, D3DXEVENT_TYPE event_type)
+{
+    FIXME("iface %p, track %u, event_type %u stub.\n", iface, track, event_type);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_GetCurrentPriorityBlend(ID3DXAnimationController *iface)
+{
+    FIXME("iface %p stub.\n", iface);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_GetUpcomingTrackEvent(ID3DXAnimationController *iface,
+        UINT track, D3DXEVENTHANDLE event)
+{
+    FIXME("iface %p, track %u, event %u stub.\n", iface, track, event);
+
+    return 0;
+}
+
+static D3DXEVENTHANDLE WINAPI d3dx9_animation_controller_GetUpcomingPriorityBlend(ID3DXAnimationController *iface,
+        D3DXEVENTHANDLE handle)
+{
+    FIXME("iface %p, handle %u stub.\n", iface, handle);
+
+    return 0;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_ValidateEvent(ID3DXAnimationController *iface, D3DXEVENTHANDLE event)
+{
+    FIXME("iface %p, event %u stub.\n", iface, event);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_GetEventDesc(ID3DXAnimationController *iface,
+        D3DXEVENTHANDLE event, D3DXEVENT_DESC *desc)
+{
+    FIXME("iface %p, event %u, desc %p stub.\n", iface, event, desc);
+
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI d3dx9_animation_controller_CloneAnimationController(ID3DXAnimationController *iface, UINT max_num_anim_outputs,
+        UINT max_num_anim_sets, UINT max_num_tracks, UINT max_num_events, ID3DXAnimationController **anim_controller)
+{
+    FIXME("iface %p, max_num_anim_outputs %u, max_num_anim_sets %u, max_num_tracks %u, max_num_events %u, anim_controller %p stub.\n",
+            iface, max_num_anim_outputs, max_num_anim_sets, max_num_tracks, max_num_events, anim_controller);
+
+    return E_NOTIMPL;
+}
+
+static const struct ID3DXAnimationControllerVtbl d3dx9_animation_controller_vtbl =
+{
+    d3dx9_animation_controller_QueryInterface,
+    d3dx9_animation_controller_AddRef,
+    d3dx9_animation_controller_Release,
+    d3dx9_animation_controller_GetMaxNumAnimationOutputs,
+    d3dx9_animation_controller_GetMaxNumAnimationSets,
+    d3dx9_animation_controller_GetMaxNumTracks,
+    d3dx9_animation_controller_GetMaxNumEvents,
+    d3dx9_animation_controller_RegisterAnimationOutput,
+    d3dx9_animation_controller_RegisterAnimationSet,
+    d3dx9_animation_controller_UnregisterAnimationSet,
+    d3dx9_animation_controller_GetNumAnimationSets,
+    d3dx9_animation_controller_GetAnimationSet,
+    d3dx9_animation_controller_GetAnimationSetByName,
+    d3dx9_animation_controller_AdvanceTime,
+    d3dx9_animation_controller_Reset,
+    d3dx9_animation_controller_GetTime,
+    d3dx9_animation_controller_SetTrackAnimationSet,
+    d3dx9_animation_controller_GetTrackAnimationSet,
+    d3dx9_animation_controller_GetTrackPriority,
+    d3dx9_animation_controller_SetTrackSpeed,
+    d3dx9_animation_controller_SetTrackWeight,
+    d3dx9_animation_controller_SetTrackPosition,
+    d3dx9_animation_controller_SetTrackEnable,
+    d3dx9_animation_controller_SetTrackDesc,
+    d3dx9_animation_controller_GetTrackDesc,
+    d3dx9_animation_controller_SetPriorityBlend,
+    d3dx9_animation_controller_GetPriorityBlend,
+    d3dx9_animation_controller_KeyTrackSpeed,
+    d3dx9_animation_controller_KeyTrackWeight,
+    d3dx9_animation_controller_KeyTrackPosition,
+    d3dx9_animation_controller_KeyTrackEnable,
+    d3dx9_animation_controller_KeyTrackBlend,
+    d3dx9_animation_controller_UnkeyEvent,
+    d3dx9_animation_controller_UnkeyAllTrackEvents,
+    d3dx9_animation_controller_UnkeyAllPriorityBlends,
+    d3dx9_animation_controller_GetCurrentTrackEvent,
+    d3dx9_animation_controller_GetCurrentPriorityBlend,
+    d3dx9_animation_controller_GetUpcomingTrackEvent,
+    d3dx9_animation_controller_GetUpcomingPriorityBlend,
+    d3dx9_animation_controller_ValidateEvent,
+    d3dx9_animation_controller_GetEventDesc,
+    d3dx9_animation_controller_CloneAnimationController
+};
+
+/***********************************************************************
+ *           D3DXCreateAnimationController    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXCreateAnimationController(UINT MaxNumAnimationOutputs, UINT MaxNumAnimationSets,
+        UINT MaxNumTracks, UINT MaxNumEvents, ID3DXAnimationController **AnimationController)
+{
+    struct d3dx9_animation_controller* object;
+
+    TRACE("MaxNumAnimationOutputs %u, MaxNumAnimationSets %u, MaxNumTracks %u, MaxNumEvents %u, AnimationController %p.\n",
+            MaxNumAnimationOutputs, MaxNumAnimationSets, MaxNumTracks, MaxNumEvents, AnimationController);
+
+    if (!AnimationController)
+        return D3DERR_INVALIDCALL;
+
+    object = HeapAlloc(GetProcessHeap(), 0, sizeof(*object));
+    if (!object)
+        return E_OUTOFMEMORY;
+
+    object->ID3DXAnimationController_iface.lpVtbl = &d3dx9_animation_controller_vtbl;
+    object->ref = 1;
+    object->max_outputs = MaxNumAnimationOutputs;
+    object->max_sets    = MaxNumAnimationSets;
+    object->max_tracks  = MaxNumTracks;
+    object->max_events  = MaxNumEvents;
+
+    *AnimationController = &object->ID3DXAnimationController_iface;
+
+    return D3D_OK;
+}
diff --git a/dlls/d3dx9_36/core.c b/dlls/d3dx9_36/core.c
index 53e9531..f1ae58f 100644
--- a/dlls/d3dx9_36/core.c
+++ b/dlls/d3dx9_36/core.c
@@ -66,7 +66,7 @@ static ULONG WINAPI ID3DXBufferImpl_AddRef(ID3DXBuffer *iface)
     struct ID3DXBufferImpl *This = impl_from_ID3DXBuffer(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %u\n", This, ref);
+//    TRACE("%p increasing refcount to %u\n", This, ref);
 
     return ref;
 }
@@ -76,7 +76,7 @@ static ULONG WINAPI ID3DXBufferImpl_Release(ID3DXBuffer *iface)
     struct ID3DXBufferImpl *This = impl_from_ID3DXBuffer(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %u\n", This, ref);
+//    TRACE("%p decreasing refcount to %u\n", This, ref);
 
     if (ref == 0)
     {
diff --git a/dlls/d3dx9_36/d3d9-dxtn.h b/dlls/d3dx9_36/d3d9-dxtn.h
new file mode 100644
index 0000000..a9eadeb
--- /dev/null
+++ b/dlls/d3dx9_36/d3d9-dxtn.h
@@ -0,0 +1,25 @@
+//
+//  d3d9-dxtn.h
+//  wine-prg
+//
+//  Created by Sergey on 24.04.15.
+//  Copyright (c) 2015 Slice. All rights reserved.
+//
+
+#ifndef wine_prg_d3d9_dxtn_h
+#define wine_prg_d3d9_dxtn_h
+
+
+//#include "config.h"
+#include "d3dx9_36_private.h"
+
+#include "wine/wined3d.h"
+
+
+typedef BOOL (*dxtn_conversion_func)(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+enum wined3d_format_id format, unsigned int w, unsigned int h);
+
+dxtn_conversion_func get_dxtn_conversion_func(D3DFORMAT format, BOOL encode);
+
+
+#endif
diff --git a/dlls/d3dx9_36/d3dx9_36.spec b/dlls/d3dx9_36/d3dx9_36.spec
index f79b6fa..545d9c3 100644
--- a/dlls/d3dx9_36/d3dx9_36.spec
+++ b/dlls/d3dx9_36/d3dx9_36.spec
@@ -22,7 +22,7 @@
 @ stub D3DXComputeIMTFromPerTexelSignal(ptr long ptr long long long long long ptr ptr ptr)
 @ stub D3DXComputeIMTFromSignal(ptr long long long long ptr ptr ptr ptr ptr)
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
-@ stub D3DXComputeNormalMap(ptr ptr ptr long long long)
+@ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
 @ stdcall D3DXComputeNormals(ptr ptr)
 @ stub D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
@@ -30,7 +30,7 @@
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
 @ stub D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr)
 @ stub D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr)
-@ stub D3DXCreateAnimationController(long long long long ptr)
+@ stdcall D3DXCreateAnimationController(long long long long ptr)
 @ stdcall D3DXCreateBox(ptr float float float ptr ptr)
 @ stdcall D3DXCreateBuffer(long ptr)
 @ stub D3DXCreateCompressedAnimationSet(ptr long long ptr long ptr ptr)
@@ -135,7 +135,7 @@
 @ stub D3DXFrameAppendChild(ptr ptr)
 @ stub D3DXFrameCalculateBoundingSphere(ptr ptr ptr)
 @ stdcall D3DXFrameDestroy(ptr ptr)
-@ stub D3DXFrameFind(ptr ptr)
+@ stdcall D3DXFrameFind(ptr str)
 @ stub D3DXFrameNumNamedMatrices(ptr)
 @ stub D3DXFrameRegisterNamedMatrices(ptr ptr)
 @ stdcall D3DXFresnelTerm(float float)
@@ -159,8 +159,8 @@
 @ stdcall D3DXGetPixelShaderProfile(ptr)
 @ stdcall D3DXGetShaderConstantTable(ptr ptr)
 @ stdcall D3DXGetShaderConstantTableEx(ptr long ptr)
-@ stub D3DXGetShaderInputSemantics(ptr ptr ptr)
-@ stub D3DXGetShaderOutputSemantics(ptr ptr ptr)
+@ stdcall D3DXGetShaderInputSemantics(ptr ptr ptr)
+@ stdcall D3DXGetShaderOutputSemantics(ptr ptr ptr)
 @ stdcall D3DXGetShaderSamplers(ptr ptr ptr)
 @ stdcall D3DXGetShaderSize(ptr)
 @ stdcall D3DXGetShaderVersion(ptr)
@@ -269,9 +269,9 @@
 @ stdcall D3DXSaveTextureToFileA(ptr long ptr ptr)
 @ stdcall D3DXSaveTextureToFileInMemory(ptr long ptr ptr)
 @ stdcall D3DXSaveTextureToFileW(ptr long ptr ptr)
-@ stub D3DXSaveVolumeToFileA(ptr long ptr ptr ptr)
-@ stub D3DXSaveVolumeToFileInMemory(ptr long ptr ptr ptr)
-@ stub D3DXSaveVolumeToFileW(ptr long ptr ptr ptr)
+@ stdcall D3DXSaveVolumeToFileA(ptr long ptr ptr ptr)
+@ stdcall D3DXSaveVolumeToFileInMemory(ptr long ptr ptr ptr)
+@ stdcall D3DXSaveVolumeToFileW(ptr long ptr ptr ptr)
 @ stdcall D3DXSHAdd(ptr long ptr ptr)
 @ stdcall D3DXSHDot(long ptr ptr)
 @ stdcall D3DXSHEvalConeLight(long ptr float float float float ptr ptr ptr)
diff --git a/dlls/d3dx9_36/d3dx9_36_private.h b/dlls/d3dx9_36/d3dx9_36_private.h
index 79f3b76..4a1073b 100644
--- a/dlls/d3dx9_36/d3dx9_36_private.h
+++ b/dlls/d3dx9_36/d3dx9_36_private.h
@@ -81,22 +81,29 @@ void copy_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch,
 void convert_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch,
     const struct volume *src_size, const struct pixel_format_desc *src_format,
     BYTE *dst, UINT dst_row_pitch, UINT dst_slice_pitch, const struct volume *dst_size,
-    const struct pixel_format_desc *dst_format, D3DCOLOR color_key, const PALETTEENTRY *palette) DECLSPEC_HIDDEN;
+    const struct pixel_format_desc *dst_format, D3DCOLOR color_key, const PALETTEENTRY *palette, BOOL dither) DECLSPEC_HIDDEN;
 void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch,
     const struct volume *src_size, const struct pixel_format_desc *src_format,
     BYTE *dst, UINT dst_row_pitch, UINT dst_slice_pitch, const struct volume *dst_size,
     const struct pixel_format_desc *dst_format, D3DCOLOR color_key, const PALETTEENTRY *palette) DECLSPEC_HIDDEN;
+void smooth_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch, const struct volume *src_size,
+        const struct pixel_format_desc *src_format, BYTE *dst, UINT dst_row_pitch, UINT dst_slice_pitch,
+        const struct volume *dst_size, const struct pixel_format_desc *dst_format, D3DCOLOR color_key)  DECLSPEC_HIDDEN;
 
 HRESULT load_texture_from_dds(IDirect3DTexture9 *texture, const void *src_data, const PALETTEENTRY *palette,
         DWORD filter, D3DCOLOR color_key, const D3DXIMAGE_INFO *src_info, unsigned int skip_levels,
         unsigned int *loaded_miplevels) DECLSPEC_HIDDEN;
 HRESULT load_cube_texture_from_dds(IDirect3DCubeTexture9 *cube_texture, const void *src_data,
     const PALETTEENTRY *palette, DWORD filter, D3DCOLOR color_key, const D3DXIMAGE_INFO *src_info) DECLSPEC_HIDDEN;
-HRESULT load_volume_from_dds(IDirect3DVolume9 *dst_volume, const PALETTEENTRY *dst_palette,
+HRESULT load_volume_from_dds(struct IDirect3DVolume9 *dst_volume, const PALETTEENTRY *dst_palette,
     const D3DBOX *dst_box, const void *src_data, const D3DBOX *src_box, DWORD filter, D3DCOLOR color_key,
     const D3DXIMAGE_INFO *src_info) DECLSPEC_HIDDEN;
 HRESULT load_volume_texture_from_dds(IDirect3DVolumeTexture9 *volume_texture, const void *src_data,
     const PALETTEENTRY *palette, DWORD filter, DWORD color_key, const D3DXIMAGE_INFO *src_info) DECLSPEC_HIDDEN;
+HRESULT save_dds_texture_to_memory(ID3DXBuffer **dst_buffer, IDirect3DBaseTexture9 *src_texture,
+                                   const PALETTEENTRY *src_palette) DECLSPEC_HIDDEN;
+HRESULT save_dds_volume_to_memory(ID3DXBuffer **dst_buffer, struct IDirect3DVolume9 *src_volume,
+                                  UINT levels, const D3DBOX *src_box)  DECLSPEC_HIDDEN;
 
 unsigned short float_32_to_16(const float in) DECLSPEC_HIDDEN;
 float float_16_to_32(const unsigned short in) DECLSPEC_HIDDEN;
@@ -110,4 +117,6 @@ const char *debug_d3dxparameter_registerset(D3DXREGISTER_SET r) DECLSPEC_HIDDEN;
 void set_number(void *outdata, D3DXPARAMETER_TYPE outtype,
         const void *indata, D3DXPARAMETER_TYPE intype) DECLSPEC_HIDDEN;
 
+HRESULT create_dummy_skin(ID3DXSkinInfo **iface) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_D3DX9_36_PRIVATE_H */
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index f0bbd0b..d05c225 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -27,6 +27,11 @@
 #include "wingdi.h"
 #include "d3dx9_36_private.h"
 #include "d3dcompiler.h"
+#include "initguid.h"
+
+/* d3dx9_26 provides an ID3DXEffect interface where the last function SetRawValue
+ * is missing. Since its otherwise identical, we just use the same vtable. */
+DEFINE_GUID(IID_ID3DXEffect26, 0xc7b17651, 0x5420, 0x490e, 0x8a, 0x7f, 0x92, 0x36, 0x75, 0xa2, 0xd6, 0x87);
 
 /* Constants for special INT/FLOAT conversation */
 #define INT_FLOAT_MULTI 255.0f
@@ -2501,7 +2506,8 @@ static HRESULT WINAPI ID3DXEffectImpl_QueryInterface(ID3DXEffect *iface, REFIID
     TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), object);
 
     if (IsEqualGUID(riid, &IID_IUnknown) ||
-        IsEqualGUID(riid, &IID_ID3DXEffect))
+        IsEqualGUID(riid, &IID_ID3DXEffect) ||
+        IsEqualGUID(riid, &IID_ID3DXEffect26))
     {
         iface->lpVtbl->AddRef(iface);
         *object = iface;
@@ -3122,13 +3128,41 @@ static HRESULT WINAPI ID3DXEffectImpl_ValidateTechnique(ID3DXEffect* iface, D3DX
     return D3D_OK;
 }
 
-static HRESULT WINAPI ID3DXEffectImpl_FindNextValidTechnique(ID3DXEffect* iface, D3DXHANDLE technique, D3DXHANDLE* next_technique)
+static HRESULT WINAPI ID3DXEffectImpl_FindNextValidTechnique(ID3DXEffect *iface,
+        D3DXHANDLE technique, D3DXHANDLE *next_technique)
 {
     struct ID3DXEffectImpl *This = impl_from_ID3DXEffect(iface);
+    struct d3dx9_base_effect *base_effect = &This->base_effect;
+    UINT i = 0;
 
-    FIXME("(%p)->(%p, %p): stub\n", This, technique, next_technique);
+    TRACE("iface %p, technique %p, next_technique %p\n", iface, technique, next_technique);
 
-    return E_NOTIMPL;
+    if (!next_technique)
+        return D3DERR_INVALIDCALL;
+
+    if (technique)
+    {
+        for (; i < base_effect->technique_count; i++)
+        {
+            if (technique == get_technique_handle(&base_effect->techniques[i]))
+            {
+                i++; /* Go to next technique */
+                break;
+            }
+        }
+    }
+
+    for (; i < base_effect->technique_count; i++)
+    {
+        if (SUCCEEDED(iface->lpVtbl->ValidateTechnique(iface, get_technique_handle(&base_effect->techniques[i]))))
+        {
+            *next_technique = get_technique_handle(&base_effect->techniques[i]);
+            return D3D_OK;
+        }
+    }
+
+    *next_technique = NULL;
+    return S_FALSE;
 }
 
 static BOOL WINAPI ID3DXEffectImpl_IsParameterUsed(ID3DXEffect* iface, D3DXHANDLE parameter, D3DXHANDLE technique)
@@ -3363,7 +3397,12 @@ static HRESULT WINAPI ID3DXEffectImpl_CloneEffect(ID3DXEffect *iface,
 
     FIXME("(%p)->(%p, %p): stub\n", This, device, effect);
 
-    return E_NOTIMPL;
+    if (!effect)
+        return D3DXERR_INVALIDDATA;
+
+    iface->lpVtbl->AddRef(iface);
+    *effect = iface;
+    return S_OK;
 }
 
 static HRESULT WINAPI ID3DXEffectImpl_SetRawValue(ID3DXEffect *iface,
diff --git a/dlls/d3dx9_36/font.c b/dlls/d3dx9_36/font.c
index dd1243e..a65a8d5 100644
--- a/dlls/d3dx9_36/font.c
+++ b/dlls/d3dx9_36/font.c
@@ -36,8 +36,29 @@ struct d3dx_font
 
     HDC hdc;
     HFONT hfont;
+
+    UINT tex_width;
+    UINT tex_height;
+    IDirect3DTexture9 *texture;
+    HBITMAP bitmap;
+    BYTE *bits;
 };
 
+/* Returns the smallest power of 2 which is greater than or equal to num */
+static UINT make_pow2(UINT num)
+{
+    UINT result = 1;
+
+    /* In the unlikely event somebody passes a large value, make sure we don't enter an infinite loop */
+    if (num >= 0x80000000)
+        return 0x80000000;
+
+    while (result < num)
+        result <<= 1;
+
+    return result;
+}
+
 static inline struct d3dx_font *impl_from_ID3DXFont(ID3DXFont *iface)
 {
     return CONTAINING_RECORD(iface, struct d3dx_font, ID3DXFont_iface);
@@ -64,19 +85,26 @@ static HRESULT WINAPI ID3DXFontImpl_QueryInterface(ID3DXFont *iface, REFIID riid
 static ULONG WINAPI ID3DXFontImpl_AddRef(ID3DXFont *iface)
 {
     struct d3dx_font *This = impl_from_ID3DXFont(iface);
-    ULONG ref=InterlockedIncrement(&This->ref);
-    TRACE("%p increasing refcount to %u\n", iface, ref);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+    //    TRACE("%p increasing refcount to %u\n", iface, ref);
     return ref;
 }
 
 static ULONG WINAPI ID3DXFontImpl_Release(ID3DXFont *iface)
 {
     struct d3dx_font *This = impl_from_ID3DXFont(iface);
-    ULONG ref=InterlockedDecrement(&This->ref);
+    ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %u\n", iface, ref);
+//    TRACE("%p decreasing refcount to %u\n", iface, ref);
 
-    if(ref==0) {
+    if (!ref)
+    {
+        if (This->texture)
+        {
+            IDirect3DTexture9_Release(This->texture);
+            DeleteObject(This->bitmap);
+        }
         DeleteObject(This->hfont);
         DeleteDC(This->hdc);
         IDirect3DDevice9_Release(This->device);
@@ -179,17 +207,177 @@ static HRESULT WINAPI ID3DXFontImpl_PreloadTextW(ID3DXFont *iface, const WCHAR *
 static INT WINAPI ID3DXFontImpl_DrawTextA(ID3DXFont *iface, ID3DXSprite *sprite,
         const char *string, INT count, RECT *rect, DWORD format, D3DCOLOR color)
 {
-    FIXME("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x stub!\n",
+    LPWSTR stringW;
+    INT countW, ret = 0;
+
+    TRACE("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x\n",
             iface,  sprite, debugstr_a(string), count, wine_dbgstr_rect(rect), format, color);
-    return 1;
+
+    if (!string || count <= 0)
+        return 0;
+
+    countW = MultiByteToWideChar(CP_ACP, 0, string, count, NULL, 0);
+    stringW = HeapAlloc(GetProcessHeap(), 0, countW * sizeof(WCHAR));
+    if (stringW)
+    {
+        MultiByteToWideChar(CP_ACP, 0, string, count, stringW, countW);
+        ret = ID3DXFont_DrawTextW(iface, sprite, stringW, countW, rect, format, color);
+        HeapFree(GetProcessHeap(), 0, stringW);
+    }
+
+    return ret;
 }
 
 static INT WINAPI ID3DXFontImpl_DrawTextW(ID3DXFont *iface, ID3DXSprite *sprite,
         const WCHAR *string, INT count, RECT *rect, DWORD format, D3DCOLOR color)
 {
-    FIXME("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x stub!\n",
+    struct d3dx_font *This = impl_from_ID3DXFont(iface);
+    RECT calc_rect = *rect;
+    INT height;
+
+    TRACE("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x\n",
             iface,  sprite, debugstr_w(string), count, wine_dbgstr_rect(rect), format, color);
-    return 1;
+
+    if (!string || count <= 0)
+        return 0;
+
+    /* Strip terminating NULL characters */
+    while (count > 0 && !string[count-1])
+        count--;
+
+    height = DrawTextW(This->hdc, string, count, &calc_rect, format | DT_CALCRECT);
+
+    if (format & DT_CALCRECT)
+    {
+        *rect = calc_rect;
+        return height;
+    }
+
+    if (format & DT_CENTER)
+    {
+        UINT new_width = calc_rect.right - calc_rect.left;
+        calc_rect.left = (rect->right + rect->left - new_width) / 2;
+        calc_rect.right = calc_rect.left + new_width;
+    }
+
+    if (height && (calc_rect.left < calc_rect.right))
+    {
+        D3DLOCKED_RECT locked_rect;
+        D3DXVECTOR3 position;
+        UINT text_width, text_height;
+        RECT text_rect;
+        ID3DXSprite *target = sprite;
+        HRESULT hr;
+        int i, j;
+
+        /* Get rect position and dimensions */
+        position.x = calc_rect.left;
+        position.y = calc_rect.top;
+        position.z = 0;
+        text_width = calc_rect.right - calc_rect.left;
+        text_height = calc_rect.bottom - calc_rect.top;
+        text_rect.left = 0;
+        text_rect.top = 0;
+        text_rect.right = text_width;
+        text_rect.bottom = text_height;
+
+        /* We need to flush as it seems all draws in the begin/end sequence use only the latest updated texture */
+        if (sprite)
+            ID3DXSprite_Flush(sprite);
+
+        /* Extend texture and DIB section to contain text */
+        if ((text_width > This->tex_width) || (text_height > This->tex_height))
+        {
+            BITMAPINFOHEADER header;
+
+            if (text_width > This->tex_width)
+                This->tex_width = make_pow2(text_width);
+            if (text_height > This->tex_height)
+                This->tex_height = make_pow2(text_height);
+
+            if (This->texture)
+            {
+                IDirect3DTexture9_Release(This->texture);
+                DeleteObject(This->bitmap);
+            }
+
+            hr = D3DXCreateTexture(This->device, This->tex_width, This->tex_height, 1, 0,
+                                   D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &This->texture);
+            if (FAILED(hr))
+            {
+                This->texture = NULL;
+                return 0;
+            }
+
+            header.biSize = sizeof(header);
+            header.biWidth = This->tex_width;
+            header.biHeight = -This->tex_height;
+            header.biPlanes = 1;
+            header.biBitCount = 32;
+            header.biCompression = BI_RGB;
+            header.biSizeImage = sizeof(DWORD) * This->tex_width * This->tex_height;
+            header.biXPelsPerMeter = 0;
+            header.biYPelsPerMeter = 0;
+            header.biClrUsed = 0;
+            header.biClrImportant = 0;
+
+            This->bitmap = CreateDIBSection(This->hdc, (const BITMAPINFO*)&header,
+                                            DIB_RGB_COLORS, (void**)&This->bits, NULL, 0);
+            if (!This->bitmap)
+            {
+                IDirect3DTexture9_Release(This->texture);
+                This->texture = NULL;
+                return 0;
+            }
+
+            SelectObject(This->hdc, This->bitmap);
+        }
+
+        if (FAILED(IDirect3DTexture9_LockRect(This->texture, 0, &locked_rect, &text_rect, D3DLOCK_DISCARD)))
+            return 0;
+
+        /* Clear rect */
+        for (i = 0; i < text_height; i++)
+            memset(This->bits + i * This->tex_width * sizeof(DWORD), 0,
+                   text_width * sizeof(DWORD));
+
+        DrawTextW(This->hdc, string, count, &text_rect, format);
+
+        /* All RGB components are equal so take one as alpha and set RGB
+         * color to white, so it can be modulated with color parameter */
+        for (i = 0; i < text_height; i++)
+        {
+            DWORD *src = (DWORD *)This->bits + i * This->tex_width;
+            DWORD *dst = (DWORD *)((BYTE *)locked_rect.pBits + i * locked_rect.Pitch);
+            for (j = 0; j < text_width; j++)
+            {
+                *dst++ = (*src++ << 24) | 0xFFFFFF;
+            }
+        }
+
+        IDirect3DTexture9_UnlockRect(This->texture, 0);
+
+        if (!sprite)
+        {
+            hr = D3DXCreateSprite(This->device, &target);
+            if (FAILED(hr))
+                 return 0;
+            ID3DXSprite_Begin(target, 0);
+        }
+
+        hr = target->lpVtbl->Draw(target, This->texture, &text_rect, NULL, &position, color);
+
+        if (!sprite)
+        {
+            ID3DXSprite_End(target);
+            ID3DXSprite_Release(target);
+        }
+
+        if (FAILED(hr))
+            return 0;
+    }
+
+    return height;
 }
 
 static HRESULT WINAPI ID3DXFontImpl_OnLostDevice(ID3DXFont *iface)
@@ -303,46 +491,55 @@ HRESULT WINAPI D3DXCreateFontIndirectW(IDirect3DDevice9 *device, const D3DXFONT_
 
     TRACE("(%p, %p, %p)\n", device, desc, font);
 
-    if( !device || !desc || !font ) return D3DERR_INVALIDCALL;
+    if (!device || !desc || !font) return D3DERR_INVALIDCALL;
+
+    TRACE("desc: %d %d %d %d %d %d %d %d %d %s\n", desc->Height, desc->Width, desc->Weight, desc->MipLevels, desc->Italic,
+            desc->CharSet, desc->OutputPrecision, desc->Quality, desc->PitchAndFamily, debugstr_w(desc->FaceName));
 
-    /* the device MUST support D3DFMT_A8R8G8B8 */
+    /* The device MUST support D3DFMT_A8R8G8B8 */
     IDirect3DDevice9_GetDirect3D(device, &d3d);
     IDirect3DDevice9_GetCreationParameters(device, &cpars);
     IDirect3DDevice9_GetDisplayMode(device, 0, &mode);
     hr = IDirect3D9_CheckDeviceFormat(d3d, cpars.AdapterOrdinal, cpars.DeviceType, mode.Format, 0, D3DRTYPE_TEXTURE, D3DFMT_A8R8G8B8);
-    if(FAILED(hr)) {
+    if (FAILED(hr))
+    {
         IDirect3D9_Release(d3d);
         return D3DXERR_INVALIDDATA;
     }
     IDirect3D9_Release(d3d);
 
-    object = HeapAlloc(GetProcessHeap(), 0, sizeof(struct d3dx_font));
-    if(object==NULL) {
-        *font=NULL;
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct d3dx_font));
+    if (!object)
+    {
+        *font = NULL;
         return E_OUTOFMEMORY;
     }
     object->ID3DXFont_iface.lpVtbl = &D3DXFont_Vtbl;
-    object->ref=1;
-    object->device=device;
-    object->desc=*desc;
+    object->ref = 1;
+    object->device = device;
+    object->desc = *desc;
 
     object->hdc = CreateCompatibleDC(NULL);
-    if( !object->hdc ) {
+    if (!object->hdc)
+    {
         HeapFree(GetProcessHeap(), 0, object);
         return D3DXERR_INVALIDDATA;
     }
 
     object->hfont = CreateFontW(desc->Height, desc->Width, 0, 0, desc->Weight, desc->Italic, FALSE, FALSE, desc->CharSet,
                                 desc->OutputPrecision, CLIP_DEFAULT_PRECIS, desc->Quality, desc->PitchAndFamily, desc->FaceName);
-    if( !object->hfont ) {
+    if (!object->hfont)
+    {
         DeleteDC(object->hdc);
         HeapFree(GetProcessHeap(), 0, object);
         return D3DXERR_INVALIDDATA;
     }
     SelectObject(object->hdc, object->hfont);
+    SetTextColor(object->hdc, 0x00ffffff);
+    SetBkColor(object->hdc, 0x00000000);
 
     IDirect3DDevice9_AddRef(device);
-    *font=&object->ID3DXFont_iface;
+    *font = &object->ID3DXFont_iface;
 
     return D3D_OK;
 }
diff --git a/dlls/d3dx9_36/line.c b/dlls/d3dx9_36/line.c
index 5de44f4..2bdbe79 100644
--- a/dlls/d3dx9_36/line.c
+++ b/dlls/d3dx9_36/line.c
@@ -59,7 +59,7 @@ static ULONG WINAPI d3dx9_line_AddRef(ID3DXLine *iface)
     struct d3dx9_line *line = impl_from_ID3DXLine(iface);
     ULONG refcount = InterlockedIncrement(&line->ref);
 
-    TRACE("%p increasing refcount to %u.\n", line, refcount);
+//    TRACE("%p increasing refcount to %u.\n", line, refcount);
 
     return refcount;
 }
@@ -69,7 +69,7 @@ static ULONG WINAPI d3dx9_line_Release(ID3DXLine *iface)
     struct d3dx9_line *line = impl_from_ID3DXLine(iface);
     ULONG refcount = InterlockedDecrement(&line->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", line, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", line, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/d3dx9_36/mesh.c b/dlls/d3dx9_36/mesh.c
index 606a088..0d4c34f 100644
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -118,7 +118,7 @@ static ULONG WINAPI d3dx9_mesh_AddRef(ID3DXMesh *iface)
     struct d3dx9_mesh *mesh = impl_from_ID3DXMesh(iface);
     ULONG refcount = InterlockedIncrement(&mesh->ref);
 
-    TRACE("%p increasing refcount to %u.\n", mesh, refcount);
+//    TRACE("%p increasing refcount to %u.\n", mesh, refcount);
 
     return refcount;
 }
@@ -128,7 +128,7 @@ static ULONG WINAPI d3dx9_mesh_Release(ID3DXMesh *iface)
     struct d3dx9_mesh *mesh = impl_from_ID3DXMesh(iface);
     ULONG refcount = InterlockedDecrement(&mesh->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", mesh, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", mesh, refcount);
 
     if (!refcount)
     {
@@ -3334,6 +3334,13 @@ static HRESULT parse_mesh(ID3DXFileData *filedata, struct mesh_data *mesh_data,
         goto end;
     }
 
+    if ((provide_flags & PROVIDE_SKININFO) && !mesh_data->skin_info)
+    {
+        hr = create_dummy_skin(&mesh_data->skin_info);
+        if (FAILED(hr))
+            goto end;
+    }
+
     hr = D3D_OK;
 
 end:
@@ -3912,9 +3919,11 @@ HRESULT WINAPI D3DXLoadMeshHierarchyFromXInMemory(const void *memory, DWORD memo
 
     if (!memory || !memory_size || !device || !frame_hierarchy || !alloc_hier)
         return D3DERR_INVALIDCALL;
+    if (load_user_data || anim_controller) {
     if (load_user_data)
-    {
-        FIXME("Loading user data not implemented.\n");
+            FIXME("Loading user data not implemented\n");
+        if (anim_controller)
+            FIXME("Animation controller creation not implemented\n");
         return E_NOTIMPL;
     }
 
@@ -3984,12 +3993,6 @@ HRESULT WINAPI D3DXLoadMeshHierarchyFromXInMemory(const void *memory, DWORD memo
         hr = D3D_OK;
     }
 
-    if (anim_controller)
-    {
-        *anim_controller = NULL;
-        FIXME("Animation controller creation not implemented.\n");
-    }
-
 cleanup:
     if (FAILED(hr) && first_frame) D3DXFrameDestroy(first_frame, alloc_hier);
     if (filedata) filedata->lpVtbl->Release(filedata);
@@ -4048,6 +4051,12 @@ HRESULT WINAPI D3DXFrameDestroy(D3DXFRAME *frame, ID3DXAllocateHierarchy *alloc_
     return D3D_OK;
 }
 
+D3DXFRAME* WINAPI D3DXFrameFind(const D3DXFRAME *frame_root, const char *name)
+{
+    FIXME("frame_root %p, name %s stub.\n", frame_root, debugstr_a(name));
+    return NULL;
+}
+
 HRESULT WINAPI D3DXLoadMeshFromXA(const char *filename, DWORD options, struct IDirect3DDevice9 *device,
         struct ID3DXBuffer **adjacency, struct ID3DXBuffer **materials, struct ID3DXBuffer **effect_instances,
         DWORD *num_materials, struct ID3DXMesh **mesh)
@@ -5168,7 +5177,7 @@ HRESULT WINAPI D3DXCreateTeapot(struct IDirect3DDevice9 *device,
 {
     FIXME("(%p, %p, %p): stub\n", device, mesh, adjacency);
 
-    return E_NOTIMPL;
+    return D3DXCreateSphere(device, 1.0f, 4, 4, mesh, adjacency);
 }
 
 HRESULT WINAPI D3DXCreateTextA(struct IDirect3DDevice9 *device, HDC hdc, const char *text, float deviation,
@@ -5186,6 +5195,9 @@ HRESULT WINAPI D3DXCreateTextA(struct IDirect3DDevice9 *device, HDC hdc, const c
 
     len = MultiByteToWideChar(CP_ACP, 0, text, -1, NULL, 0);
     textW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+  if (!textW) {
+    return E_OUTOFMEMORY;
+  }
     MultiByteToWideChar(CP_ACP, 0, text, -1, textW, len);
 
     hr = D3DXCreateTextW(device, hdc, textW, deviation, extrusion,
@@ -7016,6 +7028,7 @@ HRESULT WINAPI D3DXWeldVertices(ID3DXMesh *mesh, DWORD flags, const D3DXWELDEPSI
     DWORD *point_reps = NULL;
     struct d3dx9_mesh *This = impl_from_ID3DXMesh(mesh);
     DWORD *vertex_face_map = NULL;
+    ID3DXBuffer *vertex_remap = NULL;
     BYTE *vertices = NULL;
 
     TRACE("mesh %p, flags %#x, epsilons %p, adjacency %p, adjacency_out %p, face_remap_out %p, vertex_remap_out %p.\n",
@@ -7182,6 +7195,7 @@ cleanup:
     HeapFree(GetProcessHeap(), 0, vertex_face_map);
     if (attributes) mesh->lpVtbl->UnlockAttributeBuffer(mesh);
     if (indices) mesh->lpVtbl->UnlockIndexBuffer(mesh);
+    if (vertex_remap) ID3DXBuffer_Release(vertex_remap);
     if (vertices) mesh->lpVtbl->UnlockVertexBuffer(mesh);
 
     return hr;
@@ -7530,6 +7544,18 @@ HRESULT WINAPI D3DXComputeNormals(struct ID3DXBaseMesh *mesh, const DWORD *adjac
 }
 
 /*************************************************************************
+ * D3DXComputeNormalMap    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeNormalMap(IDirect3DTexture9 *texture, IDirect3DTexture9 *src_texture,
+        const PALETTEENTRY *src_palette, DWORD flags, DWORD channel, FLOAT amplitude)
+{
+    FIXME("texture %p, src_texture %p, src_palette %p, flags %#x, channel %u, amplitude %f stub.\n",
+            texture, src_texture, src_palette, flags, channel, amplitude);
+
+    return D3D_OK;
+}
+
+/*************************************************************************
  * D3DXIntersect    (D3DX9_36.@)
  */
 HRESULT WINAPI D3DXIntersect(ID3DXBaseMesh *mesh, const D3DXVECTOR3 *ray_pos, const D3DXVECTOR3 *ray_dir,
diff --git a/dlls/d3dx9_36/render.c b/dlls/d3dx9_36/render.c
index cca6b44..0bf52b9 100644
--- a/dlls/d3dx9_36/render.c
+++ b/dlls/d3dx9_36/render.c
@@ -151,7 +151,7 @@ static ULONG WINAPI D3DXRenderToSurface_AddRef(ID3DXRenderToSurface *iface)
     struct render_to_surface *render = impl_from_ID3DXRenderToSurface(iface);
     ULONG ref = InterlockedIncrement(&render->ref);
 
-    TRACE("%p increasing refcount to %u\n", iface, ref);
+//    TRACE("%p increasing refcount to %u\n", iface, ref);
 
     return ref;
 }
@@ -161,7 +161,7 @@ static ULONG WINAPI D3DXRenderToSurface_Release(ID3DXRenderToSurface *iface)
     struct render_to_surface *render = impl_from_ID3DXRenderToSurface(iface);
     ULONG ref = InterlockedDecrement(&render->ref);
 
-    TRACE("%p decreasing refcount to %u\n", iface, ref);
+//    TRACE("%p decreasing refcount to %u\n", iface, ref);
 
     if (!ref)
     {
@@ -488,7 +488,7 @@ static ULONG WINAPI D3DXRenderToEnvMap_AddRef(ID3DXRenderToEnvMap *iface)
     struct render_to_envmap *render = impl_from_ID3DXRenderToEnvMap(iface);
     ULONG ref = InterlockedIncrement(&render->ref);
 
-    TRACE("%p increasing refcount to %u\n", iface, ref);
+//    TRACE("%p increasing refcount to %u\n", iface, ref);
 
     return ref;
 }
@@ -498,7 +498,7 @@ static ULONG WINAPI D3DXRenderToEnvMap_Release(ID3DXRenderToEnvMap *iface)
     struct render_to_envmap *render = impl_from_ID3DXRenderToEnvMap(iface);
     ULONG ref = InterlockedDecrement(&render->ref);
 
-    TRACE("%p decreasing refcount to %u\n", iface, ref);
+//    TRACE("%p decreasing refcount to %u\n", iface, ref);
 
     if (!ref)
     {
diff --git a/dlls/d3dx9_36/shader.c b/dlls/d3dx9_36/shader.c
index e9d893b..ba28d81 100644
--- a/dlls/d3dx9_36/shader.c
+++ b/dlls/d3dx9_36/shader.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2008 Luis Busquets
  * Copyright 2009 Matteo Bruni
+ * Copyright 2010, 2013 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -448,6 +449,41 @@ HRESULT WINAPI D3DXCompileShader(const char *data, UINT length, const D3DXMACRO
         }
     }
 
+    /* Filter out D3DCompile warning messages that are not present with D3DCompileShader */
+    if (SUCCEEDED(hr) && error_msgs && *error_msgs)
+    {
+        char *messages = ID3DXBuffer_GetBufferPointer(*error_msgs);
+        DWORD size     = ID3DXBuffer_GetBufferSize(*error_msgs);
+
+        /* Ensure messages are null terminated for safe processing */
+        if (size) messages[size - 1] = 0;
+
+        while (size > 1)
+        {
+            char *prev, *next;
+
+            /* Warning has the form "warning X3206: ... implicit truncation of vector type"
+               but we only search for "X3206:" in case d3dcompiler_43 has localization */
+            prev = next = strstr(messages, "X3206:");
+            if (!prev) break;
+
+            /* get pointer to beginning and end of current line */
+            while (prev > messages && *(prev - 1) != '\n') prev--;
+            while (next < messages + size - 1 && *next != '\n') next++;
+            if (next < messages + size - 1 && *next == '\n') next++;
+
+            memmove(prev, next, messages + size - next);
+            size -= (next - prev);
+        }
+
+        /* Only return a buffer if the resulting string is not empty as some apps depend on that */
+        if (size <= 1)
+        {
+            ID3DXBuffer_Release(*error_msgs);
+            *error_msgs = NULL;
+        }
+    }
+
     return hr;
 }
 
@@ -1979,8 +2015,17 @@ HRESULT WINAPI D3DXGetShaderConstantTableEx(const DWORD *byte_code, DWORD flags,
         return D3D_OK;
     }
 
-    if (flags) FIXME("Flags (%#x) are not handled, yet!\n", flags);
-
+    if (flags) {
+        FIXME("Flags (%#x) are not handled, yet!\n", flags);
+    //trace:d3dx:D3DXGetShaderConstantTableEx byte_code 0x2771c48, flags 20000, constant_table 0xc5d8a8a0
+    //fixme:d3dx:D3DXGetShaderConstantTableEx Flags (0x20000) are not handled, yet!
+    //#define D3DXCONSTTABLE_LARGEADDRESSAWARE          0x20000
+    /*  Use the D3DXCONSTTABLE_LARGEADDRESSAWARE flag to access up to 4 GB of virtual address space
+     *  (instead of the default of 2 GB). If you do not need the additional virtual address space, 
+     *  use D3DXGetShaderConstantTable.
+     */
+        return D3DERR_INVALIDCALL; //Slice
+    }
     hr = D3DXFindShaderComment(byte_code, MAKEFOURCC('C','T','A','B'), &data, &size);
     if (hr != D3D_OK)
     {
@@ -2151,3 +2196,112 @@ HRESULT WINAPI D3DXDisassembleShader(const DWORD *shader, BOOL colorcode, const
    FIXME("%p %d %s %p: stub\n", shader, colorcode, debugstr_a(comments), disassembly);
    return E_OUTOFMEMORY;
 }
+
+static const DWORD* skip_instruction(const DWORD *byte_code, UINT shader_model)
+{
+    TRACE("Shader model %u\n", shader_model);
+
+    /* Handle all special instructions whose arguments may contain D3DSIO_DCL */
+    if ((*byte_code & D3DSI_OPCODE_MASK) == D3DSIO_COMMENT)
+    {
+        byte_code += 1 + ((*byte_code & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
+    }
+    else if (shader_model >= 2)
+    {
+        byte_code += 1 + ((*byte_code & D3DSI_INSTLENGTH_MASK) >> D3DSI_INSTLENGTH_SHIFT);
+    }
+    else if ((*byte_code & D3DSI_OPCODE_MASK) == D3DSIO_DEF)
+    {
+        byte_code += 1 + 5;
+    }
+    else
+    {
+        /* Handle remaining safe instructions */
+        while (*++byte_code & (1 << 31));
+    }
+
+    return byte_code;
+}
+
+static UINT get_shader_semantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, DWORD type)
+{
+    const DWORD *ptr = byte_code;
+    UINT shader_model = (*ptr >> 8) & 0xff;
+    UINT i = 0;
+
+    TRACE("Shader version: %#x\n", *ptr);
+    ptr++;
+
+    while (*ptr != D3DSIO_END)
+    {
+        if (*ptr & (1 << 31))
+        {
+            FIXME("Opcode expected but got %#x\n", *ptr);
+            return 0;
+        }
+        else if ((*ptr & D3DSI_OPCODE_MASK) == D3DSIO_DCL)
+        {
+            DWORD param1 = *++ptr;
+            DWORD param2 = *++ptr;
+            DWORD usage = param1 & 0x1f;
+            DWORD usage_index = (param1 >> 16) & 0xf;
+            DWORD reg_type = (((param2 >> 11) & 0x3) << 3) | ((param2 >> 28) & 0x7);
+
+            TRACE("D3DSIO_DCL param1: %#x, param2: %#x, usage: %u, usage_index: %u, reg_type: %u\n",
+                   param1, param2, usage, usage_index, reg_type);
+
+            if (reg_type == type)
+            {
+                if (semantics)
+                {
+                    semantics[i].Usage = usage;
+                    semantics[i].UsageIndex = usage_index;
+                }
+                i++;
+            }
+
+            ptr++;
+        }
+        else
+        {
+            ptr = skip_instruction(ptr, shader_model);
+        }
+    }
+
+    return i;
+}
+
+HRESULT WINAPI D3DXGetShaderInputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count)
+{
+    UINT nb_semantics;
+
+    TRACE("byte_code %p, semantics %p, count %p\n", byte_code, semantics, count);
+
+    if (!byte_code)
+        return D3DERR_INVALIDCALL;
+
+    nb_semantics = get_shader_semantics(byte_code, semantics, D3DSPR_INPUT);
+
+    if (count)
+        *count = nb_semantics;
+
+    return D3D_OK;
+}
+
+
+HRESULT WINAPI D3DXGetShaderOutputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count)
+{
+    UINT nb_semantics;
+
+    TRACE("byte_code %p, semantics %p, count %p\n", byte_code, semantics, count);
+
+    if (!byte_code)
+        return D3DERR_INVALIDCALL;
+
+    nb_semantics = get_shader_semantics(byte_code, semantics, D3DSPR_OUTPUT);
+
+    if (count)
+        *count = nb_semantics;
+
+    return D3D_OK;
+}
diff --git a/dlls/d3dx9_36/skin.c b/dlls/d3dx9_36/skin.c
index 9b93af6..3364ac3 100644
--- a/dlls/d3dx9_36/skin.c
+++ b/dlls/d3dx9_36/skin.c
@@ -2,6 +2,7 @@
  * Skin Info operations specific to D3DX9.
  *
  * Copyright (C) 2011 Dylan Smith
+ * Copyright (C) 2013 Christian Costa
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -70,7 +71,7 @@ static ULONG WINAPI d3dx9_skin_info_AddRef(ID3DXSkinInfo *iface)
     struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
     ULONG refcount = InterlockedIncrement(&skin->ref);
 
-    TRACE("%p increasing refcount to %u.\n", skin, refcount);
+//    TRACE("%p increasing refcount to %u.\n", skin, refcount);
 
     return refcount;
 }
@@ -80,7 +81,7 @@ static ULONG WINAPI d3dx9_skin_info_Release(ID3DXSkinInfo *iface)
     struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
     ULONG refcount = InterlockedDecrement(&skin->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", skin, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", skin, refcount);
 
     if (!refcount)
     {
@@ -92,7 +93,7 @@ static ULONG WINAPI d3dx9_skin_info_Release(ID3DXSkinInfo *iface)
             HeapFree(GetProcessHeap(), 0, skin->bones[i].vertices);
             HeapFree(GetProcessHeap(), 0, skin->bones[i].weights);
         }
-        HeapFree(GetProcessHeap(), 0, skin->bones);
+        if (skin->bones) HeapFree(GetProcessHeap(), 0, skin->bones);
         HeapFree(GetProcessHeap(), 0, skin);
     }
 
@@ -375,10 +376,89 @@ static HRESULT WINAPI d3dx9_skin_info_GetDeclaration(ID3DXSkinInfo *iface,
 static HRESULT WINAPI d3dx9_skin_info_UpdateSkinnedMesh(ID3DXSkinInfo *iface, const D3DXMATRIX *bone_transforms,
         const D3DXMATRIX *bone_inv_transpose_transforms, const void *src_vertices, void *dst_vertices)
 {
-    FIXME("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p stub!\n",
-            iface, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+    struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
+    DWORD size = D3DXGetFVFVertexSize(skin->fvf);
+    DWORD i, j;
 
-    return E_NOTIMPL;
+    TRACE("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p\n",
+            skin, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+
+    if (bone_inv_transpose_transforms)
+        FIXME("Skinning vertices with two position elements not supported\n");
+
+    if ((skin->fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZ) {
+        FIXME("Vertex type %#x not supported\n", skin->fvf & D3DFVF_POSITION_MASK);
+        return E_FAIL;
+    }
+
+    /* Reset all positions */
+    for (i = 0; i < skin->num_vertices; i++) {
+        D3DXVECTOR3 *position = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i);
+        position->x = 0.0f;
+        position->y = 0.0f;
+        position->z = 0.0f;
+    }
+
+    /* Update positions that are influenced by bones */
+    for (i = 0; i < skin->num_bones; i++) {
+        D3DXMATRIX bone_inverse, matrix;
+
+        D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+        D3DXMatrixMultiply(&matrix, &bone_transforms[i], &bone_inverse);
+        D3DXMatrixMultiply(&matrix, &matrix, &skin->bones[i].transform);
+
+        for (j = 0; j < skin->bones[i].num_influences; j++) {
+            D3DXVECTOR3 position;
+            D3DXVECTOR3 *position_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j]);
+            D3DXVECTOR3 *position_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j]);
+            FLOAT weight = skin->bones[i].weights[j];
+
+            D3DXVec3TransformCoord(&position, position_src, &matrix);
+            position_dest->x += weight * position.x;
+            position_dest->y += weight * position.y;
+            position_dest->z += weight * position.z;
+        }
+    }
+
+    if (skin->fvf & D3DFVF_NORMAL) {
+        /* Reset all normals */
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i + sizeof(D3DXVECTOR3));
+            normal->x = 0.0f;
+            normal->y = 0.0f;
+            normal->z = 0.0f;
+        }
+
+        /* Update normals that are influenced by bones */
+        for (i = 0; i < skin->num_bones; i++) {
+            D3DXMATRIX bone_inverse, matrix;
+
+            D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+            D3DXMatrixMultiply(&matrix, &skin->bones[i].transform, &bone_transforms[i]);
+
+            for (j = 0; j < skin->bones[i].num_influences; j++) {
+                D3DXVECTOR3 normal;
+                D3DXVECTOR3 *normal_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                FLOAT weight = skin->bones[i].weights[j];
+
+                D3DXVec3TransformNormal(&normal, normal_src, &bone_inverse);
+                D3DXVec3TransformNormal(&normal, &normal, &matrix);
+                normal_dest->x += weight * normal.x;
+                normal_dest->y += weight * normal.y;
+                normal_dest->z += weight * normal.z;
+            }
+        }
+
+        /* Normalize all normals that are influenced by bones*/
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + (i * size) + sizeof(D3DXVECTOR3));
+            if ((normal_dest->x != 0.0f) && (normal_dest->y != 0.0f) && (normal_dest->z != 0.0f))
+                D3DXVec3Normalize(normal_dest, normal_dest);
+        }
+    }
+
+    return D3D_OK;
 }
 
 static HRESULT WINAPI d3dx9_skin_info_ConvertToBlendedMesh(ID3DXSkinInfo *iface, ID3DXMesh *mesh_in,
@@ -493,3 +573,23 @@ HRESULT WINAPI D3DXCreateSkinInfoFVF(DWORD num_vertices, DWORD fvf, DWORD num_bo
 
     return D3DXCreateSkinInfo(num_vertices, declaration, num_bones, skin_info);
 }
+
+HRESULT create_dummy_skin(ID3DXSkinInfo **iface)
+{
+    static const D3DVERTEXELEMENT9 empty_declaration = D3DDECL_END();
+    struct d3dx9_skin_info *object = NULL;
+
+    object = HeapAlloc(GetProcessHeap(), 0, sizeof(*object));
+    if (!object) return E_OUTOFMEMORY;
+
+    object->ID3DXSkinInfo_iface.lpVtbl = &d3dx9_skin_info_vtbl;
+    object->ref = 1;
+    object->num_vertices = 0;
+    object->num_bones = 0;
+    object->vertex_declaration[0] = empty_declaration;
+    object->fvf = 0;
+    object->bones = NULL;
+
+    *iface = &object->ID3DXSkinInfo_iface;
+    return D3D_OK;
+}
diff --git a/dlls/d3dx9_36/sprite.c b/dlls/d3dx9_36/sprite.c
index 8fbabc3..4878ec9 100644
--- a/dlls/d3dx9_36/sprite.c
+++ b/dlls/d3dx9_36/sprite.c
@@ -94,7 +94,7 @@ static ULONG WINAPI d3dx9_sprite_AddRef(ID3DXSprite *iface)
     struct d3dx9_sprite *sprite = impl_from_ID3DXSprite(iface);
     ULONG refcount = InterlockedIncrement(&sprite->ref);
 
-    TRACE("%p increasing refcount to %u.\n", sprite, refcount);
+//    TRACE("%p increasing refcount to %u.\n", sprite, refcount);
 
     return refcount;
 }
@@ -104,7 +104,7 @@ static ULONG WINAPI d3dx9_sprite_Release(ID3DXSprite *iface)
     struct d3dx9_sprite *sprite = impl_from_ID3DXSprite(iface);
     ULONG refcount = InterlockedDecrement(&sprite->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", sprite, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", sprite, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/d3dx9_36/surface.c b/dlls/d3dx9_36/surface.c
index b8bb710..ecb4d9a 100644
--- a/dlls/d3dx9_36/surface.c
+++ b/dlls/d3dx9_36/surface.c
@@ -18,6 +18,7 @@
  *
  */
 
+#include "config.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
 #include "d3dx9_36_private.h"
@@ -26,6 +27,9 @@
 #include "ole2.h"
 #include "wincodec.h"
 
+#include "wine/wined3d.h"
+#include "d3d9-dxtn.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
 
@@ -88,6 +92,7 @@ static const GUID *d3dformat_to_wic_guid(D3DFORMAT format)
 #define DDS_CAPS_COMPLEX 0x8
 #define DDS_CAPS_TEXTURE 0x1000
 #define DDS_CAPS_MIPMAP 0x400000
+#define DDS_SURFACE_FLAGS_CUBEMAP 0x00000008 // DDS_CAPS_COMPLEX
 
 /* dds_header.caps2 */
 #define DDS_CAPS2_CUBEMAP 0x200
@@ -125,22 +130,47 @@ struct dds_pixel_format
 
 struct dds_header
 {
-    DWORD signature;
-    DWORD size;
-    DWORD flags;
-    DWORD height;
-    DWORD width;
-    DWORD pitch_or_linear_size;
-    DWORD depth;
-    DWORD miplevels;
+    DWORD signature;  //44 44 53 20  = "DDS "
+    DWORD size;       //7C 00 00 00  = 124
+    DWORD flags;      //07 10 08 00 = 00081007 = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PIXELFORMAT | DDS_LINEARSIZE
+    DWORD height;     //00 01 00 00  = 256
+    DWORD width;      //00 01 00 00 
+    DWORD pitch_or_linear_size; //00 04 00 00 = 1024
+    DWORD depth;      //00 00 00 00
+    DWORD miplevels;  //00 00 00 00 
     DWORD reserved[11];
-    struct dds_pixel_format pixel_format;
-    DWORD caps;
-    DWORD caps2;
+    struct dds_pixel_format pixel_format; //SIZE=32 FLAGS=DDS_PF_FOURCC 'DXT5' 
+    DWORD caps; //dwSurfaceFlags  //00 10 00 00 = DDS_CAPS_TEXTURE
+    DWORD caps2; //dwCubemapFlags = 0
     DWORD caps3;
     DWORD caps4;
     DWORD reserved2;
 };
+/*
+Volume DDS DX5 miplevels
+ 44 44 53 20 = DDS
+ 7C 00 00 00 = 124
+ 07 10 82 00 = 821007 = DDS_DEPTH | DDS_MIPMAPCOUNT | DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PIXELFORMAT
+ 00 01 00 00 = 256
+ 00 01 00 00 = 256
+ 00 00 00 00 = pitch = 0
+ 08 00 00 00 = depth = 8
+ 09 00 00 00 = miplevels = 9
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 
+ Pixel_format
+ 20 00 00 00 size  = 32
+ 04 00 00 00 flags = DDS_PF_FOURCC
+ 44 58 54 35 DXT5
+ 00 00 00 00 bpp = 0
+ 00 00 00 00 r,g,b mask = 0
+ 00 00 00 00 00 00 00 00 00 00 00 00 
+ 
+ 08 10 40 00 caps = 401008 = DDS_CAPS_COMPLEX | DDS_CAPS_TEXTURE | DDS_CAPS_MIPMAP
+ 00 00 20 00 caps2 = DDS_CAPS2_VOLUME
+ 00 00 00 00 00 00 00 00 00 00 00 00
+ */
 
 static D3DFORMAT dds_fourcc_to_d3dformat(DWORD fourcc)
 {
@@ -311,6 +341,14 @@ static HRESULT d3dformat_to_dds_pixel_format(struct dds_pixel_format *pixel_form
         }
     }
 
+    /* Reuse dds_fourcc_to_d3dformat as D3DFORMAT and FOURCC are DWORD with same values */
+    if (dds_fourcc_to_d3dformat(d3dformat) != D3DFMT_UNKNOWN)
+    {
+        pixel_format->flags |= DDS_PF_FOURCC;
+        pixel_format->fourcc = d3dformat;
+        return D3D_OK;
+    }
+
     WARN("Unknown pixel format %#x\n", d3dformat);
     return E_NOTIMPL;
 }
@@ -322,19 +360,11 @@ static HRESULT calculate_dds_surface_size(D3DFORMAT format, UINT width, UINT hei
     if (format_desc->type == FORMAT_UNKNOWN)
         return E_NOTIMPL;
 
-    if (format_desc->block_width != 1 || format_desc->block_height != 1)
-    {
         *pitch = format_desc->block_byte_count
             * max(1, (width + format_desc->block_width - 1) / format_desc->block_width);
         *size = *pitch
             * max(1, (height + format_desc->block_height - 1) / format_desc->block_height);
-    }
-    else
-    {
-        *pitch = width * format_desc->bytes_per_pixel;
-        *size = *pitch * height;
-    }
-
+    TRACE("return pitch=%d size=%d\n", *pitch, *size);
     return D3D_OK;
 }
 
@@ -389,8 +419,8 @@ static HRESULT get_image_info_from_dds(const void *buffer, UINT length, D3DXIMAG
 
     info->Width = header->width;
     info->Height = header->height;
-    info->Depth = 1;
-    info->MipLevels = header->miplevels ? header->miplevels : 1;
+    info->Depth = header->depth ? header->depth: 1;
+    info->MipLevels = (header->flags & DDS_MIPMAPCOUNT) ?  header->miplevels : 1;
 
     info->Format = dds_pixel_format_to_d3dformat(&header->pixel_format);
     if (info->Format == D3DFMT_UNKNOWN)
@@ -475,7 +505,7 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     if (pixel_format->type == FORMAT_UNKNOWN) return E_NOTIMPL;
 
     file_size = calculate_dds_file_size(src_desc.Format, src_desc.Width, src_desc.Height, 1, 1, 1);
-
+    TRACE("format %#x file_size=%d\n", src_desc.Format, file_size);
     hr = calculate_dds_surface_size(src_desc.Format, src_desc.Width, src_desc.Height, &dst_pitch, &surface_size);
     if (FAILED(hr)) return hr;
 
@@ -487,13 +517,14 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
 
     memset(header, 0, sizeof(*header));
     header->signature = MAKEFOURCC('D','D','S',' ');
-    header->size = sizeof(*header);
-    header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PITCH | DDS_PIXELFORMAT | DDS_MIPMAPCOUNT;
+    /* The signature is not really part of the DDS header */
+    header->size = sizeof(*header) - sizeof(header->signature);
+    header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PIXELFORMAT;
+    /* Note that native does not set DDS_LINEARSIZE flag nor pitch_or_linear_size field for DXTn */
+    header->flags |= (pixel_format->block_width != 1) || (pixel_format->block_height != 1) ? DDS_LINEARSIZE : DDS_PITCH;
     header->height = src_desc.Height;
     header->width = src_desc.Width;
     header->pitch_or_linear_size = dst_pitch;
-    header->depth = 1;
-    header->miplevels = 1;
     header->caps = DDS_CAPS_TEXTURE;
     hr = d3dformat_to_dds_pixel_format(&header->pixel_format, src_desc.Format);
     if (FAILED(hr))
@@ -521,7 +552,203 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     return D3D_OK;
 }
 
-HRESULT load_volume_from_dds(IDirect3DVolume9 *dst_volume, const PALETTEENTRY *dst_palette,
+HRESULT save_dds_volume_to_memory(ID3DXBuffer **dst_buffer, struct IDirect3DVolume9 *src_volume, UINT levels, const D3DBOX *src_box)
+{
+    HRESULT hr;
+    UINT dst_pitch, slice_size, file_size;
+    D3DVOLUME_DESC src_desc;
+    D3DLOCKED_BOX locked_box;
+    ID3DXBuffer *buffer;
+    struct dds_header *header;
+    BYTE *pixels;
+    struct volume volume;
+    const struct pixel_format_desc *pixel_format;
+
+    if (src_box)
+    {
+        FIXME("Saving a part of a volume to a DDS file is not implemented yet\n");
+        return E_NOTIMPL;
+    }
+
+    hr = IDirect3DVolume9_GetDesc(src_volume, &src_desc);
+    if (FAILED(hr)) return hr;
+
+    pixel_format = get_format_info(src_desc.Format);
+    if (pixel_format->type == FORMAT_UNKNOWN) return E_NOTIMPL;
+
+    file_size = calculate_dds_file_size(src_desc.Format, src_desc.Width, src_desc.Height, src_desc.Depth, levels, 1);
+    TRACE("format %#x file_size=%d\n", src_desc.Format, file_size);
+    hr = calculate_dds_surface_size(src_desc.Format, src_desc.Width, src_desc.Height, &dst_pitch, &slice_size);
+    if (FAILED(hr)) return hr;
+
+    hr = D3DXCreateBuffer(file_size, &buffer);
+    if (FAILED(hr)) return hr;
+
+    header = ID3DXBuffer_GetBufferPointer(buffer);
+    pixels = (BYTE *)(header + 1);
+
+    memset(header, 0, sizeof(*header));
+    header->signature = MAKEFOURCC('D','D','S',' ');
+    /* The signature is not really part of the DDS header */
+    header->size = sizeof(*header) - sizeof(header->signature);
+    header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_DEPTH | DDS_PIXELFORMAT | DDS_MIPMAPCOUNT;
+    /* Note that native does not set DDS_LINEARSIZE flag nor pitch_or_linear_size field for DXTn */
+    header->flags |= (pixel_format->block_width != 1) || (pixel_format->block_height != 1) ? DDS_LINEARSIZE : DDS_PITCH;
+    header->height = src_desc.Height;
+    header->width = src_desc.Width;
+    header->depth = src_desc.Depth;
+    header->miplevels = levels;
+    header->pitch_or_linear_size = dst_pitch;
+    header->caps = DDS_CAPS_TEXTURE;
+    header->caps2 = DDS_CAPS2_VOLUME;
+    hr = d3dformat_to_dds_pixel_format(&header->pixel_format, src_desc.Format);
+    if (FAILED(hr))
+    {
+        ID3DXBuffer_Release(buffer);
+        return hr;
+    }
+
+    hr = IDirect3DVolume9_LockBox(src_volume, &locked_box, NULL, D3DLOCK_READONLY);
+    if (FAILED(hr))
+    {
+        ID3DXBuffer_Release(buffer);
+        return hr;
+    }
+
+    volume.width = src_desc.Width;
+    volume.height = src_desc.Height;
+    volume.depth = src_desc.Depth;
+    copy_pixels(locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, pixels, dst_pitch, slice_size,
+                &volume, pixel_format);
+    
+    IDirect3DVolume9_UnlockBox(src_volume);
+    
+    *dst_buffer = buffer;
+    return D3D_OK;
+}
+
+static HRESULT get_surface(D3DRESOURCETYPE type, struct IDirect3DBaseTexture9 *tex,
+        int face, UINT level, struct IDirect3DSurface9 **surf)
+{
+    switch (type)
+    {
+        case D3DRTYPE_TEXTURE:
+            return IDirect3DTexture9_GetSurfaceLevel((IDirect3DTexture9*) tex, level, surf);
+        case D3DRTYPE_CUBETEXTURE:
+            return IDirect3DCubeTexture9_GetCubeMapSurface((IDirect3DCubeTexture9*) tex, face, level, surf);
+        default:
+            ERR("Unexpected texture type\n");
+            return E_NOTIMPL;
+    }
+}
+
+HRESULT save_dds_texture_to_memory(ID3DXBuffer **dst_buffer, IDirect3DBaseTexture9 *src_texture, const PALETTEENTRY *src_palette)
+{
+    HRESULT hr = D3DERR_INVALIDCALL;
+    D3DRESOURCETYPE type;
+    UINT mip_level;
+    UINT mip_levels;
+    UINT src_slice_pitch;
+    UINT src_row_pitch;
+    D3DVOLUME_DESC vol_desc;
+    UINT file_size;
+    IDirect3DSurface9 *surface = NULL;
+    IDirect3DVolume9 *volume = NULL;
+    struct volume volume_box;
+    D3DLOCKED_BOX locked_box;
+    ID3DXBuffer *buffer;
+    struct dds_header *header;
+    BYTE *pixels = NULL;
+    const struct pixel_format_desc *pixel_format = NULL;
+
+    type = IDirect3DBaseTexture9_GetType(src_texture);
+
+    if ((type !=  D3DRTYPE_TEXTURE) && (type != D3DRTYPE_CUBETEXTURE) && (type != D3DRTYPE_VOLUMETEXTURE))
+        return D3DERR_INVALIDCALL;
+
+    mip_levels = IDirect3DTexture9_GetLevelCount(src_texture);
+
+    if (src_palette)
+    {
+        FIXME("Saving surfaces with palettized pixel formats not implemented yet\n");
+        return E_NOTIMPL;
+    }
+
+    if (type == D3DRTYPE_VOLUMETEXTURE)
+    {
+        for (mip_level = 0; mip_level < mip_levels; mip_level++)
+        {
+            hr = IDirect3DVolumeTexture9_GetVolumeLevel((IDirect3DVolumeTexture9*)src_texture, mip_level, &volume);
+            if (FAILED(hr)) break;
+
+            hr = IDirect3DVolume9_GetDesc(volume, &vol_desc);
+            if (FAILED(hr)) return hr;
+            if (!mip_level) {
+                pixel_format = get_format_info(vol_desc.Format);
+                file_size = calculate_dds_file_size(vol_desc.Format, vol_desc.Width, vol_desc.Height, vol_desc.Depth, mip_levels, 1);
+                hr = D3DXCreateBuffer(file_size, &buffer);
+                if (FAILED(hr)) return hr;
+                header = ID3DXBuffer_GetBufferPointer(buffer);
+                pixels = (BYTE *)(header + 1);
+
+                memset(header, 0, sizeof(*header));
+                header->signature = MAKEFOURCC('D','D','S',' ');
+                /* The signature is not really part of the DDS header */
+                header->size = sizeof(*header) - sizeof(header->signature);
+                header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_DEPTH | DDS_PIXELFORMAT | DDS_MIPMAPCOUNT;
+
+                //header->flags |= (pixel_format->block_width != 1) || (pixel_format->block_height != 1) ? DDS_LINEARSIZE : DDS_PITCH;
+                header->height = vol_desc.Height;
+                header->width = vol_desc.Width;
+                header->depth = vol_desc.Depth;
+                header->miplevels = mip_levels;
+                header->pitch_or_linear_size = 0; //file_size;
+                header->caps = DDS_CAPS_COMPLEX | DDS_CAPS_TEXTURE | DDS_CAPS_MIPMAP;
+                header->caps2 = DDS_CAPS2_VOLUME;
+                hr = d3dformat_to_dds_pixel_format(&header->pixel_format, vol_desc.Format);
+                if (FAILED(hr))
+                {
+                    ID3DXBuffer_Release(buffer);
+                    return hr;
+                }
+            }
+            TRACE("format=%#x W=%d H=%d D=%d\n", vol_desc.Format, vol_desc.Width, vol_desc.Height, vol_desc.Depth);
+            hr = calculate_dds_surface_size(vol_desc.Format, vol_desc.Width, vol_desc.Height, &src_row_pitch, &src_slice_pitch);
+            hr = IDirect3DVolume9_LockBox(volume, &locked_box, NULL, D3DLOCK_READONLY);
+            if (FAILED(hr))
+            {
+                ID3DXBuffer_Release(buffer);
+                return hr;
+            }
+
+            volume_box.width = vol_desc.Width;
+            volume_box.height = vol_desc.Height;
+            volume_box.depth = vol_desc.Depth;
+            TRACE("locked.pBits %p RowP=%d SlP=%d\n", locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch);
+            copy_pixels(locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch,
+                        pixels, src_row_pitch, src_slice_pitch,
+                        &volume_box, pixel_format);
+            //       TRACE("pixels %p\n", pixels);
+            pixels += src_slice_pitch * vol_desc.Depth;
+
+            IDirect3DVolume9_UnlockBox(volume);
+            IDirect3DVolume9_Release(volume);
+        }
+        *dst_buffer = buffer;
+    }
+    else
+    {
+        hr = get_surface(type, src_texture, D3DCUBEMAP_FACE_POSITIVE_X, 0, &surface);
+
+        if (SUCCEEDED(hr))
+        {
+            hr = save_dds_surface_to_memory(dst_buffer, surface, NULL);
+            IDirect3DSurface9_Release(surface);
+        }
+    }
+    return hr;
+}
+HRESULT load_volume_from_dds(struct IDirect3DVolume9 *dst_volume, const PALETTEENTRY *dst_palette,
     const D3DBOX *dst_box, const void *src_data, const D3DBOX *src_box, DWORD filter, D3DCOLOR color_key,
     const D3DXIMAGE_INFO *src_info)
 {
@@ -1397,7 +1624,8 @@ static void get_relevant_argb_components(const struct argb_conversion_info *info
  * Recombines the output of get_relevant_argb_components and converts
  * it to the destination format.
  */
-static DWORD make_argb_color(const struct argb_conversion_info *info, const DWORD *in)
+//Slice - there must be dithering
+static DWORD make_argb_color(const struct argb_conversion_info *info, const DWORD *in, BOOL dither)
 {
     UINT i;
     DWORD val = 0;
@@ -1502,8 +1730,21 @@ void copy_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch,
     UINT row, slice;
     BYTE *dst_addr;
     const BYTE *src_addr;
-    UINT row_block_count = (size->width + format->block_width - 1) / format->block_width;
-    UINT row_count = (size->height + format->block_height - 1) / format->block_height;
+    UINT row_block_count, row_count;
+    if (!format || !format->block_width || !format->block_height) {
+        if (format) {
+            ERR("block undefined for the format %#x\n", format->format);
+        } else {
+            ERR("no format\n");
+        }        
+        return;
+    }
+    if (!size) {
+        ERR("invalid call\n");
+        return;
+    }
+    row_block_count = (size->width + format->block_width - 1) / format->block_width;
+    row_count = (size->height + format->block_height - 1) / format->block_height;
 
     for (slice = 0; slice < size->depth; slice++)
     {
@@ -1526,11 +1767,12 @@ void copy_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch,
  * any necessary format conversion and color keying.
  * Pixels outsize the source rect are blacked out.
  * Works only for ARGB formats with 1 - 4 bytes per pixel.
+ * Slice - there must be dithering while converting from 16 bit to 32 bit
  */
 void convert_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch, const struct volume *src_size,
         const struct pixel_format_desc *src_format, BYTE *dst, UINT dst_row_pitch, UINT dst_slice_pitch,
         const struct volume *dst_size, const struct pixel_format_desc *dst_format, D3DCOLOR color_key,
-        const PALETTEENTRY *palette)
+        const PALETTEENTRY *palette, BOOL dither)
 {
     struct argb_conversion_info conv_info, ck_conv_info;
     const struct pixel_format_desc *ck_format = NULL;
@@ -1567,14 +1809,14 @@ void convert_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pit
                     DWORD val;
 
                     get_relevant_argb_components(&conv_info, src_ptr, channels);
-                    val = make_argb_color(&conv_info, channels);
+                    val = make_argb_color(&conv_info, channels, dither);
 
                     if (color_key)
                     {
                         DWORD ck_pixel;
 
                         get_relevant_argb_components(&ck_conv_info, src_ptr, channels);
-                        ck_pixel = make_argb_color(&ck_conv_info, channels);
+                        ck_pixel = make_argb_color(&ck_conv_info, channels, dither);
                         if (ck_pixel == color_key)
                             val &= ~conv_info.destmask[0];
                     }
@@ -1629,27 +1871,29 @@ void convert_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pit
  * any necessary format conversion, color keying and stretching
  * using a point filter.
  * Works only for ARGB formats with 1 - 4 bytes per pixel.
+ *
  */
+//Slice - speed up the filter taking into account that there is only D3DFMT_A8R8G8B8
 void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch, const struct volume *src_size,
         const struct pixel_format_desc *src_format, BYTE *dst, UINT dst_row_pitch, UINT dst_slice_pitch,
         const struct volume *dst_size, const struct pixel_format_desc *dst_format, D3DCOLOR color_key,
         const PALETTEENTRY *palette)
 {
-    struct argb_conversion_info conv_info, ck_conv_info;
+/*    struct argb_conversion_info conv_info, ck_conv_info;
     const struct pixel_format_desc *ck_format = NULL;
-    DWORD channels[4];
+    DWORD channels[4]; */
     UINT x, y, z;
 
-    ZeroMemory(channels, sizeof(channels));
+/*    ZeroMemory(channels, sizeof(channels));
     init_argb_conversion_info(src_format, dst_format, &conv_info);
 
     if (color_key)
-    {
+    { */
         /* Color keys are always represented in D3DFMT_A8R8G8B8 format. */
-        ck_format = get_format_info(D3DFMT_A8R8G8B8);
+/*        ck_format = get_format_info(D3DFMT_A8R8G8B8);
         init_argb_conversion_info(src_format, ck_format, &ck_conv_info);
     }
-
+*/
     for (z = 0; z < dst_size->depth; z++)
     {
         BYTE *dst_slice_ptr = dst + z * dst_slice_pitch;
@@ -1664,20 +1908,22 @@ void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slic
             {
                 const BYTE *src_ptr = src_row_ptr + (x * src_size->width / dst_size->width) * src_format->bytes_per_pixel;
 
-                if (!src_format->to_rgba && !dst_format->from_rgba
+                //*((DWORD*)dst_ptr)++ = *(DWORD*)src_ptr;
+                memcpy(dst_ptr, src_ptr, dst_format->bytes_per_pixel);
+  /*              if (!src_format->to_rgba && !dst_format->from_rgba
                         && src_format->bytes_per_pixel <= 4 && dst_format->bytes_per_pixel <= 4)
                 {
                     DWORD val;
 
                     get_relevant_argb_components(&conv_info, src_ptr, channels);
-                    val = make_argb_color(&conv_info, channels);
+                    val = make_argb_color(&conv_info, channels, dither);
 
                     if (color_key)
                     {
                         DWORD ck_pixel;
 
                         get_relevant_argb_components(&ck_conv_info, src_ptr, channels);
-                        ck_pixel = make_argb_color(&ck_conv_info, channels);
+                        ck_pixel = make_argb_color(&ck_conv_info, channels, dither);
                         if (ck_pixel == color_key)
                             val &= ~conv_info.destmask[0];
                     }
@@ -1709,6 +1955,72 @@ void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slic
 
                     format_from_vec4(dst_format, &color, dst_ptr);
                 }
+*/
+                dst_ptr += dst_format->bytes_per_pixel;
+            }
+        }
+    }
+}
+
+typedef struct PIXEL {
+    BYTE b, g, r, a;
+} PIXEL;
+
+#define SMOOTH(P) \
+do { \
+    ((PIXEL*)dst_ptr)->P = (BYTE)((a01.P * (cx - dx) * 3 + a10.P * (cy - dy) * 3 + \
+                            a21.P * dx * 3 + a12.P * dy * 3 + a11.P * (cx + cy)) / ((cx + cy) * 4)); \
+} while(0)
+
+#define PRECISION 12
+
+/* like triangle filter from ARGB to ARGB */
+void smooth_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch, const struct volume *src_size,
+                              const struct pixel_format_desc *src_format, BYTE *dst, UINT dst_row_pitch, UINT dst_slice_pitch,
+                              const struct volume *dst_size, const struct pixel_format_desc *dst_format, D3DCOLOR color_key)
+{
+    UINT x, y, z;
+    PIXEL a10, a11, a12, a01, a21;
+    int  fx, cx, lx, dx, fy, cy, ly, dy;
+
+    fx = (dst_size->width << PRECISION) / src_size->width;
+    fy = (dst_size->height << PRECISION) / src_size->height;
+    if (!fx || !fy) {
+        return;
+    }
+
+    cx = ((fx - 1) >> PRECISION) + 1;
+    cy = ((fy - 1) >> PRECISION) + 1;
+
+    for (z = 0; z < dst_size->depth; z++)
+    {
+        BYTE *dst_slice_ptr = dst + z * dst_slice_pitch;
+        const BYTE *src_slice_ptr = src + src_slice_pitch * (z * src_size->depth / dst_size->depth);
+
+        for (y = 0; y < dst_size->height; y++)
+        {
+            BYTE *dst_ptr = dst_slice_ptr + y * dst_row_pitch;
+            const BYTE *src_row_ptr = src_slice_ptr + src_row_pitch * (y * src_size->height / dst_size->height);
+            ly = (y << PRECISION) / fy;
+            dy = y - ((ly * fy) >> PRECISION);
+
+            for (x = 0; x < dst_size->width; x++)
+            {
+                const BYTE *src_ptr = src_row_ptr + (x * src_size->width / dst_size->width) * src_format->bytes_per_pixel;
+
+                lx = (x << PRECISION) / fx;
+                dx = x - ((lx * fx) >> PRECISION);
+
+                a11 = *(PIXEL*)src_ptr;
+                a10 = (y == 0)?a11:(*(PIXEL*)(src_ptr - src_row_pitch));
+                a01 = (x == 0)?a11:(*(PIXEL*)(src_ptr - src_format->bytes_per_pixel));
+                a21 = (x == dst_size->width)?a11:(*(PIXEL*)(src_ptr + src_format->bytes_per_pixel));
+                a12 = (y == dst_size->height)?a11:(*(PIXEL*)(src_ptr + src_row_pitch));
+
+                SMOOTH(r);
+                SMOOTH(g);
+                SMOOTH(b);
+                SMOOTH(a);
 
                 dst_ptr += dst_format->bytes_per_pixel;
             }
@@ -1716,6 +2028,29 @@ void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slic
     }
 }
 
+
+/*typedef BOOL (*dxtn_conversion_func)(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                                     enum wined3d_format_id format, unsigned int w, unsigned int h);
+ * format must be WINED3DFMT_B8G8R8A8_UNORM
+ */
+dxtn_conversion_func get_dxtn_conversion_func(D3DFORMAT format, BOOL encode)
+{
+    switch (format)
+    {
+        case D3DFMT_DXT1:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt1_encode : wined3d_dxt1_decode;
+        case D3DFMT_DXT3:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt3_encode : wined3d_dxt3_decode;
+        case D3DFMT_DXT5:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt5_encode : wined3d_dxt5_decode;
+        default:
+            return NULL;
+    }
+}
+
 /************************************************************
  * D3DXLoadSurfaceFromMemory
  *
@@ -1757,6 +2092,9 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     D3DSURFACE_DESC surfdesc;
     D3DLOCKED_RECT lockrect;
     struct volume src_size, dst_size;
+    HRESULT ret = D3D_OK;
+//    RECT tmp_rect;
+    const BYTE *src_addr;
 
     TRACE("(%p, %p, %s, %p, %#x, %u, %p, %s, %#x, 0x%08x)\n",
             dst_surface, dst_palette, wine_dbgstr_rect(dst_rect), src_memory, src_format,
@@ -1787,6 +2125,10 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     {
         dst_size.width = surfdesc.Width;
         dst_size.height = surfdesc.Height;
+ /*       tmp_rect.left = 0;
+        tmp_rect.right = dst_size.width;
+        tmp_rect.top = 0;
+        tmp_rect.bottom = dst_size.height; */
     }
     else
     {
@@ -1803,6 +2145,7 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
             return D3D_OK;
     }
     dst_size.depth = 1;
+    TRACE("dst_size = (%d, %d, %d)\n", dst_size.width, dst_size.height, dst_size.depth);
 
     srcformatdesc = get_format_info(src_format);
     destformatdesc = get_format_info(surfdesc.Format);
@@ -1812,6 +2155,13 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
         return E_NOTIMPL;
     }
 
+    /* initial src address shift if top:left != 0:0
+     * assume src_rect correspond to image size while src_addr is byte address in compressed array, as src_pitch
+     */
+    src_addr = (const BYTE *)src_memory;
+    src_addr += ((src_rect->top + srcformatdesc->block_height - 1) / srcformatdesc->block_height) * src_pitch;
+    src_addr += ((src_rect->left + srcformatdesc->block_width - 1) / srcformatdesc->block_width) * srcformatdesc->block_byte_count;
+
     if (src_format == surfdesc.Format
             && dst_size.width == src_size.width
             && dst_size.height == src_size.height
@@ -1831,43 +2181,126 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
         if (FAILED(IDirect3DSurface9_LockRect(dst_surface, &lockrect, dst_rect, 0)))
             return D3DXERR_INVALIDDATA;
 
-        copy_pixels(src_memory, src_pitch, 0, lockrect.pBits, lockrect.Pitch, 0,
+        copy_pixels(src_addr, src_pitch, 0, lockrect.pBits, lockrect.Pitch, 0,
                 &src_size, srcformatdesc);
 
         IDirect3DSurface9_UnlockRect(dst_surface);
     }
     else /* Stretching or format conversion. */
     {
-        if (((srcformatdesc->type != FORMAT_ARGB) && (srcformatdesc->type != FORMAT_INDEX)) ||
-            (destformatdesc->type != FORMAT_ARGB))
+        /* Isakov S.L. 2015
+         * There is no way to convert DXT1 to DXT3 so I will do this by three steps
+         * 1. Convert from src_fmt to ARGB with the same size
+         * 2. Stretch from src_size to dst_size with filtering
+         * 3. Convert from ARGB to dst_fmt with the same size
+         */
+
+        dxtn_conversion_func pre_convert, post_convert;
+        UINT tmp_src_pitch, tmp_dst_pitch, tmp_src_byte_size;
+        const struct pixel_format_desc *tmp_format_desc;
+        void *tmp_src_memory = NULL;
+        void *tmp_dst_memory = NULL;
+        BOOL dither = TRUE;
+
+        pre_convert  = get_dxtn_conversion_func(srcformatdesc->format, FALSE);
+        post_convert = get_dxtn_conversion_func(destformatdesc->format, TRUE);
+
+        if ((!pre_convert && (srcformatdesc->type != FORMAT_ARGB) && (srcformatdesc->type != FORMAT_INDEX)) ||
+            (!post_convert && (destformatdesc->type != FORMAT_ARGB)))
         {
             FIXME("Format conversion missing %#x -> %#x\n", src_format, surfdesc.Format);
             return E_NOTIMPL;
         }
+        TRACE("Format conversion %#x -> %#x\n", src_format, surfdesc.Format);
 
         if (FAILED(IDirect3DSurface9_LockRect(dst_surface, &lockrect, dst_rect, 0)))
             return D3DXERR_INVALIDDATA;
 
-        if ((filter & 0xf) == D3DX_FILTER_NONE)
+        /* handle pre-conversion from src_fmt to D3DFMT_A8R8G8B8 */
+        dither = filter & D3DX_FILTER_DITHER;
+        tmp_format_desc = get_format_info(D3DFMT_A8R8G8B8);
+        tmp_src_pitch = src_size.width * tmp_format_desc->bytes_per_pixel;
+        tmp_src_byte_size = tmp_src_pitch * src_size.height;
+        tmp_src_memory = HeapAlloc(GetProcessHeap(), 0, tmp_src_byte_size);
+            if (!tmp_src_memory)
+            {
+                ret = E_OUTOFMEMORY;
+                goto error;
+            }
+        if (pre_convert)
         {
-            convert_argb_pixels(src_memory, src_pitch, 0, &src_size, srcformatdesc,
-                    lockrect.pBits, lockrect.Pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+            if (!pre_convert(src_addr, tmp_src_memory, src_pitch, tmp_src_pitch,
+                    WINED3DFMT_B8G8R8A8_UNORM, src_size.width, src_size.height))
+            {
+                ret = E_FAIL;
+                ERR("pre_convert fails\n");
+                goto error;
+            }
         }
-        else /* if ((filter & 0xf) == D3DX_FILTER_POINT) */
+        else
         {
-            if ((filter & 0xf) != D3DX_FILTER_POINT)
-                FIXME("Unhandled filter %#x.\n", filter);
+            convert_argb_pixels(src_addr, src_pitch, 0, &src_size, srcformatdesc,
+                                tmp_src_memory, tmp_src_pitch, 0, &src_size, tmp_format_desc,
+                                color_key, src_palette, dither);
+        }
 
-            /* Always apply a point filter until D3DX_FILTER_LINEAR,
-             * D3DX_FILTER_TRIANGLE and D3DX_FILTER_BOX are implemented. */
-            point_filter_argb_pixels(src_memory, src_pitch, 0, &src_size, srcformatdesc,
-                    lockrect.pBits, lockrect.Pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+        /* Stretching and filtering */
+        tmp_dst_pitch = dst_size.width * tmp_format_desc->bytes_per_pixel;
+        tmp_src_byte_size = tmp_dst_pitch * dst_size.height;
+        tmp_dst_memory = HeapAlloc(GetProcessHeap(), 0, tmp_src_byte_size);
+            if (!tmp_dst_memory)
+            {
+                ret = E_OUTOFMEMORY;
+                goto error;
+            }
+
+        switch (filter & 0xf) {
+            case D3DX_FILTER_NONE:
+                convert_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, tmp_format_desc,
+                                    tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, tmp_format_desc,
+                                    color_key, src_palette, dither);
+
+                break;
+            case D3DX_FILTER_TRIANGLE:
+                smooth_filter_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, tmp_format_desc,
+                                          tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, tmp_format_desc,
+                                          color_key);
+                break;
+            case D3DX_FILTER_POINT:
+            case D3DX_FILTER_BOX:
+            default:
+                point_filter_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, tmp_format_desc,
+                                         tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, tmp_format_desc,
+                                         color_key, src_palette);
+                break;
         }
 
+        /* handle post-conversion */
+        if (post_convert)
+        {
+            if (!post_convert(tmp_dst_memory, lockrect.pBits, tmp_dst_pitch, lockrect.Pitch,
+                    WINED3DFMT_B8G8R8A8_UNORM, dst_size.width, dst_size.height))
+            {
+                ret = E_FAIL;
+                goto error;
+            }
+        }
+        else
+        {
+            convert_argb_pixels(tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, tmp_format_desc,
+                                lockrect.pBits, lockrect.Pitch, 0,
+                                &dst_size, destformatdesc, color_key, src_palette, dither);
+        }
+
+error:
+        if (tmp_dst_memory)
+            HeapFree(GetProcessHeap(), 0, tmp_dst_memory);
+        if (tmp_src_memory)
+            HeapFree(GetProcessHeap(), 0, tmp_src_memory);
         IDirect3DSurface9_UnlockRect(dst_surface);
     }
-
-    return D3D_OK;
+    TRACE("Surface loaded\n");
+    return ret;
 }
 
 /************************************************************
@@ -2136,7 +2569,7 @@ HRESULT WINAPI D3DXSaveSurfaceToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE
             if (SUCCEEDED(hr))
             {
                 convert_argb_pixels(locked_rect.pBits, locked_rect.Pitch, 0, &size, src_format_desc,
-                    dst_data, dst_pitch, 0, &size, dst_format_desc, 0, NULL);
+                    dst_data, dst_pitch, 0, &size, dst_format_desc, 0, NULL, TRUE);
                 IDirect3DSurface9_UnlockRect(src_surface);
             }
 
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index 482f064..1bac9f0 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -2692,6 +2692,65 @@ static void test_effect_compilation_errors(IDirect3DDevice9 *device)
     effect->lpVtbl->Release(effect);
 }
 
+/*
+ * fxc.exe /Tfx_2_0
+ */
+#if 0
+technique t1 { pass p { ZEnable = TRUE; } }
+technique t2 { pass p { ZEnable = FALSE; } }
+#endif
+static const DWORD test_effect_technique_validation_blob[] =
+{
+0xfeff0901, 0x00000064, 0x00000000, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000,
+0x00000000, 0x00000001, 0x00000001, 0x00000002, 0x00000070, 0x00000003, 0x00003174, 0x00000000,
+0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00000002,
+0x00000070, 0x00000003, 0x00003274, 0x00000000, 0x00000002, 0x00000002, 0x00000001, 0x0000002c,
+0x00000000, 0x00000001, 0x00000024, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000008,
+0x00000004, 0x0000005c, 0x00000000, 0x00000001, 0x00000054, 0x00000000, 0x00000001, 0x00000000,
+0x00000000, 0x00000038, 0x00000034, 0x00000000, 0x00000000
+};
+
+static void test_effect_technique_validation(IDirect3DDevice9 *device)
+{
+    ID3DXEffect *effect;
+    ULONG count;
+    D3DXHANDLE technique1, technique2, technique;
+    HRESULT hr;
+
+    hr = D3DXCreateEffect(device, test_effect_technique_validation_blob,
+            sizeof(test_effect_technique_validation_blob), NULL, NULL, 0, NULL, &effect, NULL);
+    ok(hr == D3D_OK, "D3DXCreateEffect failed, got %#x, expected %#x\n", hr, D3D_OK);
+
+    technique1 = effect->lpVtbl->GetTechniqueByName(effect, "t1");
+    ok(technique1 != NULL, "Failed to get technique\n");
+    technique2 = effect->lpVtbl->GetTechniqueByName(effect, "t2");
+    ok(technique2 != NULL, "Failed to get technique\n");
+
+#if 0 /* This crashes on Windows */
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, (D3DXHANDLE)0xdeadbeef, &technique);
+#endif
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, NULL, NULL);
+    ok(hr == D3DERR_INVALIDCALL, "FindNextValidTechnique, got %#x, expected %#x\n", hr, D3DERR_INVALIDCALL);
+
+    technique = (D3DXHANDLE)0xdeadbeef;
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, NULL, &technique);
+    ok(hr == D3D_OK, "FindNextValidTechnique failed, got %#x, expected %#x\n", hr, D3D_OK);
+    ok(technique == technique1, "Technique returned %p, expected %p\n", technique, technique1);
+
+    technique = (D3DXHANDLE)0xdeadbeef;
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, technique1, &technique);
+    ok(hr == D3D_OK, "FindNextValidTechnique failed, got %#x, expected %#x\n", hr, D3D_OK);
+    ok(technique == technique2, "Technique returned %p, expected %p\n", technique, technique2);
+
+    technique = (D3DXHANDLE)0xdeadbeef;
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, technique2, &technique);
+    ok(hr == S_FALSE, "FindNextValidTechnique, got %#x, expected %#x\n", hr, S_FALSE);
+    ok(technique == NULL, "Technique returned %p, expected %p\n", technique, NULL);
+
+    count = effect->lpVtbl->Release(effect);
+    ok(!count, "Release failed %u\n", count);
+}
+
 START_TEST(effect)
 {
     HWND wnd;
@@ -2730,6 +2789,7 @@ START_TEST(effect)
     test_effect_parameter_value(device);
     test_effect_variable_names(device);
     test_effect_compilation_errors(device);
+    test_effect_technique_validation(device);
 
     count = IDirect3DDevice9_Release(device);
     ok(count == 0, "The device was not properly freed: refcount %u\n", count);
diff --git a/dlls/d3dx9_36/tests/mesh.c b/dlls/d3dx9_36/tests/mesh.c
index 588654d..ef2187f 100644
--- a/dlls/d3dx9_36/tests/mesh.c
+++ b/dlls/d3dx9_36/tests/mesh.c
@@ -25,6 +25,9 @@
 #include <limits.h>
 #include "wine/test.h"
 #include "d3dx9.h"
+#include "initguid.h"
+#include "rmxftmpl.h"
+#include "rmxfguid.h"
 
 #ifndef NAN
 /* From wine/port.h */
@@ -1487,8 +1490,8 @@ static void check_vertex_buffer_(int line, ID3DXMesh *mesh, const void *vertices
         return;
 
     if (mesh_fvf == fvf) {
-        DWORD vertex_size = D3DXGetFVFVertexSize(fvf), i;
-
+        DWORD vertex_size = D3DXGetFVFVertexSize(fvf);
+        int i;
         for (i = 0; i < min(num_vertices, mesh_num_vertices); i++)
         {
             const FLOAT *exp_float = vertices;
@@ -2515,6 +2518,129 @@ static void D3DXLoadMeshTest(void)
     free_test_context(test_context);
 }
 
+static ID3DXFileData *get_mesh_data(const char *memory, SIZE_T length)
+{
+    D3DXF_FILELOADMEMORY source;
+    ID3DXFileEnumObject *enumobj = NULL;
+    ID3DXFileData *filedata = NULL;
+    ID3DXFileData *ret = NULL;
+    ID3DXFile *d3dxfile = NULL;
+    SIZE_T i, nb_children;
+    HRESULT hr;
+    GUID guid;
+
+    hr = D3DXFileCreate(&d3dxfile);
+    if (FAILED(hr)) return NULL;
+
+    hr = d3dxfile->lpVtbl->RegisterTemplates(d3dxfile, D3DRM_XTEMPLATES, D3DRM_XTEMPLATE_BYTES);
+    if (FAILED(hr)) goto cleanup;
+
+    source.lpMemory = (void *)memory;
+    source.dSize    = length;
+
+    hr = d3dxfile->lpVtbl->CreateEnumObject(d3dxfile, &source, D3DXF_FILELOAD_FROMMEMORY, &enumobj);
+    if (FAILED(hr)) goto cleanup;
+
+    hr = enumobj->lpVtbl->GetChildren(enumobj, &nb_children);
+    if (FAILED(hr)) goto cleanup;
+
+    for (i = 0; i < nb_children; i++)
+    {
+        hr = enumobj->lpVtbl->GetChild(enumobj, i, &filedata);
+        if (FAILED(hr)) goto cleanup;
+
+        hr = filedata->lpVtbl->GetType(filedata, &guid);
+        if (SUCCEEDED(hr) && IsEqualGUID(&guid, &TID_D3DRMMesh))
+        {
+            ret = filedata;
+            break;
+        }
+        else
+            filedata->lpVtbl->Release(filedata);
+    }
+
+cleanup:
+    if (enumobj) enumobj->lpVtbl->Release(enumobj);
+    if (d3dxfile) d3dxfile->lpVtbl->Release(d3dxfile);
+
+    return ret;
+}
+
+static void D3DXLoadSkinMeshFromXofTest(void)
+{
+    static const char simple_xfile[] =
+        "xof 0303txt 0032"
+        "Mesh {"
+            "3;"
+            "0.0; 0.0; 0.0;,"
+            "0.0; 1.0; 0.0;,"
+            "1.0; 1.0; 0.0;;"
+            "1;"
+            "3; 0, 1, 2;;"
+        "}";
+    ID3DXBuffer *adjacency, *materials, *effects;
+    D3DPRESENT_PARAMETERS d3dpp;
+    IDirect3DDevice9 *device;
+    ID3DXFileData *filedata;
+    ID3DXSkinInfo *skininfo;
+    ID3DXMesh *mesh;
+    IDirect3D9 *d3d;
+    DWORD mat_count;
+    HRESULT hr;
+    HWND hwnd;
+
+    if (!(hwnd = CreateWindowA("static", "d3dx9_test", WS_OVERLAPPEDWINDOW, 0, 0,
+            640, 480, NULL, NULL, NULL, NULL)))
+    {
+        skip("Couldn't create application window\n");
+        return;
+    }
+
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    if (!d3d)
+    {
+        skip("Couldn't create IDirect3D9 object\n");
+        DestroyWindow(hwnd);
+        return;
+    }
+
+    ZeroMemory(&d3dpp, sizeof(d3dpp));
+    d3dpp.Windowed   = TRUE;
+    d3dpp.SwapEffect = D3DSWAPEFFECT_DISCARD;
+
+    hr = IDirect3D9_CreateDevice(d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL, hwnd, D3DCREATE_SOFTWARE_VERTEXPROCESSING, &d3dpp, &device);
+    IDirect3D9_Release(d3d);
+    if (FAILED(hr))
+    {
+        skip("Failed to create IDirect3DDevice9 object %#x\n", hr);
+        DestroyWindow(hwnd);
+        return;
+    }
+
+    filedata = get_mesh_data(simple_xfile, sizeof(simple_xfile) - 1);
+    ok(filedata != NULL, "Failed to load mesh data\n");
+
+    adjacency = materials = effects = NULL;
+    skininfo = NULL;
+    mesh = NULL;
+
+    hr = D3DXLoadSkinMeshFromXof(filedata, 0, device, &adjacency, &materials, &effects, &mat_count, &skininfo, &mesh);
+    ok(hr == D3D_OK, "Got result %x, expected 0 (D3D_OK)\n", hr);
+    ok(skininfo != NULL, "Expected non-null skininfo\n");
+
+    /* FIXME: Add additional tests for skininfo interface. */
+
+    if (adjacency) adjacency->lpVtbl->Release(adjacency);
+    if (materials) materials->lpVtbl->Release(materials);
+    if (effects) effects->lpVtbl->Release(effects);
+    if (skininfo) skininfo->lpVtbl->Release(skininfo);
+    if (mesh) mesh->lpVtbl->Release(mesh);
+
+    filedata->lpVtbl->Release(filedata);
+    IDirect3DDevice9_Release(device);
+    DestroyWindow(hwnd);
+}
+
 static BOOL compute_box(struct mesh *mesh, float width, float height, float depth)
 {
     unsigned int i, face;
@@ -2709,7 +2835,7 @@ static void test_polygon(IDirect3DDevice9 *device, float length, unsigned int si
 
     mesh.fvf = D3DFVF_XYZ | D3DFVF_NORMAL;
 
-    sprintf(name, "polygon (%g, %u)", length, sides);
+    sprintf(name, "polygon (%g, %d)", length, sides);
     compare_mesh(name, polygon, &mesh);
 
     free_mesh(&mesh);
@@ -5238,6 +5364,88 @@ static void test_create_skin_info(void)
     ok(hr == D3DERR_INVALIDCALL, "Expected D3DERR_INVALIDCALL, got %#x\n", hr);
 }
 
+static void test_update_skinned_mesh(void)
+{
+    static DWORD bone0_vertices[2] = { 1, 3 };
+    static FLOAT bone0_weights[2] = { 1.0f, 0.5f };
+    static DWORD bone1_vertices[2] = { 2, 3 };
+    static FLOAT bone1_weights[2] = { 1.0f, 0.5f };
+    static D3DMATRIX bones_matrix[2] =
+    { { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+               2.0f,  2.0f,  4.0f,  1.0f
+      } } },
+      { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+              -4.0f, -4.0f,  4.0f,  1.0f
+      } } } };
+    static D3DVECTOR vertices_src[] = {{  1.0f,  1.0f,  1.0f },
+                                       {  1.0f,  0.0f,  0.0f },
+                                       {  1.0f,  1.0f, -1.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -1.0f, -1.0f,  1.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -1.0f, -1.0f, -1.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    static D3DVECTOR vertices_ref[] = {{  0.0f,  0.0f,  0.0f },
+                                       {  0.0f,  0.0f,  0.0f },
+                                       {  3.0f,  3.0f,  3.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -5.0f, -5.0f,  5.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -2.0f, -2.0f,  3.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    D3DVECTOR vertices_dest[8];
+    HRESULT hr;
+    ID3DXSkinInfo *skin_info;
+    D3DXMATRIX matrix;
+    int i;
+
+    D3DXMatrixIdentity(&matrix);
+    for (i = 0; i < 8; i++)
+    {
+        vertices_dest[i].x = 10000.0f;
+        vertices_dest[i].y = 10000.0f;
+        vertices_dest[i].z = 10000.0f;
+    }
+
+    hr = D3DXCreateSkinInfoFVF(4, D3DFVF_XYZ | D3DFVF_NORMAL, 2, &skin_info);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 0, 2, bone0_vertices, bone0_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 0, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 1, 2, bone1_vertices, bone1_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 1, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->UpdateSkinnedMesh(skin_info, bones_matrix, NULL, vertices_src, vertices_dest);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    for (i = 0; i < 4; i++)
+    {
+        ok(compare(vertices_dest[i*2].x, vertices_ref[i*2].x), "Vertex[%d].position.x: got %g, expected %g\n",
+           i, vertices_dest[i*2].x, vertices_ref[i*2].x);
+        ok(compare(vertices_dest[i*2].y, vertices_ref[i*2].y), "Vertex[%d].position.y: got %g, expected %g\n",
+           i, vertices_dest[i*2].y, vertices_ref[i*2].y);
+        ok(compare(vertices_dest[i*2].z, vertices_ref[i*2].z), "Vertex[%d].position.z: got %g, expected %g\n",
+           i, vertices_dest[i*2].z, vertices_ref[i*2].z);
+        ok(compare(vertices_dest[i*2+1].x, vertices_ref[i*2+1].x), "Vertex[%d].normal.x: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].x, vertices_ref[i*2+1].x);
+        ok(compare(vertices_dest[i*2+1].y, vertices_ref[i*2+1].y), "Vertex[%d].normal.y: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].y, vertices_ref[i*2+1].y);
+        ok(compare(vertices_dest[i*2+1].z, vertices_ref[i*2+1].z), "Vertex[%d].normal.z: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].z, vertices_ref[i*2+1].z);
+    }
+    skin_info->lpVtbl->Release(skin_info);
+}
+
 static void test_convert_adjacency_to_point_reps(void)
 {
     HRESULT hr;
@@ -11100,6 +11308,57 @@ static void test_compute_normals(void)
     free_test_context(test_context);
 }
 
+static void D3DXCreateAnimationControllerTest(void)
+{
+    HRESULT hr;
+    ID3DXAnimationController *animation;
+    UINT value;
+
+    hr = D3DXCreateAnimationController(0, 0, 0, 0, NULL);
+    todo_wine ok(hr == D3D_OK, "D3DXCreateAnimationController returned %#x, expected D3D_OK\n", hr);
+
+if (0) /* Crashes when animation is Released */
+{
+    hr = D3DXCreateAnimationController(0, 0, 0, 0, &animation);
+    ok(hr == D3D_OK, "D3DXCreateAnimationController returned %#x, expected D3D_OK\n", hr);
+    animation->lpVtbl->Release(animation);
+}
+
+    hr = D3DXCreateAnimationController(1, 1, 1, 1, &animation);
+    ok(hr == D3D_OK, "D3DXCreateAnimationController returned %#x, expected D3D_OK\n", hr);
+
+    value = animation->lpVtbl->GetMaxNumAnimationOutputs(animation);
+    ok(value == 1, "returned %u, expected 1\n", value);
+
+    value = animation->lpVtbl->GetMaxNumAnimationSets(animation);
+    ok(value == 1, "returned %u, expected 1\n", value);
+
+    value = animation->lpVtbl->GetMaxNumTracks(animation);
+    ok(value == 1, "returned %u, expected 1\n", value);
+
+    value = animation->lpVtbl->GetMaxNumEvents(animation);
+    ok(value == 1, "returned %u, expected 1\n", value);
+
+    animation->lpVtbl->Release(animation);
+
+    hr = D3DXCreateAnimationController(100, 101, 102, 103, &animation);
+    ok(hr == D3D_OK, "D3DXCreateAnimationController returned %#x, expected D3D_OK\n", hr);
+
+    value = animation->lpVtbl->GetMaxNumAnimationOutputs(animation);
+    ok(value == 100, "returned %u, expected 100\n", value);
+
+    value = animation->lpVtbl->GetMaxNumAnimationSets(animation);
+    ok(value == 101, "returned %u, expected 101\n", value);
+
+    value = animation->lpVtbl->GetMaxNumTracks(animation);
+    ok(value == 102, "returned %u, expected 102\n", value);
+
+    value = animation->lpVtbl->GetMaxNumEvents(animation);
+    ok(value == 103, "returned %u, expected 103\n", value);
+
+    animation->lpVtbl->Release(animation);
+}
+
 START_TEST(mesh)
 {
     D3DXBoundProbeTest();
@@ -11110,18 +11369,21 @@ START_TEST(mesh)
     D3DXCreateMeshTest();
     D3DXCreateMeshFVFTest();
     D3DXLoadMeshTest();
+    D3DXLoadSkinMeshFromXofTest();
     D3DXCreateBoxTest();
     D3DXCreatePolygonTest();
     D3DXCreateSphereTest();
     D3DXCreateCylinderTest();
     D3DXCreateTextTest();
     D3DXCreateTorusTest();
+    D3DXCreateAnimationControllerTest();
     test_get_decl_length();
     test_get_decl_vertex_size();
     test_fvf_decl_conversion();
     D3DXGenerateAdjacencyTest();
     test_update_semantics();
     test_create_skin_info();
+    test_update_skinned_mesh();
     test_convert_adjacency_to_point_reps();
     test_convert_point_reps_to_adjacency();
     test_weld_vertices();
diff --git a/dlls/d3dx9_36/tests/shader.c b/dlls/d3dx9_36/tests/shader.c
index 694540c..946143e 100644
--- a/dlls/d3dx9_36/tests/shader.c
+++ b/dlls/d3dx9_36/tests/shader.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2008 Luis Busquets
+ * Copyright 2010, 2013 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -299,6 +300,26 @@ static const DWORD fx_shader_with_ctab[] =
     0x0000ffff                                                              /* END                      */
 };
 
+static const DWORD semantics_vs11[] = {
+    0xfffe0101,                                                             /* vs_1_1                       */
+    0x0001fffe, D3DSIO_DCL,                                                 /* Comment                      */
+    0x00000051, 0xa00f0001, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, /* def c1 = dcl, dcl, dcl, dcl  */
+    0x0000001f, 0x80000000, 0x900f0000,                                     /* dcl_position0 v0 (input)     */
+    0x0000001f, 0x80000005, 0x900f0001,                                     /* dcl_texcoord0 v1 (input)     */
+    0x0000001f, 0x80010005, 0x900f0002,                                     /* dcl_texcoord1 v2 (input)     */
+    0x0000001f, 0x8000000a, 0xe00f0000,                                     /* dcl_color0    oD0 (output)   */
+    0x0000ffff};                                                            /* END                          */
+
+static const DWORD semantics_vs30[] = {
+    0xfffe0300,                                                             /* vs_3_0                       */
+    0x0001fffe, D3DSIO_DCL,                                                 /* Comment                      */
+    0x05000051, 0xa00f0001, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, /* def c1 = dcl, dcl, dcl, dcl  */
+    0x0200001f, 0x80000000, 0x900f0000,                                     /* dcl_position0 v0 (input)     */
+    0x0200001f, 0x80000005, 0x900f0001,                                     /* dcl_texcoord0 v1 (input)     */
+    0x0200001f, 0x80010005, 0x900f0002,                                     /* dcl_texcoord1 v2 (input)     */
+    0x0200001f, 0x8000000a, 0xe00f0000,                                     /* dcl_color0    o0 (output)    */
+    0x0000ffff};                                                            /* END                          */
+
 static void test_get_shader_size(void)
 {
     UINT shader_size, expected;
@@ -6489,6 +6510,124 @@ static void test_registerset_defaults(void)
     if (wnd) DestroyWindow(wnd);
 }
 
+static void test_get_shader_semantics(void)
+{
+    HRESULT ret;
+    D3DXSEMANTIC semantics[MAXD3DDECLLENGTH];
+    UINT count;
+
+    /* Test D3DXGetShaderInputSemantics */
+
+    /* Check wrong parameters */
+    ret = D3DXGetShaderInputSemantics(NULL, NULL, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, NULL, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, semantics, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, semantics, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, NULL, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+
+    /* Check null semantics pointer */
+    count = 0xdeadbeef;
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, NULL, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+
+    /* Check null count pointer */
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, semantics, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Check with vs11 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Check with vs30 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs30, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Test D3DXGetShaderOutputSemantics */
+
+    /* Check wrong parameters */
+    ret = D3DXGetShaderOutputSemantics(NULL, NULL, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderOutputSemantics(NULL, NULL, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderOutputSemantics(NULL, semantics, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderOutputSemantics(NULL, semantics, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+if (0)
+{
+    /* Crashes on wvistau64 */
+    ret = D3DXGetShaderOutputSemantics(semantics_vs11, NULL, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+}
+
+    /* Check null semantics pointer */
+    count = 0xdeadbeef;
+    ret = D3DXGetShaderOutputSemantics(semantics_vs11, NULL, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 1, "Got %u, expected 1\n", count);
+
+    /* Check null count pointer */
+if (0)
+{
+    /* Crashes on wvistau64 */
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderOutputSemantics(semantics_vs11, semantics, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(semantics[0].Usage == D3DDECLUSAGE_COLOR, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_COLOR);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+}
+
+    /* Check with vs11 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderOutputSemantics(semantics_vs11, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 1, "Got %u, expected 1\n", count);
+    todo_wine
+    ok(semantics[0].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+
+    /* Check with vs30 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderOutputSemantics(semantics_vs30, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 1, "Got %u, expected 1\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_COLOR, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_COLOR);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+}
+
 START_TEST(shader)
 {
     test_get_shader_size();
@@ -6502,4 +6641,5 @@ START_TEST(shader)
     test_get_shader_constant_variables();
     test_registerset();
     test_registerset_defaults();
+    test_get_shader_semantics();
 }
diff --git a/dlls/d3dx9_36/tests/surface.c b/dlls/d3dx9_36/tests/surface.c
index 1697a03..d10d44b1 100644
--- a/dlls/d3dx9_36/tests/surface.c
+++ b/dlls/d3dx9_36/tests/surface.c
@@ -1169,7 +1169,7 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT3 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT3 format.\n");
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
         }
@@ -1195,7 +1195,7 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT5 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT5 format.\n");
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
         }
@@ -1208,10 +1208,10 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT1 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT1 format.\n");
 
             hr = D3DXLoadSurfaceFromSurface(surf, NULL, NULL, newsurf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels from DXT1 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels from DXT1 format.\n");
 
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
diff --git a/dlls/d3dx9_36/tests/texture.c b/dlls/d3dx9_36/tests/texture.c
index 095650f..59cb00e 100644
--- a/dlls/d3dx9_36/tests/texture.c
+++ b/dlls/d3dx9_36/tests/texture.c
@@ -384,6 +384,16 @@ static void test_D3DXCheckTextureRequirements(IDirect3DDevice9 *device)
         ok(height == 4, "Returned height %d, expected %d\n", height, 4);
         ok(mipmaps == 1, "Returned mipmaps %d, expected %d\n", mipmaps, 1);
         ok(format == D3DFMT_DXT5, "Returned format %u, expected %u\n", format, D3DFMT_DXT5);
+
+        format = D3DFMT_DXT5;
+        width = 5; height = 5;
+        mipmaps = 1;
+        hr = D3DXCheckTextureRequirements(device, &width, &height, &mipmaps, 0, &format, D3DPOOL_DEFAULT);
+        ok(hr == D3D_OK, "D3DXCheckTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
+        ok(width == 8, "Returned width %d, expected %d\n", width, 8);
+        ok(height == 8, "Returned height %d, expected %d\n", height, 8);
+        ok(mipmaps == 1, "Returned mipmaps %d, expected %d\n", mipmaps, 1);
+        ok(format == D3DFMT_DXT5, "Returned format %u, expected %u\n", format, D3DFMT_DXT5);
     }
     else
     {
diff --git a/dlls/d3dx9_36/tests/volume.c b/dlls/d3dx9_36/tests/volume.c
index 53260c1..d317387 100644
--- a/dlls/d3dx9_36/tests/volume.c
+++ b/dlls/d3dx9_36/tests/volume.c
@@ -202,10 +202,10 @@ static void test_D3DXLoadVolumeFromMemory(IDirect3DDevice9 *device)
 
     IDirect3DVolumeTexture9_GetVolumeLevel(volume_texture, 0, &volume);
 
-    set_box(&src_box, 1, 1, 7, 7, 0, 1);
-    set_box(&dst_box, 1, 1, 7, 7, 0, 1);
+    set_box(&src_box, 0, 0, 7, 7, 0, 1);
+    set_box(&dst_box, 0, 0, 7, 7, 0, 1);
     hr = D3DXLoadVolumeFromMemory(volume, NULL, &dst_box, pixels, D3DFMT_A8R8G8B8, 16, 32, NULL, &src_box, D3DX_DEFAULT, 0);
-    todo_wine ok(hr == D3D_OK, "D3DXLoadVolumeFromMemory returned %#x, expected %#x\n", hr, D3D_OK);
+    ok(hr == D3D_OK, "D3DXLoadVolumeFromMemory returned %#x, expected %#x\n", hr, D3D_OK);
 
     IDirect3DVolume9_Release(volume);
     IDirect3DVolumeTexture9_Release(volume_texture);
diff --git a/dlls/d3dx9_36/texture.c b/dlls/d3dx9_36/texture.c
index 38349e2..d2f60ea 100644
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -334,10 +334,10 @@ HRESULT WINAPI D3DXCheckTextureRequirements(struct IDirect3DDevice9 *device, UIN
 
     if (fmt->block_width != 1 || fmt->block_height != 1)
     {
-        if (w < fmt->block_width)
-            w = fmt->block_width;
-        if (h < fmt->block_height)
-            h = fmt->block_height;
+        if (w % fmt->block_width)
+            w += fmt->block_width - w % fmt->block_width;
+        if (h % fmt->block_height)
+            h += fmt->block_height - h % fmt->block_height;
     }
 
     if ((caps.TextureCaps & D3DPTEXTURECAPS_POW2) && (!is_pow2(w)))
@@ -662,13 +662,13 @@ HRESULT WINAPI D3DXCreateTextureFromFileInMemoryEx(struct IDirect3DDevice9 *devi
     if (imginfo.MipLevels < miplevels && (D3DFMT_DXT1 <= imginfo.Format && imginfo.Format <= D3DFMT_DXT5))
     {
         FIXME("Generation of mipmaps for compressed pixel formats is not implemented yet.\n");
-        miplevels = imginfo.MipLevels;
+        //   miplevels = imginfo.MipLevels;
     }
     if (imginfo.ResourceType == D3DRTYPE_VOLUMETEXTURE
             && D3DFMT_DXT1 <= imginfo.Format && imginfo.Format <= D3DFMT_DXT5 && miplevels > 1)
     {
-        FIXME("Generation of mipmaps for compressed pixel formats is not implemented yet.\n");
-        miplevels = 1;
+        FIXME("Generation of mipmaps for compressed pixel formats is implemented.\n");
+        //        miplevels = 1;
     }
 
     if (FAILED(IDirect3DDevice9_GetDeviceCaps(device, &caps)))
@@ -1873,10 +1873,7 @@ HRESULT WINAPI D3DXSaveTextureToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE
     if (!dst_buffer || !src_texture) return D3DERR_INVALIDCALL;
 
     if (file_format == D3DXIFF_DDS)
-    {
-        FIXME("DDS file format isn't supported yet\n");
-        return E_NOTIMPL;
-    }
+        return save_dds_texture_to_memory(dst_buffer, src_texture, src_palette);
 
     type = IDirect3DBaseTexture9_GetType(src_texture);
     switch (type)
@@ -1886,7 +1883,7 @@ HRESULT WINAPI D3DXSaveTextureToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE
             hr = get_surface(type, src_texture, D3DCUBEMAP_FACE_POSITIVE_X, 0, &surface);
             break;
         case D3DRTYPE_VOLUMETEXTURE:
-            FIXME("Volume textures aren't supported yet\n");
+            FIXME("Volume textures supported only to dds file format\n");
             return E_NOTIMPL;
         default:
             return D3DERR_INVALIDCALL;
diff --git a/dlls/d3dx9_36/volume.c b/dlls/d3dx9_36/volume.c
index fae8542..05a8686 100644
--- a/dlls/d3dx9_36/volume.c
+++ b/dlls/d3dx9_36/volume.c
@@ -16,11 +16,83 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
 #include "wine/debug.h"
 #include "d3dx9_36_private.h"
 
+#include "wine/wined3d.h"
+#include "d3d9-dxtn.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
+enum wined3d_format_id wined3dformat_from_d3dformat(D3DFORMAT format)
+{
+  BYTE *c = (BYTE *)&format;
+
+  /* Don't translate FOURCC formats */
+  if (isprint(c[0]) && isprint(c[1]) && isprint(c[2]) && isprint(c[3])) return (enum wined3d_format_id)format;
+
+  switch(format)
+  {
+    case D3DFMT_UNKNOWN: return WINED3DFMT_UNKNOWN;
+    case D3DFMT_R8G8B8: return WINED3DFMT_B8G8R8_UNORM;
+    case D3DFMT_A8R8G8B8: return WINED3DFMT_B8G8R8A8_UNORM;
+    case D3DFMT_X8R8G8B8: return WINED3DFMT_B8G8R8X8_UNORM;
+    case D3DFMT_R5G6B5: return WINED3DFMT_B5G6R5_UNORM;
+    case D3DFMT_X1R5G5B5: return WINED3DFMT_B5G5R5X1_UNORM;
+    case D3DFMT_A1R5G5B5: return WINED3DFMT_B5G5R5A1_UNORM;
+    case D3DFMT_A4R4G4B4: return WINED3DFMT_B4G4R4A4_UNORM;
+    case D3DFMT_R3G3B2: return WINED3DFMT_B2G3R3_UNORM;
+    case D3DFMT_A8: return WINED3DFMT_A8_UNORM;
+    case D3DFMT_A8R3G3B2: return WINED3DFMT_B2G3R3A8_UNORM;
+    case D3DFMT_X4R4G4B4: return WINED3DFMT_B4G4R4X4_UNORM;
+    case D3DFMT_A2B10G10R10: return WINED3DFMT_R10G10B10A2_UNORM;
+    case D3DFMT_A8B8G8R8: return WINED3DFMT_R8G8B8A8_UNORM;
+    case D3DFMT_X8B8G8R8: return WINED3DFMT_R8G8B8X8_UNORM;
+    case D3DFMT_G16R16: return WINED3DFMT_R16G16_UNORM;
+    case D3DFMT_A2R10G10B10: return WINED3DFMT_B10G10R10A2_UNORM;
+    case D3DFMT_A16B16G16R16: return WINED3DFMT_R16G16B16A16_UNORM;
+    case D3DFMT_A8P8: return WINED3DFMT_P8_UINT_A8_UNORM;
+    case D3DFMT_P8: return WINED3DFMT_P8_UINT;
+    case D3DFMT_L8: return WINED3DFMT_L8_UNORM;
+    case D3DFMT_A8L8: return WINED3DFMT_L8A8_UNORM;
+    case D3DFMT_A4L4: return WINED3DFMT_L4A4_UNORM;
+    case D3DFMT_V8U8: return WINED3DFMT_R8G8_SNORM;
+    case D3DFMT_L6V5U5: return WINED3DFMT_R5G5_SNORM_L6_UNORM;
+    case D3DFMT_X8L8V8U8: return WINED3DFMT_R8G8_SNORM_L8X8_UNORM;
+    case D3DFMT_Q8W8V8U8: return WINED3DFMT_R8G8B8A8_SNORM;
+    case D3DFMT_V16U16: return WINED3DFMT_R16G16_SNORM;
+    case D3DFMT_A2W10V10U10: return WINED3DFMT_R10G10B10_SNORM_A2_UNORM;
+    case D3DFMT_D16_LOCKABLE: return WINED3DFMT_D16_LOCKABLE;
+    case D3DFMT_D32_LOCKABLE: return WINED3DFMT_D32_LOCKABLE;
+    case D3DFMT_S8_LOCKABLE: return WINED3DFMT_S8_LOCKABLE;
+    case D3DFMT_D32: return WINED3DFMT_D32_UNORM;
+    case D3DFMT_D15S1: return WINED3DFMT_S1_UINT_D15_UNORM;
+    case D3DFMT_D24S8: return WINED3DFMT_D24_UNORM_S8_UINT;
+    case D3DFMT_D24X8: return WINED3DFMT_X8D24_UNORM;
+    case D3DFMT_D24X4S4: return WINED3DFMT_S4X4_UINT_D24_UNORM;
+    case D3DFMT_D16: return WINED3DFMT_D16_UNORM;
+    case D3DFMT_L16: return WINED3DFMT_L16_UNORM;
+    case D3DFMT_D32F_LOCKABLE: return WINED3DFMT_D32_FLOAT;
+    case D3DFMT_D24FS8: return WINED3DFMT_S8_UINT_D24_FLOAT;
+    case D3DFMT_VERTEXDATA: return WINED3DFMT_VERTEXDATA;
+    case D3DFMT_INDEX16: return WINED3DFMT_R16_UINT;
+    case D3DFMT_INDEX32: return WINED3DFMT_R32_UINT;
+    case D3DFMT_Q16W16V16U16: return WINED3DFMT_R16G16B16A16_SNORM;
+    case D3DFMT_R16F: return WINED3DFMT_R16_FLOAT;
+    case D3DFMT_G16R16F: return WINED3DFMT_R16G16_FLOAT;
+    case D3DFMT_A16B16G16R16F: return WINED3DFMT_R16G16B16A16_FLOAT;
+    case D3DFMT_R32F: return WINED3DFMT_R32_FLOAT;
+    case D3DFMT_G32R32F: return WINED3DFMT_R32G32_FLOAT;
+    case D3DFMT_A32B32G32R32F: return WINED3DFMT_R32G32B32A32_FLOAT;
+    case D3DFMT_CxV8U8: return WINED3DFMT_R8G8_SNORM_Cx;
+    default:
+      FIXME("Unhandled D3DFORMAT %#x\n", format);
+      return WINED3DFMT_UNKNOWN;
+  }
+}
+
+
 HRESULT WINAPI D3DXLoadVolumeFromFileA(IDirect3DVolume9 *dst_volume,
                                        const PALETTEENTRY *dst_palette,
                                        const D3DBOX *dst_box,
@@ -79,7 +151,16 @@ HRESULT WINAPI D3DXLoadVolumeFromFileW(IDirect3DVolume9 *dst_volume,
 
     return hr;
 }
-
+/*
+SrcRowPitch [in]
+Type: UINT
+Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one row of cells, in bytes.
+SrcSlicePitch [in]
+Type: UINT
+Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one slice of cells, in bytes.
+
+ Assumed sizes for uncompressed image. Real file size is smaller.
+*/
 HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
                                         const PALETTEENTRY *dst_palette,
                                         const D3DBOX *dst_box,
@@ -95,8 +176,10 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
     HRESULT hr;
     D3DVOLUME_DESC desc;
     D3DLOCKED_BOX locked_box;
+    D3DBOX tmp_box;
     struct volume dst_size, src_size;
     const struct pixel_format_desc *src_format_desc, *dst_format_desc;
+    const BYTE *src_addr;
 
     TRACE("(%p, %p, %p, %p, %#x, %u, %u, %p, %p, %x, %x)\n", dst_volume, dst_palette, dst_box,
             src_memory, src_format, src_row_pitch, src_slice_pitch, src_palette, src_box,
@@ -124,6 +207,12 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
         dst_size.width = desc.Width;
         dst_size.height = desc.Height;
         dst_size.depth = desc.Depth;
+        tmp_box.Left = 0;
+        tmp_box.Right = dst_size.width;
+        tmp_box.Bottom = dst_size.height;
+        tmp_box.Top  = 0;
+        tmp_box.Front  = 0;
+        tmp_box.Back = dst_size.depth;
     }
     else
     {
@@ -143,6 +232,19 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
     if (src_format_desc->type == FORMAT_UNKNOWN)
         return E_NOTIMPL;
 
+    if (src_slice_pitch == 0)
+    {
+        src_slice_pitch = src_row_pitch * max(1, (src_size.height + src_format_desc->block_height - 1) / src_format_desc->block_height);
+//        src_slice_pitch = src_row_pitch * src_size.height; //this is in bytes, not in blocks
+        WARN("workaround for src_slice_pitch = %d\n", src_slice_pitch);
+    }
+
+    /* this is initial shift of source pixels/cells */
+    src_addr = src_memory;
+    src_addr += src_box->Front * src_slice_pitch;
+    src_addr += (src_box->Top / src_format_desc->block_height) * src_row_pitch;
+    src_addr += (src_box->Left / src_format_desc->block_width) * src_format_desc->block_byte_count;
+
     dst_format_desc = get_format_info(desc.Format);
     if (dst_format_desc->type == FORMAT_UNKNOWN)
         return E_NOTIMPL;
@@ -153,7 +255,7 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
             && dst_size.depth == src_size.depth
             && color_key == 0)
     {
-        const BYTE *src_addr;
+
 
         if (src_box->Left & (src_format_desc->block_width - 1)
                 || src_box->Top & (src_format_desc->block_height - 1)
@@ -167,61 +269,175 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
             return E_NOTIMPL;
         }
 
-        src_addr = src_memory;
-        src_addr += src_box->Front * src_slice_pitch;
-        src_addr += (src_box->Top / src_format_desc->block_height) * src_row_pitch;
-        src_addr += (src_box->Left / src_format_desc->block_width) * src_format_desc->block_byte_count;
-
         hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
         if (FAILED(hr)) return hr;
 
         copy_pixels(src_addr, src_row_pitch, src_slice_pitch,
                 locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch,
-                &dst_size, dst_format_desc);
+                &src_size, src_format_desc);
 
         IDirect3DVolume9_UnlockBox(dst_volume);
     }
     else
     {
-        const BYTE *src_addr;
-
-
-        if (((src_format_desc->type != FORMAT_ARGB) && (src_format_desc->type != FORMAT_INDEX)) ||
-            (dst_format_desc->type != FORMAT_ARGB))
+        /* Isakov S.L. 2015
+         * There is no way to convert DXT1 to DXT3 so I will do this by three steps
+         * 1. Convert from src_fmt to ARGB with the same size
+         * 2. Stretch from src_size to dst_size with filtering
+         * 3. Convert from ARGB to dst_fmt with the same size
+         */
+        dxtn_conversion_func pre_convert, post_convert;
+        void *tmp_src_memory = NULL;
+        void *tmp_dst_memory = NULL;
+        BYTE *tmp_memory;
+        const struct pixel_format_desc *tmp_format_desc;
+        UINT depth_i;
+        UINT tmp_src_row_pitch, tmp_src_slice_pitch, tmp_src_byte_size;
+        UINT tmp_dst_row_pitch, tmp_dst_slice_pitch, tmp_dst_byte_size;
+        int tmp_depth = 1; //sometimes the function called with depth=0 which cause crash
+        BOOL dither;
+
+        /* assume DXTn formats, else NULL */
+        pre_convert  = get_dxtn_conversion_func(src_format_desc->format, FALSE); /* decompress */
+        post_convert = get_dxtn_conversion_func(dst_format_desc->format, TRUE);  /* compress */
+        /* and ARGBF16 is not supported :( */
+        if ((!pre_convert && (src_format_desc->type != FORMAT_ARGB) && (src_format_desc->type != FORMAT_INDEX)) ||
+            (!post_convert && (dst_format_desc->type != FORMAT_ARGB)))
         {
             FIXME("Pixel format conversion is not implemented %#x -> %#x\n",
                     src_format_desc->format, dst_format_desc->format);
             return E_NOTIMPL;
         }
+        TRACE("convert volume tex from 0x%x to 0x%x\n", src_format_desc->format, dst_format_desc->format);
+        if (!dst_box) {
+            hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, &tmp_box, 0);
+        } else 
+            hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
+        if (FAILED(hr)) {
+            ERR("fail to LockBox\n");
+            return hr;
+        }
 
-        src_addr = src_memory;
-        src_addr += src_box->Front * src_slice_pitch;
-        src_addr += src_box->Top * src_row_pitch;
-        src_addr += src_box->Left * src_format_desc->bytes_per_pixel;
+        TRACE("src_memory %p, src_addr %p, src_row_pitch=%d src_slice_pitch=%d\n",
+              src_memory, src_addr, src_row_pitch, src_slice_pitch);
+
+        /* handle pre-conversion from src_fmt to D3DFMT_A8R8G8B8 */
+        dither = filter & D3DX_FILTER_DITHER;
+        tmp_format_desc = get_format_info(D3DFMT_A8R8G8B8);
+        tmp_src_row_pitch = src_size.width * tmp_format_desc->bytes_per_pixel;
+        tmp_src_slice_pitch = tmp_src_row_pitch * src_size.height;
+        tmp_src_byte_size = tmp_src_slice_pitch * src_size.depth;
+        tmp_src_memory = HeapAlloc(GetProcessHeap(), 0, tmp_src_byte_size);
+        if (!tmp_src_memory)
+        {
+            hr = E_OUTOFMEMORY;
+            goto error;
+        }
+        tmp_memory = tmp_src_memory;
+        if (pre_convert)
+        {
+            //calculate_dds - for reference
+            for (depth_i = 0; depth_i < src_size.depth; depth_i++)
+            {
+                if (!pre_convert(src_addr, tmp_memory, src_row_pitch, tmp_src_row_pitch,
+                                 WINED3DFMT_B8G8R8A8_UNORM, src_size.width, src_size.height))
+                {
+                    hr = E_FAIL;
+                    ERR("fail to pre_convert\n");
+                    goto error;
+                }
+                src_addr += src_slice_pitch / src_format_desc->block_byte_count;
+                tmp_memory += tmp_src_slice_pitch;
+            }
+        }
+        else
+        {
+            convert_argb_pixels(src_addr, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
+                                tmp_src_memory, tmp_src_row_pitch, tmp_src_slice_pitch, &src_size, tmp_format_desc,
+                                color_key, src_palette, dither);
+        }
 
-        hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
-        if (FAILED(hr)) return hr;
+        /* calculation for dst_size */
+        tmp_depth = dst_size.depth?dst_size.depth:src_size.depth;
+        tmp_dst_row_pitch = dst_size.width * tmp_format_desc->bytes_per_pixel;  /* bytes */
+        tmp_dst_slice_pitch = tmp_dst_row_pitch * dst_size.height; /* bytes */
+        tmp_dst_byte_size = tmp_dst_slice_pitch * tmp_depth;
+        tmp_dst_memory = HeapAlloc(GetProcessHeap(), 0, tmp_dst_byte_size);
+        TRACE("allocated memory %p size=%d\n", tmp_dst_memory, tmp_dst_byte_size);
+        if (!tmp_dst_memory)
+        {
+            hr = E_OUTOFMEMORY;
+            goto error;
+        }
+        tmp_memory = tmp_dst_memory;
+
+        /* Resize/Filtering */
+        switch (filter & 0xf) {
+            case D3DX_FILTER_NONE:
+                convert_argb_pixels(tmp_src_memory, tmp_src_row_pitch, tmp_src_slice_pitch, &src_size, tmp_format_desc,
+                                    tmp_dst_memory, tmp_dst_row_pitch, tmp_dst_slice_pitch, &dst_size,
+                                    tmp_format_desc, color_key, src_palette, dither);
+
+                break;
+            case D3DX_FILTER_TRIANGLE:
+                smooth_filter_argb_pixels(tmp_src_memory, tmp_src_row_pitch, tmp_src_slice_pitch, &src_size, tmp_format_desc,
+                                         tmp_dst_memory, tmp_dst_row_pitch, tmp_dst_slice_pitch, &dst_size,
+                                         tmp_format_desc, color_key);
+                break;
+            case D3DX_FILTER_POINT:
+            case D3DX_FILTER_BOX:
+            default:
+                point_filter_argb_pixels(tmp_src_memory, tmp_src_row_pitch, tmp_src_slice_pitch, &src_size, tmp_format_desc,
+                                         tmp_dst_memory, tmp_dst_row_pitch, tmp_dst_slice_pitch, &dst_size,
+                                         tmp_format_desc, color_key, src_palette);
+                break;
+        }
 
-        if ((filter & 0xf) == D3DX_FILTER_NONE)
+        src_addr = tmp_dst_memory;
+        tmp_memory = locked_box.pBits;
+        /* handle post-conversion from D3DFMT_A8R8G8B8 to dst_fmt*/
+        if (post_convert)
         {
-            convert_argb_pixels(src_memory, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
-                    locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, &dst_size, dst_format_desc, color_key,
-                    src_palette);
+            for (depth_i = 0; depth_i < tmp_depth; depth_i++)
+            {
+                if (!post_convert(src_addr, tmp_memory, tmp_dst_row_pitch, locked_box.RowPitch,
+                                  WINED3DFMT_B8G8R8A8_UNORM,
+                                  dst_size.width, dst_size.height))
+                {
+                    hr = E_FAIL;
+                    ERR("fail to post_convert\n");
+                    goto error;
+                }
+                src_addr += tmp_dst_slice_pitch;
+                tmp_memory += locked_box.SlicePitch / dst_format_desc->block_byte_count;
+            }
         }
         else
         {
-            if ((filter & 0xf) != D3DX_FILTER_POINT)
-                FIXME("Unhandled filter %#x.\n", filter);
-
-            point_filter_argb_pixels(src_addr, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
-                    locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, &dst_size, dst_format_desc, color_key,
-                    src_palette);
+            //convert from WINED3DFMT_B8G8R8A8_UNORM to dst_fmt if not DXTn
+            convert_argb_pixels(src_addr, tmp_dst_row_pitch, tmp_dst_slice_pitch, &dst_size, tmp_format_desc,
+                                locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch,
+                                &dst_size, dst_format_desc, color_key, src_palette, dither);
         }
 
+
+        TRACE("format converted from 0x%x to 0x%x\n",
+              src_format_desc->format, dst_format_desc->format);
+        
+    error:
+        if (tmp_dst_memory) {
+            //            TRACE("heap_free %p end at %p\n", tmp_dst_memory, tmp_memory);
+            HeapFree(GetProcessHeap(), 0, tmp_dst_memory);
+        }
+        if (tmp_src_memory) {
+            //            TRACE("heap_free %p end at %p\n", tmp_src_memory, tmp_memory);
+            HeapFree(GetProcessHeap(), 0, tmp_src_memory);
+        }
+        //        TRACE("UnlockBox\n");
         IDirect3DVolume9_UnlockBox(dst_volume);
     }
-
-    return D3D_OK;
+    //    TRACE("return %#x\n", hr);
+    return hr;
 }
 
 HRESULT WINAPI D3DXLoadVolumeFromFileInMemory(IDirect3DVolume9 *dst_volume,
@@ -325,3 +541,84 @@ HRESULT WINAPI D3DXLoadVolumeFromVolume(IDirect3DVolume9 *dst_volume,
     IDirect3DVolume9_UnlockBox(src_volume);
     return hr;
 }
+
+
+HRESULT WINAPI D3DXSaveVolumeToFileA(const char *dst_filename, D3DXIMAGE_FILEFORMAT file_format,
+                                     struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *src_palette, const D3DBOX *srcbox)
+{
+  int len;
+  WCHAR *filename;
+  HRESULT hr;
+  ID3DXBuffer *buffer;
+  
+  TRACE("(%s, %#x, %p, %p, %p): relay\n",
+        wine_dbgstr_a(dst_filename), file_format, srcvolume, src_palette, srcbox);
+  
+  if (!dst_filename) return D3DERR_INVALIDCALL;
+  
+  len = MultiByteToWideChar(CP_ACP, 0, dst_filename, -1, NULL, 0);
+  filename = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+  if (!filename) return E_OUTOFMEMORY;
+  MultiByteToWideChar(CP_ACP, 0, dst_filename, -1, filename, len);
+  
+  hr = D3DXSaveVolumeToFileInMemory(&buffer, file_format, srcvolume, src_palette, srcbox);
+  if (SUCCEEDED(hr))
+  {
+    hr = write_buffer_to_file(filename, buffer);
+    ID3DXBuffer_Release(buffer);
+  }
+  
+  HeapFree(GetProcessHeap(), 0, filename);
+  return hr;
+}
+
+HRESULT WINAPI D3DXSaveVolumeToFileW(const WCHAR *dst_filename, D3DXIMAGE_FILEFORMAT file_format,
+                                     struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *src_palette, const D3DBOX *srcbox)
+{
+  HRESULT hr;
+  ID3DXBuffer *buffer;
+  
+  TRACE("(%s, %#x, %p, %p, %p): relay\n",
+        wine_dbgstr_w(dst_filename), file_format, srcvolume, src_palette, srcbox);
+  
+  if (!dst_filename) return D3DERR_INVALIDCALL;
+  
+  hr = D3DXSaveVolumeToFileInMemory(&buffer, file_format, srcvolume, src_palette, srcbox);
+  if (SUCCEEDED(hr))
+  {
+    hr = write_buffer_to_file(dst_filename, buffer);
+    ID3DXBuffer_Release(buffer);
+  }
+  
+  return hr;
+}
+
+HRESULT WINAPI D3DXSaveVolumeToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE_FILEFORMAT file_format,
+                                           struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *src_palette, const D3DBOX *srcbox)
+{
+  TRACE("(%p, %#x, %p, %p, %p)\n",
+        dst_buffer, file_format, srcvolume, src_palette, srcbox);
+  
+  if (!dst_buffer || !srcvolume) return D3DERR_INVALIDCALL;
+  
+  if (src_palette)
+  {
+    FIXME("Saving volume with palettized pixel formats is not implemented yet\n");
+    return D3DERR_INVALIDCALL;
+  }
+  
+  switch (file_format)
+  {
+    case D3DXIFF_DDS:
+      return save_dds_volume_to_memory(dst_buffer, srcvolume, 1, srcbox); 
+    case D3DXIFF_HDR:
+    case D3DXIFF_PFM:
+    case D3DXIFF_TGA:
+    case D3DXIFF_PPM:
+      FIXME("File format %#x is not supported yet\n", file_format);
+      return E_NOTIMPL;
+    default:
+      return D3DERR_INVALIDCALL;
+  }
+}
+
diff --git a/dlls/d3dx9_36/xfile.c b/dlls/d3dx9_36/xfile.c
index eda0d7e..0f037c1 100644
--- a/dlls/d3dx9_36/xfile.c
+++ b/dlls/d3dx9_36/xfile.c
@@ -110,7 +110,7 @@ static ULONG WINAPI d3dx9_file_data_AddRef(ID3DXFileData *iface)
     struct d3dx9_file_data *file_data = impl_from_ID3DXFileData(iface);
     ULONG refcount = InterlockedIncrement(&file_data->ref);
 
-    TRACE("%p increasing refcount to %u.\n", file_data, refcount);
+//    TRACE("%p increasing refcount to %u.\n", file_data, refcount);
 
     return refcount;
 }
@@ -120,7 +120,7 @@ static ULONG WINAPI d3dx9_file_data_Release(ID3DXFileData *iface)
     struct d3dx9_file_data *file_data = impl_from_ID3DXFileData(iface);
     ULONG refcount = InterlockedDecrement(&file_data->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", file_data, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", file_data, refcount);
 
     if (!refcount)
     {
@@ -412,7 +412,7 @@ static ULONG WINAPI d3dx9_file_enum_object_AddRef(ID3DXFileEnumObject *iface)
     struct d3dx9_file_enum_object *file_enum = impl_from_ID3DXFileEnumObject(iface);
     ULONG refcount = InterlockedIncrement(&file_enum->ref);
 
-    TRACE("%p increasing refcount to %u.\n", file_enum, refcount);
+//    TRACE("%p increasing refcount to %u.\n", file_enum, refcount);
 
     return refcount;
 }
@@ -422,7 +422,7 @@ static ULONG WINAPI d3dx9_file_enum_object_Release(ID3DXFileEnumObject *iface)
     struct d3dx9_file_enum_object *file_enum = impl_from_ID3DXFileEnumObject(iface);
     ULONG refcount = InterlockedDecrement(&file_enum->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", file_enum, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", file_enum, refcount);
 
     if (!refcount)
     {
@@ -527,7 +527,7 @@ static ULONG WINAPI d3dx9_file_AddRef(ID3DXFile *iface)
     struct d3dx9_file *file = impl_from_ID3DXFile(iface);
     ULONG refcount = InterlockedIncrement(&file->ref);
 
-    TRACE("%p increasing refcount to %u.\n", file, refcount);
+//    TRACE("%p increasing refcount to %u.\n", file, refcount);
 
     return refcount;
 }
@@ -537,7 +537,7 @@ static ULONG WINAPI d3dx9_file_Release(ID3DXFile *iface)
     struct d3dx9_file *file = impl_from_ID3DXFile(iface);
     ULONG refcount = InterlockedDecrement(&file->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", file, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", file, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/dbghelp/path.c b/dlls/dbghelp/path.c
index 8c74426..d89ebab 100644
--- a/dlls/dbghelp/path.c
+++ b/dlls/dbghelp/path.c
@@ -17,7 +17,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #include <stdlib.h>
 #include <stdio.h>
@@ -547,6 +547,8 @@ static BOOL CALLBACK module_find_cb(PCWSTR buffer, PVOID user)
             struct pdb_lookup           pdb_lookup;
             char                        fn[MAX_PATH];
 
+          memset(&pdb_lookup, 0, sizeof(struct pdb_lookup));
+
             WideCharToMultiByte(CP_ACP, 0, buffer, -1, fn, MAX_PATH, NULL, NULL);
             pdb_lookup.filename = fn;
 
diff --git a/dlls/ddraw/main.c b/dlls/ddraw/main.c
index 06b448f..14f7842 100644
--- a/dlls/ddraw/main.c
+++ b/dlls/ddraw/main.c
@@ -20,7 +20,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #include "wine/port.h"
 
@@ -249,6 +249,11 @@ DDRAW_Create(const GUID *guid,
     {
         device_type = WINED3D_DEVICE_TYPE_HAL;
     }
+    else if(guid && guid->Data1 == 0xaeb2cdd4)
+    {
+      FIXME("call to 0xaeb2cdd4\n");
+      device_type = WINED3D_DEVICE_TYPE_HAL;
+    }
     else
     {
         device_type = 0;
@@ -611,7 +616,7 @@ static ULONG WINAPI ddraw_class_factory_AddRef(IClassFactory *iface)
     struct ddraw_class_factory *factory = impl_from_IClassFactory(iface);
     ULONG ref = InterlockedIncrement(&factory->ref);
 
-    TRACE("%p increasing refcount to %u.\n", factory, ref);
+//    TRACE("%p increasing refcount to %u.\n", factory, ref);
 
     return ref;
 }
@@ -631,7 +636,7 @@ static ULONG WINAPI ddraw_class_factory_Release(IClassFactory *iface)
     struct ddraw_class_factory *factory = impl_from_IClassFactory(iface);
     ULONG ref = InterlockedDecrement(&factory->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", factory, ref);
+//    TRACE("%p decreasing refcount to %u.\n", factory, ref);
 
     if (!ref)
         HeapFree(GetProcessHeap(), 0, factory);
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index 45c7594..a3becc9 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -20,7 +20,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #include "wine/port.h"
 
@@ -348,7 +348,7 @@ static ULONG WINAPI ddraw_surface7_AddRef(IDirectDrawSurface7 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface7(iface);
     ULONG refcount = InterlockedIncrement(&This->ref7);
 
-    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
     {
@@ -363,7 +363,7 @@ static ULONG WINAPI ddraw_surface4_AddRef(IDirectDrawSurface4 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface4(iface);
     ULONG refcount = InterlockedIncrement(&This->ref4);
 
-    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
+ //   TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
     {
@@ -378,7 +378,7 @@ static ULONG WINAPI ddraw_surface3_AddRef(IDirectDrawSurface3 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface3(iface);
     ULONG refcount = InterlockedIncrement(&This->ref3);
 
-    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
     {
@@ -393,7 +393,7 @@ static ULONG WINAPI ddraw_surface2_AddRef(IDirectDrawSurface2 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface2(iface);
     ULONG refcount = InterlockedIncrement(&This->ref2);
 
-    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
     {
@@ -408,7 +408,7 @@ static ULONG WINAPI ddraw_surface1_AddRef(IDirectDrawSurface *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface(iface);
     ULONG refcount = InterlockedIncrement(&This->ref1);
 
-    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
     {
@@ -423,7 +423,7 @@ static ULONG WINAPI ddraw_gamma_control_AddRef(IDirectDrawGammaControl *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawGammaControl(iface);
     ULONG refcount = InterlockedIncrement(&This->gamma_count);
 
-    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p increasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 1)
     {
@@ -437,7 +437,7 @@ static ULONG WINAPI d3d_texture2_AddRef(IDirect3DTexture2 *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture2(iface);
 
-    TRACE("iface %p.\n", iface);
+ //   TRACE("iface %p.\n", iface);
 
     return IUnknown_AddRef(surface->texture_outer);
 }
@@ -446,7 +446,7 @@ static ULONG WINAPI d3d_texture1_AddRef(IDirect3DTexture *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture(iface);
 
-    TRACE("iface %p.\n", iface);
+//    TRACE("iface %p.\n", iface);
 
     return IUnknown_AddRef(surface->texture_outer);
 }
@@ -541,7 +541,7 @@ static void ddraw_surface_cleanup(struct ddraw_surface *surface)
 ULONG ddraw_surface_release_iface(struct ddraw_surface *This)
 {
     ULONG iface_count = InterlockedDecrement(&This->iface_count);
-    TRACE("%p decreasing iface count to %u.\n", This, iface_count);
+//    TRACE("%p decreasing iface count to %u.\n", This, iface_count);
 
     if (iface_count == 0)
     {
@@ -599,7 +599,7 @@ static ULONG WINAPI ddraw_surface7_Release(IDirectDrawSurface7 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface7(iface);
     ULONG refcount = InterlockedDecrement(&This->ref7);
 
-    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 0)
     {
@@ -614,7 +614,7 @@ static ULONG WINAPI ddraw_surface4_Release(IDirectDrawSurface4 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface4(iface);
     ULONG refcount = InterlockedDecrement(&This->ref4);
 
-    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 0)
     {
@@ -629,7 +629,7 @@ static ULONG WINAPI ddraw_surface3_Release(IDirectDrawSurface3 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface3(iface);
     ULONG refcount = InterlockedDecrement(&This->ref3);
 
-    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 0)
     {
@@ -644,7 +644,7 @@ static ULONG WINAPI ddraw_surface2_Release(IDirectDrawSurface2 *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface2(iface);
     ULONG refcount = InterlockedDecrement(&This->ref2);
 
-    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 0)
     {
@@ -659,7 +659,7 @@ static ULONG WINAPI ddraw_surface1_Release(IDirectDrawSurface *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawSurface(iface);
     ULONG refcount = InterlockedDecrement(&This->ref1);
 
-    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 0)
     {
@@ -674,7 +674,7 @@ static ULONG WINAPI ddraw_gamma_control_Release(IDirectDrawGammaControl *iface)
     struct ddraw_surface *This = impl_from_IDirectDrawGammaControl(iface);
     ULONG refcount = InterlockedDecrement(&This->gamma_count);
 
-    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
+//    TRACE("iface %p decreasing refcount to %u.\n", iface, refcount);
 
     if (refcount == 0)
     {
@@ -688,7 +688,11 @@ static ULONG WINAPI d3d_texture2_Release(IDirect3DTexture2 *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture2(iface);
 
-    TRACE("iface %p.\n", iface);
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
+ //   TRACE("iface %p.\n", iface);
 
     return IUnknown_Release(surface->texture_outer);
 }
@@ -697,7 +701,11 @@ static ULONG WINAPI d3d_texture1_Release(IDirect3DTexture *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture(iface);
 
-    TRACE("iface %p.\n", iface);
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
+//    TRACE("iface %p.\n", iface);
 
     return IUnknown_Release(surface->texture_outer);
 }
@@ -737,6 +745,10 @@ static HRESULT WINAPI ddraw_surface7_GetAttachedSurface(IDirectDrawSurface7 *ifa
     DDSCAPS2 our_caps;
     int i;
 
+  if (!This) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, Caps, Surface);
 
     wined3d_mutex_lock();
@@ -823,6 +835,10 @@ static HRESULT WINAPI ddraw_surface4_GetAttachedSurface(IDirectDrawSurface4 *ifa
     IDirectDrawSurface7 *attachment7;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     hr = ddraw_surface7_GetAttachedSurface(&surface->IDirectDrawSurface7_iface,
@@ -849,6 +865,10 @@ static HRESULT WINAPI ddraw_surface3_GetAttachedSurface(IDirectDrawSurface3 *ifa
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -880,6 +900,10 @@ static HRESULT WINAPI ddraw_surface2_GetAttachedSurface(IDirectDrawSurface2 *ifa
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -911,6 +935,10 @@ static HRESULT WINAPI ddraw_surface1_GetAttachedSurface(IDirectDrawSurface *ifac
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -1040,6 +1068,10 @@ static HRESULT WINAPI ddraw_surface7_Lock(IDirectDrawSurface7 *iface,
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface7(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1058,6 +1090,10 @@ static HRESULT WINAPI ddraw_surface4_Lock(IDirectDrawSurface4 *iface, RECT *rect
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1078,6 +1114,10 @@ static HRESULT WINAPI ddraw_surface3_Lock(IDirectDrawSurface3 *iface, RECT *rect
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1104,6 +1144,10 @@ static HRESULT WINAPI ddraw_surface2_Lock(IDirectDrawSurface2 *iface, RECT *rect
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1129,6 +1173,10 @@ static HRESULT WINAPI ddraw_surface1_Lock(IDirectDrawSurface *iface, RECT *rect,
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1166,6 +1214,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_Unlock(IDirectDrawSurface
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface7(iface);
     HRESULT hr;
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, rect %s.\n", iface, wine_dbgstr_rect(pRect));
 
     wined3d_mutex_lock();
@@ -1181,6 +1233,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_Unlock(IDirectDrawSurface
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, rect %p.\n", iface, pRect);
 
     return ddraw_surface7_Unlock(&surface->IDirectDrawSurface7_iface, pRect);
@@ -1190,6 +1246,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_Unlock(IDirectDrawSurface
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
@@ -1200,6 +1260,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_Unlock(IDirectDrawSurface
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
@@ -1210,6 +1274,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_Unlock(IDirectDrawSurface
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
@@ -1225,10 +1293,14 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_Flip(IDirectDrawSurface7
     struct ddraw_texture *ddraw_texture, *prev_ddraw_texture;
     DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, {0}};
     struct wined3d_texture *texture;
-    IDirectDrawSurface7 *current;
+    IDirectDrawSurface7 *current = NULL;
     struct wined3d_surface *tmp;
     HRESULT hr;
 
+  if (!src_impl || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, src %p, flags %#x.\n", iface, src, flags);
 
     if (src == iface || !(dst_impl->surface_desc.ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_OVERLAY)))
@@ -1345,6 +1417,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_Flip(IDirectDrawSurface4
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface4(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1357,6 +1433,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_Flip(IDirectDrawSurface3
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface3(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1369,6 +1449,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_Flip(IDirectDrawSurface2
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface2(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1381,6 +1465,10 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_Flip(IDirectDrawSurface *
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -6239,6 +6327,11 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
     DDSURFACEDESC2 *desc = &surface->surface_desc;
     struct wined3d_resource_desc wined3d_desc;
     unsigned int version = texture->version;
+    UINT row_pitch, slice_pitch;
+    struct wined3d_resource *resource = wined3d_surface_get_resource(wined3d_surface);
+
+    wined3d_resource_get_pitch(resource, &row_pitch, &slice_pitch);
+
 
     surface->IDirectDrawSurface7_iface.lpVtbl = &ddraw_surface7_vtbl;
     surface->IDirectDrawSurface4_iface.lpVtbl = &ddraw_surface4_vtbl;
@@ -6269,7 +6362,7 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
     }
 
     *desc = texture->surface_desc;
-    wined3d_resource_get_desc(wined3d_surface_get_resource(wined3d_surface), &wined3d_desc);
+    wined3d_resource_get_desc(resource, &wined3d_desc);
     desc->dwWidth = wined3d_desc.width;
     desc->dwHeight = wined3d_desc.height;
     surface->first_attached = surface;
@@ -6279,14 +6372,16 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
         if (desc->dwFlags & DDSD_LPSURFACE)
             desc->u1.dwLinearSize = ~0u;
         else
-            desc->u1.dwLinearSize = wined3d_surface_get_pitch(wined3d_surface) * ((desc->dwHeight + 3) / 4);
+        {
+            desc->u1.dwLinearSize = row_pitch * ((desc->dwHeight + 3) / 4);
+        }
         desc->dwFlags |= DDSD_LINEARSIZE;
         desc->dwFlags &= ~(DDSD_LPSURFACE | DDSD_PITCH);
     }
     else
     {
         if (!(desc->dwFlags & DDSD_LPSURFACE))
-            desc->u1.lPitch = wined3d_surface_get_pitch(wined3d_surface);
+            desc->u1.lPitch = row_pitch;
         desc->dwFlags |= DDSD_PITCH;
         desc->dwFlags &= ~(DDSD_LPSURFACE | DDSD_LINEARSIZE);
     }
diff --git a/dlls/dinput/joystick_osx.c b/dlls/dinput/joystick_osx.c
index 6a8926d..e910c1d 100644
--- a/dlls/dinput/joystick_osx.c
+++ b/dlls/dinput/joystick_osx.c
@@ -19,7 +19,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #include "wine/port.h"
 
@@ -702,7 +702,7 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
         for ( idx = 0; idx < cnt; idx++ )
         {
             IOHIDValueRef valueRef;
-            int val, oldVal, newVal;
+            int val, oldVal = 0, newVal;
             IOHIDElementRef element = ( IOHIDElementRef ) CFArrayGetValueAtIndex( device->elements, idx );
             int type = IOHIDElementGetType( element );
 
diff --git a/dlls/ieframe/client.c b/dlls/ieframe/client.c
index dadbe13..4ea35b8 100644
--- a/dlls/ieframe/client.c
+++ b/dlls/ieframe/client.c
@@ -15,7 +15,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include <stdio.h>
 
 #include "ieframe.h"
@@ -297,6 +297,9 @@ static HRESULT WINAPI InPlaceSite_OnInPlaceActivateEx(IOleInPlaceSiteEx *iface,
     TRACE("(%p)->(%p, %x)\n", This, pfNoRedraw, dwFlags);
 
     /* FIXME: Avoid redraw, when possible */
+    if (!pfNoRedraw) {
+      return S_OK;
+    }
     *pfNoRedraw = FALSE;
 
     if (dwFlags) {
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 89ae5c4..d481c50 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -1102,6 +1102,8 @@ static DWORD WINAPI start_process( PEB *peb )
         DPRINTF( "%04x:Starting process %s (entryproc=%p)\n", GetCurrentThreadId(),
                  debugstr_w(peb->ProcessParameters->ImagePathName.Buffer), entry );
 
+    FIXME("Wine XSherry %s is a testing version based on WineHQ.\n", wine_get_version());
+
     SetLastError( 0 );  /* clear error code */
     if (peb->BeingDebugged) DbgBreakPoint();
     return call_process_entry( peb, entry );
diff --git a/dlls/krnl386.exe16/int2f.c b/dlls/krnl386.exe16/int2f.c
index f5b5aaa..a62dbaf 100644
--- a/dlls/krnl386.exe16/int2f.c
+++ b/dlls/krnl386.exe16/int2f.c
@@ -20,7 +20,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 
 #include <string.h>
@@ -1027,8 +1027,8 @@ static void MSCDEX_Handler(CONTEXT* context)
                ERR("ES:BX==0 ! SEGFAULT ?\n");
                ERR("-->BX=0x%04x, ES=0x%04x, DS=0x%04x, CX=0x%04x\n",
                    BX_reg(context), context->SegEs, context->SegDs, CX_reg(context));
-               driver_request[4] |= 0x80;
-               driver_request[3] = 5;  /* bad request length */
+   //            driver_request[4] |= 0x80;
+   //            driver_request[3] = 5;  /* bad request length */
                return;
            }
 
diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
index 4faafe9..ba2ba0f 100644
--- a/dlls/ntdll/directory.c
+++ b/dlls/ntdll/directory.c
@@ -1860,12 +1860,11 @@ static int read_directory_getdirentries( int fd, IO_STATUS_BLOCK *io, void *buff
                                          BOOLEAN restart_scan, FILE_INFORMATION_CLASS class )
 {
     long restart_pos;
-    ULONG_PTR restart_info_pos = 0;
     size_t size, initial_size = length;
-    int res, fake_dot_dot = 1;
+    int res, fake_dot_dot = 1, stop_get = 0;
     char *data, local_buffer[8192];
     struct dirent *de;
-    union file_directory_info *info, *last_info = NULL, *restart_last_info = NULL;
+    union file_directory_info *info, *last_info = NULL;
 
     size = initial_size;
     data = local_buffer;
@@ -1919,9 +1918,6 @@ static int read_directory_getdirentries( int fd, IO_STATUS_BLOCK *io, void *buff
             if ((info = append_entry( buffer, io, length, "..", NULL, mask, class )))
                 last_info = info;
 
-            restart_last_info = last_info;
-            restart_info_pos = io->Information;
-
             /* check if we still have enough space for the largest possible entry */
             if (last_info && io->Information + max_dir_info_size(class) > length)
             {
@@ -1931,54 +1927,41 @@ static int read_directory_getdirentries( int fd, IO_STATUS_BLOCK *io, void *buff
         }
     }
 
-    while (res > 0)
+    do
     {
-        res -= dir_reclen(de);
-        if (de->d_fileno &&
-            !(fake_dot_dot && (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." ))) &&
-            ((info = append_entry( buffer, io, length, de->d_name, NULL, mask, class ))))
+        while ((char *)de - data < res && !stop_get)
         {
-            last_info = info;
-            if (io->u.Status == STATUS_BUFFER_OVERFLOW)
+            if (de->d_fileno &&
+                !(fake_dot_dot && (!strcmp( de->d_name, "." ) || !strcmp( de->d_name, ".." ))) &&
+                ((info = append_entry( buffer, io, length, de->d_name, NULL, mask, class ))))
             {
-                lseek( fd, (unsigned long)restart_pos, SEEK_SET );
-                if (restart_info_pos)  /* if we have a complete read already, return it */
+                last_info = info;
+                if (io->u.Status == STATUS_BUFFER_OVERFLOW)
                 {
-                    io->u.Status = STATUS_SUCCESS;
-                    io->Information = restart_info_pos;
-                    last_info = restart_last_info;
-                    break;
+                    stop_get = 1;
+                    break; /* do not update de as the current entry was not added */
                 }
-                /* otherwise restart from the start with a smaller size */
-                size = (char *)de - data;
-                if (!size) break;
-                io->Information = 0;
-                last_info = NULL;
-                goto restart;
-            }
-            if (!has_wildcard( mask )) break;
-            /* if we have to return but the buffer contains more data, restart with a smaller size */
-            if (res > 0 && (single_entry || io->Information + max_dir_info_size(class) > length))
-            {
-                lseek( fd, (unsigned long)restart_pos, SEEK_SET );
-                size = (char *)de + dir_reclen(de) - data;
-                io->Information = restart_info_pos;
-                last_info = restart_last_info;
-                goto restart;
+                /* FIXME: why is this here and not in read_directory_readdir or read_directory_getdents? */
+                if (!has_wildcard( mask )) break;
+
+                if (single_entry || io->Information + max_dir_info_size(class) > length) stop_get = 1;
             }
+            /* move on to the next entry */
+            de = (struct dirent *)((char *)de + dir_reclen(de));
         }
-        /* move on to the next entry */
-        if (res > 0)
+        if (!stop_get)
         {
-            de = (struct dirent *)((char *)de + dir_reclen(de));
-            continue;
+            res = wine_getdirentries( fd, data, size, &restart_pos );
+            de = (struct dirent *)data;
         }
-        if (size < initial_size) break;  /* already restarted once, give up now */
-        restart_last_info = last_info;
-        restart_info_pos = io->Information;
-    restart:
-        res = wine_getdirentries( fd, data, size, &restart_pos );
-        de = (struct dirent *)data;
+    } 
+    while (res > 0 && !stop_get);
+
+    /* Rewind fd to resume at the current de */
+    if (stop_get && (char *)de - data < res)
+    {
+        lseek( fd, restart_pos, SEEK_SET);
+        wine_getdirentries( fd, data, (char *)de - data, &restart_pos );
     }
 
     if (last_info) last_info->next = 0;
diff --git a/dlls/secur32/schannel_macosx.c b/dlls/secur32/schannel_macosx.c
index cfd2371..c71189c 100644
--- a/dlls/secur32/schannel_macosx.c
+++ b/dlls/secur32/schannel_macosx.c
@@ -1016,6 +1016,7 @@ BOOL schan_imp_init(void)
     supported_protocols = SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_TLS1_0_CLIENT;
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
+#ifdef   SSLGetProtocolVersionMax
     if(SSLGetProtocolVersionMax != NULL) {
         SSLProtocol max_protocol;
         SSLContextRef ctx;
@@ -1036,6 +1037,7 @@ BOOL schan_imp_init(void)
         }
     }
 #endif
+#endif
 
     return TRUE;
 }
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index 33016a1..3621b64 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -284,18 +284,26 @@ BOOL WINAPI EnumDisplayDevicesA( LPCSTR lpDevice, DWORD i, LPDISPLAY_DEVICEA lpD
 BOOL WINAPI EnumDisplayDevicesW( LPCWSTR lpDevice, DWORD i, LPDISPLAY_DEVICEW lpDisplayDevice,
                                  DWORD dwFlags )
 {
-    FIXME("(%s,%d,%p,0x%08x), stub!\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
+    if (!lpDisplayDevice) {
+        return FALSE;
+    }
 
-    if (i)
+    if (i) {
+        FIXME("(%s,%d,%p,0x%08x), stub!\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
         return FALSE;
+    }
 
-    memcpy(lpDisplayDevice->DeviceName, primary_device_name, sizeof(primary_device_name));
-    memcpy(lpDisplayDevice->DeviceString, primary_device_string, sizeof(primary_device_string));
-  
     lpDisplayDevice->StateFlags =
-        DISPLAY_DEVICE_ATTACHED_TO_DESKTOP |
-        DISPLAY_DEVICE_PRIMARY_DEVICE |
-        DISPLAY_DEVICE_VGA_COMPATIBLE;
+      DISPLAY_DEVICE_ATTACHED_TO_DESKTOP |
+      DISPLAY_DEVICE_VGA_COMPATIBLE;
+
+    if (!lpDevice) {
+        lpDisplayDevice->StateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+        memcpy(lpDisplayDevice->DeviceName, primary_device_name, sizeof(primary_device_name));
+    } else {
+        strcpyW(lpDisplayDevice->DeviceName, lpDevice);
+    }
+    memcpy(lpDisplayDevice->DeviceString, primary_device_string, sizeof(primary_device_string));
 
     if(lpDisplayDevice->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(lpDisplayDevice->DeviceID))
         memcpy(lpDisplayDevice->DeviceID, primary_device_deviceid, sizeof(primary_device_deviceid));
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 87bc97b..a52ae72 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -17,7 +17,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #include "wine/port.h"
 
@@ -55,6 +55,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION surfaces_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+/* from dlls/ntdll/actctx.c */
+struct wndclass_redirect_data
+{
+    ULONG size;
+    DWORD res;
+    ULONG name_len;
+    ULONG name_offset;
+    ULONG module_len;
+    ULONG module_offset;
+};
+
 /**********************************************************************/
 
 /* helper for Get/SetWindowLong */
@@ -1293,6 +1304,39 @@ static void dump_window_styles( DWORD style, DWORD exstyle )
 #undef DUMPED_EX_STYLES
 }
 
+static BOOL get_redir_class_name(LPCWSTR className, LPWSTR redirClassName, int len)
+{
+    ATOM classatom;
+    ACTCTX_SECTION_KEYED_DATA askd;
+    WCHAR classNameStr[256];
+    struct wndclass_redirect_data* wcrd;
+
+    classatom = get_int_atom_value(className);
+    if (classatom)
+        GlobalGetAtomNameW(classatom, classNameStr, sizeof(classNameStr) / sizeof(*classNameStr));
+    else
+        strcpyW(classNameStr, className);
+
+    askd.cbSize = sizeof(askd);
+    if (FindActCtxSectionStringW(0, NULL, ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, classNameStr, &askd)) {
+        wcrd = askd.lpData;
+
+        if (wcrd->name_len == 0)
+            return FALSE;
+
+        if (wcrd->name_len > len) {
+            WARN("Redirected class name too long for buffer\n");
+            return FALSE;
+        }
+
+        memcpy(redirClassName, (unsigned char*)askd.lpData + wcrd->name_offset, wcrd->name_len);
+        redirClassName[wcrd->name_len / sizeof(WCHAR)] = 0;
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
 
 /***********************************************************************
  *           WIN_CreateWindowEx
@@ -1309,6 +1353,7 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     MDICREATESTRUCTW mdi_cs;
     CBT_CREATEWNDW cbtc;
     CREATESTRUCTW cbcs;
+    WCHAR redirClassName[256];
 
     TRACE("%s %s ex=%08x style=%08x %d,%d %dx%d parent=%p menu=%p inst=%p params=%p\n",
           unicode ? debugstr_w(cs->lpszName) : debugstr_a((LPCSTR)cs->lpszName),
@@ -1445,6 +1490,23 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
 
     /* Create the window structure */
 
+    wndPtr = NULL;
+
+    if (get_redir_class_name(className, redirClassName, sizeof(redirClassName)))
+    {
+        WNDCLASSW wc;
+
+        TRACE("Redirecting %s to %s\n", debugstr_w(className), debugstr_w(redirClassName));
+
+        wndPtr = create_window_handle( parent, owner, redirClassName, module, unicode );
+
+        if (GetLastError() == ERROR_INVALID_HANDLE && GetClassInfoW( 0, redirClassName, &wc ))
+            wndPtr = create_window_handle( parent, owner, redirClassName, module, unicode );
+
+        if (!wndPtr)
+            WARN("Could not create window of class %s\n", debugstr_w(redirClassName));
+    }
+
     if (!(wndPtr = create_window_handle( parent, owner, className, module, unicode )))
     {
         WNDCLASSW wc;
diff --git a/dlls/windowscodecs/stream.c b/dlls/windowscodecs/stream.c
index d05e940..5d24cc1 100644
--- a/dlls/windowscodecs/stream.c
+++ b/dlls/windowscodecs/stream.c
@@ -15,7 +15,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "wine/debug.h"
 
 #define COBJMACROS
@@ -1021,7 +1021,7 @@ HRESULT stream_initialize_from_filehandle(IWICStream *iface, HANDLE file)
     StreamOnFileHandle *pObject;
     IWICStream *stream = NULL;
     HANDLE map;
-    void *mem;
+    void *mem = NULL;
     LARGE_INTEGER size;
     HRESULT hr;
     TRACE("(%p,%p)\n", iface, file);
diff --git a/dlls/wined3d/Makefile.in b/dlls/wined3d/Makefile.in
index 655800b..7e81975 100644
--- a/dlls/wined3d/Makefile.in
+++ b/dlls/wined3d/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	device.c \
 	directx.c \
 	drawprim.c \
+	dxtn.c \
 	gl_compat.c \
 	glsl_shader.c \
 	nvidia_texture_shader.c \
@@ -26,6 +27,8 @@ C_SRCS = \
 	surface.c \
 	swapchain.c \
 	texture.c \
+  	txc_compress_dxtn.c \
+  	txc_fetch_dxtn.c \
 	utils.c \
 	vertexdeclaration.c \
 	view.c \
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 0e8b32b..4a6e0c6 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1239,18 +1239,22 @@ void context_invalidate_state(struct wined3d_context *context, DWORD state)
 }
 
 /* This function takes care of wined3d pixel format selection. */
-static int context_choose_pixel_format(const struct wined3d_device *device, HDC hdc,
-        const struct wined3d_format *color_format, const struct wined3d_format *ds_format,
+static int context_choose_pixel_format(const struct wined3d_device *device, const struct wined3d_swapchain *swapchain,
+        HDC hdc, const struct wined3d_format *color_format, const struct wined3d_format *ds_format,
         BOOL auxBuffers, BOOL findCompatible)
 {
     int iPixelFormat=0;
     unsigned int current_value;
     unsigned int cfg_count = device->adapter->cfg_count;
+    BOOL double_buffer = TRUE;
     unsigned int i;
 
     TRACE("device %p, dc %p, color_format %s, ds_format %s, aux_buffers %#x, find_compatible %#x.\n",
             device, hdc, debug_d3dformat(color_format->id), debug_d3dformat(ds_format->id),
             auxBuffers, findCompatible);
+            
+    if (wined3d_settings.offscreen_rendering_mode == ORM_FBO && !swapchain->desc.backbuffer_count)
+        double_buffer = FALSE;
 
     current_value = 0;
     for (i = 0; i < cfg_count; ++i)
@@ -1263,7 +1267,7 @@ static int context_choose_pixel_format(const struct wined3d_device *device, HDC
         if (cfg->iPixelType != WGL_TYPE_RGBA_ARB)
             continue;
         /* In window mode we need a window drawable format and double buffering. */
-        if (!(cfg->windowDrawable && cfg->doubleBuffer))
+        if (!cfg->windowDrawable || (double_buffer && !cfg->doubleBuffer))
             continue;
         if (cfg->redSize < color_format->red_size)
             continue;
@@ -1286,17 +1290,19 @@ static int context_choose_pixel_format(const struct wined3d_device *device, HDC
          * depth it is no problem to emulate 16-bit using e.g. 24-bit, so accept that. */
         if (cfg->depthSize == ds_format->depth_size)
             value += 1;
-        if (cfg->stencilSize == ds_format->stencil_size)
+        if (!cfg->doubleBuffer == !double_buffer)
             value += 2;
-        if (cfg->alphaSize == color_format->alpha_size)
+        if (cfg->stencilSize == ds_format->stencil_size)
             value += 4;
+        if (cfg->alphaSize == color_format->alpha_size)
+            value += 8;
         /* We like to have aux buffers in backbuffer mode */
         if (auxBuffers && cfg->auxBuffers)
-            value += 8;
+            value += 16;
         if (cfg->redSize == color_format->red_size
                 && cfg->greenSize == color_format->green_size
                 && cfg->blueSize == color_format->blue_size)
-            value += 16;
+            value += 32;
 
         if (value > current_value)
         {
@@ -1317,7 +1323,9 @@ static int context_choose_pixel_format(const struct wined3d_device *device, HDC
         ZeroMemory(&pfd, sizeof(pfd));
         pfd.nSize      = sizeof(pfd);
         pfd.nVersion   = 1;
-        pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DOUBLEBUFFER | PFD_DRAW_TO_WINDOW;/*PFD_GENERIC_ACCELERATED*/
+        pfd.dwFlags    = PFD_SUPPORT_OPENGL | PFD_DRAW_TO_WINDOW;/*PFD_GENERIC_ACCELERATED*/
+        if (double_buffer)
+            pfd.dwFlags |= PFD_DOUBLEBUFFER;
         pfd.iPixelType = PFD_TYPE_RGBA;
         pfd.cAlphaBits = color_format->alpha_size;
         pfd.cColorBits = color_format->red_size + color_format->green_size
@@ -1573,13 +1581,13 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     }
 
     /* Try to find a pixel format which matches our requirements. */
-    pixel_format = context_choose_pixel_format(device, hdc, color_format, ds_format, auxBuffers, FALSE);
+    pixel_format = context_choose_pixel_format(device, swapchain, hdc, color_format, ds_format, auxBuffers, FALSE);
 
     /* Try to locate a compatible format if we weren't able to find anything. */
     if (!pixel_format)
     {
         TRACE("Trying to locate a compatible pixel format because an exact match failed.\n");
-        pixel_format = context_choose_pixel_format(device, hdc, color_format, ds_format, auxBuffers, TRUE);
+        pixel_format = context_choose_pixel_format(device, swapchain, hdc, color_format, ds_format, auxBuffers, TRUE);
     }
 
     /* If we still don't have a pixel format, something is very wrong as ChoosePixelFormat barely fails */
@@ -3138,7 +3146,7 @@ static void context_bind_shader_resources(struct wined3d_context *context, const
 
             if (!(view = state->shader_resource_view[shader_types[i].type][entry->resource_idx]))
             {
-                WARN("No resource view bound at index %u, %u.\n", shader_types[i].type, entry->resource_idx);
+                //  WARN("No resource view bound at index %u, %u.\n", shader_types[i].type, entry->resource_idx);  //Slice - legion times
                 continue;
             }
 
@@ -3150,7 +3158,7 @@ static void context_bind_shader_resources(struct wined3d_context *context, const
 
             if (!(sampler = state->sampler[shader_types[i].type][entry->sampler_idx]))
             {
-                WARN("No sampler object bound at index %u, %u.\n", shader_types[i].type, entry->sampler_idx);
+                //  WARN("No sampler object bound at index %u, %u.\n", shader_types[i].type, entry->sampler_idx);
                 continue;
             }
 
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 170536d..a384d3d 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -479,7 +479,7 @@ ULONG CDECL wined3d_device_incref(struct wined3d_device *device)
 {
     ULONG refcount = InterlockedIncrement(&device->ref);
 
-    TRACE("%p increasing refcount to %u.\n", device, refcount);
+//    TRACE("%p increasing refcount to %u.\n", device, refcount);
 
     return refcount;
 }
@@ -495,7 +495,7 @@ ULONG CDECL wined3d_device_decref(struct wined3d_device *device)
 {
     ULONG refcount = InterlockedDecrement(&device->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", device, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", device, refcount);
 
     if (!refcount)
     {
@@ -519,11 +519,11 @@ ULONG CDECL wined3d_device_decref(struct wined3d_device *device)
         {
             struct wined3d_resource *resource;
 
-            FIXME("Device released with resources still bound, acceptable but unexpected.\n");
+            WARN("Device released with resources still bound, acceptable but unexpected.\n");
 
             LIST_FOR_EACH_ENTRY(resource, &device->resources, struct wined3d_resource, resource_list_entry)
             {
-                FIXME("Leftover resource %p with type %s (%#x).\n",
+                TRACE("Leftover resource %p with type %s (%#x).\n",
                         resource, debug_d3dresourcetype(resource->type), resource->type);
             }
         }
@@ -3473,21 +3473,27 @@ static HRESULT device_update_volume(struct wined3d_device *device,
     TRACE("device %p, src_volume %p, dst_volume %p.\n",
             device, src_volume, dst_volume);
 
-    if (src_volume->resource.format != dst_volume->resource.format)
+    if (src_volume->resource.format->id != dst_volume->resource.format->id)
     {
-        FIXME("Source and destination formats do not match.\n");
+        FIXME("Source %x and destination %x formats do not match.\n",
+              src_volume->resource.format->id, dst_volume->resource.format->id);
+        //Slice - convert?
         return WINED3DERR_INVALIDCALL;
     }
     if (src_volume->resource.width != dst_volume->resource.width
             || src_volume->resource.height != dst_volume->resource.height
             || src_volume->resource.depth != dst_volume->resource.depth)
     {
-        FIXME("Source and destination sizes do not match.\n");
+        FIXME("Source (%d, %d, %d) and destination (%d, %d, %d) sizes do not match.\n",
+              src_volume->resource.width, src_volume->resource.height, src_volume->resource.depth, 
+              dst_volume->resource.width, dst_volume->resource.height, dst_volume->resource.depth);
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY)))
+  if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY))) {
+      FIXME("wined3d_volume_map failed\n");
         return hr;
+  }
 
     context = context_acquire(device, NULL);
 
@@ -3543,8 +3549,14 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    level_count = min(wined3d_texture_get_level_count(src_texture),
-            wined3d_texture_get_level_count(dst_texture));
+    /* Check that both textures have the compatible numbers of levels. */
+    //Slice
+    level_count = wined3d_texture_get_level_count(dst_texture);
+    if (wined3d_texture_get_level_count(src_texture) < level_count)
+    {
+        WARN("Source has fewer level counts then destination, returning WINED3DERR_INVALIDCALL.\n");
+        return  WINED3DERR_INVALIDCALL;
+    }
 
     src_size = max(src_texture->resource.width, src_texture->resource.height);
     dst_size = max(dst_texture->resource.width, dst_texture->resource.height);
@@ -3558,7 +3570,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         src_size >>= 1;
         ++src_skip_levels;
     }
-
+	if (src_skip_levels) FIXME("skip %d levels\n", src_skip_levels);
     /* Make sure that the destination texture is loaded. */
     context = context_acquire(device, NULL);
     wined3d_texture_load(dst_texture, context, FALSE);
@@ -3617,6 +3629,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         {
             for (i = 0; i < level_count; ++i)
             {
+            //Slice - make here surface from volume? Or implement decompress?
                 hr = device_update_volume(device,
                         volume_from_resource(wined3d_texture_get_sub_resource(src_texture,
                                 i + src_skip_levels)),
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 1a7d837..47f41e4 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -112,6 +112,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_color_buffer_float",           ARB_COLOR_BUFFER_FLOAT        },
     {"GL_ARB_debug_output",                 ARB_DEBUG_OUTPUT              },
     {"GL_ARB_depth_buffer_float",           ARB_DEPTH_BUFFER_FLOAT        },
+    {"GL_ARB_depth_clamp",                  ARB_DEPTH_CLAMP               },
     {"GL_ARB_depth_texture",                ARB_DEPTH_TEXTURE             },
     {"GL_ARB_draw_buffers",                 ARB_DRAW_BUFFERS              },
     {"GL_ARB_draw_elements_base_vertex",    ARB_DRAW_ELEMENTS_BASE_VERTEX },
@@ -137,6 +138,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_provoking_vertex",             ARB_PROVOKING_VERTEX          },
     {"GL_ARB_sampler_objects",              ARB_SAMPLER_OBJECTS           },
     {"GL_ARB_shader_bit_encoding",          ARB_SHADER_BIT_ENCODING       },
+    {"GL_ARB_shader_objects",               ARB_SHADER_OBJECTS            },
     {"GL_ARB_shader_texture_lod",           ARB_SHADER_TEXTURE_LOD        },
     {"GL_ARB_shading_language_100",         ARB_SHADING_LANGUAGE_100      },
     {"GL_ARB_shadow",                       ARB_SHADOW                    },
@@ -145,6 +147,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_texture_compression",          ARB_TEXTURE_COMPRESSION       },
     {"GL_ARB_texture_compression_rgtc",     ARB_TEXTURE_COMPRESSION_RGTC  },
     {"GL_ARB_texture_cube_map",             ARB_TEXTURE_CUBE_MAP          },
+    {"GL_ARB_texture_env_add",              ARB_TEXTURE_ENV_ADD           },
     {"GL_ARB_texture_env_combine",          ARB_TEXTURE_ENV_COMBINE       },
     {"GL_ARB_texture_env_dot3",             ARB_TEXTURE_ENV_DOT3          },
     {"GL_ARB_texture_float",                ARB_TEXTURE_FLOAT             },
@@ -183,6 +186,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_gpu_program_parameters",       EXT_GPU_PROGRAM_PARAMETERS    },
     {"GL_EXT_gpu_shader4",                  EXT_GPU_SHADER4               },
     {"GL_EXT_packed_depth_stencil",         EXT_PACKED_DEPTH_STENCIL      },
+    {"GL_EXT_paletted_texture",             EXT_PALETTED_TEXTURE          },//ns
     {"GL_EXT_point_parameters",             EXT_POINT_PARAMETERS          },
     {"GL_EXT_provoking_vertex",             EXT_PROVOKING_VERTEX          },
     {"GL_EXT_secondary_color",              EXT_SECONDARY_COLOR           },
@@ -191,6 +195,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_texture3D",                    EXT_TEXTURE3D                 },
     {"GL_EXT_texture_compression_rgtc",     EXT_TEXTURE_COMPRESSION_RGTC  },
     {"GL_EXT_texture_compression_s3tc",     EXT_TEXTURE_COMPRESSION_S3TC  },
+    {"GL_EXT_texture_env_add",              EXT_TEXTURE_ENV_ADD           },
     {"GL_EXT_texture_env_combine",          EXT_TEXTURE_ENV_COMBINE       },
     {"GL_EXT_texture_env_dot3",             EXT_TEXTURE_ENV_DOT3          },
     {"GL_EXT_texture_filter_anisotropic",   EXT_TEXTURE_FILTER_ANISOTROPIC},
@@ -202,6 +207,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_vertex_array_bgra",            EXT_VERTEX_ARRAY_BGRA         },
 
     /* NV */
+    {"GL_NV_depth_clamp",                   NV_DEPTH_CLAMP                },
     {"GL_NV_fence",                         NV_FENCE                      },
     {"GL_NV_fog_distance",                  NV_FOG_DISTANCE               },
     {"GL_NV_fragment_program",              NV_FRAGMENT_PROGRAM           },
@@ -221,6 +227,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_NV_vertex_program2",               NV_VERTEX_PROGRAM2            },
     {"GL_NV_vertex_program2_option",        NV_VERTEX_PROGRAM2_OPTION     },
     {"GL_NV_vertex_program3",               NV_VERTEX_PROGRAM3            },
+    {"GL_NVX_gpu_memory_info",              NVX_GPU_MEMORY_INFO           },
 
     /* SGI */
     {"GL_SGIS_generate_mipmap",             SGIS_GENERATE_MIPMAP          },
@@ -231,6 +238,7 @@ static const struct wined3d_extension_map wgl_extension_map[] =
     {"WGL_ARB_pixel_format",                WGL_ARB_PIXEL_FORMAT             },
     {"WGL_EXT_swap_control",                WGL_EXT_SWAP_CONTROL             },
     {"WGL_WINE_pixel_format_passthrough",   WGL_WINE_PIXEL_FORMAT_PASSTHROUGH},
+    {"WGL_WINE_gpu_info",                   WGL_WINE_GPU_INFO                },
 };
 
 /**********************************************************
@@ -406,7 +414,7 @@ ULONG CDECL wined3d_incref(struct wined3d *wined3d)
 {
     ULONG refcount = InterlockedIncrement(&wined3d->ref);
 
-    TRACE("%p increasing refcount to %u.\n", wined3d, refcount);
+//    TRACE("%p increasing refcount to %u.\n", wined3d, refcount);
 
     return refcount;
 }
@@ -415,7 +423,7 @@ ULONG CDECL wined3d_decref(struct wined3d *wined3d)
 {
     ULONG refcount = InterlockedDecrement(&wined3d->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", wined3d, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", wined3d, refcount);
 
     if (!refcount)
     {
@@ -616,6 +624,47 @@ static BOOL match_not_dx10_capable(const struct wined3d_gl_info *gl_info, const
     return !match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device);
 }
 
+
+static BOOL match_apple_broken_uniforms(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+                                        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+  const char *sysrelease;
+  unsigned int major, minor, ret;
+  void (CDECL *my_wine_get_host_version)(const char **sysname, const char **release);
+
+  /* MacOS dx9 GPU drivers more GLSL vertex shader uniforms than supported by the hardware, and if
+   * more are used it falls back to software. While the compiler can detect if the shader uses all
+   * declared uniforms, the optimization fails if the shader uses relative addressing. So any GLSL
+   * shader using relative addressing falls back to software.
+   *
+   * ARB vp gives the correct amount of uniforms, so use it instead of GLSL.
+   *
+   * In addition, AMD Radeon HD GPUs advertise > 256 constants and can support this in HW, but the
+   * driver nevertheless falls back to software if more than 256 are used. This is fixed in MacOS
+   * 10.8.3 */
+
+  /* Non-Apple GL vendors report uniforms correctly */
+  if (!match_apple(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return FALSE;
+  /* All dx9 cards are overreported on OSX */
+  if (!match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return TRUE;
+  /* Nvidia and Intel DX10 cards support > 256 uniforms */
+  if (card_vendor != HW_VENDOR_AMD) return FALSE;
+
+  /* On OSX 10.8.3 and later, AMD GPUs support more than 256 constants. This OSX version reports
+   * uname -r "12.3.0" */
+  my_wine_get_host_version = (void *)GetProcAddress(GetModuleHandleA("ntdll.dll"), "wine_get_host_version");
+  if (!my_wine_get_host_version) return FALSE;
+
+  my_wine_get_host_version(NULL, &sysrelease);
+  ret = sscanf(sysrelease, "%u.%u", &major, &minor);
+  TRACE("host version %s\n", sysrelease);
+  if (ret != 2) return FALSE; /* String format changed, assume workaround not needed */
+  if (major > 12) return FALSE;
+  if (major == 12 && minor >= 3) return FALSE;
+
+  return TRUE;
+}
+
 /* A GL context is provided by the caller */
 static BOOL match_allows_spec_alpha(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
@@ -770,6 +819,18 @@ static BOOL match_fglrx(const struct wined3d_gl_info *gl_info, const char *gl_re
     return gl_vendor == GL_VENDOR_FGLRX;
 }
 
+static void quirk_arb_constants(struct wined3d_gl_info *gl_info)
+{
+    TRACE("Using ARB vs constant limit(%u->%u) for GLSL.\n", 
+    gl_info->limits.glsl_vs_float_constants,
+    gl_info->limits.arb_vs_native_constants);
+    gl_info->limits.glsl_vs_float_constants = gl_info->limits.arb_vs_native_constants;
+    TRACE("Using ARB ps constant limit(%u->%u) for GLSL.\n",
+    gl_info->limits.glsl_ps_float_constants,
+    gl_info->limits.arb_ps_native_constants);
+    gl_info->limits.glsl_ps_float_constants = gl_info->limits.arb_ps_native_constants;
+}
+
 static BOOL match_r200(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -875,11 +936,24 @@ static BOOL match_broken_arb_fog(const struct wined3d_gl_info *gl_info, const ch
 
 static void quirk_apple_glsl_constants(struct wined3d_gl_info *gl_info)
 {
+    static UINT once;
     /* MacOS needs uniforms for relative addressing offsets. This can accumulate to quite a few uniforms.
      * Beyond that the general uniform isn't optimal, so reserve a number of uniforms. 12 vec4's should
      * allow 48 different offsets or other helper immediate values. */
-    TRACE("Reserving 12 GLSL constants for compiler private use.\n");
+    //other match_apple quirks
+    if ( wined3d_settings.user_quirks & 1) {
+        gl_info->quirks |= WINED3D_CX_QUIRK_BLIT;
+    }
+    if ( wined3d_settings.user_quirks & 2) {
+        gl_info->quirks |= WINED3D_QUIRK_NO_DXTN;
+    }
+    if ( wined3d_settings.user_quirks & 4) {
+        //       FIXME("Reserving 12 GLSL constants for compiler private use.\n");
     gl_info->reserved_glsl_constants = max(gl_info->reserved_glsl_constants, 12);
+	}
+    if (!once++) {
+        FIXME("There are %d GLSL constants reserved\n", gl_info->reserved_glsl_constants);
+    }
 }
 
 static void quirk_amd_dx9(struct wined3d_gl_info *gl_info)
@@ -939,8 +1013,10 @@ static void quirk_texcoord_w(struct wined3d_gl_info *gl_info)
      * all radeon cards on Macs and whitelist the good ones. That way we're prepared for the future. If
      * this workaround is activated on cards that do not need it, it won't break things, just affect
      * performance negatively. */
-    TRACE("Enabling vertex texture coord fixes in vertex shaders.\n");
+    if ( wined3d_settings.user_quirks & 8) {
+        FIXME("Enabling vertex texture coord fixes in vertex shaders.\n");
     gl_info->quirks |= WINED3D_QUIRK_SET_TEXCOORD_W;
+	}
 }
 
 static void quirk_clip_varying(struct wined3d_gl_info *gl_info)
@@ -1206,6 +1282,7 @@ static const struct gpu_description gpu_description_table[] =
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_6600GT,     "NVIDIA GeForce 6600 GT",           DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_6800,       "NVIDIA GeForce 6800",              DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7300,       "NVIDIA GeForce Go 7300",           DRIVER_NVIDIA_GEFORCE6,  256 },
+    {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7300LE,       "NVIDIA GeForce 7300LE",           DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7400,       "NVIDIA GeForce Go 7400",           DRIVER_NVIDIA_GEFORCE6,  256 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7600,       "NVIDIA GeForce 7600 GT",           DRIVER_NVIDIA_GEFORCE6,  256 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7800GT,     "NVIDIA GeForce 7800 GT",           DRIVER_NVIDIA_GEFORCE6,  256 },
@@ -1238,6 +1315,7 @@ static const struct gpu_description gpu_description_table[] =
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GTS350M,    "NVIDIA GeForce GTS 350M",          DRIVER_NVIDIA_GEFORCE8,  1024},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_410M,       "NVIDIA GeForce 410M",              DRIVER_NVIDIA_GEFORCE8,  512},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GT420,      "NVIDIA GeForce GT 420",            DRIVER_NVIDIA_GEFORCE8,  2048},
+    {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GT425M,     "NVIDIA GeForce GT 425M",           DRIVER_NVIDIA_GEFORCE8,  1024},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GT430,      "NVIDIA GeForce GT 430",            DRIVER_NVIDIA_GEFORCE8,  1024},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GT440,      "NVIDIA GeForce GT 440",            DRIVER_NVIDIA_GEFORCE8,  1024},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GTS450,     "NVIDIA GeForce GTS 450",           DRIVER_NVIDIA_GEFORCE8,  1024},
@@ -1397,12 +1475,12 @@ static const struct gpu_description *get_gpu_description(enum wined3d_pci_vendor
     return NULL;
 }
 
-static void init_driver_info(struct wined3d_driver_info *driver_info,
+static void init_driver_info(struct wined3d_gl_info *gl_info, struct wined3d_driver_info *driver_info,
         enum wined3d_pci_vendor vendor, enum wined3d_pci_device device)
 {
     OSVERSIONINFOW os_version;
     WORD driver_os_version;
-    enum wined3d_display_driver driver;
+    enum wined3d_display_driver driver = DRIVER_UNKNOWN;
     enum wined3d_driver_model driver_model;
     const struct driver_version_information *version_info;
     const struct gpu_description *gpu_desc;
@@ -1410,9 +1488,22 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
     if (driver_info->vendor != PCI_VENDOR_NONE || driver_info->device != PCI_DEVICE_NONE)
     {
         static unsigned int once;
+        unsigned int real_vendor, real_device;
 
         TRACE("GPU override %04x:%04x.\n", wined3d_settings.pci_vendor_id, wined3d_settings.pci_device_id);
 
+        if (gl_info->supported[WGL_WINE_GPU_INFO] &&
+            gl_info->gl_ops.ext.p_wglGetPCIInfoWINE(&real_vendor, &real_device))
+        {
+            if (get_gpu_description(real_vendor, real_device))
+            {
+                vendor = real_vendor;
+                device = real_device;
+            }
+            else if (!once++)
+                ERR_(winediag)("Could not find GPU info for %04x:%04x.\n", real_vendor, real_device);
+        }
+
         driver_info->vendor = wined3d_settings.pci_vendor_id;
         if (driver_info->vendor == PCI_VENDOR_NONE)
             driver_info->vendor = vendor;
@@ -1434,6 +1525,10 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
     driver_info->vendor = vendor;
     driver_info->device = device;
 
+    /* Set a default amount of video memory (64MB). In general this code isn't used unless the user
+     * overrides the pci ids to a card which is not in our database. */
+    driver_info->vram_bytes = WINE_DEFAULT_VIDMEM;
+
     memset(&os_version, 0, sizeof(os_version));
     os_version.dwOSVersionInfoSize = sizeof(os_version);
     if (!GetVersionExW(&os_version))
@@ -1505,7 +1600,28 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
         driver_info->vram_bytes = WINE_DEFAULT_VIDMEM;
         driver = DRIVER_UNKNOWN;
     }
+/*
+    if (gl_info->supported[NVX_GPU_MEMORY_INFO])
+    {
+        GLint vram_kb;
+        gl_info->gl_ops.gl.p_glGetIntegerv(GL_GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX, &vram_kb);
 
+        driver_info->vram_bytes = (UINT64)vram_kb * 1024;
+        TRACE("Got 0x%s as video memory from NVX_GPU_MEMORY_INFO extension.\n",
+                wine_dbgstr_longlong(driver_info->vram_bytes));
+    }
+
+    if (gl_info->supported[WGL_WINE_GPU_INFO])
+    {
+        unsigned int vram_mb;
+        if (gl_info->gl_ops.ext.p_wglGetMemoryInfoWINE(&vram_mb))
+        {
+            driver_info->vram_bytes = (UINT64)vram_mb * 1024 * 1024;
+            TRACE("Got 0x%s as video memory from wglGetGPUInfoWINE.\n",
+                    wine_dbgstr_longlong(driver_info->vram_bytes));
+        }
+    }
+*/
     if (wined3d_settings.emulated_textureram)
     {
         TRACE("Overriding amount of video memory with 0x%s bytes.\n",
@@ -1747,6 +1863,7 @@ cards_nvidia_binary[] =
     {"GTS 450",                     CARD_NVIDIA_GEFORCE_GTS450},    /* Geforce 400 - midend low */
     {"GT 440",                      CARD_NVIDIA_GEFORCE_GT440},     /* Geforce 400 - lowend */
     {"GT 430",                      CARD_NVIDIA_GEFORCE_GT430},     /* Geforce 400 - lowend */
+    {"GT 425M",                     CARD_NVIDIA_GEFORCE_GT425M},    /* Geforce 400 - lowend mobile */
     {"GT 420",                      CARD_NVIDIA_GEFORCE_GT420},     /* Geforce 400 - lowend */
     {"410M",                        CARD_NVIDIA_GEFORCE_410M},      /* Geforce 400 - lowend mobile */
     {"GT 330",                      CARD_NVIDIA_GEFORCE_GT330},     /* Geforce 300 - highend */
@@ -1802,7 +1919,8 @@ cards_nvidia_binary[] =
     {"7700",                        CARD_NVIDIA_GEFORCE_7600},      /* Geforce 7 - midend */
     {"7600",                        CARD_NVIDIA_GEFORCE_7600},      /* Geforce 7 - midend */
     {"7400",                        CARD_NVIDIA_GEFORCE_7400},      /* Geforce 7 - lower medium */
-    {"7300",                        CARD_NVIDIA_GEFORCE_7300},      /* Geforce 7 - lowend */
+    {"7300 LE",   		     CARD_NVIDIA_GEFORCE_7300LE},    /* Geforce 7 - lowend */
+    {"7300",     		     CARD_NVIDIA_GEFORCE_7300},      /* Geforce 7 - go */
     {"6800",                        CARD_NVIDIA_GEFORCE_6800},      /* Geforce 6 - highend */
     {"6700",                        CARD_NVIDIA_GEFORCE_6600GT},    /* Geforce 6 - midend */
     {"6610",                        CARD_NVIDIA_GEFORCE_6600GT},    /* Geforce 6 - midend */
@@ -1839,6 +1957,28 @@ cards_nvidia_binary[] =
  * eg HD 4800 is returned for multiple cards, even for RV790 based ones. */
 cards_amd_binary[] =
 {
+    /* by family name */
+    {"Hawaii",                      CARD_AMD_RADEON_R9    },
+    {"Kaveri",                      CARD_AMD_RADEON_R7    },
+    {"Kabini",                      CARD_AMD_RADEON_R3    },
+    {"Bonair",                      CARD_AMD_RADEON_HD8770},
+    /* Southern Islands */
+    {"Oland",                       CARD_AMD_RADEON_HD8670},
+    {"Hainan",                      CARD_AMD_RADEON_HD8600M},
+    {"Tahiti",                      CARD_AMD_RADEON_HD7900},
+    {"Pitcairn",                    CARD_AMD_RADEON_HD7800},
+    {"Verde",                       CARD_AMD_RADEON_HD7700},
+    /* Northern Islands */
+    {"Cayman",                      CARD_AMD_RADEON_HD6900},
+    {"Barts",                       CARD_AMD_RADEON_HD6800},
+    {"Turks",                       CARD_AMD_RADEON_HD6600},
+    {"Caicos",                      CARD_AMD_RADEON_HD6400},
+    /* Evergreen */
+    {"Hemlock",                     CARD_AMD_RADEON_HD5900},
+    {"Cypress",                     CARD_AMD_RADEON_HD5800},
+    {"Juniper",                     CARD_AMD_RADEON_HD5700},
+    {"Redwood",                     CARD_AMD_RADEON_HD5600},
+    {"Cedar",                       CARD_AMD_RADEON_HD5400},
     /* Southern Islands */
     {"HD 7900",                     CARD_AMD_RADEON_HD7900},
     {"HD 7800",                     CARD_AMD_RADEON_HD7800},
@@ -1933,10 +2073,12 @@ cards_intel[] =
     {"Ivybridge Server",            CARD_INTEL_IVBS},
     {"Ivybridge Mobile",            CARD_INTEL_IVBM},
     {"Ivybridge Desktop",           CARD_INTEL_IVBD},
+    {"Intel HD Graphics 4000",      CARD_INTEL_IVBM},
     /* Sandybridge */
     {"Sandybridge Server",          CARD_INTEL_SNBS},
     {"Sandybridge Mobile",          CARD_INTEL_SNBM},
     {"Sandybridge Desktop",         CARD_INTEL_SNBD},
+    {"Intel HD Graphics 3000",      CARD_INTEL_SNBM},
     /* Ironlake */
     {"Ironlake Mobile",             CARD_INTEL_ILKM},
     {"Ironlake Desktop",            CARD_INTEL_ILKD},
@@ -3690,6 +3832,17 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
 
     wined3d_adapter_init_limits(gl_info);
 
+  gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
+  card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
+  TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
+  
+  device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version, gl_renderer_str, &gl_vendor, &card_vendor);
+  TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
+
+  if (match_apple_broken_uniforms(gl_info, gl_renderer_str, gl_vendor, card_vendor, device)) {
+    quirk_arb_constants(gl_info);
+  }
+
     if (gl_info->supported[ARB_VERTEX_PROGRAM] && test_arb_vs_offset_limit(gl_info))
         gl_info->quirks |= WINED3D_QUIRK_ARB_VS_OFFSET_LIMIT;
 
@@ -3712,6 +3865,10 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
     adapter->fragment_pipe = select_fragment_implementation(gl_info, adapter->shader_backend);
     adapter->blitter = select_blit_implementation(gl_info, adapter->shader_backend);
 
+    /* FIXME: The GLSL vertex pipe supports 4 vertex blending matrices. */
+    if (adapter->vertex_pipe == &glsl_vertex_pipe)
+        gl_info->limits.blends = MAX_VERTEX_BLENDS;
+
     adapter->shader_backend->shader_get_caps(gl_info, &shader_caps);
     adapter->d3d_info.vs_clipping = shader_caps.wined3d_caps & WINED3D_SHADER_CAP_VS_CLIPPING;
     adapter->d3d_info.limits.vs_version = shader_caps.vs_version;
@@ -3795,12 +3952,6 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
         }
     }
 
-    gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
-    card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
-    TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
-
-    device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version, gl_renderer_str, &gl_vendor, &card_vendor);
-    TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
 
     gl_info->wrap_lookup[WINED3D_TADDRESS_WRAP - WINED3D_TADDRESS_WRAP] = GL_REPEAT;
     gl_info->wrap_lookup[WINED3D_TADDRESS_MIRROR - WINED3D_TADDRESS_WRAP] =
@@ -3825,7 +3976,7 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
     }
 
     fixup_extensions(gl_info, gl_renderer_str, gl_vendor, card_vendor, device);
-    init_driver_info(driver_info, card_vendor, device);
+    init_driver_info(gl_info, driver_info, card_vendor, device);
     gl_ext_emul_mask = adapter->vertex_pipe->vp_get_emul_mask(gl_info)
             | adapter->fragment_pipe->get_emul_mask(gl_info);
     if (gl_ext_emul_mask & GL_EXT_EMUL_ARB_MULTITEXTURE)
@@ -4298,7 +4449,8 @@ static BOOL wined3d_check_pixel_format_depth(const struct wined3d_gl_info *gl_in
     if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_FLOAT)
         return FALSE;
 
-    if ((format->id == WINED3DFMT_D16_LOCKABLE) || (format->id == WINED3DFMT_D32_FLOAT))
+    if ((format->id == WINED3DFMT_D16_LOCKABLE) || (format->id == WINED3DFMT_D32_FLOAT) ||
+        (format->id == WINED3DFMT_D32_LOCKABLE) || (format->id == WINED3DFMT_S8_LOCKABLE))
         lockable = TRUE;
 
     /* On some modern cards like the Geforce8/9, GLX doesn't offer some
@@ -4400,8 +4552,16 @@ HRESULT CDECL wined3d_check_device_multisample_type(const struct wined3d *wined3
 
     if (quality_levels)
     {
-        if (multisample_type == WINED3D_MULTISAMPLE_NON_MASKABLE)
+        if (wined3d_settings.msaa_quality_levels)
+        {
+            *quality_levels = wined3d_settings.msaa_quality_levels;
+            TRACE("Overriding MSAA quality levels to %i\n", *quality_levels);
+        }
+        else if (multisample_type == WINED3D_MULTISAMPLE_NON_MASKABLE)
+        {
             *quality_levels = gl_info->limits.samples;
+            WARN("probably wrong, setting quality_levels to %d\n", *quality_levels);
+        }
         else
             *quality_levels = 1;
     }
@@ -4472,7 +4632,7 @@ static BOOL CheckRenderTargetCapability(const struct wined3d_adapter *adapter,
                 || adapter_format->green_size != check_format->green_size
                 || adapter_format->blue_size != check_format->blue_size)
         {
-            TRACE("[FAILED]\n");
+            ERR("[FAILED]\n");
             return FALSE;
         }
 
@@ -4800,7 +4960,7 @@ HRESULT CDECL wined3d_check_device_type(const struct wined3d *wined3d, UINT adap
          * WINED3DFMT_UNKNOWN. */
         if (backbuffer_format == WINED3DFMT_UNKNOWN)
             backbuffer_format = display_format;
-
+/* always OK
         if (FAILED(wined3d_check_device_format_conversion(wined3d, adapter_idx,
                 device_type, backbuffer_format, display_format)))
         {
@@ -4808,6 +4968,7 @@ HRESULT CDECL wined3d_check_device_type(const struct wined3d *wined3d, UINT adap
                     debug_d3dformat(backbuffer_format), debug_d3dformat(display_format));
             return WINED3DERR_NOTAVAILABLE;
         }
+ */
     }
     else
     {
@@ -5927,7 +6088,7 @@ static void wined3d_adapter_init_nogl(struct wined3d_adapter *adapter, UINT ordi
 {
     DISPLAY_DEVICEW display_device;
 
-    memset(adapter, 0, sizeof(*adapter));
+    memset(adapter, 0, sizeof(struct wined3d_adapter));
     adapter->ordinal = ordinal;
     adapter->monitorPoint.x = -1;
     adapter->monitorPoint.y = -1;
diff --git a/dlls/wined3d/dxtn.c b/dlls/wined3d/dxtn.c
new file mode 100644
index 0000000..27d65be
--- /dev/null
+++ b/dlls/wined3d/dxtn.c
@@ -0,0 +1,535 @@
+/*
+ * Copyright 2014 Michael Mller
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+#include "wined3d_private.h"
+#include "wine/library.h"
+#include "txc_dxtn.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+
+#if DXTN_STATIC == 0
+static void* txc_dxtn_handle;
+static void (*pfetch_2d_texel_rgba_dxt1)(int srcRowStride, const BYTE *pixData, int i, int j, DWORD *texel);
+static void (*pfetch_2d_texel_rgba_dxt3)(int srcRowStride, const BYTE *pixData, int i, int j, DWORD *texel);
+static void (*pfetch_2d_texel_rgba_dxt5)(int srcRowStride, const BYTE *pixData, int i, int j, DWORD *texel);
+static void (*ptx_compress_dxtn)(int comps, int width, int height, const BYTE *srcPixData,
+                                 GLenum destformat, BYTE *dest, int dstRowStride);
+#else
+static BOOL txc_dxtn_handle = TRUE;
+#endif
+
+static inline BOOL dxt1_to_x8r8g8b8(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        DWORD *dst_line = (DWORD *)(dst + y * pitch_out);
+        for (x = 0; x < w; ++x)
+        {
+            /* pfetch_2d_texel_rgba_dxt1 doesn't correctly handle pitch */
+            pfetch_2d_texel_rgba_dxt1(0, src + (y / 4) * pitch_in + (x / 4) * 8,
+                                      x & 3, y & 3, &color);
+            if (alpha)
+            {
+                dst_line[x] = (color & 0xff00ff00) | ((color & 0xff) << 16) |
+                              ((color & 0xff0000) >> 16);
+            }
+            else
+            {
+                dst_line[x] = 0xff000000 | ((color & 0xff) << 16) |
+                              (color & 0xff00) | ((color & 0xff0000) >> 16);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static inline BOOL dxt1_to_x4r4g4b4(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        WORD *dst_line = (WORD *)(dst + y * pitch_out);
+        for (x = 0; x < w; ++x)
+        {
+            /* pfetch_2d_texel_rgba_dxt1 doesn't correctly handle pitch */
+            pfetch_2d_texel_rgba_dxt1(0, src + (y / 4) * pitch_in + (x / 4) * 16,
+                                      x & 3, y & 3, &color);
+            if (alpha)
+            {
+                dst_line[x] = ((color & 0xf0000000) >> 16) | ((color & 0xf00000) >> 20) |
+                              ((color & 0xf000) >> 8) | ((color & 0xf0) << 4);
+            }
+            else
+            {
+                dst_line[x] = 0xf000  | ((color & 0xf00000) >> 20) |
+                              ((color & 0xf000) >> 8) | ((color & 0xf0) << 4);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static inline BOOL dxt1_to_x1r5g5b5(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        WORD *dst_line = (WORD *)(dst + y * pitch_out);
+        for (x = 0; x < w; ++x)
+        {
+            /* pfetch_2d_texel_rgba_dxt1 doesn't correctly handle pitch */
+            pfetch_2d_texel_rgba_dxt1(0, src + (y / 4) * pitch_in + (x / 4) * 16,
+                                      x & 3, y & 3, &color);
+            if (alpha)
+            {
+                dst_line[x] = ((color & 0x80000000) >> 16) | ((color & 0xf80000) >> 19) |
+                              ((color & 0xf800) >> 6) | ((color & 0xf8) << 7);
+            }
+            else
+            {
+                dst_line[x] = 0x8000 | ((color & 0xf80000) >> 19) |
+                              ((color & 0xf800) >> 6) | ((color & 0xf8) << 7);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static inline BOOL dxt3_to_x8r8g8b8(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        DWORD *dst_line = (DWORD *)(dst + y * pitch_out);
+        for (x = 0; x < w; ++x)
+        {
+            /* pfetch_2d_texel_rgba_dxt3 doesn't correctly handle pitch */
+            pfetch_2d_texel_rgba_dxt3(0, src + (y / 4) * pitch_in + (x / 4) * 16,
+                                      x & 3, y & 3, &color);
+            if (alpha)
+            {
+                dst_line[x] = (color & 0xff00ff00) | ((color & 0xff) << 16) |
+                              ((color & 0xff0000) >> 16);
+            }
+            else
+            {
+                dst_line[x] = 0xff000000 | ((color & 0xff) << 16) |
+                              (color & 0xff00) | ((color & 0xff0000) >> 16);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static inline BOOL dxt3_to_x4r4g4b4(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        WORD *dst_line = (WORD *)(dst + y * pitch_out);
+        for (x = 0; x < w; ++x)
+        {
+            /* pfetch_2d_texel_rgba_dxt3 doesn't correctly handle pitch */
+            pfetch_2d_texel_rgba_dxt3(0, src + (y / 4) * pitch_in + (x / 4) * 16,
+                                      x & 3, y & 3, &color);
+            if (alpha)
+            {
+                dst_line[x] = ((color & 0xf0000000) >> 16) | ((color & 0xf00000) >> 20) |
+                              ((color & 0xf000) >> 8) | ((color & 0xf0) << 4);
+            }
+            else
+            {
+                dst_line[x] = 0xf000  | ((color & 0xf00000) >> 20) |
+                              ((color & 0xf000) >> 8) | ((color & 0xf0) << 4);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static inline BOOL dxt5_to_x8r8g8b8(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    for (y = 0; y < h; ++y)
+    {
+        DWORD *dst_line = (DWORD *)(dst + y * pitch_out);
+        for (x = 0; x < w; ++x)
+        {
+            /* pfetch_2d_texel_rgba_dxt5 doesn't correctly handle pitch */
+            pfetch_2d_texel_rgba_dxt5(0, src + (y / 4) * pitch_in + (x / 4) * 16,
+                                      x & 3, y & 3, &color);
+            if (alpha)
+            {
+                dst_line[x] = (color & 0xff00ff00) | ((color & 0xff) << 16) |
+                              ((color & 0xff0000) >> 16);
+            }
+            else
+            {
+                dst_line[x] = 0xff000000 | ((color & 0xff) << 16) |
+                              (color & 0xff00) | ((color & 0xff0000) >> 16);
+            }
+        }
+    }
+
+    return TRUE;
+}
+
+static inline BOOL x8r8g8b8_to_dxtn(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, GLenum destformat, BOOL alpha)
+{
+    unsigned int x, y;
+    DWORD color, *tmp;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u\n", w, h, pitch_in, pitch_out);
+
+    tmp = HeapAlloc(GetProcessHeap(), 0, h * w * sizeof(DWORD));
+    if (!tmp)
+    {
+        ERR("Failed to allocate memory for conversion\n");
+        return FALSE;
+    }
+
+    for (y = 0; y < h; ++y)
+    {
+        const DWORD *src_line = (const DWORD *)(src + y * pitch_in);
+        DWORD *dst_line = tmp + y * w;
+        for (x = 0; x < w; ++x)
+        {
+            color = src_line[x];
+            if (alpha)
+            {
+                dst_line[x] = (color & 0xff00ff00) | ((color & 0xff) << 16) |
+                              ((color & 0xff0000) >> 16);
+            }
+            else
+            {
+                dst_line[x] = 0xff000000 | ((color & 0xff) << 16) |
+                              (color & 0xff00) | ((color & 0xff0000) >> 16);
+            }
+        }
+    }
+
+    ptx_compress_dxtn(4, w, h, (BYTE *)tmp, destformat, dst, pitch_out);
+    HeapFree(GetProcessHeap(), 0, tmp);
+    return TRUE;
+}
+
+static inline BOOL x1r5g5b5_to_dxtn(const BYTE *src, BYTE *dst, DWORD pitch_in,
+        DWORD pitch_out, unsigned int w, unsigned int h, GLenum destformat, BOOL alpha)
+{
+    static const unsigned char convert_5to8[] =
+    {
+        0x00, 0x08, 0x10, 0x19, 0x21, 0x29, 0x31, 0x3a,
+        0x42, 0x4a, 0x52, 0x5a, 0x63, 0x6b, 0x73, 0x7b,
+        0x84, 0x8c, 0x94, 0x9c, 0xa5, 0xad, 0xb5, 0xbd,
+        0xc5, 0xce, 0xd6, 0xde, 0xe6, 0xef, 0xf7, 0xff,
+    };
+    unsigned int x, y;
+    DWORD *tmp;
+    WORD color;
+
+    TRACE("Converting %ux%u pixels, pitches %u %u.\n", w, h, pitch_in, pitch_out);
+
+    tmp = HeapAlloc(GetProcessHeap(), 0, h * w * sizeof(DWORD));
+    if (!tmp)
+    {
+        ERR("Failed to allocate memory for conversion\n");
+        return FALSE;
+    }
+
+    for (y = 0; y < h; ++y)
+    {
+        const WORD *src_line = (const WORD *)(src + y * pitch_in);
+        DWORD *dst_line = tmp + y * w;
+        for (x = 0; x < w; ++x)
+        {
+            color = src_line[x];
+            if (alpha)
+            {
+                dst_line[x] = ((color & 0x8000) ? 0xff000000 : 0) |
+                              convert_5to8[(color & 0x001f)] << 16 |
+                              convert_5to8[(color & 0x03e0) >> 5] << 8 |
+                              convert_5to8[(color & 0x7c00) >> 10];
+            }
+            else
+            {
+                dst_line[x] = 0xff000000 |
+                              convert_5to8[(color & 0x001f)] << 16 |
+                              convert_5to8[(color & 0x03e0) >> 5] << 8 |
+                              convert_5to8[(color & 0x7c00) >> 10];
+            }
+        }
+    }
+
+    ptx_compress_dxtn(4, w, h, (BYTE *)tmp, destformat, dst, pitch_out);
+    HeapFree(GetProcessHeap(), 0, tmp);
+    return TRUE;
+}
+
+BOOL wined3d_dxt1_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+        enum wined3d_format_id format, unsigned int w, unsigned int h)
+{
+    if (!txc_dxtn_handle)
+        return FALSE;
+
+    switch (format)
+    {
+        case WINED3DFMT_B8G8R8A8_UNORM:
+            return dxt1_to_x8r8g8b8(src, dst, pitch_in, pitch_out, w, h, TRUE);
+        case WINED3DFMT_B8G8R8X8_UNORM:
+            return dxt1_to_x8r8g8b8(src, dst, pitch_in, pitch_out, w, h, FALSE);
+        case WINED3DFMT_B4G4R4A4_UNORM:
+            return dxt1_to_x4r4g4b4(src, dst, pitch_in, pitch_out, w, h, TRUE);
+        case WINED3DFMT_B4G4R4X4_UNORM:
+            return dxt1_to_x4r4g4b4(src, dst, pitch_in, pitch_out, w, h, FALSE);
+        case WINED3DFMT_B5G5R5A1_UNORM:
+            return dxt1_to_x1r5g5b5(src, dst, pitch_in, pitch_out, w, h, TRUE);
+        case WINED3DFMT_B5G5R5X1_UNORM:
+            return dxt1_to_x1r5g5b5(src, dst, pitch_in, pitch_out, w, h, FALSE);
+        default:
+            break;
+    }
+
+    FIXME("Cannot find a conversion function from format DXT1 to %s.\n", debug_d3dformat(format));
+    return FALSE;
+}
+
+BOOL wined3d_dxt3_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+        enum wined3d_format_id format, unsigned int w, unsigned int h)
+{
+    if (!txc_dxtn_handle)
+        return FALSE;
+
+    switch (format)
+    {
+        case WINED3DFMT_B8G8R8A8_UNORM:
+            return dxt3_to_x8r8g8b8(src, dst, pitch_in, pitch_out, w, h, TRUE);
+        case WINED3DFMT_B8G8R8X8_UNORM:
+            return dxt3_to_x8r8g8b8(src, dst, pitch_in, pitch_out, w, h, FALSE);
+        case WINED3DFMT_B4G4R4A4_UNORM:
+            return dxt3_to_x4r4g4b4(src, dst, pitch_in, pitch_out, w, h, TRUE);
+        case WINED3DFMT_B4G4R4X4_UNORM:
+            return dxt3_to_x4r4g4b4(src, dst, pitch_in, pitch_out, w, h, FALSE);
+        default:
+            break;
+    }
+
+    FIXME("Cannot find a conversion function from format DXT3 to %s.\n", debug_d3dformat(format));
+    return FALSE;
+}
+
+BOOL wined3d_dxt5_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+        enum wined3d_format_id format, unsigned int w, unsigned int h)
+{
+    if (!txc_dxtn_handle)
+        return FALSE;
+
+    switch (format)
+    {
+        case WINED3DFMT_B8G8R8A8_UNORM:
+            return dxt5_to_x8r8g8b8(src, dst, pitch_in, pitch_out, w, h, TRUE);
+        case WINED3DFMT_B8G8R8X8_UNORM:
+            return dxt5_to_x8r8g8b8(src, dst, pitch_in, pitch_out, w, h, FALSE);
+        default:
+            break;
+    }
+
+    FIXME("Cannot find a conversion function from format DXT5 to %s.\n", debug_d3dformat(format));
+    return FALSE;
+}
+
+BOOL wined3d_dxt1_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+        enum wined3d_format_id format, unsigned int w, unsigned int h)
+{
+    if (!txc_dxtn_handle)
+        return FALSE;
+
+    switch (format)
+    {
+        case WINED3DFMT_B8G8R8A8_UNORM:
+            return x8r8g8b8_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, TRUE);
+        case WINED3DFMT_B8G8R8X8_UNORM:
+            return x8r8g8b8_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGB_S3TC_DXT1_EXT, FALSE);
+        case WINED3DFMT_B5G5R5A1_UNORM:
+            return x1r5g5b5_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGBA_S3TC_DXT1_EXT, TRUE);
+        case WINED3DFMT_B5G5R5X1_UNORM:
+            return x1r5g5b5_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGB_S3TC_DXT1_EXT, FALSE);
+        default:
+            break;
+    }
+
+    FIXME("Cannot find a conversion function from format %s to DXT1.\n", debug_d3dformat(format));
+    return FALSE;
+}
+
+BOOL wined3d_dxt3_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+        enum wined3d_format_id format, unsigned int w, unsigned int h)
+{
+    if (!txc_dxtn_handle)
+        return FALSE;
+
+    switch (format)
+    {
+        case WINED3DFMT_B8G8R8A8_UNORM:
+            return x8r8g8b8_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, TRUE);
+        case WINED3DFMT_B8G8R8X8_UNORM:
+            return x8r8g8b8_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGBA_S3TC_DXT3_EXT, FALSE);
+        default:
+            break;
+    }
+
+    FIXME("Cannot find a conversion function from format %s to DXT3.\n", debug_d3dformat(format));
+    return FALSE;
+}
+
+BOOL wined3d_dxt5_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+        enum wined3d_format_id format, unsigned int w, unsigned int h)
+{
+    if (!txc_dxtn_handle)
+        return FALSE;
+
+    switch (format)
+    {
+        case WINED3DFMT_B8G8R8A8_UNORM:
+            return x8r8g8b8_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, TRUE);
+        case WINED3DFMT_B8G8R8X8_UNORM:
+            return x8r8g8b8_to_dxtn(src, dst, pitch_in, pitch_out, w, h,
+                                    GL_COMPRESSED_RGBA_S3TC_DXT5_EXT, FALSE);
+        default:
+            break;
+    }
+
+    FIXME("Cannot find a conversion function from format %s to DXT5.\n", debug_d3dformat(format));
+    return FALSE;
+}
+
+BOOL wined3d_dxtn_init(void)
+{
+#if DXTN_STATIC
+  txc_dxtn_handle = TRUE;
+  return TRUE;
+#else
+    static const char *soname[] =
+    {
+#ifdef SONAME_LIBTXC_DXTN
+        SONAME_LIBTXC_DXTN,
+#endif
+#ifdef __APPLE__
+        "libtxc_dxtn.dylib",
+        "libtxc_dxtn_s2tc.dylib",
+#endif
+        "libtxc_dxtn.so",
+        "libtxc_dxtn_s2tc.so.0"
+    };
+    int i;
+
+    for (i = 0; i < sizeof(soname)/sizeof(soname[0]); i++)
+    {
+        txc_dxtn_handle = wine_dlopen(soname[i], RTLD_NOW, NULL, 0);
+        if (txc_dxtn_handle) break;
+    }
+
+    if (!txc_dxtn_handle)
+    {
+        FIXME("Wine cannot find the txc_dxtn library, DXTn software support unavailable.\n");
+        return FALSE;
+    }
+
+    #define LOAD_FUNCPTR(f) \
+        if (!(p##f = wine_dlsym(txc_dxtn_handle, #f, NULL, 0))) \
+        { \
+            ERR("Can't find symbol %s , DXTn software support unavailable.\n", #f); \
+            goto error; \
+        }
+
+    LOAD_FUNCPTR(fetch_2d_texel_rgba_dxt1);
+    LOAD_FUNCPTR(fetch_2d_texel_rgba_dxt3);
+    LOAD_FUNCPTR(fetch_2d_texel_rgba_dxt5);
+    LOAD_FUNCPTR(tx_compress_dxtn);
+
+    #undef LOAD_FUNCPTR
+    return TRUE;
+
+error:
+    wine_dlclose(txc_dxtn_handle, NULL, 0);
+    txc_dxtn_handle = NULL;
+    return FALSE;
+#endif  
+}
+
+BOOL wined3d_dxtn_supported(void)
+{
+#if DXTN_STATIC
+    return TRUE;
+#else  
+    return (txc_dxtn_handle != NULL);
+#endif
+}
+
+void wined3d_dxtn_free(void)
+{
+#if DXTN_STATIC == 0  
+    if (txc_dxtn_handle)
+        wine_dlclose(txc_dxtn_handle, NULL, 0);
+#endif
+}
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 6fe0ff6..c74db02 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -507,6 +507,8 @@ static void shader_glsl_load_samplers(const struct wined3d_gl_info *gl_info,
             mapped_unit = tex_unit_map[sampler_info[i].base_idx + j];
             if (mapped_unit == WINED3D_UNMAPPED_STAGE || mapped_unit >= gl_info->limits.combined_samplers)
             {
+                //WINED3D_UNMAPPED_STAGE = 0xFFFFFFFF =
+                //err:d3d_shader:shader_glsl_load_samplers Trying to load sampler vs_sampler3 on unsupported unit 4294967295.
                 ERR("Trying to load sampler %s on unsupported unit %u.\n", sampler_name->buffer, mapped_unit);
                 continue;
             }
@@ -5768,8 +5770,7 @@ static GLuint shader_glsl_generate_ffp_vertex_shader(struct shader_glsl_priv *pr
     {
         {"vec4", "ffp_attrib_position"},        /* WINED3D_FFP_POSITION */
         {"vec4", "ffp_attrib_blendweight"},     /* WINED3D_FFP_BLENDWEIGHT */
-        /* TODO: Indexed vertex blending */
-        {"float", ""},                          /* WINED3D_FFP_BLENDINDICES */
+        {"vec4", "ffp_attrib_blendindices"},   /* WINED3D_FFP_BLENDINDICES */
         {"vec3", "ffp_attrib_normal"},          /* WINED3D_FFP_NORMAL */
         {"float", "ffp_attrib_psize"},          /* WINED3D_FFP_PSIZE */
         {"vec4", "ffp_attrib_diffuse"},         /* WINED3D_FFP_DIFFUSE */
@@ -5853,6 +5854,8 @@ static GLuint shader_glsl_generate_ffp_vertex_shader(struct shader_glsl_priv *pr
     shader_addline(buffer, "\nvoid main()\n{\n");
     shader_addline(buffer, "float m;\n");
     shader_addline(buffer, "vec3 r;\n");
+    if (settings->vb_indices)
+    	shader_addline(buffer, "    int ind;\n");
 
     for (i = 0; i < ARRAY_SIZE(attrib_info); ++i)
     {
@@ -5883,8 +5886,17 @@ static GLuint shader_glsl_generate_ffp_vertex_shader(struct shader_glsl_priv *pr
             shader_addline(buffer, "ffp_attrib_blendweight[%u] -= ffp_attrib_blendweight[%u];\n", settings->vertexblends, i);
 
         shader_addline(buffer, "vec4 ec_pos = vec4(0.0);\n");
-        for (i = 0; i < settings->vertexblends + 1; ++i)
+        for (i = 0; i < settings->vertexblends + 1; ++i) {
+	 if (settings->vb_indices) {
+	    shader_addline(buffer, "if (ffp_attrib_blendindices[%u] >= 0) {\n",i);
+	    shader_addline(buffer, "ind = int(ffp_attrib_blendindices[%u]+0.1);\n", i);
+	    shader_addline(buffer, "ec_pos += ffp_attrib_blendweight[%u] * (ffp_modelview_matrix[ind] * ffp_attrib_position);\n", i);
+	    shader_addline(buffer, "}\n");
+	 } else {
             shader_addline(buffer, "ec_pos += ffp_attrib_blendweight[%u] * (ffp_modelview_matrix[%u] * ffp_attrib_position);\n", i, i);
+	  }
+	    
+	}
 
         shader_addline(buffer, "gl_Position = ffp_projection_matrix * ec_pos;\n");
         if (settings->clipping)
@@ -5901,8 +5913,13 @@ static GLuint shader_glsl_generate_ffp_vertex_shader(struct shader_glsl_priv *pr
         }
         else
         {
-            for (i = 0; i < settings->vertexblends + 1; ++i)
-                shader_addline(buffer, "normal += ffp_attrib_blendweight[%u] * (mat3(ffp_modelview_matrix[%u]) * ffp_attrib_normal);\n", i, i);
+            for (i = 0; i < settings->vertexblends + 1; ++i) {
+	        if (settings->vb_indices) {
+			shader_addline(buffer, "ind = int(ffp_attrib_blendindices[%u]+0.1);\n", i);
+			shader_addline(buffer, "normal += ffp_attrib_blendweight[%u] * (mat3(ffp_modelview_matrix[ind]) * ffp_attrib_normal);\n", i);
+		} else
+                	shader_addline(buffer, "normal += ffp_attrib_blendweight[%u] * (mat3(ffp_modelview_matrix[%u]) * ffp_attrib_normal);\n", i, i);
+	   }
         }
 
         if (settings->normalize)
@@ -6894,7 +6911,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
     GLuint vs_id = 0;
     GLuint gs_id = 0;
     GLuint ps_id = 0;
-    struct list *ps_list, *vs_list;
+    struct list *ps_list = NULL, *vs_list = NULL;
     WORD attribs_map;
     struct wined3d_string_buffer *tmp_name;
 
@@ -6918,7 +6935,6 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
     else if (use_vs(state))
     {
         struct vs_compile_args vs_compile_args;
-
         vshader = state->shader[WINED3D_SHADER_TYPE_VERTEX];
 
         find_vs_compile_args(state, vshader, context->stream_info.swizzle_map, &vs_compile_args, d3d_info);
@@ -7996,7 +8012,7 @@ static void glsl_vertex_pipe_vp_get_caps(const struct wined3d_gl_info *gl_info,
     caps->ffp_generic_attributes = TRUE;
     caps->max_active_lights = MAX_ACTIVE_LIGHTS;
     caps->max_vertex_blend_matrices = MAX_VERTEX_BLENDS;
-    caps->max_vertex_blend_matrix_index = 0;
+    caps->max_vertex_blend_matrix_index = MAX_VERTEX_BLENDS-1;
     caps->vertex_processing_caps = WINED3DVTXPCAPS_TEXGEN
             | WINED3DVTXPCAPS_MATERIALSOURCE7
             | WINED3DVTXPCAPS_VERTEXFOG
@@ -8310,6 +8326,131 @@ static const struct StateEntryTemplate glsl_vertex_pipe_vp_states[] =
     {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(1)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(1)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
     {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(2)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(2)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
     {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(3)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(3)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(4)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(4)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(5)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(5)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(6)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(6)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(7)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(7)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(8)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(8)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(9)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(9)),                glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(10)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(10)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(11)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(11)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(12)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(12)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(13)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(13)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(14)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(14)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(15)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(15)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(16)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(16)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(17)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(17)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(18)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(18)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(19)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(19)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(20)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(20)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(21)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(21)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(22)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(22)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(23)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(23)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(24)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(24)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(25)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(25)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(26)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(26)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(27)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(27)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(28)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(28)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(29)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(29)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(30)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(30)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(31)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(31)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(32)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(32)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(33)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(33)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(34)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(34)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(35)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(35)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(36)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(36)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(37)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(37)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(38)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(38)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(39)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(39)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(40)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(40)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(41)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(41)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(42)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(42)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(43)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(43)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(44)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(44)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(45)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(45)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(46)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(46)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(47)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(47)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(48)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(48)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(49)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(49)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(50)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(50)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(51)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(51)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(52)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(52)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(53)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(53)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(54)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(54)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(55)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(55)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(56)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(56)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(57)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(57)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(58)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(58)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(59)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(59)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(60)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(60)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(61)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(61)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(62)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(62)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(63)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(63)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(64)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(64)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(65)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(65)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(66)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(66)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(67)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(67)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(68)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(68)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(69)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(69)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(70)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(70)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(71)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(71)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(72)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(72)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(73)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(73)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(74)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(74)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(75)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(75)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(76)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(76)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(77)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(77)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(78)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(78)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(79)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(79)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(80)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(80)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(81)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(81)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(82)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(82)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(83)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(83)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(84)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(84)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(85)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(85)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(86)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(86)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(87)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(87)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(88)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(88)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(89)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(89)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(90)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(90)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(91)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(91)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(92)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(92)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(93)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(93)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(94)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(94)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(95)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(95)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(96)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(96)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(97)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(97)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(98)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(98)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(99)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(99)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(100)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(100)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(101)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(101)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(102)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(102)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(103)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(103)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(104)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(104)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(105)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(105)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(106)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(106)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(107)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(107)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(108)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(108)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(109)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(109)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(110)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(110)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(111)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(111)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(112)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(112)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(113)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(113)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(114)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(114)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(115)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(115)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(116)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(116)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(117)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(117)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(118)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(118)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(119)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(119)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+   {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(120)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(120)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(121)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(121)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(122)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(122)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(123)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(123)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(124)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(124)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(125)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(125)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(126)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(126)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(127)),                {STATE_TRANSFORM(WINED3D_TS_WORLD_MATRIX(127)),               glsl_vertex_pipe_vertexblend }, WINED3D_GL_EXT_NONE    },
+    
     {STATE_TEXTURESTAGE(0, WINED3D_TSS_TEXTURE_TRANSFORM_FLAGS), {STATE_TEXTURESTAGE(0, WINED3D_TSS_TEXTURE_TRANSFORM_FLAGS), glsl_vertex_pipe_texmatrix}, WINED3D_GL_EXT_NONE       },
     {STATE_TEXTURESTAGE(1, WINED3D_TSS_TEXTURE_TRANSFORM_FLAGS), {STATE_TEXTURESTAGE(1, WINED3D_TSS_TEXTURE_TRANSFORM_FLAGS), glsl_vertex_pipe_texmatrix}, WINED3D_GL_EXT_NONE       },
     {STATE_TEXTURESTAGE(2, WINED3D_TSS_TEXTURE_TRANSFORM_FLAGS), {STATE_TEXTURESTAGE(2, WINED3D_TSS_TEXTURE_TRANSFORM_FLAGS), glsl_vertex_pipe_texmatrix}, WINED3D_GL_EXT_NONE       },
@@ -8389,7 +8530,19 @@ static const struct StateEntryTemplate glsl_vertex_pipe_vp_states[] =
 };
 
 /* TODO:
- *   - Implement vertex tweening. */
+ *   - This currently depends on GL fixed function functions to set things
+ *     like light parameters. Ideally we'd use regular uniforms for that.
+ *   - In part because of the previous point, much of this is modelled after
+ *     GL fixed function, and has much of the same limitations. For example,
+ *     D3D spot lights are slightly different from GL spot lights.
+ *   - We can now implement drawing transformed vertices using the GLSL pipe,
+ *     instead of using the immediate mode fallback.
+ *   - Similarly, we don't need the fallback for certain combinations of
+ *     material sources anymore.
+ *   - Implement vertex tweening.
+ *   - Handle WINED3D_TSS_TEXCOORD_INDEX in the shader, instead of duplicating
+ *     attribute arrays in load_tex_coords().
+ *   - Per-vertex point sizes. */
 const struct wined3d_vertex_pipe_ops glsl_vertex_pipe =
 {
     glsl_vertex_pipe_vp_enable,
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
index b86adf1..c9dcdc6 100644
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -148,10 +148,14 @@ enum wined3d_event_query_result wined3d_event_query_finish(const struct wined3d_
             case GL_CONDITION_SATISFIED:
                 ret = WINED3D_EVENT_QUERY_OK;
                 break;
+            //Slice
+            case GL_TIMEOUT_EXPIRED_APPLE:
+                ret = WINED3D_EVENT_QUERY_NOT_STARTED;
+                break;
 
                 /* We don't expect a timeout for a ~584 year wait */
             default:
-                ERR("glClientWaitSync returned %#x.\n", gl_ret);
+                ERR("glClientWaitSync returned %#x.\n", gl_ret); //glClientWaitSync returned 0x911b == GL_TIMEOUT_EXPIRED_APPLE
                 ret = WINED3D_EVENT_QUERY_ERROR;
         }
     }
@@ -181,6 +185,9 @@ void wined3d_event_query_issue(struct wined3d_event_query *query, const struct w
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    if (!query || !device) {
+        return;
+    }
 
     if (query->context)
     {
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
index d466764..972f166 100644
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -50,10 +50,12 @@ static DWORD resource_access_from_pool(enum wined3d_pool pool)
 
 static void resource_check_usage(DWORD usage)
 {
-    static const DWORD handled = WINED3DUSAGE_RENDERTARGET
+    static DWORD handled = WINED3DUSAGE_RENDERTARGET
             | WINED3DUSAGE_DEPTHSTENCIL
             | WINED3DUSAGE_WRITEONLY
             | WINED3DUSAGE_DYNAMIC
+            | WINED3DUSAGE_SOFTWAREPROCESSING
+            | WINED3DUSAGE_POINTS
             | WINED3DUSAGE_AUTOGENMIPMAP
             | WINED3DUSAGE_STATICDECL
             | WINED3DUSAGE_OVERLAY
@@ -66,7 +68,15 @@ static void resource_check_usage(DWORD usage)
      * driver. */
 
     if (usage & ~handled)
+    {
         FIXME("Unhandled usage flags %#x.\n", usage & ~handled);
+        handled |= usage;
+    }
+
+//#define WINED3DUSAGE_SOFTWAREPROCESSING                         0x00000010
+//#define WINED3DUSAGE_DONOTCLIP                                  0x00000020
+//#define WINED3DUSAGE_POINTS                                     0x00000040
+
     if ((usage & (WINED3DUSAGE_DYNAMIC | WINED3DUSAGE_WRITEONLY)) == WINED3DUSAGE_DYNAMIC)
         WARN_(d3d_perf)("WINED3DUSAGE_DYNAMIC used without WINED3DUSAGE_WRITEONLY.\n");
 }
@@ -78,8 +88,8 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
         void *parent, const struct wined3d_parent_ops *parent_ops,
         const struct wined3d_resource_ops *resource_ops)
 {
-    const struct wined3d *d3d = device->wined3d;
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    const struct wined3d *d3d; // = device->wined3d;
+    const struct wined3d_gl_info *gl_info; // = &device->adapter->gl_info;
     static const enum wined3d_gl_resource_type gl_resource_types[][4] =
     {
         /* 0                            */ {WINED3D_GL_RES_TYPE_COUNT},
@@ -94,6 +104,12 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     enum wined3d_gl_resource_type gl_type = WINED3D_GL_RES_TYPE_COUNT;
     enum wined3d_gl_resource_type base_type = gl_resource_types[type][0];
 
+    if (!device || !resource) {
+        return WINED3DERR_INVALIDCALL;
+    }
+    d3d = device->wined3d;
+    gl_info = &device->adapter->gl_info;
+
     resource_check_usage(usage);
 
     if (base_type != WINED3D_GL_RES_TYPE_COUNT)
@@ -193,7 +209,24 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     resource->resource_ops = resource_ops;
     resource->map_binding = WINED3D_LOCATION_SYSMEM;
 
-    if (size)
+    switch (type)
+    {
+        /* Memory for surfaces and volumes is allocated by the texture itself allowing apps to make
+         * assumptions about memory contiguity and loading surfaces all at once. */
+        case WINED3D_RTYPE_SURFACE:
+        case WINED3D_RTYPE_VOLUME:
+            if ((usage & WINED3DUSAGE_TEXTURE) && wined3d_settings.contiguous_tex_mem)
+            {
+                resource->managed = TRUE;
+                resource->freed = FALSE;
+                break;
+            }
+        default:
+            resource->managed = FALSE;
+            break;
+    }
+
+    if (size && !resource->managed)
     {
         if (!wined3d_resource_allocate_sysmem(resource))
         {
@@ -207,7 +240,7 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     }
 
     /* Check that we have enough video ram left */
-    if (pool == WINED3D_POOL_DEFAULT && d3d->flags & WINED3D_VIDMEM_ACCOUNTING)
+    if (pool == WINED3D_POOL_DEFAULT && d3d->flags & WINED3D_VIDMEM_ACCOUNTING && !resource->managed)
     {
         if (size > wined3d_device_get_available_texture_mem(device))
         {
@@ -229,7 +262,7 @@ void resource_cleanup(struct wined3d_resource *resource)
 
     TRACE("Cleaning up resource %p.\n", resource);
 
-    if (resource->pool == WINED3D_POOL_DEFAULT && d3d->flags & WINED3D_VIDMEM_ACCOUNTING)
+    if (resource->pool == WINED3D_POOL_DEFAULT && d3d->flags & WINED3D_VIDMEM_ACCOUNTING && !resource->managed)
     {
         TRACE("Decrementing device memory pool by %u.\n", resource->size);
         adapter_adjust_memory(resource->device->adapter, (INT64)0 - resource->size);
@@ -298,25 +331,77 @@ void CDECL wined3d_resource_get_desc(const struct wined3d_resource *resource, st
 HRESULT CDECL wined3d_resource_map(struct wined3d_resource *resource, unsigned int sub_resource_idx,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
-    TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %p, flags %#x.\n",
-            resource, sub_resource_idx, map_desc, box, flags);
+ //   TRACE("resource %p, sub_resource_idx %u, map_desc %p, box %p, flags %#x.\n",
+ //           resource, sub_resource_idx, map_desc, box, flags);
 
     return resource->resource_ops->resource_sub_resource_map(resource, sub_resource_idx, map_desc, box, flags);
 }
 
 HRESULT CDECL wined3d_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx)
 {
-    TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
+//    TRACE("resource %p, sub_resource_idx %u.\n", resource, sub_resource_idx);
 
     return resource->resource_ops->resource_sub_resource_unmap(resource, sub_resource_idx);
 }
 
+BOOL texture_manage_memory(struct wined3d_resource *resource, BOOL alloc)
+{
+    struct wined3d_texture *texture;
+    UINT sub_count;
+    UINT i;
+    BYTE *current_heap;
+
+    if (resource->type == WINED3D_RTYPE_SURFACE)
+        texture = ((struct wined3d_surface*)resource)->container;
+    else
+        texture = ((struct wined3d_volume*)resource)->container;
+
+    FIXME("(%p %u %p %u %p\n", resource, alloc, texture, texture->allocated_subresource, texture->resource.heap_memory);
+
+    sub_count = texture->level_count * texture->layer_count;
+
+    if (alloc)
+    {
+        if (!texture->allocated_subresource && !texture->resource.heap_memory)
+        {
+            FIXME("Allocate mipchain (%p)\n", texture);
+            if (!wined3d_resource_allocate_sysmem(&texture->resource))
+                return FALSE;
+            FIXME("=> %p\n", texture->resource.heap_memory);
+            current_heap = texture->resource.heap_memory;
+            for (i = 0; i < sub_count; i++)
+            {
+                texture->sub_resources[i]->heap_memory = current_heap;
+                current_heap += texture->sub_resources[i]->size;
+                FIXME("=> size %u\n", texture->sub_resources[i]->size);
+            }
+        }
+        texture->allocated_subresource++;
+        resource->freed = FALSE;
+    }
+    else
+    {
+        if (!--texture->allocated_subresource)
+        {
+            FIXME("Free mipchain (%p)\n", texture);
+            wined3d_resource_free_sysmem(&texture->resource);
+            for (i = 0; i < sub_count; i++)
+                texture->sub_resources[i]->heap_memory = NULL;
+        }
+    }
+
+    return TRUE;
+}
+
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
 {
     void **p;
     SIZE_T align = RESOURCE_ALIGNMENT - 1 + sizeof(*p);
     void *mem;
 
+    if (resource->managed)
+        return texture_manage_memory(resource, TRUE);
+
     if (!(mem = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, resource->size + align)))
         return FALSE;
 
@@ -330,13 +415,24 @@ BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
 
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource)
 {
-    void **p = resource->heap_memory;
+    if (!resource->managed)
+    {
+        void **p = resource->heap_memory;
 
-    if (!p)
-        return;
+        if (!p)
+            return;
 
-    HeapFree(GetProcessHeap(), 0, *(--p));
-    resource->heap_memory = NULL;
+        HeapFree(GetProcessHeap(), 0, *(--p));
+        resource->heap_memory = NULL;
+    }
+    else
+    {
+        /* Apparently this fonction can be called more that once between texture life cyce 
+           (not only at the end for clean-up). We need then another flag to avoid decrementing the counter several times) */
+        if (!resource->freed)
+            texture_manage_memory(resource, FALSE);
+        resource->freed = TRUE;
+    }
 }
 
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource, DWORD flags)
@@ -365,7 +461,7 @@ DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resourc
     else if (flags & (WINED3D_MAP_DISCARD | WINED3D_MAP_NOOVERWRITE)
             && !(resource->usage & WINED3DUSAGE_DYNAMIC))
     {
-        WARN("DISCARD or NOOVERWRITE map on non-dynamic buffer, ignoring.\n");
+        WARN("DISCARD or NOOVERWRITE map on non-dynamic buffer, ignoring.\n"); //tumblebugs2
         return 0;
     }
 
@@ -430,3 +526,35 @@ void wined3d_resource_update_draw_binding(struct wined3d_resource *resource)
     else
         resource->draw_binding = WINED3D_LOCATION_TEXTURE_RGB;
 }
+
+void wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch)
+{
+    unsigned int alignment;
+    const struct wined3d_format *format = resource->format;
+
+/*    if (resource->custom_row_pitch)
+    {
+        *row_pitch = resource->custom_row_pitch;
+        *slice_pitch = resource->custom_slice_pitch;
+        return;
+    } */
+
+    alignment = resource->device->surface_alignment;
+    *row_pitch = wined3d_format_calculate_pitch(resource->format, resource->width);
+    *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
+    //   if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_BLOCKS)
+    {
+        /* Since compressed formats are block based, pitch means the amount of
+         * bytes to the next row of block rather than the next row of pixels. */
+        UINT slice_block_count = (resource->height + format->block_height - 1) / format->block_height;
+        *slice_pitch = *row_pitch * slice_block_count;
+    }
+/*    else
+    {
+        *slice_pitch = *row_pitch * resource->height;
+    } */
+
+    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
+}
+
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index 7e85988..ff261e7 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -253,7 +253,7 @@ void string_buffer_clear(struct wined3d_string_buffer *buffer)
 
 BOOL string_buffer_init(struct wined3d_string_buffer *buffer)
 {
-    buffer->buffer_size = 32;
+    buffer->buffer_size = 16384;
     if (!(buffer->buffer = HeapAlloc(GetProcessHeap(), 0, buffer->buffer_size)))
     {
         ERR("Failed to allocate shader buffer memory.\n");
@@ -2118,7 +2118,7 @@ ULONG CDECL wined3d_shader_incref(struct wined3d_shader *shader)
 {
     ULONG refcount = InterlockedIncrement(&shader->ref);
 
-    TRACE("%p increasing refcount to %u.\n", shader, refcount);
+//    TRACE("%p increasing refcount to %u.\n", shader, refcount);
 
     return refcount;
 }
@@ -2127,7 +2127,7 @@ ULONG CDECL wined3d_shader_decref(struct wined3d_shader *shader)
 {
     ULONG refcount = InterlockedDecrement(&shader->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", shader, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", shader, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index 91d6417..b3e8157 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -360,8 +360,11 @@ static GLenum gl_blend_factor(enum wined3d_blend factor, const struct wined3d_fo
         case WINED3D_BLEND_INVBLENDFACTOR:
             return GL_ONE_MINUS_CONSTANT_COLOR_EXT;
         default:
-            FIXME("Unhandled blend factor %#x.\n", factor);
+        {
+            static int once;
+            if (factor && !once++) FIXME("Unhandled blend factor %#x.\n", factor);
             return GL_NONE;
+        }
     }
 }
 
@@ -1571,6 +1574,7 @@ void state_pointsprite(struct wined3d_context *context, const struct wined3d_sta
 
 static void state_wrap(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+    static DWORD once, old_id;
     if (state->render_states[WINED3D_RS_WRAP0]
             || state->render_states[WINED3D_RS_WRAP1]
             || state->render_states[WINED3D_RS_WRAP2]
@@ -1586,8 +1590,18 @@ static void state_wrap(struct wined3d_context *context, const struct wined3d_sta
             || state->render_states[WINED3D_RS_WRAP12]
             || state->render_states[WINED3D_RS_WRAP13]
             || state->render_states[WINED3D_RS_WRAP14]
-            || state->render_states[WINED3D_RS_WRAP15])
-        FIXME("(WINED3D_RS_WRAP0) Texture wrapping not yet supported.\n");
+ 	        || state->render_states[WINED3D_RS_WRAP15]) {
+        if (!once || old_id != state_id) {
+            once++;
+            if (old_id != state_id) {
+                once = 0;
+                old_id = state_id;
+            }
+
+            FIXME("(WINED3D_RS_WRAP0) Texture wrapping not yet supported. id=%d\n", state_id);
+        }
+
+    }
 }
 
 static void state_msaa_w(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index a8f7179..902a8fe 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -364,6 +364,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     BITMAPINFO *b_info;
     int extraline = 0;
     DWORD *masks;
+    UINT row_pitch, slice_pitch;
 
     TRACE("surface %p.\n", surface);
 
@@ -409,10 +410,11 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
 
     b_info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     /* TODO: Is there a nicer way to force a specific alignment? (8 byte for ddraw) */
-    b_info->bmiHeader.biWidth = wined3d_surface_get_pitch(surface) / format->byte_count;
+    wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+    b_info->bmiHeader.biWidth = row_pitch / format->byte_count;
     b_info->bmiHeader.biHeight = 0 - surface->resource.height - extraline;
     b_info->bmiHeader.biSizeImage = (surface->resource.height + extraline)
-            * wined3d_surface_get_pitch(surface);
+            * row_pitch;
     b_info->bmiHeader.biPlanes = 1;
     b_info->bmiHeader.biBitCount = format->byte_count * 8;
 
@@ -769,6 +771,26 @@ static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RE
     return TRUE;
 }
 
+static void prepare_blit_quirks(const struct wined3d_device *device, const struct wined3d_gl_info *gl_info)
+{
+  /* ATI Macs blend blits even though GL_EXT_framebuffer_blit says that this
+   * operation does not blend. This sometimes even happens if GL_BLEND is
+   * disabled, although in my glut test case blending has to be enabled for
+   * the bug to occur. While we're at it, disable blending.
+   *
+   * Tracked by crossover hacks bug 5391. */
+  gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+  gl_info->gl_ops.gl.p_glBlendFunc(GL_ONE, GL_ZERO);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHABLENDENABLE));
+  
+  gl_info->gl_ops.gl.p_glDisable(GL_ALPHA_TEST);
+  gl_info->gl_ops.gl.p_glAlphaFunc(GL_ALWAYS, 0.0);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHATESTENABLE));
+  gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
+  gl_info->gl_ops.gl.p_glStencilFunc(GL_ALWAYS, 0, 0);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+}
+
 static void surface_depth_blt_fbo(const struct wined3d_device *device,
         struct wined3d_surface *src_surface, DWORD src_location, const RECT *src_rect,
         struct wined3d_surface *dst_surface, DWORD dst_location, const RECT *dst_rect)
@@ -853,6 +875,9 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     gl_info->gl_ops.gl.p_glDisable(GL_SCISSOR_TEST);
     context_invalidate_state(context, STATE_RENDER(WINED3D_RS_SCISSORTESTENABLE));
 
+  if (gl_info->quirks & WINED3D_CX_QUIRK_BLIT)
+    prepare_blit_quirks(device, gl_info);
+
     gl_info->fbo_ops.glBlitFramebuffer(src_rect->left, src_rect->top, src_rect->right, src_rect->bottom,
             dst_rect->left, dst_rect->top, dst_rect->right, dst_rect->bottom, gl_mask, GL_NEAREST);
     checkGLcall("glBlitFramebuffer()");
@@ -1338,14 +1363,14 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         void *mem;
         GLenum gl_format = format->glFormat;
         GLenum gl_type = format->glType;
-        int src_pitch = 0;
-        int dst_pitch = 0;
+        UINT src_pitch = 0;
+        UINT dst_row_pitch, dst_slice_pitch;
 
         if (surface->flags & SFLAG_NONPOW2)
         {
             unsigned char alignment = surface->resource.device->surface_alignment;
             src_pitch = format->byte_count * surface->pow2Width;
-            dst_pitch = wined3d_surface_get_pitch(surface);
+            wined3d_resource_get_pitch(&surface->resource, &dst_row_pitch, &dst_slice_pitch);
             src_pitch = (src_pitch + alignment - 1) & ~(alignment - 1);
             mem = HeapAlloc(GetProcessHeap(), 0, src_pitch * surface->pow2Height);
         }
@@ -1432,12 +1457,12 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
              * won't be released, and doesn't have to be re-read. */
             src_data = mem;
             dst_data = data.addr;
-            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_pitch);
+            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_row_pitch);
             for (y = 0; y < surface->resource.height; ++y)
             {
-                memcpy(dst_data, src_data, dst_pitch);
+                memcpy(dst_data, src_data, dst_row_pitch);
                 src_data += src_pitch;
-                dst_data += dst_pitch;
+                dst_data += dst_row_pitch;
             }
 
             HeapFree(GetProcessHeap(), 0, mem);
@@ -1599,7 +1624,7 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     UINT update_w, update_h;
     UINT dst_w, dst_h;
     RECT r, dst_rect;
-    UINT src_pitch;
+    UINT src_row_pitch, src_slice_pitch;
     POINT p;
 
     TRACE("dst_surface %p, dst_point %s, src_surface %p, src_rect %s.\n",
@@ -1687,10 +1712,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     wined3d_texture_bind_and_dirtify(dst_surface->container, context, FALSE);
 
     surface_get_memory(src_surface, &data, src_surface->locations);
-    src_pitch = wined3d_surface_get_pitch(src_surface);
+    //src_pitch = wined3d_surface_get_pitch(src_surface);
+  wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
 
     wined3d_surface_upload_data(dst_surface, gl_info, src_format, src_rect,
-            src_pitch, dst_point, FALSE, wined3d_const_bo_address(&data));
+            src_row_pitch, dst_point, FALSE, wined3d_const_bo_address(&data));
 
     context_release(context);
 
@@ -1928,7 +1954,7 @@ HRESULT CDECL wined3d_surface_is_lost(const struct wined3d_surface *surface)
 {
     TRACE("surface %p.\n", surface);
 
-    /* D3D8 and 9 lose full devices, ddraw only surfaces. */
+    /* D3D8 and 9 loose full devices, ddraw only surfaces. */
     return surface->flags & SFLAG_LOST ? WINED3DERR_DEVICELOST : WINED3D_OK;
 }
 
@@ -1939,7 +1965,7 @@ HRESULT CDECL wined3d_surface_restore(struct wined3d_surface *surface)
     surface->flags &= ~SFLAG_LOST;
     return WINED3D_OK;
 }
-
+/*
 DWORD CDECL wined3d_surface_get_pitch(const struct wined3d_surface *surface)
 {
     unsigned int alignment;
@@ -1958,7 +1984,7 @@ DWORD CDECL wined3d_surface_get_pitch(const struct wined3d_surface *surface)
 
     return pitch;
 }
-
+*/
 HRESULT CDECL wined3d_surface_set_overlay_position(struct wined3d_surface *surface, LONG x, LONG y)
 {
     LONG w, h;
@@ -2332,6 +2358,126 @@ static void convert_yuy2_r5g6b5(const BYTE *src, BYTE *dst,
     }
 }
 
+static void convert_dxt1_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt1_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_dxt1_a4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4A4_UNORM, w, h);
+}
+
+static void convert_dxt1_x4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4X4_UNORM, w, h);
+}
+
+static void convert_dxt1_a1r5g5b5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5A1_UNORM, w, h);
+}
+
+static void convert_dxt1_x1r5g5b5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5X1_UNORM, w, h);
+}
+
+static void convert_dxt3_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt3_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_dxt3_a4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4A4_UNORM, w, h);
+}
+
+static void convert_dxt3_x4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4X4_UNORM, w, h);
+}
+
+static void convert_dxt5_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt5_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a1r5g5b5_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5A1_UNORM, w, h);
+}
+
+static void convert_x1r5g5b5_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5X1_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt3(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt3(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
 struct d3dfmt_converter_desc
 {
     enum wined3d_format_id from, to;
@@ -2348,6 +2494,33 @@ static const struct d3dfmt_converter_desc converters[] =
     {WINED3DFMT_YUY2,           WINED3DFMT_B5G6R5_UNORM,    convert_yuy2_r5g6b5},
 };
 
+static const struct d3dfmt_converter_desc dxtn_converters[] =
+{
+    /* decode DXT */
+    {WINED3DFMT_DXT1,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt1_a8r8g8b8},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt1_x8r8g8b8},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B4G4R4A4_UNORM,  convert_dxt1_a4r4g4b4},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B4G4R4X4_UNORM,  convert_dxt1_x4r4g4b4},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B5G5R5A1_UNORM,  convert_dxt1_a1r5g5b5},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B5G5R5X1_UNORM,  convert_dxt1_x1r5g5b5},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt3_a8r8g8b8},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt3_x8r8g8b8},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B4G4R4A4_UNORM,  convert_dxt3_a4r4g4b4},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B4G4R4X4_UNORM,  convert_dxt3_x4r4g4b4},
+    {WINED3DFMT_DXT5,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt5_a8r8g8b8},
+    {WINED3DFMT_DXT5,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt5_x8r8g8b8},
+
+    /* encode DXT */
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT1,            convert_a8r8g8b8_dxt1},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT1,            convert_x8r8g8b8_dxt1},
+    {WINED3DFMT_B5G5R5A1_UNORM, WINED3DFMT_DXT1,            convert_a1r5g5b5_dxt1},
+    {WINED3DFMT_B5G5R5X1_UNORM, WINED3DFMT_DXT1,            convert_x1r5g5b5_dxt1},
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT3,            convert_a8r8g8b8_dxt3},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT3,            convert_x8r8g8b8_dxt3},
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT5,            convert_a8r8g8b8_dxt5},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT5,            convert_x8r8g8b8_dxt5}
+};
+
 static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_format_id from,
         enum wined3d_format_id to)
 {
@@ -2359,6 +2532,12 @@ static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_fo
             return &converters[i];
     }
 
+    for (i = 0; i < (sizeof(dxtn_converters) / sizeof(*dxtn_converters)); ++i)
+    {
+        if (dxtn_converters[i].from == from && dxtn_converters[i].to == to)
+            return wined3d_dxtn_supported() ? &dxtn_converters[i] : NULL;
+    }
+
     return NULL;
 }
 
@@ -2604,7 +2783,8 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
     if (fmt_flags & WINED3DFMT_FLAG_BROKEN_PITCH)
         map_desc->row_pitch = surface->resource.width * format->byte_count;
     else
-        map_desc->row_pitch = wined3d_surface_get_pitch(surface);
+ /*       map_desc->row_pitch = wined3d_surface_get_pitch(surface); */
+      wined3d_resource_get_pitch(&surface->resource, &map_desc->row_pitch, &map_desc->slice_pitch);
     map_desc->slice_pitch = surface->resource.height * map_desc->row_pitch;
 
     if (!box)
@@ -2753,6 +2933,7 @@ static void read_from_framebuffer(struct wined3d_surface *surface,
     int i;
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
+    DWORD slice_pitch, pitch;
 
     surface_get_memory(surface, &data, dst_location);
 
@@ -2794,8 +2975,8 @@ static void read_from_framebuffer(struct wined3d_surface *surface,
     }
 
     /* Setup pixel store pack state -- to glReadPixels into the correct place */
-    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH,
-            wined3d_surface_get_pitch(surface) / surface->resource.format->byte_count);
+    wined3d_resource_get_pitch(&surface->resource, &pitch, &slice_pitch);
+    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, pitch / surface->resource.format->byte_count);
     checkGLcall("glPixelStorei");
 
     gl_info->gl_ops.gl.p_glReadPixels(0, 0,
@@ -2812,8 +2993,6 @@ static void read_from_framebuffer(struct wined3d_surface *surface,
     {
         /* glReadPixels returns the image upside down, and there is no way to prevent this.
          * Flip the lines in software. */
-        UINT pitch = wined3d_surface_get_pitch(surface);
-
         if (!(row = HeapAlloc(GetProcessHeap(), 0, pitch)))
             goto error;
 
@@ -2874,7 +3053,6 @@ void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb, struct
     gl_info = context->gl_info;
     device_invalidate_state(device, STATE_FRAMEBUFFER);
 
-    wined3d_texture_prepare_texture(surface->container, context, srgb);
     wined3d_texture_bind_and_dirtify(surface->container, context, srgb);
 
     TRACE("Reading back offscreen render target %p.\n", surface);
@@ -3749,6 +3927,7 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         gl_info->gl_ops.gl.p_glTexParameteri(bind_target, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
         gl_info->gl_ops.gl.p_glTexParameteri(bind_target, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
         gl_info->gl_ops.gl.p_glTexParameteri(bind_target, GL_TEXTURE_WRAP_R, GL_CLAMP_TO_EDGE);
+//        gl_info->gl_ops.gl.p_glTexParameteri(bind_target, GL_DEPTH_TEXTURE_MODE_ARB, GL_LUMINANCE); //Slice -?
         gl_info->gl_ops.gl.p_glBindTexture(bind_target, old_binding);
 
         context_apply_fbo_state_blit(context, GL_FRAMEBUFFER,
@@ -3932,7 +4111,8 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_color_key_conversion *conversion;
     struct wined3d_texture *texture = surface->container;
-    UINT width, src_pitch, dst_pitch;
+//    UINT width, src_pitch, dst_pitch;
+    UINT width, src_row_pitch, src_slice_pitch, dst_pitch;
     struct wined3d_bo_address data;
     struct wined3d_format format;
     POINT dst_point = {0, 0};
@@ -4017,7 +4197,8 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     wined3d_texture_bind_and_dirtify(texture, context, srgb);
 
     width = surface->resource.width;
-    src_pitch = wined3d_surface_get_pitch(surface);
+//    src_pitch = wined3d_surface_get_pitch(surface);
+    wined3d_resource_get_pitch(&surface->resource, &src_row_pitch, &src_slice_pitch);    
 
     format = *texture->resource.format;
     if ((conversion = wined3d_format_get_color_key_conversion(texture, TRUE)))
@@ -4055,9 +4236,9 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             context_release(context);
             return E_OUTOFMEMORY;
         }
-        format.convert(data.addr, mem, src_pitch, src_pitch * height,
+        format.convert(data.addr, mem, src_row_pitch, src_row_pitch * height,
                 dst_pitch, dst_pitch * height, width, height, 1);
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
     else if (conversion)
@@ -4077,14 +4258,14 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         }
         if (texture->swapchain && texture->swapchain->palette)
             palette = texture->swapchain->palette;
-        conversion->convert(data.addr, src_pitch, mem, dst_pitch,
+        conversion->convert(data.addr, src_row_pitch, mem, dst_pitch,
                 width, height, palette, &texture->async.gl_color_key);
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
 
     wined3d_surface_upload_data(surface, gl_info, &format, &src_rect,
-            src_pitch, &dst_point, srgb, wined3d_const_bo_address(&data));
+            src_row_pitch, &dst_point, srgb, wined3d_const_bo_address(&data));
 
     HeapFree(GetProcessHeap(), 0, mem);
 
@@ -4161,6 +4342,8 @@ HRESULT surface_load_location(struct wined3d_surface *surface, struct wined3d_co
         return WINED3DERR_DEVICELOST;
     }
 
+    wined3d_surface_prepare(surface, context, location);
+
     switch (location)
     {
         case WINED3D_LOCATION_DIB:
@@ -4253,6 +4436,11 @@ static BOOL ffp_blit_supported(const struct wined3d_gl_info *gl_info,
                 return FALSE;
             }
         case WINED3D_BLIT_OP_COLOR_BLIT:
+            if (src_pool == WINED3D_POOL_SYSTEM_MEM || dst_pool == WINED3D_POOL_SYSTEM_MEM) {
+            	FIXME("blit to WINED3D_POOL_SYSTEM_MEM\n");
+                return FALSE;
+            }
+
             if (TRACE_ON(d3d_surface) && TRACE_ON(d3d))
             {
                 TRACE("Checking support for fixup:\n");
@@ -4476,6 +4664,8 @@ static HRESULT surface_cpu_blt_compressed(const BYTE *src_data, BYTE *dst_data,
 
             case WINED3DFMT_DXT2:
             case WINED3DFMT_DXT3:
+            case WINED3DFMT_DXT4:
+            case WINED3DFMT_DXT5:
                 for (y = 0; y < update_h; y += format->block_height)
                 {
                     struct block
@@ -5104,6 +5294,13 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
     }
 
     surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+    //Slice - make clipping
+    if (dst_rect.top > dst_surface->resource.height) {
+        dst_rect.top = dst_surface->resource.height;
+    }
+    if (dst_rect.right > dst_surface->resource.width) {
+        dst_rect.right = dst_surface->resource.width;
+    }
 
     if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
             || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
@@ -5118,6 +5315,12 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
     if (src_surface)
     {
         surface_get_rect(src_surface, src_rect_in, &src_rect);
+        if (src_rect.top > src_surface->resource.height) {
+            src_rect.top = src_surface->resource.height;
+        }
+        if (src_rect.right > src_surface->resource.width) {
+            src_rect.right = src_surface->resource.width;
+        }
 
         if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
                 || src_rect.left > src_surface->resource.width || src_rect.left < 0
@@ -5204,6 +5407,11 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             && (src_rect.right - src_rect.left != dst_rect.right - dst_rect.left
             || src_rect.bottom - src_rect.top != dst_rect.bottom - dst_rect.top);
     convert = src_surface && src_surface->resource.format->id != dst_surface->resource.format->id;
+    //Slice - make condition if we want cpu_blt for compressed texture
+ /*   if (src_surface->resource.format_flags & WINED3DFMT_FLAG_COMPRESSED) {
+        FIXME("only cpu blt for compressed textures\n");
+        goto cpu;
+    } */
 
     dst_ds_flags = dst_surface->container->resource.format_flags
             & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
@@ -5342,6 +5550,9 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                 TRACE("Using FBO blit.\n");
 
                 context = context_acquire(device, NULL);
+
+                wined3d_surface_prepare(dst_surface, context, dst_surface->container->resource.draw_binding);
+
                 surface_blt_fbo(device, context, filter,
                         src_surface, src_surface->container->resource.draw_binding, &src_rect,
                         dst_surface, dst_surface->container->resource.draw_binding, &dst_rect);
@@ -5388,6 +5599,12 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     unsigned int resource_size;
     HRESULT hr;
 
+    if (multisample_quality > 0)
+    {
+        FIXME("multisample_quality set to %u, substituting 0.\n", multisample_quality);
+        multisample_quality = 0;
+    }
+
     /* Quick lockable sanity check.
      * TODO: remove this after surfaces, usage and lockability have been debugged properly
      * this function is too deep to need to care about things like this.
@@ -5444,7 +5661,8 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     /* Flags */
     if (flags & WINED3D_SURFACE_DISCARD)
         surface->flags |= SFLAG_DISCARD;
-    if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE)
+    if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE ||
+        desc->format == WINED3DFMT_D32_LOCKABLE || desc->format == WINED3DFMT_S8_LOCKABLE)
         surface->resource.access_flags |= WINED3D_RESOURCE_ACCESS_CPU;
 
     surface->texture_target = target;
@@ -5523,6 +5741,24 @@ void wined3d_surface_prepare(struct wined3d_surface *surface, struct wined3d_con
 {
     switch (location)
     {
+        case WINED3D_LOCATION_SYSMEM:
+            surface_prepare_system_memory(surface);
+            break;
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            if (!surface->user_memory)
+                ERR("Map binding is set to WINED3D_LOCATION_USER_MEMORY but surface->user_memory is NULL.\n");
+            break;
+
+        case WINED3D_LOCATION_DIB:
+            if (!surface->dib.bitmap_data)
+                ERR("Map binding is set to WINED3D_LOCATION_DIB but surface->dib.bitmap_data is NULL.\n");
+            break;
+
+        case WINED3D_LOCATION_BUFFER:
+            /* Intentionally not yet handled in this patch. */
+            break;
+
         case WINED3D_LOCATION_TEXTURE_RGB:
             wined3d_texture_prepare_texture(surface->container, context, FALSE);
             break;
@@ -5531,6 +5767,10 @@ void wined3d_surface_prepare(struct wined3d_surface *surface, struct wined3d_con
             wined3d_texture_prepare_texture(surface->container, context, TRUE);
             break;
 
+        case WINED3D_LOCATION_DRAWABLE:
+            /* Nothing to do. */
+            break;
+
         case WINED3D_LOCATION_RB_MULTISAMPLE:
             surface_prepare_rb(surface, context->gl_info, TRUE);
             break;
@@ -5538,5 +5778,8 @@ void wined3d_surface_prepare(struct wined3d_surface *surface, struct wined3d_con
         case WINED3D_LOCATION_RB_RESOLVED:
             surface_prepare_rb(surface, context->gl_info, FALSE);
             break;
+
+        default:
+            ERR("Trying to prepare unknown location %#x\n", location);
     }
 }
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index e45fe17..c5737aa 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -136,12 +136,17 @@ HRESULT CDECL wined3d_swapchain_present(struct wined3d_swapchain *swapchain,
         const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
         const RGNDATA *dirty_region, DWORD flags)
 {
+    static DWORD notified_flags = 0;
+
     TRACE("swapchain %p, src_rect %s, dst_rect %s, dst_window_override %p, dirty_region %p, flags %#x.\n",
             swapchain, wine_dbgstr_rect(src_rect), wine_dbgstr_rect(dst_rect),
             dst_window_override, dirty_region, flags);
 
-    if (flags)
-        FIXME("Ignoring flags %#x.\n", flags);
+    if (flags & ~notified_flags)
+    {
+        FIXME("Ignoring flags %#x.\n", flags & ~notified_flags);
+        notified_flags |= flags;
+    }
 
     if (!swapchain->back_buffers)
     {
@@ -254,8 +259,10 @@ HRESULT CDECL wined3d_swapchain_set_gamma_ramp(const struct wined3d_swapchain *s
 
     TRACE("swapchain %p, flags %#x, ramp %p.\n", swapchain, flags, ramp);
 
-    if (flags)
-        FIXME("Ignoring flags %#x.\n", flags);
+    if (flags) {
+        FIXME("Ignoring flags %#x.\n", flags); //D3DSGR_CALIBRATE //Slice-todo
+        return WINED3D_OK;
+    }
 
     dc = GetDC(swapchain->device_window);
     SetDeviceGammaRamp(dc, (void *)ramp);
@@ -757,6 +764,13 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
     HRESULT hr;
     UINT i;
 
+    if (desc->backbuffer_count > WINED3DPRESENT_BACK_BUFFER_MAX)
+    {
+        FIXME("The application requested %u back buffers, this is not supported.\n",
+                desc->backbuffer_count);
+        return WINED3DERR_INVALIDCALL;
+    }
+
     if (desc->backbuffer_count > 1)
     {
         FIXME("The application requested more than one back buffer, this is not properly supported.\n"
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 1d5bec7..ddf7895 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -33,6 +33,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
         const struct wined3d_resource_ops *resource_ops)
 {
     const struct wined3d_format *format = wined3d_get_format(&device->adapter->gl_info, desc->format);
+    UINT surfaces_size = 0;
     HRESULT hr;
 
     TRACE("texture %p, texture_ops %p, layer_count %u, level_count %u, resource_type %s, format %s, "
@@ -43,9 +44,16 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
             debug_d3dusage(desc->usage), debug_d3dpool(desc->pool), desc->width, desc->height, desc->depth,
             surface_flags, device, parent, parent_ops, resource_ops);
 
+    if ((desc->usage & WINED3DUSAGE_TEXTURE) && wined3d_settings.contiguous_tex_mem)
+    {
+        surfaces_size = wined3d_format_calculate_size_total(format, device->surface_alignment, desc->width,
+                desc->height, desc->depth, level_count, desc->resource_type);
+        texture->allocated_subresource = level_count * layer_count;
+    }
+
     if (FAILED(hr = resource_init(&texture->resource, device, desc->resource_type, format,
             desc->multisample_type, desc->multisample_quality, desc->usage, desc->pool,
-            desc->width, desc->height, desc->depth, 0, parent, parent_ops, resource_ops)))
+            desc->width, desc->height, desc->depth, surfaces_size, parent, parent_ops, resource_ops)))
     {
         static unsigned int once;
 
@@ -122,9 +130,9 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
     for (i = 0; i < sub_count; ++i)
     {
         struct wined3d_resource *sub_resource = texture->sub_resources[i];
-
-        if (sub_resource)
-            texture->texture_ops->texture_sub_resource_cleanup(sub_resource);
+      TRACE("i=%d subresource=%p, ops=%p\n", i, sub_resource, texture->texture_ops);
+        if (sub_resource && texture->texture_ops && texture->texture_ops->texture_sub_resource_cleanup)
+            texture->texture_ops->texture_sub_resource_cleanup(sub_resource); //Slice - crash
     }
 
     wined3d_texture_unload_gl_texture(texture);
@@ -571,8 +579,8 @@ HRESULT CDECL wined3d_texture_set_color_key(struct wined3d_texture *texture,
         DWORD flags, const struct wined3d_color_key *color_key)
 {
     struct wined3d_device *device = texture->resource.device;
-    static const DWORD all_flags = WINED3D_CKEY_DST_BLT | WINED3D_CKEY_DST_OVERLAY
-            | WINED3D_CKEY_SRC_BLT | WINED3D_CKEY_SRC_OVERLAY;
+    static const DWORD all_flags = WINED3D_CKEY_COLORSPACE | WINED3D_CKEY_DST_BLT
+            | WINED3D_CKEY_DST_OVERLAY | WINED3D_CKEY_SRC_BLT | WINED3D_CKEY_SRC_OVERLAY;
 
     TRACE("texture %p, flags %#x, color_key %p.\n", texture, flags, color_key);
 
@@ -582,6 +590,13 @@ HRESULT CDECL wined3d_texture_set_color_key(struct wined3d_texture *texture,
         return WINED3DERR_INVALIDCALL;
     }
 
+    if (flags & WINED3D_CKEY_COLORSPACE)
+    {
+        //SLice 0x9 = WINED3D_CKEY_SRC_BLT | WINED3D_CKEY_COLORSPACE
+        FIXME("Unhandled flags %#x.\n", flags);
+        return WINED3DERR_INVALIDCALL;
+    }
+
     wined3d_cs_emit_set_color_key(device->cs, texture, flags, color_key);
 
     return WINED3D_OK;
@@ -782,13 +797,21 @@ static void texture2d_sub_resource_add_dirty_region(struct wined3d_resource *sub
 static void texture2d_sub_resource_cleanup(struct wined3d_resource *sub_resource)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
-
+  //Slice
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
     wined3d_surface_destroy(surface);
 }
 
 static void texture2d_sub_resource_invalidate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
 
     surface_invalidate_location(surface, location);
 }
@@ -796,6 +819,10 @@ static void texture2d_sub_resource_invalidate_location(struct wined3d_resource *
 static void texture2d_sub_resource_validate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
 
     surface_validate_location(surface, location);
 }
@@ -807,6 +834,10 @@ static void texture2d_sub_resource_upload_data(struct wined3d_resource *sub_reso
     static const POINT dst_point = {0, 0};
     struct wined3d_const_bo_address addr;
     RECT src_rect;
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
 
     src_rect.left = 0;
     src_rect.top = 0;
@@ -997,6 +1028,7 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
     struct wined3d_resource_desc surface_desc;
     unsigned int i, j;
     HRESULT hr;
+    BYTE *current_heap;
 
     /* TODO: It should only be possible to create textures for formats
      * that are reported as supported. */
@@ -1059,6 +1091,7 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
     /* Generate all the surfaces. */
     surface_desc = *desc;
     surface_desc.resource_type = WINED3D_RTYPE_SURFACE;
+    current_heap = texture->resource.heap_memory;
     for (i = 0; i < texture->level_count; ++i)
     {
         /* Create the 6 faces. */
@@ -1084,6 +1117,13 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
                 return hr;
             }
 
+            if ((desc->usage & WINED3DUSAGE_TEXTURE) && wined3d_settings.contiguous_tex_mem)
+            {
+                surface->resource.heap_memory = current_heap;
+                current_heap += wined3d_format_calculate_size(texture->resource.format,
+                        device->surface_alignment, surface_desc.width, surface_desc.height, 1);
+            }
+
             texture->sub_resources[idx] = &surface->resource;
             TRACE("Created surface level %u @ %p.\n", i, surface);
         }
@@ -1103,6 +1143,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     UINT pow2_width, pow2_height;
     unsigned int i;
     HRESULT hr;
+    BYTE *current_heap;
 
     /* TODO: It should only be possible to create textures for formats
      * that are reported as supported. */
@@ -1207,6 +1248,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     /* Generate all the surfaces. */
     surface_desc = *desc;
     surface_desc.resource_type = WINED3D_RTYPE_SURFACE;
+    current_heap = texture->resource.heap_memory;
     for (i = 0; i < texture->level_count; ++i)
     {
         struct wined3d_surface *surface;
@@ -1219,6 +1261,13 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             return hr;
         }
 
+        if ((desc->usage & WINED3DUSAGE_TEXTURE) && wined3d_settings.contiguous_tex_mem)
+        {
+            surface->resource.heap_memory = current_heap;
+            current_heap += wined3d_format_calculate_size(texture->resource.format,
+                    device->surface_alignment, surface_desc.width, surface_desc.height, 1);
+        }
+
         texture->sub_resources[i] = &surface->resource;
         TRACE("Created surface level %u @ %p.\n", i, surface);
         /* Calculate the next mipmap level. */
@@ -1244,13 +1293,24 @@ static void texture3d_sub_resource_add_dirty_region(struct wined3d_resource *sub
 static void texture3d_sub_resource_cleanup(struct wined3d_resource *sub_resource)
 {
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
-
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
+  TRACE("volume %p destroy\n", volume);
+  //trace:d3d_texture:texture3d_sub_resource_cleanup volume 0x70f1c60 destroy
     wined3d_volume_destroy(volume);
 }
 
 static void texture3d_sub_resource_invalidate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
 
     wined3d_volume_invalidate_location(volume, location);
 }
@@ -1258,6 +1318,11 @@ static void texture3d_sub_resource_invalidate_location(struct wined3d_resource *
 static void texture3d_sub_resource_validate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
 
     wined3d_volume_validate_location(volume, location);
 }
@@ -1268,8 +1333,13 @@ static void texture3d_sub_resource_upload_data(struct wined3d_resource *sub_reso
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
     struct wined3d_const_bo_address addr;
     unsigned int row_pitch, slice_pitch;
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
 
-    wined3d_volume_get_pitch(volume, &row_pitch, &slice_pitch);
+    wined3d_resource_get_pitch(sub_resource, &row_pitch, &slice_pitch);
     if (row_pitch != data->row_pitch || slice_pitch != data->slice_pitch)
         FIXME("Ignoring row/slice pitch (%u/%u).\n", data->row_pitch, data->slice_pitch);
 
@@ -1365,6 +1435,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     struct wined3d_resource_desc volume_desc;
     unsigned int i;
     HRESULT hr;
+    BYTE *current_heap;
 
     /* TODO: It should only be possible to create textures for formats
      * that are reported as supported. */
@@ -1440,6 +1511,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     /* Generate all the surfaces. */
     volume_desc = *desc;
     volume_desc.resource_type = WINED3D_RTYPE_VOLUME;
+    current_heap = texture->resource.heap_memory;
     for (i = 0; i < texture->level_count; ++i)
     {
         struct wined3d_volume *volume;
@@ -1451,6 +1523,13 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             return hr;
         }
 
+        if ((desc->usage & WINED3DUSAGE_TEXTURE) && wined3d_settings.contiguous_tex_mem)
+        {
+            volume->resource.heap_memory = current_heap;
+            current_heap += wined3d_format_calculate_size(texture->resource.format,
+                    device->surface_alignment, volume_desc.width, volume_desc.height, volume_desc.depth);
+        }
+
         texture->sub_resources[i] = &volume->resource;
 
         /* Calculate the next mipmap level. */
diff --git a/dlls/wined3d/txc_compress_dxtn.c b/dlls/wined3d/txc_compress_dxtn.c
new file mode 100644
index 0000000..217f6b5
--- /dev/null
+++ b/dlls/wined3d/txc_compress_dxtn.c
@@ -0,0 +1,853 @@
+/*
+ * libtxc_dxtn
+ * Version:  1.0
+ *
+ * Copyright (C) 2004  Roland Scheidegger   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "config.h"
+//#include <stdio.h>
+//#include <stdlib.h>
+#include "txc_dxtn.h"
+
+/* weights used for error function, basically weights (unsquared 2/4/1) according to rgb->luminance conversion
+   not sure if this really reflects visual perception */
+#define REDWEIGHT 4
+#define GREENWEIGHT 16
+#define BLUEWEIGHT 1
+
+#define ALPHACUT 127
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3d);
+
+static void fancybasecolorsearch( GLubyte *blkaddr, GLubyte srccolors[4][4][4], GLubyte *bestcolor[2],
+                           GLint numxpixels, GLint numypixels, GLint type, GLboolean haveAlpha)
+{
+   /* use same luminance-weighted distance metric to determine encoding as for finding the base colors */
+
+   /* TODO could also try to find a better encoding for the 3-color-encoding type, this really should be done
+      if it's rgba_dxt1 and we have alpha in the block, currently even values which will be mapped to black
+      due to their alpha value will influence the result */
+   GLint i, j, colors, z;
+   GLuint pixerror, pixerrorred, pixerrorgreen, pixerrorblue, pixerrorbest;
+   GLint colordist, blockerrlin[2][3];
+   GLubyte nrcolor[2];
+   GLint pixerrorcolorbest[3];
+   GLubyte enc = 0;
+   GLubyte cv[4][4];
+   GLubyte testcolor[2][3];
+
+/*   fprintf(stderr, "color begin 0 r/g/b %d/%d/%d, 1 r/g/b %d/%d/%d\n",
+      bestcolor[0][0], bestcolor[0][1], bestcolor[0][2], bestcolor[1][0], bestcolor[1][1], bestcolor[1][2]);*/
+   if (((bestcolor[0][0] & 0xf8) << 8 | (bestcolor[0][1] & 0xfc) << 3 | bestcolor[0][2] >> 3) <
+      ((bestcolor[1][0] & 0xf8) << 8 | (bestcolor[1][1] & 0xfc) << 3 | bestcolor[1][2] >> 3)) {
+      testcolor[0][0] = bestcolor[0][0];
+      testcolor[0][1] = bestcolor[0][1];
+      testcolor[0][2] = bestcolor[0][2];
+      testcolor[1][0] = bestcolor[1][0];
+      testcolor[1][1] = bestcolor[1][1];
+      testcolor[1][2] = bestcolor[1][2];
+   }
+   else {
+      testcolor[1][0] = bestcolor[0][0];
+      testcolor[1][1] = bestcolor[0][1];
+      testcolor[1][2] = bestcolor[0][2];
+      testcolor[0][0] = bestcolor[1][0];
+      testcolor[0][1] = bestcolor[1][1];
+      testcolor[0][2] = bestcolor[1][2];
+   }
+
+   for (i = 0; i < 3; i ++) {
+      cv[0][i] = testcolor[0][i];
+      cv[1][i] = testcolor[1][i];
+      cv[2][i] = (testcolor[0][i] * 2 + testcolor[1][i]) / 3;
+      cv[3][i] = (testcolor[0][i] + testcolor[1][i] * 2) / 3;
+   }
+
+   blockerrlin[0][0] = 0;
+   blockerrlin[0][1] = 0;
+   blockerrlin[0][2] = 0;
+   blockerrlin[1][0] = 0;
+   blockerrlin[1][1] = 0;
+   blockerrlin[1][2] = 0;
+
+   nrcolor[0] = 0;
+   nrcolor[1] = 0;
+
+   for (j = 0; j < numypixels; j++) {
+      for (i = 0; i < numxpixels; i++) {
+         pixerrorbest = 0xffffffff;
+         for (colors = 0; colors < 4; colors++) {
+            colordist = srccolors[j][i][0] - (cv[colors][0]);
+            pixerror = colordist * colordist * REDWEIGHT;
+            pixerrorred = colordist;
+            colordist = srccolors[j][i][1] - (cv[colors][1]);
+            pixerror += colordist * colordist * GREENWEIGHT;
+            pixerrorgreen = colordist;
+            colordist = srccolors[j][i][2] - (cv[colors][2]);
+            pixerror += colordist * colordist * BLUEWEIGHT;
+            pixerrorblue = colordist;
+            if (pixerror < pixerrorbest) {
+               enc = colors;
+               pixerrorbest = pixerror;
+               pixerrorcolorbest[0] = pixerrorred;
+               pixerrorcolorbest[1] = pixerrorgreen;
+               pixerrorcolorbest[2] = pixerrorblue;
+            }
+         }
+         if (enc == 0) {
+            for (z = 0; z < 3; z++) {
+               blockerrlin[0][z] += 3 * pixerrorcolorbest[z];
+            }
+            nrcolor[0] += 3;
+         }
+         else if (enc == 2) {
+            for (z = 0; z < 3; z++) {
+               blockerrlin[0][z] += 2 * pixerrorcolorbest[z];
+            }
+            nrcolor[0] += 2;
+            for (z = 0; z < 3; z++) {
+               blockerrlin[1][z] += 1 * pixerrorcolorbest[z];
+            }
+            nrcolor[1] += 1;
+         }
+         else if (enc == 3) {
+            for (z = 0; z < 3; z++) {
+               blockerrlin[0][z] += 1 * pixerrorcolorbest[z];
+            }
+            nrcolor[0] += 1;
+            for (z = 0; z < 3; z++) {
+               blockerrlin[1][z] += 2 * pixerrorcolorbest[z];
+            }
+            nrcolor[1] += 2;
+         }
+         else if (enc == 1) {
+            for (z = 0; z < 3; z++) {
+               blockerrlin[1][z] += 3 * pixerrorcolorbest[z];
+            }
+            nrcolor[1] += 3;
+         }
+      }
+   }
+   if (nrcolor[0] == 0) nrcolor[0] = 1;
+   if (nrcolor[1] == 0) nrcolor[1] = 1;
+   for (j = 0; j < 2; j++) {
+      for (i = 0; i < 3; i++) {
+	 GLint newvalue = testcolor[j][i] + blockerrlin[j][i] / nrcolor[j];
+	 if (newvalue <= 0)
+	    testcolor[j][i] = 0;
+	 else if (newvalue >= 255)
+	    testcolor[j][i] = 255;
+	 else testcolor[j][i] = newvalue;
+      }
+   }
+
+   if ((abs(testcolor[0][0] - testcolor[1][0]) < 8) &&
+       (abs(testcolor[0][1] - testcolor[1][1]) < 4) &&
+       (abs(testcolor[0][2] - testcolor[1][2]) < 8)) {
+       /* both colors are so close they might get encoded as the same 16bit values */
+      GLubyte coldiffred, coldiffgreen, coldiffblue, coldiffmax, factor, ind0, ind1;
+
+      coldiffred = abs(testcolor[0][0] - testcolor[1][0]);
+      coldiffgreen = 2 * abs(testcolor[0][1] - testcolor[1][1]);
+      coldiffblue = abs(testcolor[0][2] - testcolor[1][2]);
+      coldiffmax = coldiffred;
+      if (coldiffmax < coldiffgreen) coldiffmax = coldiffgreen;
+      if (coldiffmax < coldiffblue) coldiffmax = coldiffblue;
+      if (coldiffmax > 0) {
+         if (coldiffmax > 4) factor = 2;
+         else if (coldiffmax > 2) factor = 3;
+         else factor = 4;
+         /* Won't do much if the color value is near 255... */
+         /* argh so many ifs */
+         if (testcolor[1][1] >= testcolor[0][1]) {
+            ind1 = 1; ind0 = 0;
+         }
+         else {
+            ind1 = 0; ind0 = 1;
+         }
+         if ((testcolor[ind1][1] + factor * coldiffgreen) <= 255)
+            testcolor[ind1][1] += factor * coldiffgreen;
+         else testcolor[ind1][1] = 255;
+         if ((testcolor[ind1][0] - testcolor[ind0][1]) > 0) {
+            if ((testcolor[ind1][0] + factor * coldiffred) <= 255)
+               testcolor[ind1][0] += factor * coldiffred;
+            else testcolor[ind1][0] = 255;
+         }
+         else {
+            if ((testcolor[ind0][0] + factor * coldiffred) <= 255)
+               testcolor[ind0][0] += factor * coldiffred;
+            else testcolor[ind0][0] = 255;
+         }
+         if ((testcolor[ind1][2] - testcolor[ind0][2]) > 0) {
+            if ((testcolor[ind1][2] + factor * coldiffblue) <= 255)
+               testcolor[ind1][2] += factor * coldiffblue;
+            else testcolor[ind1][2] = 255;
+         }
+         else {
+            if ((testcolor[ind0][2] + factor * coldiffblue) <= 255)
+               testcolor[ind0][2] += factor * coldiffblue;
+            else testcolor[ind0][2] = 255;
+         }
+      }
+   }
+
+   if (((testcolor[0][0] & 0xf8) << 8 | (testcolor[0][1] & 0xfc) << 3 | testcolor[0][2] >> 3) <
+      ((testcolor[1][0] & 0xf8) << 8 | (testcolor[1][1] & 0xfc) << 3 | testcolor[1][2]) >> 3) {
+      for (i = 0; i < 3; i++) {
+         bestcolor[0][i] = testcolor[0][i];
+         bestcolor[1][i] = testcolor[1][i];
+      }
+   }
+   else {
+      for (i = 0; i < 3; i++) {
+         bestcolor[0][i] = testcolor[1][i];
+         bestcolor[1][i] = testcolor[0][i];
+      }
+   }
+
+/*     fprintf(stderr, "color end 0 r/g/b %d/%d/%d, 1 r/g/b %d/%d/%d\n",
+     bestcolor[0][0], bestcolor[0][1], bestcolor[0][2], bestcolor[1][0], bestcolor[1][1], bestcolor[1][2]);*/
+}
+
+
+
+static void storedxtencodedblock( GLubyte *blkaddr, GLubyte srccolors[4][4][4], GLubyte *bestcolor[2],
+                           GLint numxpixels, GLint numypixels, GLuint type, GLboolean haveAlpha)
+{
+   /* use same luminance-weighted distance metric to determine encoding as for finding the base colors */
+
+   GLint i, j, colors;
+   GLuint testerror, testerror2, pixerror, pixerrorbest;
+   GLint colordist;
+   GLushort color0, color1, tempcolor;
+   GLuint bits = 0, bits2 = 0;
+   GLubyte *colorptr;
+   GLubyte enc = 0;
+   GLubyte cv[4][4];
+
+   bestcolor[0][0] = bestcolor[0][0] & 0xf8;
+   bestcolor[0][1] = bestcolor[0][1] & 0xfc;
+   bestcolor[0][2] = bestcolor[0][2] & 0xf8;
+   bestcolor[1][0] = bestcolor[1][0] & 0xf8;
+   bestcolor[1][1] = bestcolor[1][1] & 0xfc;
+   bestcolor[1][2] = bestcolor[1][2] & 0xf8;
+
+   color0 = bestcolor[0][0] << 8 | bestcolor[0][1] << 3 | bestcolor[0][2] >> 3;
+   color1 = bestcolor[1][0] << 8 | bestcolor[1][1] << 3 | bestcolor[1][2] >> 3;
+   if (color0 < color1) {
+      tempcolor = color0; color0 = color1; color1 = tempcolor;
+      colorptr = bestcolor[0]; bestcolor[0] = bestcolor[1]; bestcolor[1] = colorptr;
+   }
+
+
+   for (i = 0; i < 3; i++) {
+      cv[0][i] = bestcolor[0][i];
+      cv[1][i] = bestcolor[1][i];
+      cv[2][i] = (bestcolor[0][i] * 2 + bestcolor[1][i]) / 3;
+      cv[3][i] = (bestcolor[0][i] + bestcolor[1][i] * 2) / 3;
+   }
+
+   testerror = 0;
+   for (j = 0; j < numypixels; j++) {
+      for (i = 0; i < numxpixels; i++) {
+         pixerrorbest = 0xffffffff;
+         for (colors = 0; colors < 4; colors++) {
+            colordist = srccolors[j][i][0] - cv[colors][0];
+            pixerror = colordist * colordist * REDWEIGHT;
+            colordist = srccolors[j][i][1] - cv[colors][1];
+            pixerror += colordist * colordist * GREENWEIGHT;
+            colordist = srccolors[j][i][2] - cv[colors][2];
+            pixerror += colordist * colordist * BLUEWEIGHT;
+            if (pixerror < pixerrorbest) {
+               pixerrorbest = pixerror;
+               enc = colors;
+            }
+         }
+         testerror += pixerrorbest;
+         bits |= enc << (2 * (j * 4 + i));
+      }
+   }
+   /* some hw might disagree but actually decoding should always use 4-color encoding
+      for non-dxt1 formats */
+   if (type == GL_COMPRESSED_RGB_S3TC_DXT1_EXT || type == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) {
+      for (i = 0; i < 3; i++) {
+         cv[2][i] = (bestcolor[0][i] + bestcolor[1][i]) / 2;
+         /* this isn't used. Looks like the black color constant can only be used
+            with RGB_DXT1 if I read the spec correctly (note though that the radeon gpu disagrees,
+            it will decode 3 to black even with DXT3/5), and due to how the color searching works
+            it won't get used even then */
+         cv[3][i] = 0;
+      }
+      testerror2 = 0;
+      for (j = 0; j < numypixels; j++) {
+         for (i = 0; i < numxpixels; i++) {
+            pixerrorbest = 0xffffffff;
+            if ((type == GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) && (srccolors[j][i][3] <= ALPHACUT)) {
+               enc = 3;
+               pixerrorbest = 0; /* don't calculate error */
+            }
+            else {
+               /* we're calculating the same what we have done already for colors 0-1 above... */
+               for (colors = 0; colors < 3; colors++) {
+                  colordist = srccolors[j][i][0] - cv[colors][0];
+                  pixerror = colordist * colordist * REDWEIGHT;
+                  colordist = srccolors[j][i][1] - cv[colors][1];
+                  pixerror += colordist * colordist * GREENWEIGHT;
+                  colordist = srccolors[j][i][2] - cv[colors][2];
+                  pixerror += colordist * colordist * BLUEWEIGHT;
+                  if (pixerror < pixerrorbest) {
+                     pixerrorbest = pixerror;
+                     /* need to exchange colors later */
+                     if (colors > 1) enc = colors;
+                     else enc = colors ^ 1;
+                  }
+               }
+            }
+            testerror2 += pixerrorbest;
+            bits2 |= enc << (2 * (j * 4 + i));
+         }
+      }
+   } else {
+      testerror2 = 0xffffffff;
+   }
+
+   /* finally we're finished, write back colors and bits */
+   if ((testerror > testerror2) || (haveAlpha)) {
+      *blkaddr++ = color1 & 0xff;
+      *blkaddr++ = color1 >> 8;
+      *blkaddr++ = color0 & 0xff;
+      *blkaddr++ = color0 >> 8;
+      *blkaddr++ = bits2 & 0xff;
+      *blkaddr++ = ( bits2 >> 8) & 0xff;
+      *blkaddr++ = ( bits2 >> 16) & 0xff;
+      *blkaddr = bits2 >> 24;
+   }
+   else {
+      *blkaddr++ = color0 & 0xff;
+      *blkaddr++ = color0 >> 8;
+      *blkaddr++ = color1 & 0xff;
+      *blkaddr++ = color1 >> 8;
+      *blkaddr++ = bits & 0xff;
+      *blkaddr++ = ( bits >> 8) & 0xff;
+      *blkaddr++ = ( bits >> 16) & 0xff;
+      *blkaddr = bits >> 24;
+   }
+}
+
+static void encodedxtcolorblockfaster( GLubyte *blkaddr, GLubyte srccolors[4][4][4],
+                         GLint numxpixels, GLint numypixels, GLuint type )
+{
+/* simplistic approach. We need two base colors, simply use the "highest" and the "lowest" color
+   present in the picture as base colors */
+
+   /* define lowest and highest color as shortest and longest vector to 0/0/0, though the
+      vectors are weighted similar to their importance in rgb-luminance conversion
+      doesn't work too well though...
+      This seems to be a rather difficult problem */
+
+   GLubyte *bestcolor[2];
+   GLubyte basecolors[2][3];
+   GLubyte i, j;
+   GLuint lowcv, highcv, testcv;
+   GLboolean haveAlpha = GL_FALSE;
+
+   lowcv = highcv = srccolors[0][0][0] * srccolors[0][0][0] * REDWEIGHT +
+                          srccolors[0][0][1] * srccolors[0][0][1] * GREENWEIGHT +
+                          srccolors[0][0][2] * srccolors[0][0][2] * BLUEWEIGHT;
+   bestcolor[0] = bestcolor[1] = srccolors[0][0];
+   for (j = 0; j < numypixels; j++) {
+      for (i = 0; i < numxpixels; i++) {
+         /* don't use this as a base color if the pixel will get black/transparent anyway */
+         if ((type != GL_COMPRESSED_RGBA_S3TC_DXT1_EXT) || (srccolors[j][i][3] > ALPHACUT)) {
+            testcv = srccolors[j][i][0] * srccolors[j][i][0] * REDWEIGHT +
+                     srccolors[j][i][1] * srccolors[j][i][1] * GREENWEIGHT +
+                     srccolors[j][i][2] * srccolors[j][i][2] * BLUEWEIGHT;
+            if (testcv > highcv) {
+               highcv = testcv;
+               bestcolor[1] = srccolors[j][i];
+            }
+            else if (testcv < lowcv) {
+               lowcv = testcv;
+               bestcolor[0] = srccolors[j][i];
+            }
+         }
+         else haveAlpha = GL_TRUE;
+      }
+   }
+   /* make sure the original color values won't get touched... */
+   for (j = 0; j < 2; j++) {
+      for (i = 0; i < 3; i++) {
+         basecolors[j][i] = bestcolor[j][i];
+      }
+   }
+   bestcolor[0] = basecolors[0];
+   bestcolor[1] = basecolors[1];
+
+   /* try to find better base colors */
+   fancybasecolorsearch(blkaddr, srccolors, bestcolor, numxpixels, numypixels, type, haveAlpha);
+   /* find the best encoding for these colors, and store the result */
+   storedxtencodedblock(blkaddr, srccolors, bestcolor, numxpixels, numypixels, type, haveAlpha);
+}
+
+static void writedxt5encodedalphablock( GLubyte *blkaddr, GLubyte alphabase1, GLubyte alphabase2,
+                         GLubyte alphaenc[16])
+{
+   *blkaddr++ = alphabase1;
+   *blkaddr++ = alphabase2;
+   *blkaddr++ = alphaenc[0] | (alphaenc[1] << 3) | ((alphaenc[2] & 3) << 6);
+   *blkaddr++ = (alphaenc[2] >> 2) | (alphaenc[3] << 1) | (alphaenc[4] << 4) | ((alphaenc[5] & 1) << 7);
+   *blkaddr++ = (alphaenc[5] >> 1) | (alphaenc[6] << 2) | (alphaenc[7] << 5);
+   *blkaddr++ = alphaenc[8] | (alphaenc[9] << 3) | ((alphaenc[10] & 3) << 6);
+   *blkaddr++ = (alphaenc[10] >> 2) | (alphaenc[11] << 1) | (alphaenc[12] << 4) | ((alphaenc[13] & 1) << 7);
+   *blkaddr++ = (alphaenc[13] >> 1) | (alphaenc[14] << 2) | (alphaenc[15] << 5);
+}
+
+static void encodedxt5alpha(GLubyte *blkaddr, GLubyte srccolors[4][4][4],
+                            GLint numxpixels, GLint numypixels)
+{
+   GLubyte alphabase[2], alphause[2];
+    GLshort alphatest[2] = {0, 0};
+   GLuint alphablockerror1, alphablockerror2, alphablockerror3;
+   GLubyte i, j, aindex, acutValues[7];
+   GLubyte alphaenc1[16], alphaenc2[16], alphaenc3[16];
+   GLboolean alphaabsmin = GL_FALSE;
+   GLboolean alphaabsmax = GL_FALSE;
+   GLshort alphadist;
+
+   /* find lowest and highest alpha value in block, alphabase[0] lowest, alphabase[1] highest */
+   alphabase[0] = 0xff; alphabase[1] = 0x0;
+   for (j = 0; j < numypixels; j++) {
+      for (i = 0; i < numxpixels; i++) {
+         if (srccolors[j][i][3] == 0)
+            alphaabsmin = GL_TRUE;
+         else if (srccolors[j][i][3] == 255)
+            alphaabsmax = GL_TRUE;
+         else {
+            if (srccolors[j][i][3] > alphabase[1])
+               alphabase[1] = srccolors[j][i][3];
+            if (srccolors[j][i][3] < alphabase[0])
+               alphabase[0] = srccolors[j][i][3];
+         }
+      }
+   }
+
+
+   if ((alphabase[0] > alphabase[1]) && !(alphaabsmin && alphaabsmax)) { /* one color, either max or min */
+      /* shortcut here since it is a very common case (and also avoids later problems) */
+      /* || (alphabase[0] == alphabase[1] && !alphaabsmin && !alphaabsmax) */
+      /* could also thest for alpha0 == alpha1 (and not min/max), but probably not common, so don't bother */
+
+      *blkaddr++ = srccolors[0][0][3];
+      blkaddr++;
+      *blkaddr++ = 0;
+      *blkaddr++ = 0;
+      *blkaddr++ = 0;
+      *blkaddr++ = 0;
+      *blkaddr++ = 0;
+      *blkaddr++ = 0;
+/*      fprintf(stderr, "enc0 used\n");*/
+      return;
+   }
+
+   /* find best encoding for alpha0 > alpha1 */
+   /* it's possible this encoding is better even if both alphaabsmin and alphaabsmax are true */
+   alphablockerror1 = 0x0;
+   alphablockerror2 = 0xffffffff;
+   alphablockerror3 = 0xffffffff;
+   if (alphaabsmin) alphause[0] = 0;
+   else alphause[0] = alphabase[0];
+   if (alphaabsmax) alphause[1] = 255;
+   else alphause[1] = alphabase[1];
+   /* calculate the 7 cut values, just the middle between 2 of the computed alpha values */
+   for (aindex = 0; aindex < 7; aindex++) {
+      /* don't forget here is always rounded down */
+      acutValues[aindex] = (alphause[0] * (2*aindex + 1) + alphause[1] * (14 - (2*aindex + 1))) / 14;
+   }
+
+   for (j = 0; j < numypixels; j++) {
+      for (i = 0; i < numxpixels; i++) {
+         /* maybe it's overkill to have the most complicated calculation just for the error
+            calculation which we only need to figure out if encoding1 or encoding2 is better... */
+         if (srccolors[j][i][3] > acutValues[0]) {
+            alphaenc1[4*j + i] = 0;
+            alphadist = srccolors[j][i][3] - alphause[1];
+         }
+         else if (srccolors[j][i][3] > acutValues[1]) {
+            alphaenc1[4*j + i] = 2;
+            alphadist = srccolors[j][i][3] - (alphause[1] * 6 + alphause[0] * 1) / 7;
+         }
+         else if (srccolors[j][i][3] > acutValues[2]) {
+            alphaenc1[4*j + i] = 3;
+            alphadist = srccolors[j][i][3] - (alphause[1] * 5 + alphause[0] * 2) / 7;
+         }
+         else if (srccolors[j][i][3] > acutValues[3]) {
+            alphaenc1[4*j + i] = 4;
+            alphadist = srccolors[j][i][3] - (alphause[1] * 4 + alphause[0] * 3) / 7;
+         }
+         else if (srccolors[j][i][3] > acutValues[4]) {
+            alphaenc1[4*j + i] = 5;
+            alphadist = srccolors[j][i][3] - (alphause[1] * 3 + alphause[0] * 4) / 7;
+         }
+         else if (srccolors[j][i][3] > acutValues[5]) {
+            alphaenc1[4*j + i] = 6;
+            alphadist = srccolors[j][i][3] - (alphause[1] * 2 + alphause[0] * 5) / 7;
+         }
+         else if (srccolors[j][i][3] > acutValues[6]) {
+            alphaenc1[4*j + i] = 7;
+            alphadist = srccolors[j][i][3] - (alphause[1] * 1 + alphause[0] * 6) / 7;
+         }
+         else {
+            alphaenc1[4*j + i] = 1;
+            alphadist = srccolors[j][i][3] - alphause[0];
+         }
+         alphablockerror1 += alphadist * alphadist;
+      }
+   }
+/*      for (i = 0; i < 16; i++) {
+         fprintf(stderr, "%d ", alphaenc1[i]);
+      }
+      fprintf(stderr, "cutVals ");
+      for (i = 0; i < 8; i++) {
+         fprintf(stderr, "%d ", acutValues[i]);
+      }
+      fprintf(stderr, "srcVals ");
+      for (j = 0; j < numypixels; j++)
+         for (i = 0; i < numxpixels; i++) {
+            fprintf(stderr, "%d ", srccolors[j][i][3]);
+         }
+
+      fprintf(stderr, "\n");
+   }*/
+   /* it's not very likely this encoding is better if both alphaabsmin and alphaabsmax
+      are false but try it anyway */
+   if (alphablockerror1 >= 32) {
+
+      /* don't bother if encoding is already very good, this condition should also imply
+      we have valid alphabase colors which we absolutely need (alphabase[0] <= alphabase[1]) */
+      alphablockerror2 = 0;
+      for (aindex = 0; aindex < 5; aindex++) {
+         /* don't forget here is always rounded down */
+         acutValues[aindex] = (alphabase[0] * (10 - (2*aindex + 1)) + alphabase[1] * (2*aindex + 1)) / 10;
+      }
+      for (j = 0; j < numypixels; j++) {
+         for (i = 0; i < numxpixels; i++) {
+             /* maybe it's overkill to have the most complicated calculation just for the error
+               calculation which we only need to figure out if encoding1 or encoding2 is better... */
+            if (srccolors[j][i][3] == 0) {
+               alphaenc2[4*j + i] = 6;
+               alphadist = 0;
+            }
+            else if (srccolors[j][i][3] == 255) {
+               alphaenc2[4*j + i] = 7;
+               alphadist = 0;
+            }
+            else if (srccolors[j][i][3] <= acutValues[0]) {
+               alphaenc2[4*j + i] = 0;
+               alphadist = srccolors[j][i][3] - alphabase[0];
+            }
+            else if (srccolors[j][i][3] <= acutValues[1]) {
+               alphaenc2[4*j + i] = 2;
+               alphadist = srccolors[j][i][3] - (alphabase[0] * 4 + alphabase[1] * 1) / 5;
+            }
+            else if (srccolors[j][i][3] <= acutValues[2]) {
+               alphaenc2[4*j + i] = 3;
+               alphadist = srccolors[j][i][3] - (alphabase[0] * 3 + alphabase[1] * 2) / 5;
+            }
+            else if (srccolors[j][i][3] <= acutValues[3]) {
+               alphaenc2[4*j + i] = 4;
+               alphadist = srccolors[j][i][3] - (alphabase[0] * 2 + alphabase[1] * 3) / 5;
+            }
+            else if (srccolors[j][i][3] <= acutValues[4]) {
+               alphaenc2[4*j + i] = 5;
+               alphadist = srccolors[j][i][3] - (alphabase[0] * 1 + alphabase[1] * 4) / 5;
+            }
+            else {
+               alphaenc2[4*j + i] = 1;
+               alphadist = srccolors[j][i][3] - alphabase[1];
+            }
+            alphablockerror2 += alphadist * alphadist;
+         }
+      }
+
+
+      /* skip this if the error is already very small
+         this encoding is MUCH better on average than #2 though, but expensive! */
+      if ((alphablockerror2 > 96) && (alphablockerror1 > 96)) {
+         GLshort blockerrlin1 = 0;
+         GLshort blockerrlin2 = 0;
+         GLubyte nralphainrangelow = 0;
+         GLubyte nralphainrangehigh = 0;
+         alphatest[0] = 0xff;
+         alphatest[1] = 0x0;
+         /* if we have large range it's likely there are values close to 0/255, try to map them to 0/255 */
+         for (j = 0; j < numypixels; j++) {
+            for (i = 0; i < numxpixels; i++) {
+               if ((srccolors[j][i][3] > alphatest[1]) && (srccolors[j][i][3] < (255 -(alphabase[1] - alphabase[0]) / 28)))
+                  alphatest[1] = srccolors[j][i][3];
+               if ((srccolors[j][i][3] < alphatest[0]) && (srccolors[j][i][3] > (alphabase[1] - alphabase[0]) / 28))
+                  alphatest[0] = srccolors[j][i][3];
+            }
+         }
+          /* shouldn't happen too often, don't really care about those degenerated cases */
+          if (alphatest[1] <= alphatest[0]) {
+             alphatest[0] = 1;
+             alphatest[1] = 254;
+/*             fprintf(stderr, "only 1 or 0 colors for encoding!\n");*/
+         }
+         for (aindex = 0; aindex < 5; aindex++) {
+         /* don't forget here is always rounded down */
+            acutValues[aindex] = (alphatest[0] * (10 - (2*aindex + 1)) + alphatest[1] * (2*aindex + 1)) / 10;
+         }
+
+         /* find the "average" difference between the alpha values and the next encoded value.
+            This is then used to calculate new base values.
+            Should there be some weighting, i.e. those values closer to alphatest[x] have more weight,
+            since they will see more improvement, and also because the values in the middle are somewhat
+            likely to get no improvement at all (because the base values might move in different directions)?
+            OTOH it would mean the values in the middle are even less likely to get an improvement
+         */
+         for (j = 0; j < numypixels; j++) {
+            for (i = 0; i < numxpixels; i++) {
+               if (srccolors[j][i][3] <= alphatest[0] / 2) {
+               }
+               else if (srccolors[j][i][3] > ((255 + alphatest[1]) / 2)) {
+               }
+               else if (srccolors[j][i][3] <= acutValues[0]) {
+                  blockerrlin1 += (srccolors[j][i][3] - alphatest[0]);
+                  nralphainrangelow += 1;
+               }
+               else if (srccolors[j][i][3] <= acutValues[1]) {
+                  blockerrlin1 += (srccolors[j][i][3] - (alphatest[0] * 4 + alphatest[1] * 1) / 5);
+                  blockerrlin2 += (srccolors[j][i][3] - (alphatest[0] * 4 + alphatest[1] * 1) / 5);
+                  nralphainrangelow += 1;
+                  nralphainrangehigh += 1;
+               }
+               else if (srccolors[j][i][3] <= acutValues[2]) {
+                  blockerrlin1 += (srccolors[j][i][3] - (alphatest[0] * 3 + alphatest[1] * 2) / 5);
+                  blockerrlin2 += (srccolors[j][i][3] - (alphatest[0] * 3 + alphatest[1] * 2) / 5);
+                  nralphainrangelow += 1;
+                  nralphainrangehigh += 1;
+               }
+               else if (srccolors[j][i][3] <= acutValues[3]) {
+                  blockerrlin1 += (srccolors[j][i][3] - (alphatest[0] * 2 + alphatest[1] * 3) / 5);
+                  blockerrlin2 += (srccolors[j][i][3] - (alphatest[0] * 2 + alphatest[1] * 3) / 5);
+                  nralphainrangelow += 1;
+                  nralphainrangehigh += 1;
+               }
+               else if (srccolors[j][i][3] <= acutValues[4]) {
+                  blockerrlin1 += (srccolors[j][i][3] - (alphatest[0] * 1 + alphatest[1] * 4) / 5);
+                  blockerrlin2 += (srccolors[j][i][3] - (alphatest[0] * 1 + alphatest[1] * 4) / 5);
+                  nralphainrangelow += 1;
+                  nralphainrangehigh += 1;
+                  }
+               else {
+                  blockerrlin2 += (srccolors[j][i][3] - alphatest[1]);
+                  nralphainrangehigh += 1;
+               }
+            }
+         }
+         /* shouldn't happen often, needed to avoid div by zero */
+         if (nralphainrangelow == 0) nralphainrangelow = 1;
+         if (nralphainrangehigh == 0) nralphainrangehigh = 1;
+         alphatest[0] = alphatest[0] + (blockerrlin1 / nralphainrangelow);
+/*         fprintf(stderr, "block err lin low %d, nr %d\n", blockerrlin1, nralphainrangelow);
+         fprintf(stderr, "block err lin high %d, nr %d\n", blockerrlin2, nralphainrangehigh);*/
+         /* again shouldn't really happen often... */
+         if (alphatest[0] < 0) {
+            alphatest[0] = 0;
+/*            fprintf(stderr, "adj alpha base val to 0\n");*/
+         }
+         alphatest[1] = alphatest[1] + (blockerrlin2 / nralphainrangehigh);
+         if (alphatest[1] > 255) {
+            alphatest[1] = 255;
+/*            fprintf(stderr, "adj alpha base val to 255\n");*/
+         }
+
+         alphablockerror3 = 0;
+         for (aindex = 0; aindex < 5; aindex++) {
+         /* don't forget here is always rounded down */
+            acutValues[aindex] = (alphatest[0] * (10 - (2*aindex + 1)) + alphatest[1] * (2*aindex + 1)) / 10;
+         }
+         for (j = 0; j < numypixels; j++) {
+            for (i = 0; i < numxpixels; i++) {
+                /* maybe it's overkill to have the most complicated calculation just for the error
+                  calculation which we only need to figure out if encoding1 or encoding2 is better... */
+               if (srccolors[j][i][3] <= alphatest[0] / 2) {
+                  alphaenc3[4*j + i] = 6;
+                  alphadist = srccolors[j][i][3];
+               }
+               else if (srccolors[j][i][3] > ((255 + alphatest[1]) / 2)) {
+                  alphaenc3[4*j + i] = 7;
+                  alphadist = 255 - srccolors[j][i][3];
+               }
+               else if (srccolors[j][i][3] <= acutValues[0]) {
+                  alphaenc3[4*j + i] = 0;
+                  alphadist = srccolors[j][i][3] - alphatest[0];
+               }
+               else if (srccolors[j][i][3] <= acutValues[1]) {
+                 alphaenc3[4*j + i] = 2;
+                 alphadist = srccolors[j][i][3] - (alphatest[0] * 4 + alphatest[1] * 1) / 5;
+               }
+               else if (srccolors[j][i][3] <= acutValues[2]) {
+                  alphaenc3[4*j + i] = 3;
+                  alphadist = srccolors[j][i][3] - (alphatest[0] * 3 + alphatest[1] * 2) / 5;
+               }
+               else if (srccolors[j][i][3] <= acutValues[3]) {
+                  alphaenc3[4*j + i] = 4;
+                  alphadist = srccolors[j][i][3] - (alphatest[0] * 2 + alphatest[1] * 3) / 5;
+               }
+               else if (srccolors[j][i][3] <= acutValues[4]) {
+                  alphaenc3[4*j + i] = 5;
+                  alphadist = srccolors[j][i][3] - (alphatest[0] * 1 + alphatest[1] * 4) / 5;
+               }
+               else {
+                  alphaenc3[4*j + i] = 1;
+                  alphadist = srccolors[j][i][3] - alphatest[1];
+               }
+               alphablockerror3 += alphadist * alphadist;
+            }
+         }
+      }
+   }
+  /* write the alpha values and encoding back. */
+   if ((alphablockerror1 <= alphablockerror2) && (alphablockerror1 <= alphablockerror3)) {
+/*      if (alphablockerror1 > 96) fprintf(stderr, "enc1 used, error %d\n", alphablockerror1);*/
+      writedxt5encodedalphablock( blkaddr, alphause[1], alphause[0], alphaenc1 );
+   }
+   else if (alphablockerror2 <= alphablockerror3) {
+/*      if (alphablockerror2 > 96) fprintf(stderr, "enc2 used, error %d\n", alphablockerror2);*/
+      writedxt5encodedalphablock( blkaddr, alphabase[0], alphabase[1], alphaenc2 );
+   }
+   else {
+/*      fprintf(stderr, "enc3 used, error %d\n", alphablockerror3);*/
+      writedxt5encodedalphablock( blkaddr, (GLubyte)alphatest[0], (GLubyte)alphatest[1], alphaenc3 );
+   }
+}
+
+static void extractsrccolors( GLubyte srcpixels[4][4][4], const GLchan *srcaddr,
+                         GLint srcRowStride, GLint numxpixels, GLint numypixels, GLint comps)
+{
+   GLubyte i, j, c;
+   const GLchan *curaddr;
+   for (j = 0; j < numypixels; j++) {
+      curaddr = srcaddr + j * srcRowStride * comps;
+      for (i = 0; i < numxpixels; i++) {
+         for (c = 0; c < comps; c++) {
+            srcpixels[j][i][c] = *curaddr++ / (CHAN_MAX / 255);
+         }
+      }
+   }
+}
+
+
+void ptx_compress_dxtn(GLint srccomps, GLint width, GLint height, const GLubyte *srcPixData,
+                     GLenum destFormat, GLubyte *dest, GLint dstRowStride)
+{
+      GLubyte *blkaddr = dest;
+      GLubyte srcpixels[4][4][4];
+      const GLchan *srcaddr = srcPixData;
+      GLint numxpixels, numypixels;
+      GLint i, j;
+      GLint dstRowDiff;
+
+   switch (destFormat) {
+   case GL_COMPRESSED_RGB_S3TC_DXT1_EXT:
+   case GL_COMPRESSED_RGBA_S3TC_DXT1_EXT:
+      /* hmm we used to get called without dstRowStride... */
+      dstRowDiff = dstRowStride >= (width * 2) ? dstRowStride - (((width + 3) & ~3) * 2) : 0;
+/*      fprintf(stderr, "dxt1 tex width %d tex height %d dstRowStride %d\n",
+              width, height, dstRowStride); */
+       TRACE("dxt1 tex width %d tex height %d dstRowStride %d\n",
+             width, height, dstRowStride);
+      for (j = 0; j < height; j += 4) {
+         if (height > j + 3) numypixels = 4;
+         else numypixels = height - j;
+         srcaddr = srcPixData + j * width * srccomps;
+         for (i = 0; i < width; i += 4) {
+            if (width > i + 3) numxpixels = 4;
+            else numxpixels = width - i;
+            extractsrccolors(srcpixels, srcaddr, width, numxpixels, numypixels, srccomps);
+            encodedxtcolorblockfaster(blkaddr, srcpixels, numxpixels, numypixels, destFormat);
+            srcaddr += srccomps * numxpixels;
+            blkaddr += 8;
+         }
+         blkaddr += dstRowDiff;
+      }
+      break;
+   case GL_COMPRESSED_RGBA_S3TC_DXT3_EXT:
+      dstRowDiff = dstRowStride >= (width * 4) ? dstRowStride - (((width + 3) & ~3) * 4) : 0;
+/*      fprintf(stderr, "dxt3 tex width %d tex height %d dstRowStride %d\n",
+              width, height, dstRowStride); */
+       TRACE("dxt3 tex width %d tex height %d dstRowStride %d\n",
+             width, height, dstRowStride);
+      for (j = 0; j < height; j += 4) {
+         if (height > j + 3) numypixels = 4;
+         else numypixels = height - j;
+         srcaddr = srcPixData + j * width * srccomps;
+         for (i = 0; i < width; i += 4) {
+            if (width > i + 3) numxpixels = 4;
+            else numxpixels = width - i;
+            extractsrccolors(srcpixels, srcaddr, width, numxpixels, numypixels, srccomps);
+            *blkaddr++ = (srcpixels[0][0][3] >> 4) | (srcpixels[0][1][3] & 0xf0);
+            *blkaddr++ = (srcpixels[0][2][3] >> 4) | (srcpixels[0][3][3] & 0xf0);
+            *blkaddr++ = (srcpixels[1][0][3] >> 4) | (srcpixels[1][1][3] & 0xf0);
+            *blkaddr++ = (srcpixels[1][2][3] >> 4) | (srcpixels[1][3][3] & 0xf0);
+            *blkaddr++ = (srcpixels[2][0][3] >> 4) | (srcpixels[2][1][3] & 0xf0);
+            *blkaddr++ = (srcpixels[2][2][3] >> 4) | (srcpixels[2][3][3] & 0xf0);
+            *blkaddr++ = (srcpixels[3][0][3] >> 4) | (srcpixels[3][1][3] & 0xf0);
+            *blkaddr++ = (srcpixels[3][2][3] >> 4) | (srcpixels[3][3][3] & 0xf0);
+            encodedxtcolorblockfaster(blkaddr, srcpixels, numxpixels, numypixels, destFormat);
+            srcaddr += srccomps * numxpixels;
+            blkaddr += 8;
+         }
+         blkaddr += dstRowDiff;
+      }
+      break;
+   case GL_COMPRESSED_RGBA_S3TC_DXT5_EXT:
+      dstRowDiff = dstRowStride >= (width * 4) ? dstRowStride - (((width + 3) & ~3) * 4) : 0;
+/*      fprintf(stderr, "dxt5 tex width %d tex height %d dstRowStride %d\n",
+              width, height, dstRowStride); */
+       TRACE("dxt5 tex width %d tex height %d dstRowStride %d\n",
+             width, height, dstRowStride);
+      for (j = 0; j < height; j += 4) {
+         if (height > j + 3) numypixels = 4;
+         else numypixels = height - j;
+         srcaddr = srcPixData + j * width * srccomps;
+         for (i = 0; i < width; i += 4) {
+            if (width > i + 3) numxpixels = 4;
+            else numxpixels = width - i;
+            extractsrccolors(srcpixels, srcaddr, width, numxpixels, numypixels, srccomps);
+            encodedxt5alpha(blkaddr, srcpixels, numxpixels, numypixels);
+            encodedxtcolorblockfaster(blkaddr + 8, srcpixels, numxpixels, numypixels, destFormat);
+            srcaddr += srccomps * numxpixels;
+            blkaddr += 16;
+         }
+         blkaddr += dstRowDiff;
+      }
+      break;
+   default:
+//      fprintf(stderr, "libdxtn: Bad dstFormat %d in tx_compress_dxtn\n", destFormat);
+       ERR( "libdxtn: Bad dstFormat %d in tx_compress_dxtn\n", destFormat);
+      return;
+   }
+}
+
+
diff --git a/dlls/wined3d/txc_dxtn.h b/dlls/wined3d/txc_dxtn.h
new file mode 100644
index 0000000..5c8d4c1
--- /dev/null
+++ b/dlls/wined3d/txc_dxtn.h
@@ -0,0 +1,55 @@
+/*
+ * libtxc_dxtn
+ * Version:  1.0
+ *
+ * Copyright (C) 2004  Roland Scheidegger   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _TXC_DXTN_H
+#define _TXC_DXTN_H
+
+//#include "config.h"
+
+#include "wined3d_private.h"
+
+typedef GLubyte GLchan;
+#define UBYTE_TO_CHAN(b)  (b)
+#define CHAN_MAX 255
+#define RCOMP 0
+#define GCOMP 1
+#define BCOMP 2
+#define ACOMP 3
+
+#define DXTN_STATIC 1
+
+void pfetch_2d_texel_rgb_dxt1(GLint srcRowStride, const GLubyte *pixdata,
+			     GLint i, GLint j, GLvoid *texel);
+void pfetch_2d_texel_rgba_dxt1(GLint srcRowStride, const GLubyte *pixdata,
+			     GLint i, GLint j, GLvoid *texel);
+void pfetch_2d_texel_rgba_dxt3(GLint srcRowStride, const GLubyte *pixdata,
+			     GLint i, GLint j, GLvoid *texel);
+void pfetch_2d_texel_rgba_dxt5(GLint srcRowStride, const GLubyte *pixdata,
+			     GLint i, GLint j, GLvoid *texel);
+
+void ptx_compress_dxtn(GLint srccomps, GLint width, GLint height,
+		      const GLubyte *srcPixData, GLenum destformat,
+		      GLubyte *dest, GLint dstRowStride);
+
+#endif /* _TXC_DXTN_H */
diff --git a/dlls/wined3d/txc_fetch_dxtn.c b/dlls/wined3d/txc_fetch_dxtn.c
new file mode 100644
index 0000000..b3e3549
--- /dev/null
+++ b/dlls/wined3d/txc_fetch_dxtn.c
@@ -0,0 +1,244 @@
+/*
+ * libtxc_dxtn
+ * Version:  1.0
+ *
+ * Copyright (C) 2004  Roland Scheidegger   All Rights Reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * BRIAN PAUL BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
+ * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#include "config.h"
+//#include <stdio.h>
+#include "txc_dxtn.h"
+
+#define EXP5TO8R(packedcol)					\
+   ((((packedcol) >> 8) & 0xf8) | (((packedcol) >> 13) & 0x7))
+
+#define EXP6TO8G(packedcol)					\
+   ((((packedcol) >> 3) & 0xfc) | (((packedcol) >>  9) & 0x3))
+
+#define EXP5TO8B(packedcol)					\
+   ((((packedcol) << 3) & 0xf8) | (((packedcol) >>  2) & 0x7))
+
+#define EXP4TO8(col)						\
+   ((col) | ((col) << 4))
+
+/* inefficient. To be efficient, it would be necessary to decode 16 pixels at once */
+
+static void dxt135_decode_imageblock ( const GLubyte *img_block_src,
+                         GLint i, GLint j, GLuint dxt_type, GLvoid *texel ) {
+   GLchan *rgba = (GLchan *) texel;
+   const GLushort color0 = img_block_src[0] | (img_block_src[1] << 8);
+   const GLushort color1 = img_block_src[2] | (img_block_src[3] << 8);
+   const GLuint bits = img_block_src[4] | (img_block_src[5] << 8) |
+      (img_block_src[6] << 16) | (img_block_src[7] << 24);
+   /* What about big/little endian? */
+   GLubyte bit_pos = 2 * (j * 4 + i) ;
+   GLubyte code = (GLubyte) ((bits >> bit_pos) & 3);
+
+   rgba[ACOMP] = CHAN_MAX;
+   switch (code) {
+   case 0:
+      rgba[RCOMP] = UBYTE_TO_CHAN( EXP5TO8R(color0) );
+      rgba[GCOMP] = UBYTE_TO_CHAN( EXP6TO8G(color0) );
+      rgba[BCOMP] = UBYTE_TO_CHAN( EXP5TO8B(color0) );
+      break;
+   case 1:
+      rgba[RCOMP] = UBYTE_TO_CHAN( EXP5TO8R(color1) );
+      rgba[GCOMP] = UBYTE_TO_CHAN( EXP6TO8G(color1) );
+      rgba[BCOMP] = UBYTE_TO_CHAN( EXP5TO8B(color1) );
+      break;
+   case 2:
+      if ((dxt_type > 1) || (color0 > color1)) {
+         rgba[RCOMP] = UBYTE_TO_CHAN( ((EXP5TO8R(color0) * 2 + EXP5TO8R(color1)) / 3) );
+         rgba[GCOMP] = UBYTE_TO_CHAN( ((EXP6TO8G(color0) * 2 + EXP6TO8G(color1)) / 3) );
+         rgba[BCOMP] = UBYTE_TO_CHAN( ((EXP5TO8B(color0) * 2 + EXP5TO8B(color1)) / 3) );
+      }
+      else {
+         rgba[RCOMP] = UBYTE_TO_CHAN( ((EXP5TO8R(color0) + EXP5TO8R(color1)) / 2) );
+         rgba[GCOMP] = UBYTE_TO_CHAN( ((EXP6TO8G(color0) + EXP6TO8G(color1)) / 2) );
+         rgba[BCOMP] = UBYTE_TO_CHAN( ((EXP5TO8B(color0) + EXP5TO8B(color1)) / 2) );
+      }
+      break;
+   case 3:
+      if ((dxt_type > 1) || (color0 > color1)) {
+         rgba[RCOMP] = UBYTE_TO_CHAN( ((EXP5TO8R(color0) + EXP5TO8R(color1) * 2) / 3) );
+         rgba[GCOMP] = UBYTE_TO_CHAN( ((EXP6TO8G(color0) + EXP6TO8G(color1) * 2) / 3) );
+         rgba[BCOMP] = UBYTE_TO_CHAN( ((EXP5TO8B(color0) + EXP5TO8B(color1) * 2) / 3) );
+      }
+      else {
+         rgba[RCOMP] = 0;
+         rgba[GCOMP] = 0;
+         rgba[BCOMP] = 0;
+         if (dxt_type == 1) rgba[ACOMP] = UBYTE_TO_CHAN(0);
+      }
+      break;
+   default:
+   /* CANNOT happen (I hope) */
+      break;
+   }
+}
+
+
+void pfetch_2d_texel_rgb_dxt1(GLint srcRowStride, const GLubyte *pixdata,
+                         GLint i, GLint j, GLvoid *texel)
+{
+   /* Extract the (i,j) pixel from pixdata and return it
+    * in texel[RCOMP], texel[GCOMP], texel[BCOMP], texel[ACOMP].
+    */
+
+   const GLubyte *blksrc = (pixdata + ((srcRowStride + 3) / 4 * (j / 4) + (i / 4)) * 8);
+   dxt135_decode_imageblock(blksrc, (i&3), (j&3), 0, texel);
+}
+
+
+void pfetch_2d_texel_rgba_dxt1(GLint srcRowStride, const GLubyte *pixdata,
+                         GLint i, GLint j, GLvoid *texel)
+{
+   /* Extract the (i,j) pixel from pixdata and return it
+    * in texel[RCOMP], texel[GCOMP], texel[BCOMP], texel[ACOMP].
+    */
+
+   const GLubyte *blksrc = (pixdata + ((srcRowStride + 3) / 4 * (j / 4) + (i / 4)) * 8);
+   dxt135_decode_imageblock(blksrc, (i&3), (j&3), 1, texel);
+}
+
+void pfetch_2d_texel_rgba_dxt3(GLint srcRowStride, const GLubyte *pixdata,
+                         GLint i, GLint j, GLvoid *texel) {
+
+   /* Extract the (i,j) pixel from pixdata and return it
+    * in texel[RCOMP], texel[GCOMP], texel[BCOMP], texel[ACOMP].
+    */
+
+   GLchan *rgba = (GLchan *) texel;
+   const GLubyte *blksrc = (pixdata + ((srcRowStride + 3) / 4 * (j / 4) + (i / 4)) * 16);
+#if 0
+   /* Simple 32bit version. */
+/* that's pretty brain-dead for a single pixel, isn't it? */
+   const GLubyte bit_pos = 4 * ((j&3) * 4 + (i&3));
+   const GLuint alpha_low = blksrc[0] | (blksrc[1] << 8) | (blksrc[2] << 16) | (blksrc[3] << 24);
+   const GLuint alpha_high = blksrc[4] | (blksrc[5] << 8) | (blksrc[6] << 16) | (blksrc[7] << 24);
+
+   dxt135_decode_imageblock(blksrc + 8, (i&3), (j&3), 2, texel);
+   if (bit_pos < 32)
+      rgba[ACOMP] = UBYTE_TO_CHAN( (GLubyte)(EXP4TO8((alpha_low >> bit_pos) & 15)) );
+   else
+      rgba[ACOMP] = UBYTE_TO_CHAN( (GLubyte)(EXP4TO8((alpha_high >> (bit_pos - 32)) & 15)) );
+#endif
+#if 1
+/* TODO test this! */
+   const GLubyte anibble = (blksrc[((j&3) * 4 + (i&3)) / 2] >> (4 * (i&1))) & 0xf;
+   dxt135_decode_imageblock(blksrc + 8, (i&3), (j&3), 2, texel);
+   rgba[ACOMP] = UBYTE_TO_CHAN( (GLubyte)(EXP4TO8(anibble)) );
+#endif
+
+}
+
+void pfetch_2d_texel_rgba_dxt5(GLint srcRowStride, const GLubyte *pixdata,
+                         GLint i, GLint j, GLvoid *texel) {
+
+   /* Extract the (i,j) pixel from pixdata and return it
+    * in texel[RCOMP], texel[GCOMP], texel[BCOMP], texel[ACOMP].
+    */
+
+   GLchan *rgba = (GLchan *) texel;
+   const GLubyte *blksrc = (pixdata + ((srcRowStride + 3) / 4 * (j / 4) + (i / 4)) * 16);
+   const GLubyte alpha0 = blksrc[0];
+   const GLubyte alpha1 = blksrc[1];
+#if 0
+   const GLubyte bit_pos = 3 * ((j&3) * 4 + (i&3));
+   /* simple 32bit version */
+   const GLuint bits_low = blksrc[2] | (blksrc[3] << 8) | (blksrc[4] << 16) | (blksrc[5] << 24);
+   const GLuint bits_high = blksrc[6] | (blksrc[7] << 8);
+   GLubyte code;
+
+   if (bit_pos < 30)
+      code = (GLubyte) ((bits_low >> bit_pos) & 7);
+   else if (bit_pos == 30)
+      code = (GLubyte) ((bits_low >> 30) & 3) | ((bits_high << 2) & 4);
+   else
+      code = (GLubyte) ((bits_high >> (bit_pos - 32)) & 7);
+#endif
+#if 1
+/* TODO test this! */
+   const GLubyte bit_pos = ((j&3) * 4 + (i&3)) * 3;
+   const GLubyte acodelow = blksrc[2 + bit_pos / 8];
+   const GLubyte acodehigh = blksrc[3 + bit_pos / 8];
+   const GLubyte code = (acodelow >> (bit_pos & 0x7) |
+      (acodehigh  << (8 - (bit_pos & 0x7)))) & 0x7;
+#endif
+   dxt135_decode_imageblock(blksrc + 8, (i&3), (j&3), 2, texel);
+#if 0
+   if (alpha0 > alpha1) {
+      switch (code) {
+      case 0:
+         rgba[ACOMP] = UBYTE_TO_CHAN( alpha0 );
+         break;
+      case 1:
+         rgba[ACOMP] = UBYTE_TO_CHAN( alpha1 );
+         break;
+      case 2:
+      case 3:
+      case 4:
+      case 5:
+      case 6:
+      case 7:
+         rgba[ACOMP] = UBYTE_TO_CHAN( ((alpha0 * (8 - code) + (alpha1 * (code - 1))) / 7) );
+         break;
+      }
+   }
+   else {
+      switch (code) {
+      case 0:
+         rgba[ACOMP] = UBYTE_TO_CHAN( alpha0 );
+         break;
+      case 1:
+         rgba[ACOMP] = UBYTE_TO_CHAN( alpha1 );
+         break;
+      case 2:
+      case 3:
+      case 4:
+      case 5:
+         rgba[ACOMP] = UBYTE_TO_CHAN( ((alpha0 * (6 - code) + (alpha1 * (code - 1))) / 5) );
+         break;
+      case 6:
+         rgba[ACOMP] = 0;
+         break;
+      case 7:
+         rgba[ACOMP] = CHAN_MAX;
+         break;
+      }
+   }
+#endif
+/* not sure. Which version is faster? */
+#if 1
+/* TODO test this */
+   if (code == 0)
+      rgba[ACOMP] = UBYTE_TO_CHAN( alpha0 );
+   else if (code == 1)
+      rgba[ACOMP] = UBYTE_TO_CHAN( alpha1 );
+   else if (alpha0 > alpha1)
+      rgba[ACOMP] = UBYTE_TO_CHAN( ((alpha0 * (8 - code) + (alpha1 * (code - 1))) / 7) );
+   else if (code < 6)
+      rgba[ACOMP] = UBYTE_TO_CHAN( ((alpha0 * (6 - code) + (alpha1 * (code - 1))) / 5) );
+   else if (code == 6)
+      rgba[ACOMP] = 0;
+   else
+      rgba[ACOMP] = CHAN_MAX;
+#endif
+}
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 17ac29d..f84ddc5 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -113,7 +113,9 @@ static const struct wined3d_format_channels formats[] =
     {WINED3DFMT_R10G11B11_SNORM,           10, 11, 11,  0,   0, 10, 21,  0,    4,   0,     0},
     {WINED3DFMT_R10G10B10_SNORM_A2_UNORM,  10, 10, 10,  2,   0, 10, 20, 30,    4,   0,     0},
     /* Depth stencil formats */
+    {WINED3DFMT_D32_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
     {WINED3DFMT_D16_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
+    {WINED3DFMT_S8_LOCKABLE,                0,  0,  0,  0,   0,  0,  0,  0,    1,   8,     0},
     {WINED3DFMT_D32_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
     {WINED3DFMT_S1_UINT_D15_UNORM,          0,  0,  0,  0,   0,  0,  0,  0,    2,  15,     1},
     {WINED3DFMT_D24_UNORM_S8_UINT,          0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
@@ -133,6 +135,9 @@ static const struct wined3d_format_channels formats[] =
     {WINED3DFMT_ATI1N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
     {WINED3DFMT_ATI2N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
     {WINED3DFMT_NVDB,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
+// hack by Michael Bond bug 23807
+    {WINED3DFMT_DF16,                       0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
+    {WINED3DFMT_DF24,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     0},
     {WINED3DFMT_INST,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
     {WINED3DFMT_INTZ,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
     {WINED3DFMT_RESZ,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
@@ -201,11 +206,11 @@ struct wined3d_format_block_info
 
 static const struct wined3d_format_block_info format_block_info[] =
 {
-    {WINED3DFMT_DXT1,   4,  4,  8,  TRUE},
-    {WINED3DFMT_DXT2,   4,  4,  16, TRUE},
-    {WINED3DFMT_DXT3,   4,  4,  16, TRUE},
-    {WINED3DFMT_DXT4,   4,  4,  16, TRUE},
-    {WINED3DFMT_DXT5,   4,  4,  16, TRUE},
+    {WINED3DFMT_DXT1,   4,  4,  8,  FALSE}, //TRUE},
+    {WINED3DFMT_DXT2,   4,  4,  16, FALSE}, //TRUE},
+    {WINED3DFMT_DXT3,   4,  4,  16, FALSE}, //TRUE},
+    {WINED3DFMT_DXT4,   4,  4,  16, FALSE}, //TRUE},
+    {WINED3DFMT_DXT5,   4,  4,  16, FALSE}, //TRUE},
     {WINED3DFMT_ATI1N,  4,  4,  8,  FALSE},
     {WINED3DFMT_ATI2N,  4,  4,  16, FALSE},
     {WINED3DFMT_YUY2,   2,  1,  4,  FALSE},
@@ -667,9 +672,22 @@ static void convert_s8_uint_d24_float(const BYTE *src, BYTE *dst, UINT src_row_p
 static BOOL color_in_range(const struct wined3d_color_key *color_key, DWORD color)
 {
     /* FIXME: Is this really how color keys are supposed to work? I think it
-     * makes more sense to compare the individual channels. */
+     * makes more sense to compare the individual channels. 
     return color >= color_key->color_space_low_value
-            && color <= color_key->color_space_high_value;
+          && color <= color_key->color_space_high_value; */
+ 
+#define RED_KEY(x)   (x & 0xff0000)
+#define GREEN_KEY(x) (x & 0x00ff00)  
+#define BLUE_KEY(x)  (x & 0x0000ff)
+    return ((RED_KEY(color) >= RED_KEY(color_key->color_space_low_value)) &&
+            (RED_KEY(color) <= RED_KEY(color_key->color_space_high_value)) &&
+            (GREEN_KEY(color) >= GREEN_KEY(color_key->color_space_low_value)) &&
+            (GREEN_KEY(color) <= GREEN_KEY(color_key->color_space_high_value)) &&
+            (BLUE_KEY(color) >= BLUE_KEY(color_key->color_space_low_value)) &&
+            (BLUE_KEY(color) <= BLUE_KEY(color_key->color_space_high_value)));
+#undef RED_KEY
+#undef GREEN_KEY
+#undef BLUE_KEY
 }
 
 static void convert_p8_uint_b8g8r8a8_unorm(const BYTE *src, unsigned int src_pitch,
@@ -1175,6 +1193,14 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             | WINED3DFMT_FLAG_BUMPMAP,
             EXT_TEXTURE_SNORM,          NULL},
     /* Depth stencil formats */
+    {WINED3DFMT_D32_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
+            WINED3DFMT_FLAG_DEPTH,
+            WINED3D_GL_EXT_NONE,        NULL},
+    {WINED3DFMT_D32_LOCKABLE,           GL_DEPTH_COMPONENT32_ARB,         GL_DEPTH_COMPONENT32_ARB,               0,
+            GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
+            WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_SHADOW,
+            ARB_DEPTH_TEXTURE,          NULL},
     {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
             WINED3DFMT_FLAG_DEPTH,
@@ -1183,6 +1209,10 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_SHADOW,
             ARB_DEPTH_TEXTURE,          NULL},
+    {WINED3DFMT_S8_LOCKABLE,            GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_BYTE,                          0,
+            WINED3DFMT_FLAG_DEPTH,
+            WINED3D_GL_EXT_NONE,        NULL},
     {WINED3DFMT_D32_UNORM,              GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
             WINED3DFMT_FLAG_DEPTH,
@@ -1281,6 +1311,28 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING
             | WINED3DFMT_FLAG_COMPRESSED,
             ARB_TEXTURE_COMPRESSION_RGTC, NULL},
+  //bug 23807
+  {WINED3DFMT_DF16,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
+      GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_SHORT,                0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      EXT_PACKED_DEPTH_STENCIL,   NULL},
+    {WINED3DFMT_DF16,                   GL_DEPTH24_STENCIL8,              GL_DEPTH24_STENCIL8,                    0,
+      GL_DEPTH_STENCIL,           GL_UNSIGNED_SHORT,                0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      ARB_FRAMEBUFFER_OBJECT,     NULL},
+    {WINED3DFMT_DF24,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
+      GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_INT_24_8_EXT,         0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      EXT_PACKED_DEPTH_STENCIL,   NULL},
+    {WINED3DFMT_DF24,                   GL_DEPTH24_STENCIL8,              GL_DEPTH24_STENCIL8,                    0,
+      GL_DEPTH_STENCIL,           GL_UNSIGNED_INT_24_8,             0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      ARB_FRAMEBUFFER_OBJECT,     NULL},
+
     {WINED3DFMT_INTZ,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
             GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_INT_24_8_EXT,         0,
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING
@@ -2256,13 +2308,13 @@ static BOOL init_format_texture_info(struct wined3d_adapter *adapter, struct win
 
 static BOOL color_match(DWORD c1, DWORD c2, BYTE max_diff)
 {
-    if (abs((c1 & 0xff) - (c2 & 0xff)) > max_diff) return FALSE;
+    if (abs((int)(c1 & 0xff) - (int)(c2 & 0xff)) > max_diff) return FALSE;
     c1 >>= 8; c2 >>= 8;
-    if (abs((c1 & 0xff) - (c2 & 0xff)) > max_diff) return FALSE;
+    if (abs((int)(c1 & 0xff) - (int)(c2 & 0xff)) > max_diff) return FALSE;
     c1 >>= 8; c2 >>= 8;
-    if (abs((c1 & 0xff) - (c2 & 0xff)) > max_diff) return FALSE;
+    if (abs((int)(c1 & 0xff) - (int)(c2 & 0xff)) > max_diff) return FALSE;
     c1 >>= 8; c2 >>= 8;
-    if (abs((c1 & 0xff) - (c2 & 0xff)) > max_diff) return FALSE;
+    if (abs((int)(c1 & 0xff) - (int)(c2 & 0xff)) > max_diff) return FALSE;
     return TRUE;
 }
 
@@ -2638,6 +2690,7 @@ static void apply_format_fixups(struct wined3d_adapter *adapter, struct wined3d_
      *
      * Note that GL_NV_texture_compression_vtc adds this functionality to OpenGL, but the
      * block layout is not compatible with the one used by d3d. See volume_dxt5_test. */
+     if (gl_info->quirks & WINED3D_QUIRK_NO_DXTN) {
     idx = getFmtIdx(WINED3DFMT_DXT1);
     gl_info->formats[idx].flags[WINED3D_GL_RES_TYPE_TEX_3D] &= ~WINED3DFMT_FLAG_TEXTURE;
     idx = getFmtIdx(WINED3DFMT_DXT2);
@@ -2648,6 +2701,7 @@ static void apply_format_fixups(struct wined3d_adapter *adapter, struct wined3d_
     gl_info->formats[idx].flags[WINED3D_GL_RES_TYPE_TEX_3D] &= ~WINED3DFMT_FLAG_TEXTURE;
     idx = getFmtIdx(WINED3DFMT_DXT5);
     gl_info->formats[idx].flags[WINED3D_GL_RES_TYPE_TEX_3D] &= ~WINED3DFMT_FLAG_TEXTURE;
+    }
     /* Similarly with ATI1N / ATI2N and GL_ARB_texture_compression_rgtc. */
     idx = getFmtIdx(WINED3DFMT_ATI1N);
     gl_info->formats[idx].flags[WINED3D_GL_RES_TYPE_TEX_3D] &= ~WINED3DFMT_FLAG_TEXTURE;
@@ -2821,8 +2875,12 @@ const struct wined3d_format *wined3d_get_format(const struct wined3d_gl_info *gl
 
     if (idx == -1)
     {
+        static enum wined3d_format_id old_id;
+        if (old_id != format_id) {
+            old_id = format_id;
         FIXME("Can't find format %s (%#x) in the format lookup table\n",
                 debug_d3dformat(format_id), format_id);
+        }
         /* Get the caller a valid pointer */
         idx = getFmtIdx(WINED3DFMT_UNKNOWN);
     }
@@ -2834,10 +2892,10 @@ UINT wined3d_format_calculate_pitch(const struct wined3d_format *format, UINT wi
 {
     /* For block based formats, pitch means the amount of bytes to the next
      * row of blocks rather than the next row of pixels. */
-    if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_BLOCKS)
+    //    if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_BLOCKS)
         return format->block_byte_count * ((width + format->block_width - 1) / format->block_width);
 
-    return format->byte_count * width;
+    //return format->byte_count * width; //it's the same for non-block but not for TEX_3D
 }
 
 UINT wined3d_format_calculate_size(const struct wined3d_format *format, UINT alignment,
@@ -2850,15 +2908,15 @@ UINT wined3d_format_calculate_size(const struct wined3d_format *format, UINT ali
     {
         size = 0;
     }
-    else if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_BLOCKS)
+    else //if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_BLOCKS)
     {
         UINT row_count = (height + format->block_height - 1) / format->block_height;
         size = row_count * ((pitch + alignment - 1) & ~(alignment - 1));
-    }
+    } /*
     else
     {
         size = height * ((pitch + alignment - 1) & ~(alignment - 1));
-    }
+    }*/
 
     if (format->flags[WINED3D_GL_RES_TYPE_TEX_2D] & WINED3DFMT_FLAG_HEIGHT_SCALE)
     {
@@ -2872,6 +2930,42 @@ UINT wined3d_format_calculate_size(const struct wined3d_format *format, UINT ali
     return size;
 }
 
+UINT wined3d_format_calculate_size_total(const struct wined3d_format *format, UINT alignment,
+        UINT width, UINT height, UINT depth, UINT levels, enum wined3d_resource_type type)
+{
+    UINT size = 0;
+    unsigned int i;
+
+    for (i = 0; i < levels; ++i)
+    {
+        size += wined3d_format_calculate_size(format, alignment, width, height, depth);
+        switch (type)
+        {
+            case WINED3D_RTYPE_TEXTURE:
+                width = max(1, width >> 1);
+                height = max(1, height >> 1);
+                break;
+            case WINED3D_RTYPE_VOLUME_TEXTURE:
+                width = max(1, width >> 1);
+                height = max(1, height >> 1);
+                depth = max(1, depth >> 1);
+                break;
+            case WINED3D_RTYPE_CUBE_TEXTURE:
+                width = max(1, width >> 1);
+                height = width;
+                break;
+            default:
+                ERR("Invalid texture type: %s\n", debug_d3dresourcetype(type));
+                return 0;
+        }
+    }
+
+    if (type == WINED3D_RTYPE_CUBE_TEXTURE)
+        size *= 6;
+
+    return size;
+}
+
 /*****************************************************************************
  * Trace formatting of useful values
  */
@@ -2911,6 +3005,8 @@ const char *debug_d3dformat(enum wined3d_format_id format_id)
         FMT_TO_STR(WINED3DFMT_G8R8_G8B8);
         FMT_TO_STR(WINED3DFMT_R8G8_B8G8);
         FMT_TO_STR(WINED3DFMT_D16_LOCKABLE);
+        FMT_TO_STR(WINED3DFMT_D32_LOCKABLE);
+        FMT_TO_STR(WINED3DFMT_S8_LOCKABLE);
         FMT_TO_STR(WINED3DFMT_D32_UNORM);
         FMT_TO_STR(WINED3DFMT_S1_UINT_D15_UNORM);
         FMT_TO_STR(WINED3DFMT_X8D24_UNORM);
@@ -3013,6 +3109,9 @@ const char *debug_d3dformat(enum wined3d_format_id format_id)
         FMT_TO_STR(WINED3DFMT_B5G5R5A1_UNORM);
         FMT_TO_STR(WINED3DFMT_B8G8R8A8_UNORM);
         FMT_TO_STR(WINED3DFMT_B8G8R8X8_UNORM);
+        //bug 23807
+        FMT_TO_STR(WINED3DFMT_DF16);
+        FMT_TO_STR(WINED3DFMT_DF24);
         FMT_TO_STR(WINED3DFMT_INTZ);
         FMT_TO_STR(WINED3DFMT_RESZ);
         FMT_TO_STR(WINED3DFMT_NULL);
@@ -3053,7 +3152,7 @@ const char *debug_d3ddevicetype(enum wined3d_device_type device_type)
 
 const char *debug_d3dusage(DWORD usage)
 {
-    char buf[333];
+    char buf[433];
 
     buf[0] = '\0';
 #define WINED3DUSAGE_TO_STR(u) if (usage & u) { strcat(buf, " | "#u); usage &= ~u; }
@@ -3070,8 +3169,9 @@ const char *debug_d3dusage(DWORD usage)
     WINED3DUSAGE_TO_STR(WINED3DUSAGE_DMAP);
     WINED3DUSAGE_TO_STR(WINED3DUSAGE_STATICDECL);
     WINED3DUSAGE_TO_STR(WINED3DUSAGE_OVERLAY);
+    WINED3DUSAGE_TO_STR(WINED3DUSAGE_TEXTURE);
 #undef WINED3DUSAGE_TO_STR
-    if (usage) FIXME("Unrecognized usage flag(s) %#x\n", usage);
+    if (usage & ~WINED3DUSAGE_QUERY_MASK) FIXME("Unrecognized usage flag(s) %#x\n", usage);
 
     return buf[0] ? wine_dbg_sprintf("%s", &buf[3]) : "0";
 }
@@ -3090,7 +3190,7 @@ const char *debug_d3dusagequery(DWORD usagequery)
     WINED3DUSAGEQUERY_TO_STR(WINED3DUSAGE_QUERY_VERTEXTEXTURE);
     WINED3DUSAGEQUERY_TO_STR(WINED3DUSAGE_QUERY_WRAPANDMIP);
 #undef WINED3DUSAGEQUERY_TO_STR
-    if (usagequery) FIXME("Unrecognized usage query flag(s) %#x\n", usagequery);
+    if (usagequery & WINED3DUSAGE_QUERY_MASK) FIXME("Unrecognized usage query flag(s) %#x\n", usagequery);
 
     return buf[0] ? wine_dbg_sprintf("%s", &buf[3]) : "0";
 }
@@ -4016,6 +4116,81 @@ unsigned int count_bits(unsigned int mask)
     return count;
 }
 
+/* Helper function for retrieving color info for ChoosePixelFormat and wglChoosePixelFormatARB.
+ * The later function requires individual color components. */
+BOOL getColorBits(const struct wined3d_format *format,
+        BYTE *redSize, BYTE *greenSize, BYTE *blueSize, BYTE *alphaSize, BYTE *totalSize)
+{
+    TRACE("format %s.\n", debug_d3dformat(format->id));
+
+    switch (format->id)
+    {
+        case WINED3DFMT_B10G10R10A2_UNORM:
+        case WINED3DFMT_R10G10B10A2_UNORM:
+        case WINED3DFMT_B8G8R8X8_UNORM:
+        case WINED3DFMT_B8G8R8_UNORM:
+        case WINED3DFMT_B8G8R8A8_UNORM:
+        case WINED3DFMT_R8G8B8A8_UNORM:
+        case WINED3DFMT_B5G5R5X1_UNORM:
+        case WINED3DFMT_B5G5R5A1_UNORM:
+        case WINED3DFMT_B5G6R5_UNORM:
+        case WINED3DFMT_B4G4R4X4_UNORM:
+        case WINED3DFMT_B4G4R4A4_UNORM:
+        case WINED3DFMT_B2G3R3_UNORM:
+        case WINED3DFMT_P8_UINT_A8_UNORM:
+        case WINED3DFMT_P8_UINT:
+            break;
+        default:
+            FIXME("Unsupported format %s.\n", debug_d3dformat(format->id));
+            return FALSE;
+    }
+
+    *redSize = format->red_size;
+    *greenSize = format->green_size;
+    *blueSize = format->blue_size;
+    *alphaSize = format->alpha_size;
+    *totalSize = *redSize + *greenSize + *blueSize + *alphaSize;
+
+    TRACE("Returning red: %d, green: %d, blue: %d, alpha: %d, total: %d for format %s.\n",
+            *redSize, *greenSize, *blueSize, *alphaSize, *totalSize, debug_d3dformat(format->id));
+    return TRUE;
+}
+
+/* Helper function for retrieving depth/stencil info for ChoosePixelFormat and wglChoosePixelFormatARB */
+BOOL getDepthStencilBits(const struct wined3d_format *format, BYTE *depthSize, BYTE *stencilSize)
+{
+    TRACE("format %s.\n", debug_d3dformat(format->id));
+
+    switch (format->id)
+    {
+        case WINED3DFMT_D16_LOCKABLE:
+        case WINED3DFMT_D32_LOCKABLE:
+        case WINED3DFMT_S8_LOCKABLE:
+        case WINED3DFMT_D16_UNORM:
+        case WINED3DFMT_S1_UINT_D15_UNORM:
+        case WINED3DFMT_X8D24_UNORM:
+        case WINED3DFMT_S4X4_UINT_D24_UNORM:
+        case WINED3DFMT_D24_UNORM_S8_UINT:
+        case WINED3DFMT_S8_UINT_D24_FLOAT:
+        case WINED3DFMT_D32_UNORM:
+        case WINED3DFMT_D32_FLOAT:
+        case WINED3DFMT_DF16:
+        case WINED3DFMT_DF24:
+        case WINED3DFMT_INTZ:
+            break;
+        default:
+            FIXME("Unsupported depth/stencil format %s.\n", debug_d3dformat(format->id));
+            return FALSE;
+    }
+
+    *depthSize = format->depth_size;
+    *stencilSize = format->stencil_size;
+
+    TRACE("Returning depthSize: %d and stencilSize: %d for format %s.\n",
+            *depthSize, *stencilSize, debug_d3dformat(format->id));
+    return TRUE;
+}
+
 /* Note: It's the caller's responsibility to ensure values can be expressed
  * in the requested format. UNORM formats for example can only express values
  * in the range 0.0f -> 1.0f. */
@@ -4889,6 +5064,10 @@ void wined3d_ffp_get_vs_settings(const struct wined3d_context *context,
         settings->flatshading = FALSE;
 
     settings->padding = 0;
+    
+    settings->vb_indices = 0;
+    if (state->render_states[WINED3D_RS_INDEXEDVERTEXBLENDENABLE] != 0 && (si->use_map & (1 << WINED3D_FFP_BLENDINDICES)) != 0)
+    	settings->vb_indices = 1;
 }
 
 static int wined3d_ffp_vertex_program_key_compare(const void *key, const struct wine_rb_entry *entry)
@@ -4959,7 +5138,8 @@ const char *wined3d_debug_location(DWORD location)
     LOCATION_TO_STR(WINED3D_LOCATION_RB_MULTISAMPLE);
     LOCATION_TO_STR(WINED3D_LOCATION_RB_RESOLVED);
 #undef LOCATION_TO_STR
-    if (location) FIXME("Unrecognized location flag(s) %#x.\n", location);
+ //   if (location) FIXME("Unrecognized location flag(s) %#x.\n", location);
+  //Unrecognized location flag(s) 0xfffffc00.
 
     return buf[0] ? wine_dbg_sprintf("%s", &buf[3]) : "0";
 }
diff --git a/dlls/wined3d/vertexdeclaration.c b/dlls/wined3d/vertexdeclaration.c
index 9eb5907..90c97ea 100644
--- a/dlls/wined3d/vertexdeclaration.c
+++ b/dlls/wined3d/vertexdeclaration.c
@@ -92,7 +92,7 @@ static BOOL declaration_element_valid_ffp(const struct wined3d_vertex_element *e
                 default:
                     return FALSE;
             }
-
+	    
         case WINED3D_DECL_USAGE_BLEND_WEIGHT:
             switch(element->format)
             {
@@ -111,6 +111,15 @@ static BOOL declaration_element_valid_ffp(const struct wined3d_vertex_element *e
                     return FALSE;
             }
 
+        case WINED3D_DECL_USAGE_BLEND_INDICES:
+            switch(element->format)
+            {
+                case WINED3DFMT_R8G8B8A8_UINT:
+                    return TRUE;
+                default:
+                    return FALSE;
+            }
+            
         case WINED3D_DECL_USAGE_NORMAL:
             switch(element->format)
             {
@@ -124,6 +133,7 @@ static BOOL declaration_element_valid_ffp(const struct wined3d_vertex_element *e
             }
 
         case WINED3D_DECL_USAGE_TEXCOORD:
+        case WINED3D_DECL_USAGE_PSIZE:  //Slice
             switch(element->format)
             {
                 case WINED3DFMT_R32_FLOAT:
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
index 0231c23..e08a150 100644
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -40,6 +40,7 @@ BOOL volume_prepare_system_memory(struct wined3d_volume *volume)
     return TRUE;
 }
 
+#if 0 
 void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch, UINT *slice_pitch)
 {
     const struct wined3d_format *format = volume->resource.format;
@@ -64,6 +65,7 @@ void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pit
     TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
 }
 
+#endif
 /* This call just uploads data, the caller is responsible for binding the
  * correct texture. */
 /* Context activation is done by the caller. */
@@ -82,7 +84,7 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
             volume, context, volume->texture_level, debug_d3dformat(format->id),
             format->id);
 
-    if (format->convert)
+    if (format->convert) //this is conversion for destination format
     {
         UINT dst_row_pitch, dst_slice_pitch;
         UINT src_row_pitch, src_slice_pitch;
@@ -95,7 +97,7 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
         dst_row_pitch = width * format->conv_byte_count;
         dst_slice_pitch = dst_row_pitch * height;
 
-        wined3d_volume_get_pitch(volume, &src_row_pitch, &src_slice_pitch);
+        wined3d_resource_get_pitch(&volume->resource, &src_row_pitch, &src_slice_pitch);
 
         converted_mem = HeapAlloc(GetProcessHeap(), 0, dst_slice_pitch * depth);
         format->convert(data->addr, converted_mem, src_row_pitch, src_slice_pitch,
@@ -132,7 +134,7 @@ void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD locat
 
 void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location)
 {
-    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
+//    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
     volume->locations &= ~location;
     TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
 }
@@ -610,7 +612,8 @@ HRESULT wined3d_volume_map(struct wined3d_volume *volume,
     }
     else
     {
-        wined3d_volume_get_pitch(volume, &map_desc->row_pitch, &map_desc->slice_pitch);
+ //       wined3d_volume_get_pitch(volume, &map_desc->row_pitch, &map_desc->slice_pitch);
+      wined3d_resource_get_pitch(&volume->resource, &map_desc->row_pitch, &map_desc->slice_pitch);
     }
 
     if (!box)
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index a7e625d..2218d4c 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -181,6 +181,7 @@
 
 @ cdecl wined3d_resource_get_desc(ptr ptr)
 @ cdecl wined3d_resource_get_parent(ptr)
+@ cdecl wined3d_resource_get_pitch(ptr ptr ptr)
 @ cdecl wined3d_resource_get_priority(ptr)
 @ cdecl wined3d_resource_map(ptr long ptr ptr long)
 @ cdecl wined3d_resource_set_parent(ptr ptr)
@@ -227,7 +228,6 @@
 @ cdecl wined3d_surface_from_resource(ptr)
 @ cdecl wined3d_surface_get_overlay_position(ptr ptr ptr)
 @ cdecl wined3d_surface_get_parent(ptr)
-@ cdecl wined3d_surface_get_pitch(ptr)
 @ cdecl wined3d_surface_get_resource(ptr)
 @ cdecl wined3d_surface_getdc(ptr ptr)
 @ cdecl wined3d_surface_incref(ptr)
@@ -283,3 +283,11 @@
 @ cdecl wined3d_vertex_declaration_decref(ptr)
 @ cdecl wined3d_vertex_declaration_get_parent(ptr)
 @ cdecl wined3d_vertex_declaration_incref(ptr)
+
+@ cdecl wined3d_dxtn_supported()
+@ cdecl wined3d_dxt1_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt1_encode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt3_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt3_encode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt5_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt5_encode(ptr ptr long long long long long)
diff --git a/dlls/wined3d/wined3d_gl.h b/dlls/wined3d/wined3d_gl.h
index 437f62f..8e2cd7e 100644
--- a/dlls/wined3d/wined3d_gl.h
+++ b/dlls/wined3d/wined3d_gl.h
@@ -48,6 +48,7 @@ enum wined3d_gl_extension
     ARB_COLOR_BUFFER_FLOAT,
     ARB_DEBUG_OUTPUT,
     ARB_DEPTH_BUFFER_FLOAT,
+    ARB_DEPTH_CLAMP,
     ARB_DEPTH_TEXTURE,
     ARB_DRAW_BUFFERS,
     ARB_DRAW_ELEMENTS_BASE_VERTEX,
@@ -73,6 +74,7 @@ enum wined3d_gl_extension
     ARB_PROVOKING_VERTEX,
     ARB_SAMPLER_OBJECTS,
     ARB_SHADER_BIT_ENCODING,
+    ARB_SHADER_OBJECTS,
     ARB_SHADER_TEXTURE_LOD,
     ARB_SHADING_LANGUAGE_100,
     ARB_SHADOW,
@@ -81,6 +83,7 @@ enum wined3d_gl_extension
     ARB_TEXTURE_COMPRESSION,
     ARB_TEXTURE_COMPRESSION_RGTC,
     ARB_TEXTURE_CUBE_MAP,
+    ARB_TEXTURE_ENV_ADD,
     ARB_TEXTURE_ENV_COMBINE,
     ARB_TEXTURE_ENV_DOT3,
     ARB_TEXTURE_FLOAT,
@@ -117,6 +120,7 @@ enum wined3d_gl_extension
     EXT_GPU_PROGRAM_PARAMETERS,
     EXT_GPU_SHADER4,
     EXT_PACKED_DEPTH_STENCIL,
+    EXT_PALETTED_TEXTURE,
     EXT_POINT_PARAMETERS,
     EXT_PROVOKING_VERTEX,
     EXT_SECONDARY_COLOR,
@@ -125,6 +129,7 @@ enum wined3d_gl_extension
     EXT_TEXTURE3D,
     EXT_TEXTURE_COMPRESSION_RGTC,
     EXT_TEXTURE_COMPRESSION_S3TC,
+    EXT_TEXTURE_ENV_ADD,
     EXT_TEXTURE_ENV_COMBINE,
     EXT_TEXTURE_ENV_DOT3,
     EXT_TEXTURE_FILTER_ANISOTROPIC,
@@ -135,6 +140,7 @@ enum wined3d_gl_extension
     EXT_TEXTURE_SRGB_DECODE,
     EXT_VERTEX_ARRAY_BGRA,
     /* NVIDIA */
+    NV_DEPTH_CLAMP,
     NV_FENCE,
     NV_FOG_DISTANCE,
     NV_FRAGMENT_PROGRAM,
@@ -154,12 +160,14 @@ enum wined3d_gl_extension
     NV_VERTEX_PROGRAM2,
     NV_VERTEX_PROGRAM2_OPTION,
     NV_VERTEX_PROGRAM3,
+    NVX_GPU_MEMORY_INFO,
     /* SGI */
     SGIS_GENERATE_MIPMAP,
     /* WGL extensions */
     WGL_ARB_PIXEL_FORMAT,
     WGL_EXT_SWAP_CONTROL,
     WGL_WINE_PIXEL_FORMAT_PASSTHROUGH,
+    WGL_WINE_GPU_INFO,
     /* Internally used */
     WINED3D_GL_BLEND_EQUATION,
     WINED3D_GL_NORMALIZED_TEXRECT,
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
index 0543d97..c66f7e3 100644
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -77,6 +77,8 @@ struct wined3d_settings wined3d_settings =
     ORM_FBO,        /* Use FBOs to do offscreen rendering */
     PCI_VENDOR_NONE,/* PCI Vendor ID */
     PCI_DEVICE_NONE,/* PCI Device ID */
+    FALSE,          /* Allocate contiguous memory for texture surfaces. */
+    0,              /* Multisampling AA Quality Levels */
     0,              /* The default of memory is set in init_driver_info */
     NULL,           /* No wine logo by default */
     TRUE,           /* Multisampling enabled by default. */
@@ -86,6 +88,10 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+  FALSE,            /* Override vertex constants? */
+  256,             /* Number of vertex shaders to use */
+  253,              /* default for UserQuirks */
+
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -246,6 +252,7 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
                 wined3d_settings.pci_device_id = pci_device_id;
             }
         }
+        tmpvalue = 0;
         if ( !get_config_key_dword( hkey, appkey, "VideoPciVendorID", &tmpvalue) )
         {
             int pci_vendor_id = tmpvalue;
@@ -261,6 +268,26 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
                 wined3d_settings.pci_vendor_id = pci_vendor_id;
             }
         }
+        if (!get_config_key( hkey, appkey, "MultisamplingAAQualityLevels", buffer, size ))
+        {
+            int quality_levels = atoi(buffer);
+            if(quality_levels > 0)
+            {
+                wined3d_settings.msaa_quality_levels = quality_levels;
+                TRACE("Setting MultisamplingAAQualityLevels to %i\n", quality_levels);
+            }
+            else
+                ERR("MultisamplingAAQualityLevels is %i but must be >0\n", quality_levels);
+        }
+        if (!get_config_key(hkey, appkey, "ContiguousTextureMemory", buffer, size))
+        {
+            if (!strcmp(buffer,"enabled"))
+            {
+                WARN_(winediag)("Enabling allocation of contiguous memory for texture surfaces.\n");
+                WARN_(winediag)("System memory usage is not optimized yet. Expect OOM to happen more quickly.\n");
+                wined3d_settings.contiguous_tex_mem = TRUE;
+            }
+        }
         if ( !get_config_key( hkey, appkey, "VideoMemorySize", buffer, size) )
         {
             int TmpVideoMemorySize = atoi(buffer);
@@ -302,6 +329,31 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Not always rendering backbuffers offscreen.\n");
             wined3d_settings.always_offscreen = FALSE;
         }
+        if (!get_config_key(hkey, appkey, "OverrideVertexShaders", buffer, size) && !strcmp(buffer,"enabled"))
+        {
+          TRACE("Override Vertex Shader Constants\n");
+          wined3d_settings.override_vertex_constants = TRUE;
+        }
+        if (!get_config_key(hkey, appkey, "VertexShaderConstants", buffer, size))
+        {
+          int TmpVertexShaderConstants = atoi(buffer);
+          if (TmpVertexShaderConstants > 0)
+          {
+            wined3d_settings.vertex_constants_number = TmpVertexShaderConstants;
+            TRACE("Use %i Vertex Shader Constants\n", TmpVertexShaderConstants);
+          }
+        }
+        tmpvalue = 0;
+      if (!get_config_key_dword(hkey, appkey, "UserQuirks", &tmpvalue))
+      {
+        int TmpUserQuirks = tmpvalue;
+        if (TmpUserQuirks > 0)
+        {
+          wined3d_settings.user_quirks = TmpUserQuirks;
+          TRACE("Use %i UserQuirks\n", TmpUserQuirks);
+        }
+      }
+
         if (!get_config_key_dword(hkey, appkey, "MaxShaderModelVS", &wined3d_settings.max_sm_vs))
             TRACE("Limiting VS shader model to %u.\n", wined3d_settings.max_sm_vs);
         if (!get_config_key_dword(hkey, appkey, "MaxShaderModelGS", &wined3d_settings.max_sm_gs))
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index a60919e..da7a4b6 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -68,6 +68,16 @@
 #define WINED3D_QUIRK_LIMITED_TEX_FILTERING     0x00000100
 #define WINED3D_QUIRK_BROKEN_ARB_FOG            0x00000200
 
+#define WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER    0x00010000
+#define WINED3D_CX_QUIRK_COMPRESSED_CUBE_MIP    0x00020000  /* Intel GPU */
+#define WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN       0x00040000
+#define WINED3D_CX_QUIRK_TEXCOORD_FOG           0x00080000  /* old ATI */
+#define WINED3D_CX_QUIRK_BROKEN_ARA             0x00100000  /* Nvidia 8xxx */
+#define WINED3D_CX_QUIRK_BLIT                   0x00200000
+#define WINED3D_CX_QUIRK_RENDER_TO_FBO          0x00800000
+#define WINED3D_QUIRK_NO_DXTN                   0x01000000
+
+
 /* Texture format fixups */
 
 enum fixup_channel_source
@@ -184,7 +194,7 @@ void wined3d_rb_free(void *ptr) DECLSPEC_HIDDEN;
 #define MAX_CONSTANT_BUFFERS        15
 #define MAX_SAMPLER_OBJECTS         16
 #define MAX_SHADER_RESOURCE_VIEWS   128
-#define MAX_VERTEX_BLENDS           4
+#define MAX_VERTEX_BLENDS           148
 
 struct min_lookup
 {
@@ -273,6 +283,8 @@ struct wined3d_settings
     unsigned short pci_vendor_id;
     unsigned short pci_device_id;
     /* Memory tracking and object counting. */
+    BOOL contiguous_tex_mem;
+    unsigned int msaa_quality_levels;
     UINT64 emulated_textureram;
     char *logo;
     int allow_multisampling;
@@ -282,6 +294,10 @@ struct wined3d_settings
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+  BOOL override_vertex_constants;
+  int vertex_constants_number;
+  int user_quirks;
+
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -1547,21 +1563,28 @@ enum wined3d_pci_device
     CARD_NVIDIA_GEFORCE_6200        = 0x014f,
     CARD_NVIDIA_GEFORCE_6600GT      = 0x0140,
     CARD_NVIDIA_GEFORCE_6800        = 0x0041,
-    CARD_NVIDIA_GEFORCE_7300        = 0x01d7, /* GeForce Go 7300 */
+//    CARD_NVIDIA_GEFORCE_7450        = 0x01d9, /* GeForce Go 7450 */
     CARD_NVIDIA_GEFORCE_7400        = 0x01d8,
+    CARD_NVIDIA_GEFORCE_7300        = 0x01d7, /* GeForce Go 7300 */
+    CARD_NVIDIA_GEFORCE_7300LE      = 0x01d1, /* GeForce 7300LE */
     CARD_NVIDIA_GEFORCE_7600        = 0x0391,
     CARD_NVIDIA_GEFORCE_7800GT      = 0x0092,
     CARD_NVIDIA_GEFORCE_8200        = 0x0849, /* Other PCI ID 0x084b */
     CARD_NVIDIA_GEFORCE_8300GS      = 0x0423,
     CARD_NVIDIA_GEFORCE_8400GS      = 0x0404,
     CARD_NVIDIA_GEFORCE_8500GT      = 0x0421,
-    CARD_NVIDIA_GEFORCE_8600GT      = 0x0402,
+//    CARD_NVIDIA_GEFORCE_8400SE      = 0x0420,
+//    CARD_NVIDIA_GEFORCE_330GT       = 0x0410,
     CARD_NVIDIA_GEFORCE_8600MGT     = 0x0407,
+//    CARD_NVIDIA_GEFORCE_8600GS      = 0x0403,
+    CARD_NVIDIA_GEFORCE_8600GT      = 0x0402,
+//    CARD_NVIDIA_GEFORCE_8600GTS     = 0x0400,
     CARD_NVIDIA_GEFORCE_8800GTS     = 0x0193,
     CARD_NVIDIA_GEFORCE_8800GTX     = 0x0191,
     CARD_NVIDIA_GEFORCE_9200        = 0x086d,
     CARD_NVIDIA_GEFORCE_9300        = 0x086c,
     CARD_NVIDIA_GEFORCE_9400M       = 0x0863,
+    CARD_NVIDIA_GEFORCE_9400        = 0x0867,
     CARD_NVIDIA_GEFORCE_9400GT      = 0x042c,
     CARD_NVIDIA_GEFORCE_9500GT      = 0x0640,
     CARD_NVIDIA_GEFORCE_9600GT      = 0x0622,
@@ -1580,6 +1603,7 @@ enum wined3d_pci_device
     CARD_NVIDIA_GEFORCE_GTS350M     = 0x0cb0,
     CARD_NVIDIA_GEFORCE_410M        = 0x1055,
     CARD_NVIDIA_GEFORCE_GT420       = 0x0de2,
+    CARD_NVIDIA_GEFORCE_GT425M      = 0x0df0,
     CARD_NVIDIA_GEFORCE_GT430       = 0x0de1,
     CARD_NVIDIA_GEFORCE_GT440       = 0x0de0,
     CARD_NVIDIA_GEFORCE_GTS450      = 0x0dc4,
@@ -1619,7 +1643,10 @@ enum wined3d_pci_device
     CARD_NVIDIA_GEFORCE_GTX780      = 0x1004,
     CARD_NVIDIA_GEFORCE_GTX780TI    = 0x100a,
     CARD_NVIDIA_GEFORCE_GTX970      = 0x13c2,
+//    CARD_NVIDIA_GEFORCE_GTX980M     = 0x13d7,
     CARD_NVIDIA_GEFORCE_GTX970M     = 0x13d8,
+//    CARD_NVIDIA_GEFORCE_GTX965M     = 0x13d9,
+//    CARD_NVIDIA_GEFORCE_GTX960      = 0x1401,
 
     CARD_VMWARE_SVGA3D              = 0x0405,
 
@@ -1945,7 +1972,8 @@ struct wined3d_ffp_vs_settings
     DWORD texcoords       : 8;  /* MAX_TEXTURES */
     DWORD ortho_fog       : 1;
     DWORD flatshading     : 1;
-    DWORD padding         : 10;
+    DWORD vb_indices	  : 1;
+    DWORD padding         : 9;
 
     DWORD texgen[MAX_TEXTURES];
 };
@@ -2181,6 +2209,8 @@ struct wined3d_resource
     UINT multisample_quality;
     DWORD usage;
     enum wined3d_pool pool;
+    BOOL managed;
+    BOOL freed;
     DWORD access_flags;
     DWORD draw_binding;
     DWORD map_binding;
@@ -2277,6 +2307,7 @@ struct wined3d_texture
     DWORD sampler;
     DWORD flags;
     GLenum target;
+    UINT allocated_subresource;
 
     /* May only be accessed from the command stream worker thread. */
     struct wined3d_texture_async
@@ -2354,7 +2385,7 @@ BOOL volume_prepare_system_memory(struct wined3d_volume *volume) DECLSPEC_HIDDEN
 HRESULT wined3d_volume_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
         unsigned int level, struct wined3d_volume **volume) DECLSPEC_HIDDEN;
 void wined3d_volume_destroy(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
-void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch, UINT *slice_pitch) DECLSPEC_HIDDEN;
+//void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch, UINT *slice_pitch) DECLSPEC_HIDDEN;
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context,
         BOOL srgb_mode) DECLSPEC_HIDDEN;
 void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location) DECLSPEC_HIDDEN;
@@ -2909,6 +2940,10 @@ void state_pointsprite(struct wined3d_context *context,
 void state_shademode(struct wined3d_context *context,
         const struct wined3d_state *state, DWORD state_id) DECLSPEC_HIDDEN;
 
+BOOL getColorBits(const struct wined3d_format *format,
+        BYTE *redSize, BYTE *greenSize, BYTE *blueSize, BYTE *alphaSize, BYTE *totalSize) DECLSPEC_HIDDEN;
+BOOL getDepthStencilBits(const struct wined3d_format *format,
+        BYTE *depthSize, BYTE *stencilSize) DECLSPEC_HIDDEN;
 GLenum gl_primitive_type_from_d3d(enum wined3d_primitive_type primitive_type) DECLSPEC_HIDDEN;
 
 /* Math utils */
@@ -3252,6 +3287,9 @@ const struct wined3d_format *wined3d_get_format(const struct wined3d_gl_info *gl
 UINT wined3d_format_calculate_pitch(const struct wined3d_format *format, UINT width) DECLSPEC_HIDDEN;
 UINT wined3d_format_calculate_size(const struct wined3d_format *format,
         UINT alignment, UINT width, UINT height, UINT depth) DECLSPEC_HIDDEN;
+UINT wined3d_format_calculate_size_total(const struct wined3d_format *format,
+        UINT alignment, UINT width, UINT height, UINT depth, UINT levels,
+        enum wined3d_resource_type type) DECLSPEC_HIDDEN;
 DWORD wined3d_format_convert_from_float(const struct wined3d_surface *surface,
         const struct wined3d_color *color) DECLSPEC_HIDDEN;
 BOOL wined3d_format_convert_color_to_float(const struct wined3d_format *format,
diff --git a/dlls/winemac.drv/cocoa_app.m b/dlls/winemac.drv/cocoa_app.m
index 3a80f1d..704c922 100644
--- a/dlls/winemac.drv/cocoa_app.m
+++ b/dlls/winemac.drv/cocoa_app.m
@@ -729,11 +729,12 @@ - (NSArray*)modesMatchingMode:(CGDisplayModeRef)mode forDisplay:(CGDirectDisplay
         NSDictionary* options = nil;
 
 #if defined(MAC_OS_X_VERSION_10_8) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+#if defined(kCGDisplayShowDuplicateLowResolutionModes)
         if (&kCGDisplayShowDuplicateLowResolutionModes != NULL)
             options = [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:TRUE]
                                                   forKey:(NSString*)kCGDisplayShowDuplicateLowResolutionModes];
 #endif
-
+#endif
         NSArray *modes = [(NSArray*)CGDisplayCopyAllDisplayModes(displayID, (CFDictionaryRef)options) autorelease];
         for (id candidateModeObject in modes)
         {
diff --git a/dlls/winemac.drv/display.c b/dlls/winemac.drv/display.c
index ad01191..1eb518f 100644
--- a/dlls/winemac.drv/display.c
+++ b/dlls/winemac.drv/display.c
@@ -18,7 +18,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 
 #include "macdrv.h"
@@ -553,6 +553,7 @@ static CFArrayRef copy_display_modes(CGDirectDisplayID display)
     CFArrayRef modes = NULL;
 
 #if defined(MAC_OS_X_VERSION_10_8) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+#ifdef kCGDisplayShowDuplicateLowResolutionModes
     if (&kCGDisplayShowDuplicateLowResolutionModes != NULL &&
         CGDisplayModeGetPixelWidth != NULL && CGDisplayModeGetPixelHeight != NULL)
     {
@@ -661,6 +662,7 @@ static CFArrayRef copy_display_modes(CGDirectDisplayID display)
     }
     else
 #endif
+#endif
         modes = CGDisplayCopyAllDisplayModes(display, NULL);
 
     return modes;
@@ -681,9 +683,9 @@ LONG CDECL macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
     struct macdrv_display *displays;
     int num_displays;
     CFArrayRef display_modes;
-    CFIndex count, i, safe, best;
+    CFIndex count, i, safe, best = 0;
     CGDisplayModeRef best_display_mode;
-    uint32_t best_io_flags;
+    uint32_t best_io_flags = 0;
 
     TRACE("%s %p %p 0x%08x %p\n", debugstr_w(devname), devmode, hwnd, flags, lpvoid);
 
@@ -942,7 +944,7 @@ BOOL CDECL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode,
     struct macdrv_display *displays = NULL;
     int num_displays;
     CGDisplayModeRef display_mode;
-    int display_mode_bpp;
+    int display_mode_bpp = 24;
     BOOL synthesized = FALSE;
     double rotation;
     uint32_t io_flags;
@@ -1215,6 +1217,7 @@ BOOL CDECL macdrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info)
     int num_displays;
     CGDirectDisplayID display_id;
     int i;
+  BOOL unique_monitor_names = TRUE;
 
     TRACE("%p, %p\n", monitor, info);
 
diff --git a/include/d3d9types.h b/include/d3d9types.h
index cec42ec..e3919cc 100644
--- a/include/d3d9types.h
+++ b/include/d3d9types.h
@@ -814,23 +814,36 @@ typedef enum _D3DFORMAT {
     D3DFMT_L16                  =  81,
     D3DFMT_D32F_LOCKABLE        =  82,
     D3DFMT_D24FS8               =  83,
+    /* d3d9ex formats */
+  /* Z-Stencil formats valid for CPU access */  
+    D3DFMT_D32_LOCKABLE         =  84,
+    D3DFMT_S8_LOCKABLE          =  85,
+
 
     D3DFMT_VERTEXDATA           = 100,
     D3DFMT_INDEX16              = 101,
     D3DFMT_INDEX32              = 102,
     D3DFMT_Q16W16V16U16         = 110,
     /* Floating point formats */
+  // s10e5 formats (16-bits per channel) 
     D3DFMT_R16F                 = 111,
     D3DFMT_G16R16F              = 112,
     D3DFMT_A16B16G16R16F        = 113,
     
     /* IEEE formats */
+  // IEEE s23e8 formats (32-bits per channel) 
     D3DFMT_R32F                 = 114,
     D3DFMT_G32R32F              = 115,
     D3DFMT_A32B32G32R32F        = 116,
     
     D3DFMT_CxV8U8               = 117,
-
+    /* d3d9ex formats */
+  // Monochrome 1 bit per pixel format 
+    D3DFMT_A1                   = 118,
+  // 2.8 biased fixed point 
+    D3DFMT_A2B10G10R10_XR_BIAS  = 119,
+  // Binary format indicating that the data has no inherent type 
+    D3DFMT_BINARYBUFFER         = 199,
 
     D3DFMT_FORCE_DWORD          = 0xFFFFFFFF
 } D3DFORMAT;
diff --git a/include/d3dx9tex.h b/include/d3dx9tex.h
index 542460f..fbe8ae6 100644
--- a/include/d3dx9tex.h
+++ b/include/d3dx9tex.h
@@ -185,6 +185,8 @@ HRESULT WINAPI D3DXSaveVolumeToFileA(const char *destfile, D3DXIMAGE_FILEFORMAT
         struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *srcpalette, const D3DBOX *srcbox);
 HRESULT WINAPI D3DXSaveVolumeToFileW(const WCHAR *destfile, D3DXIMAGE_FILEFORMAT destformat,
         struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *srcpalette, const D3DBOX *srcbox);
+HRESULT WINAPI D3DXSaveVolumeToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE_FILEFORMAT file_format,
+        struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *srcpalette, const D3DBOX *srcbox);
 #define D3DXSaveVolumeToFile WINELIB_NAME_AW(D3DXSaveVolumeToFile)
 
 
diff --git a/include/wine/wgl_driver.h b/include/wine/wgl_driver.h
index c52185d..046b604 100644
--- a/include/wine/wgl_driver.h
+++ b/include/wine/wgl_driver.h
@@ -2903,6 +2903,8 @@ struct opengl_funcs
         BOOL       (WINE_GLAPI *p_wglSetPbufferAttribARB)(struct wgl_pbuffer *,const int*);
         BOOL       (WINE_GLAPI *p_wglSetPixelFormatWINE)(HDC,int);
         BOOL       (WINE_GLAPI *p_wglSwapIntervalEXT)(int);
+        BOOL       (WINE_GLAPI *p_wglGetPCIInfoWINE)(unsigned int *, unsigned int *);
+        BOOL       (WINE_GLAPI *p_wglGetMemoryInfoWINE)(unsigned int *);
     } ext;
 };
 
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index 2deb450..aeb5e62 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -22,7 +22,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #ifndef __WINE_WINED3D_H
 #define __WINE_WINED3D_H
 
@@ -135,7 +135,9 @@ enum wined3d_format_id
     WINED3DFMT_R8G8_SNORM_L8X8_UNORM,
     WINED3DFMT_R10G11B11_SNORM,
     WINED3DFMT_R10G10B10_SNORM_A2_UNORM,
+    WINED3DFMT_D32_LOCKABLE,
     WINED3DFMT_D16_LOCKABLE,
+    WINED3DFMT_S8_LOCKABLE,
     WINED3DFMT_D32_UNORM,
     WINED3DFMT_S1_UINT_D15_UNORM,
     WINED3DFMT_X8D24_UNORM,
@@ -251,6 +253,8 @@ enum wined3d_format_id
     WINED3DFMT_NVDB                         = WINEMAKEFOURCC('N','V','D','B'),
     WINED3DFMT_NVHU                         = WINEMAKEFOURCC('N','V','H','U'),
     WINED3DFMT_NVHS                         = WINEMAKEFOURCC('N','V','H','S'),
+  WINED3DFMT_DF16                         = WINEMAKEFOURCC('D','F','1','6'),
+  WINED3DFMT_DF24                         = WINEMAKEFOURCC('D','F','2','4'),
     WINED3DFMT_INTZ                         = WINEMAKEFOURCC('I','N','T','Z'),
     WINED3DFMT_RESZ                         = WINEMAKEFOURCC('R','E','S','Z'),
     WINED3DFMT_NULL                         = WINEMAKEFOURCC('N','U','L','L'),
@@ -503,6 +507,13 @@ enum wined3d_patch_edge_style
     WINED3D_PATCH_EDGE_CONTINUOUS           = 1,
 };
 
+enum wined3d_backbuffer_type
+{
+    WINED3D_BACKBUFFER_TYPE_MONO            = 0,
+    WINED3D_BACKBUFFER_TYPE_LEFT            = 1,
+    WINED3D_BACKBUFFER_TYPE_RIGHT           = 2,
+};
+
 enum wined3d_swap_effect
 {
     WINED3D_SWAP_EFFECT_DISCARD             = 1,
@@ -797,6 +808,7 @@ enum wined3d_display_rotation
 
 #define WINED3DADAPTER_DEFAULT                                  0
 #define WINED3DENUM_NO_WHQL_LEVEL                               2
+#define WINED3DPRESENT_BACK_BUFFER_MAX                          3
 
 #define WINED3DTSS_TCI_PASSTHRU                                 0x00000
 #define WINED3DTSS_TCI_CAMERASPACENORMAL                        0x10000
@@ -1244,6 +1256,7 @@ enum wined3d_display_rotation
 
 #define WINED3D_RESZ_CODE                                       0x7fa05000
 
+#define WINED3D_CKEY_COLORSPACE                                 0x00000001
 #define WINED3D_CKEY_DST_BLT                                    0x00000002
 #define WINED3D_CKEY_DST_OVERLAY                                0x00000004
 #define WINED3D_CKEY_SRC_BLT                                    0x00000008
@@ -2018,6 +2031,7 @@ struct wined3d_surface;
 struct wined3d_swapchain;
 struct wined3d_texture;
 struct wined3d_vertex_declaration;
+struct wined3d_volume;
 
 struct wined3d_device_parent
 {
@@ -2148,6 +2162,8 @@ HRESULT __cdecl wined3d_device_end_scene(struct wined3d_device *device);
 HRESULT __cdecl wined3d_device_end_stateblock(struct wined3d_device *device, struct wined3d_stateblock **stateblock);
 void __cdecl wined3d_device_evict_managed_resources(struct wined3d_device *device);
 UINT __cdecl wined3d_device_get_available_texture_mem(const struct wined3d_device *device);
+HRESULT __cdecl wined3d_device_get_back_buffer(const struct wined3d_device *device, UINT swapchain_idx,
+        UINT backbuffer_idx, enum wined3d_backbuffer_type backbuffer_type, struct wined3d_surface **backbuffer);
 INT __cdecl wined3d_device_get_base_vertex_index(const struct wined3d_device *device);
 HRESULT __cdecl wined3d_device_get_clip_plane(const struct wined3d_device *device,
         UINT plane_idx, struct wined3d_vec4 *plane);
@@ -2159,6 +2175,8 @@ struct wined3d_rendertarget_view * __cdecl wined3d_device_get_depth_stencil_view
 HRESULT __cdecl wined3d_device_get_device_caps(const struct wined3d_device *device, WINED3DCAPS *caps);
 HRESULT __cdecl wined3d_device_get_display_mode(const struct wined3d_device *device, UINT swapchain_idx,
         struct wined3d_display_mode *mode, enum wined3d_display_rotation *rotation);
+HRESULT __cdecl wined3d_device_get_front_buffer_data(const struct wined3d_device *device,
+        UINT swapchain_idx, struct wined3d_surface *dst_surface);
 void __cdecl wined3d_device_get_gamma_ramp(const struct wined3d_device *device,
         UINT swapchain_idx, struct wined3d_gamma_ramp *ramp);
 struct wined3d_shader * __cdecl wined3d_device_get_geometry_shader(const struct wined3d_device *device);
@@ -2229,6 +2247,8 @@ HRESULT __cdecl wined3d_device_init_3d(struct wined3d_device *device, struct win
 HRESULT __cdecl wined3d_device_init_gdi(struct wined3d_device *device, struct wined3d_swapchain_desc *swapchain_desc);
 void __cdecl wined3d_device_multiply_transform(struct wined3d_device *device,
         enum wined3d_transform_state state, const struct wined3d_matrix *matrix);
+HRESULT __cdecl wined3d_device_present(const struct wined3d_device *device, const RECT *src_rect,
+        const RECT *dst_rect, HWND dst_window_override, const RGNDATA *dirty_region, DWORD flags);
 HRESULT __cdecl wined3d_device_process_vertices(struct wined3d_device *device,
         UINT src_start_idx, UINT dst_idx, UINT vertex_count, struct wined3d_buffer *dst_buffer,
         const struct wined3d_vertex_declaration *declaration, DWORD flags, DWORD dst_fvf);
@@ -2426,6 +2446,8 @@ HRESULT __cdecl wined3d_resource_map(struct wined3d_resource *resource, unsigned
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags);
 void __cdecl wined3d_resource_set_parent(struct wined3d_resource *resource, void *parent);
 DWORD __cdecl wined3d_resource_set_priority(struct wined3d_resource *resource, DWORD priority);
+void __cdecl wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+                                        UINT *slice_pitch);
 HRESULT __cdecl wined3d_resource_unmap(struct wined3d_resource *resource, unsigned int sub_resource_idx);
 
 HRESULT __cdecl wined3d_rendertarget_view_create(const struct wined3d_rendertarget_view_desc *desc,
@@ -2481,9 +2503,11 @@ HRESULT __cdecl wined3d_surface_blt(struct wined3d_surface *dst_surface, const R
         const WINEDDBLTFX *blt_fx, enum wined3d_texture_filter_type filter);
 ULONG __cdecl wined3d_surface_decref(struct wined3d_surface *surface);
 struct wined3d_surface * __cdecl wined3d_surface_from_resource(struct wined3d_resource *resource);
+HRESULT __cdecl wined3d_surface_get_blt_status(const struct wined3d_surface *surface, DWORD flags);
+HRESULT __cdecl wined3d_surface_get_flip_status(const struct wined3d_surface *surface, DWORD flags);
 HRESULT __cdecl wined3d_surface_get_overlay_position(const struct wined3d_surface *surface, LONG *x, LONG *y);
 void * __cdecl wined3d_surface_get_parent(const struct wined3d_surface *surface);
-DWORD __cdecl wined3d_surface_get_pitch(const struct wined3d_surface *surface);
+//DWORD __cdecl wined3d_surface_get_pitch(const struct wined3d_surface *surface);
 struct wined3d_resource * __cdecl wined3d_surface_get_resource(struct wined3d_surface *surface);
 HRESULT __cdecl wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc);
 ULONG __cdecl wined3d_surface_incref(struct wined3d_surface *surface);
@@ -2570,6 +2594,16 @@ ULONG __cdecl wined3d_vertex_declaration_decref(struct wined3d_vertex_declaratio
 void * __cdecl wined3d_vertex_declaration_get_parent(const struct wined3d_vertex_declaration *declaration);
 ULONG __cdecl wined3d_vertex_declaration_incref(struct wined3d_vertex_declaration *declaration);
 
+ULONG __cdecl wined3d_volume_decref(struct wined3d_volume *volume);
+struct wined3d_volume * __cdecl wined3d_volume_from_resource(struct wined3d_resource *resource);
+void * __cdecl wined3d_volume_get_parent(const struct wined3d_volume *volume);
+struct wined3d_resource * __cdecl wined3d_volume_get_resource(struct wined3d_volume *volume);
+ULONG __cdecl wined3d_volume_incref(struct wined3d_volume *volume);
+HRESULT __cdecl wined3d_volume_map(struct wined3d_volume *volume,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags);
+void __cdecl wined3d_volume_preload(struct wined3d_volume *volume);
+HRESULT __cdecl wined3d_volume_unmap(struct wined3d_volume *volume);
+
 /* Return the integer base-2 logarithm of x. Undefined for x == 0. */
 static inline unsigned int wined3d_log2i(unsigned int x)
 {
@@ -2601,4 +2635,20 @@ static inline unsigned int wined3d_log2i(unsigned int x)
 #endif
 }
 
+
+BOOL wined3d_dxt1_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt1_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt3_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt3_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt5_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt5_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxtn_supported(void);
+
+
 #endif /* __WINE_WINED3D_H */
diff --git a/libs/wine/Makefile.in b/libs/wine/Makefile.in
index 1b7fea8..8207014 100644
--- a/libs/wine/Makefile.in
+++ b/libs/wine/Makefile.in
@@ -112,7 +112,7 @@ libwine_LDFLAGS = $(LIBWINE_LDFLAGS)
 libwine_DEPS = $(LIBWINE_DEPENDS)
 
 version.c: dummy
-	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
+	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-$(PACKAGE_VERSION)") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1 (XSherry)";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
 
 dummy:
 .PHONY: dummy
diff --git a/tools/makedep.c b/tools/makedep.c
index 14a26ef..5b55243 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -17,7 +17,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
-
+//Slice 2015
 #include "config.h"
 #define NO_LIBWINE_PORT
 #include "wine/port.h"
@@ -1974,7 +1974,7 @@ static struct strarray output_install_rules( const struct makefile *make, struct
     output( "install %s::", target );
     output_filenames_obj_dir( make, targets );
     output( "\n" );
-
+    output( "\t@echo [INSTALL_DATA] %s\n", target);
     install_sh = top_dir_path( make, "tools/install-sh" );
     for (i = 0; i < files.count; i += 2)
     {
@@ -1984,27 +1984,30 @@ static struct strarray output_install_rules( const struct makefile *make, struct
         switch (*dest)
         {
         case 'd':  /* data file */
-            output( "\t%s -m 644 $(INSTALL_DATA_FLAGS) %s $(DESTDIR)%s\n",
+            output( "\t@%s -m 644 $(INSTALL_DATA_FLAGS) %s $(DESTDIR)%s\n",
                     install_sh, obj_dir_path( make, file ), dest + 1 );
             break;
         case 'D':  /* data file in source dir */
-            output( "\t%s -m 644 $(INSTALL_DATA_FLAGS) %s $(DESTDIR)%s\n",
+            output( "\t@%s -m 644 $(INSTALL_DATA_FLAGS) %s $(DESTDIR)%s\n",
                     install_sh, src_dir_path( make, file ), dest + 1 );
             break;
         case 'p':  /* program file */
-            output( "\tSTRIPPROG=\"$(STRIP)\" %s $(INSTALL_PROGRAM_FLAGS) %s $(DESTDIR)%s\n",
+            output( "\t@STRIPPROG=\"$(STRIP)\" %s $(INSTALL_PROGRAM_FLAGS) %s $(DESTDIR)%s\n",
                     install_sh, obj_dir_path( make, file ), dest + 1 );
             break;
         case 's':  /* script */
-            output( "\t%s $(INSTALL_SCRIPT_FLAGS) %s $(DESTDIR)%s\n",
+            output( "\t@%s $(INSTALL_SCRIPT_FLAGS) %s $(DESTDIR)%s\n",
                     install_sh, obj_dir_path( make, file ), dest + 1 );
+            output( "\t@echo [INSTALL_SCRIPT] %s\n", file );
             break;
         case 'S':  /* script in source dir */
-            output( "\t%s $(INSTALL_SCRIPT_FLAGS) %s $(DESTDIR)%s\n",
+            output( "\t@%s $(INSTALL_SCRIPT_FLAGS) %s $(DESTDIR)%s\n",
                     install_sh, src_dir_path( make, file ), dest + 1 );
+            output( "\t@echo [INSTALL_SCRIPT] %s\n", file );
             break;
         case 'y':  /* symlink */
-            output( "\trm -f $(DESTDIR)%s && $(LN_S) %s $(DESTDIR)%s\n", dest + 1, file, dest + 1 );
+            output( "\t@rm -f $(DESTDIR)%s && $(LN_S) %s $(DESTDIR)%s\n", dest + 1, file, dest + 1 );
+            output( "\t@echo [RM] %s\n", file );
             break;
         default:
             assert(0);
@@ -2099,7 +2102,8 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             }
             else output( "%s.tab.c: %s\n", obj, source->filename );
 
-            output( "\t$(BISON) -p %s_ -o $@ %s\n", obj, source->filename );
+            output( "\t@$(BISON) -p %s_ -o $@ %s\n", obj, source->filename );
+            output( "\t@echo [BISON] $@\n" );
         }
         else if (!strcmp( ext, "x" ))  /* template file */
         {
@@ -2120,14 +2124,15 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         else if (!strcmp( ext, "l" ))  /* lex file */
         {
             output( "%s.yy.c: %s\n", obj_dir_path( make, obj ), source->filename );
-            output( "\t$(FLEX) -o$@ %s\n", source->filename );
+            output( "\t@$(FLEX) -o$@ %s\n", source->filename );
+            output( "\t@echo [FLEX] $@\n" );
         }
         else if (!strcmp( ext, "rc" ))  /* resource file */
         {
             strarray_add( &res_files, strmake( "%s.res", obj ));
             output( "%s.res: %s %s\n", obj_dir_path( make, obj ),
                     tools_path( make, "wrc" ), source->filename );
-            output( "\t%s -o $@", tools_path( make, "wrc" ) );
+            output( "\t@%s -o $@", tools_path( make, "wrc" ) );
             if (make->is_win16) output_filename( "-m16" );
             else output_filenames( target_flags );
             output_filename( "--nostdinc" );
@@ -2140,6 +2145,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
                 output_filename( strmake( "--po-dir=%s", top_obj_dir_path( make, "po" )));
                 output_filename( source->filename );
                 output( "\n" );
+                output( "\t@echo [WRC] $@\n" );
                 output( "%s.res:", obj_dir_path( make, obj ));
                 output_filenames( mo_files );
                 output( "\n" );
@@ -2149,6 +2155,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             {
                 output_filename( source->filename );
                 output( "\n" );
+                output( "\t@echo [WRC] $@\n" );
             }
             output( "%s.res:", obj_dir_path( make, obj ));
             output_filenames( dependencies );
@@ -2206,7 +2213,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             if (!targets.count) continue;
             output_filenames_obj_dir( make, targets );
             output( ": %s\n", tools_path( make, "widl" ));
-            output( "\t%s -o $@", tools_path( make, "widl" ) );
+            output( "\t@%s -o $@", tools_path( make, "widl" ) );
             output_filenames( target_flags );
             output_filenames( includes );
             output_filenames( make->define_args );
@@ -2214,6 +2221,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             output_filenames( get_expanded_make_var_array( make, "EXTRAIDLFLAGS" ));
             output_filename( source->filename );
             output( "\n" );
+            output( "\t@echo [WIDL] $@\n" );
             output_filenames_obj_dir( make, targets );
             output( ": %s", source->filename );
             output_filenames( dependencies );
@@ -2329,7 +2337,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             if (source->file->flags & FLAG_C_IMPLIB) strarray_add( &implib_objs, strmake( "%s.o", obj ));
             strarray_add( &object_files, strmake( "%s.o", obj ));
             output( "%s.o: %s\n", obj_dir_path( make, obj ), source->filename );
-            output( "\t$(CC) -c -o $@ %s", source->filename );
+            output( "\t@$(CC) -c -o $@ %s", source->filename );
             output_filenames( includes );
             output_filenames( make->define_args );
             output_filenames( extradefs );
@@ -2342,11 +2350,12 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             output_filenames( cpp_flags );
             output_filename( "$(CFLAGS)" );
             output( "\n" );
+            output( "\t@echo [CC] %s\n", source->filename);
             if (crosstarget && need_cross)
             {
                 strarray_add( &crossobj_files, strmake( "%s.cross.o", obj ));
                 output( "%s.cross.o: %s\n", obj_dir_path( make, obj ), source->filename );
-                output( "\t$(CROSSCC) -c -o $@ %s", source->filename );
+                output( "\t@$(CROSSCC) -c -o $@ %s", source->filename );
                 output_filenames( includes );
                 output_filenames( make->define_args );
                 output_filenames( extradefs );
@@ -2354,6 +2363,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
                 output_filenames( cpp_flags );
                 output_filename( "$(CFLAGS)" );
                 output( "\n" );
+              output( "\t@echo [CROSSCC] %s\n", source->filename);
             }
             if (make->testdll && !strcmp( ext, "c" ) && !(source->file->flags & FLAG_GENERATED))
             {
@@ -2381,7 +2391,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output( "%s: %s", obj_dir_path( make, "rsrc.pot" ), tools_path( make, "wrc" ) );
         output_filenames( po_files );
         output( "\n" );
-        output( "\t%s -O pot -o $@", tools_path( make, "wrc" ));
+        output( "\t@%s -O pot -o $@", tools_path( make, "wrc" ));
         if (make->is_win16) output_filename( "-m16" );
         else output_filenames( target_flags );
         output_filename( "--nostdinc" );
@@ -2389,6 +2399,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output_filenames( make->define_args );
         output_filenames( po_files );
         output( "\n" );
+      output( "\t@echo [WRC] $@\n" );
         strarray_add( &clean_files, "rsrc.pot" );
     }
 
@@ -2397,9 +2408,10 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output( "%s: %s", obj_dir_path( make, "msg.pot" ), tools_path( make, "wmc" ));
         output_filenames( mc_files );
         output( "\n" );
-        output( "\t%s -O pot -o $@", tools_path( make, "wmc" ));
+        output( "\t@%s -O pot -o $@", tools_path( make, "wmc" ));
         output_filenames( mc_files );
         output( "\n" );
+        output( "\t@echo [WMC] $@\n" );
         strarray_add( &clean_files, "msg.pot" );
     }
 
@@ -2407,9 +2419,10 @@ static struct strarray output_sources( const struct makefile *make, struct strar
     {
         output( "%s: %s %s\n", obj_dir_path( make, "dlldata.c" ),
                 tools_path( make, "widl" ), src_dir_path( make, "Makefile.in" ));
-        output( "\t%s --dlldata-only -o $@", tools_path( make, "widl" ));
+        output( "\t@%s --dlldata-only -o $@", tools_path( make, "widl" ));
         output_filenames( dlldata_files );
         output( "\n" );
+        output( "\t@echo [WIDL] $@\n" );
     }
 
     if (make->module && !make->staticlib)
@@ -2452,7 +2465,8 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output_filenames_obj_dir( make, object_files );
         output_filenames_obj_dir( make, res_files );
         output( "\n" );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@echo [making] $@\n" );
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2468,6 +2482,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
 
         if (spec_file && make->importlib)
         {
@@ -2520,10 +2535,11 @@ static struct strarray output_sources( const struct makefile *make, struct strar
                 output( "%s.cross.a: %s %s", importlib_path, tools_path( make, "winebuild" ), spec_file );
                 output_filenames_obj_dir( make, cross_files );
                 output( "\n" );
-                output( "\t%s -b %s -w --implib -o $@ --export %s",
+                output( "\t@%s -b %s -w --implib -o $@ --export %s",
                         tools_path( make, "winebuild" ), crosstarget, spec_file );
                 output_filenames_obj_dir( make, cross_files );
                 output( "\n" );
+                output( "\t@echo [WINEBUILD] $@\n" );
             }
         }
 
@@ -2532,37 +2548,41 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             if (c2man_files.count)
             {
                 output( "manpages::\n" );
-                output( "\t%s -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
+                output( "\t@%s -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
                 output_filename( strmake( "-R%s", top_dir_path( make, "" )));
                 output_filename( strmake( "-I%s", top_dir_path( make, "include" )));
                 output_filename( strmake( "-o %s/man%s",
                                           top_obj_dir_path( make, "documentation" ), man_ext ));
                 output_filenames( c2man_files );
                 output( "\n" );
+                output( "\t@echo [C2MAN] $@\n" );
                 output( "htmlpages::\n" );
-                output( "\t%s -Th -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
+                output( "\t@%s -Th -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
                 output_filename( strmake( "-R%s", top_dir_path( make, "" )));
                 output_filename( strmake( "-I%s", top_dir_path( make, "include" )));
                 output_filename( strmake( "-o %s",
                                           top_obj_dir_path( make, "documentation/html" )));
                 output_filenames( c2man_files );
                 output( "\n" );
+                output( "\t@echo [HTML] $@\n" );
                 output( "sgmlpages::\n" );
-                output( "\t%s -Ts -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
+                output( "\t@%s -Ts -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
                 output_filename( strmake( "-R%s", top_dir_path( make, "" )));
                 output_filename( strmake( "-I%s", top_dir_path( make, "include" )));
                 output_filename( strmake( "-o %s",
                                           top_obj_dir_path( make, "documentation/api-guide" )));
                 output_filenames( c2man_files );
                 output( "\n" );
+                output( "\t@echo [SGML] $@\n" );
                 output( "xmlpages::\n" );
-                output( "\t%s -Tx -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
+                output( "\t@%s -Tx -w %s", top_dir_path( make, "tools/c2man.pl" ), spec_file );
                 output_filename( strmake( "-R%s", top_dir_path( make, "" )));
                 output_filename( strmake( "-I%s", top_dir_path( make, "include" )));
                 output_filename( strmake( "-o %s",
                                           top_obj_dir_path( make, "documentation/api-guide-xml" )));
                 output_filenames( c2man_files );
                 output( "\n" );
+                output( "\t@echo [XML] $@\n" );
                 strarray_add( &phony_targets, "manpages" );
                 strarray_add( &phony_targets, "htmlpages" );
                 strarray_add( &phony_targets, "sgmlpages" );
@@ -2662,7 +2682,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         strarray_add( &all_targets, strmake( "%s%s", testmodule, dll_ext ));
         strarray_add( &clean_files, strmake( "%s%s", stripped, dll_ext ));
         output( "%s%s:\n", obj_dir_path( make, testmodule ), dll_ext );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2673,8 +2693,9 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
         output( "%s%s:\n", obj_dir_path( make, stripped ), dll_ext );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2686,6 +2707,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
         output( "%s%s %s%s:", obj_dir_path( make, testmodule ), dll_ext,
                 obj_dir_path( make, stripped ), dll_ext );
         output_filenames_obj_dir( make, object_files );
@@ -2708,7 +2730,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             output_filenames_obj_dir( make, crossobj_files );
             output_filenames_obj_dir( make, res_files );
             output( "\n" );
-            output( "\t%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
+            output( "\t@%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
             output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
             if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
             output_filename( "--lib-suffix=.cross.a" );
@@ -2717,6 +2739,7 @@ static struct strarray output_sources( const struct makefile *make, struct strar
             output_filenames( all_libs );
             output_filename( "$(LDFLAGS)" );
             output( "\n" );
+            output( "\t@echo [WINEGCC] $@\n" );
             strarray_add( &phony_targets, obj_dir_path( make, "crosstest" ));
             if (make->obj_dir) output( "crosstest: %s\n", obj_dir_path( make, "crosstest" ));
         }
@@ -2988,6 +3011,11 @@ static void output_gitignore( const char *dest, struct strarray files )
     output_file = create_temp_file( dest );
 
     output( "# Automatically generated by make depend; DO NOT EDIT!!\n" );
+    output( "./Makefile\n");
+    output( ".DS_Store\n");
+    output( "dlls/.DS_Store\n");
+    output( "tools/.DS_Store\n");
+    output( "programs/.DS_Store\n");
     for (i = 0; i < files.count; i++)
     {
         if (!strchr( files.str[i], '/' )) output( "/" );
