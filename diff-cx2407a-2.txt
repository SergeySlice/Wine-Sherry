diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/comctl32/listbox.c /Users/sergey/src/crossover-2407/wine/dlls/comctl32/listbox.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/comctl32/listbox.c	2025-01-25 02:42:25
+++ /Users/sergey/src/crossover-2407/wine/dlls/comctl32/listbox.c	2025-02-23 20:13:03
@@ -454,14 +454,18 @@ static void LISTBOX_UpdateSize( LB_DESCR *descr )
 static void LISTBOX_UpdateSize( LB_DESCR *descr )
 {
     RECT rect;
+    LONG style = GetWindowLongW( descr->self, GWL_STYLE );
 
     GetClientRect( descr->self, &rect );
+    if (style & WS_HSCROLL)
+         rect.bottom += GetSystemMetrics(SM_CYHSCROLL);
     descr->width  = rect.right - rect.left;
     descr->height = rect.bottom - rect.top;
     if (!(descr->style & LBS_NOINTEGRALHEIGHT) && !(descr->style & LBS_OWNERDRAWVARIABLE))
     {
         INT remaining;
         RECT rect;
+
 
         GetWindowRect( descr->self, &rect );
         if(descr->item_height != 0)
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/comctl32/toolbar.c /Users/sergey/src/crossover-2407/wine/dlls/comctl32/toolbar.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/comctl32/toolbar.c	2025-01-25 02:42:25
+++ /Users/sergey/src/crossover-2407/wine/dlls/comctl32/toolbar.c	2025-02-23 20:13:03
@@ -6360,7 +6360,7 @@ TOOLBAR_Notify (TOOLBAR_INFO *infoPtr, LPNMHDR lpnmh)
         return 0;
 
     default:
-        return 0;
+        return SendMessageW(infoPtr->hwndNotify, WM_NOTIFY, lpnmh->idFrom, (LPARAM)lpnmh);
     }
 }
 
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/d3d11/device.c /Users/sergey/src/crossover-2407/wine/dlls/d3d11/device.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/d3d11/device.c	2025-01-25 02:42:25
+++ /Users/sergey/src/crossover-2407/wine/dlls/d3d11/device.c	2025-02-23 20:28:14
@@ -769,7 +769,8 @@ static void STDMETHODCALLTYPE d3d11_device_context_Dra
 
     TRACE("iface %p, index_count %u, start_index_location %u, base_vertex_location %d.\n",
             iface, index_count, start_index_location, base_vertex_location);
-
+    if (index_count == 0)
+        return;
     wined3d_device_context_draw_indexed(context->wined3d_context,
             base_vertex_location, start_index_location, index_count, 0, 0);
 }
@@ -988,6 +989,10 @@ static void STDMETHODCALLTYPE d3d11_device_context_Beg
     struct d3d11_device_context *context = impl_from_ID3D11DeviceContext1(iface);
     struct d3d_query *query = unsafe_impl_from_ID3D11Asynchronous(asynchronous);
 
+    if (!query) {
+      ERR("no query\n");
+      return;
+    }
     TRACE("iface %p, asynchronous %p.\n", iface, asynchronous);
 
     wined3d_device_context_issue_query(context->wined3d_context, query->wined3d_query, WINED3DISSUE_BEGIN);
@@ -998,7 +1003,10 @@ static void STDMETHODCALLTYPE d3d11_device_context_End
 {
     struct d3d11_device_context *context = impl_from_ID3D11DeviceContext1(iface);
     struct d3d_query *query = unsafe_impl_from_ID3D11Asynchronous(asynchronous);
-
+    if (!query) {
+      ERR("no query\n");
+      return;
+    }
     TRACE("iface %p, asynchronous %p.\n", iface, asynchronous);
 
     wined3d_device_context_issue_query(context->wined3d_context, query->wined3d_query, WINED3DISSUE_END);
@@ -1009,6 +1017,10 @@ static HRESULT STDMETHODCALLTYPE d3d11_device_context_
 {
     struct d3d11_device_context *context = impl_from_ID3D11DeviceContext1(iface);
     struct d3d_query *query = unsafe_impl_from_ID3D11Asynchronous(asynchronous);
+    if (!query) {
+      ERR("no query\n");
+      return E_INVALIDARG;
+    }
     unsigned int wined3d_flags;
     HRESULT hr;
 
@@ -1049,6 +1061,10 @@ static void STDMETHODCALLTYPE d3d11_device_context_Set
     TRACE("iface %p, predicate %p, value %#x.\n", iface, predicate, value);
 
     query = unsafe_impl_from_ID3D11Query((ID3D11Query *)predicate);
+    if (!query) {
+      ERR("no query\n");
+      return;
+    }
 
     wined3d_device_context_set_predication(context->wined3d_context, query ? query->wined3d_query : NULL, value);
 }
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/ddraw/device.c /Users/sergey/src/crossover-2407/wine/dlls/ddraw/device.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/ddraw/device.c	2025-01-25 02:42:25
+++ /Users/sergey/src/crossover-2407/wine/dlls/ddraw/device.c	2025-02-23 20:46:03
@@ -1028,12 +1028,16 @@ static HRESULT WINAPI d3d_device1_NextViewport(IDirect
  *  D3D_OK because it's a stub
  *
  *****************************************************************************/
+//Slice - bug 10729
+static D3DPICKRECORD FakeRecord = { 0x2, 0, 0x1, 0};
+
 static HRESULT WINAPI d3d_device1_Pick(IDirect3DDevice *iface, IDirect3DExecuteBuffer *buffer,
         IDirect3DViewport *viewport, DWORD flags, D3DRECT *rect)
 {
     FIXME("iface %p, buffer %p, viewport %p, flags %#lx, rect %s stub!\n",
             iface, buffer, viewport, flags, wine_dbgstr_rect((RECT *)rect));
 
+
     return D3D_OK;
 }
 
@@ -1057,7 +1061,12 @@ static HRESULT WINAPI d3d_device1_GetPickRecords(IDire
         DWORD *count, D3DPICKRECORD *records)
 {
     FIXME("iface %p, count %p, records %p stub!\n", iface, count, records);
+    *count = 1;
 
+    if (!records) {
+          return DDERR_INVALIDPARAMS;
+    }
+    *records = FakeRecord;
     return D3D_OK;
 }
 
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/ddraw/viewport.c /Users/sergey/src/crossover-2407/wine/dlls/ddraw/viewport.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/ddraw/viewport.c	2025-01-25 02:42:25
+++ /Users/sergey/src/crossover-2407/wine/dlls/ddraw/viewport.c	2025-02-23 20:13:03
@@ -740,13 +740,21 @@ static HRESULT WINAPI d3d_viewport_Clear(IDirect3DView
     HRESULT hr;
     IDirect3DViewport3 *current_viewport;
     IDirect3DDevice3 *d3d_device3;
+    D3DRECT full_rect;
 
     TRACE("iface %p, rect_count %lu, rects %p, flags %#lx.\n", iface, rect_count, rects, flags);
 
     if (!rects || !rect_count)
     {
         WARN("rect_count = %lu, rects = %p, ignoring clear\n", rect_count, rects);
-        return D3D_OK;
+//      return D3D_OK;
+        //Slice: 43159
+        full_rect.x1 = 0;
+        full_rect.y1 = 0;
+        full_rect.x2 = This->viewports.vp1.dwWidth;
+        full_rect.y2 = This->viewports.vp1.dwHeight;
+        rect_count = 1;
+        rects = &full_rect;
     }
 
     if (This->active_device == NULL) {
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/wined3d/adapter_gl.c /Users/sergey/src/crossover-2407/wine/dlls/wined3d/adapter_gl.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/wined3d/adapter_gl.c	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/dlls/wined3d/adapter_gl.c	2025-02-23 20:38:47
@@ -1289,6 +1289,7 @@ static enum wined3d_feature_level feature_level_from_c
         const struct shader_caps *shader_caps, const struct fragment_caps *fragment_caps)
 {
     unsigned int shader_model;
+    return WINED3D_FEATURE_LEVEL_11_1;
 
     shader_model = min(shader_caps->vs_version, shader_caps->ps_version);
     shader_model = min(shader_model, max(shader_caps->gs_version, 3));
@@ -3580,7 +3581,13 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3
         /* GL_ARB_map_buffer_range and GL_APPLE_flush_buffer_range provide the same
          * functionality. Prefer the ARB extension */
         gl_info->supported[APPLE_FLUSH_BUFFER_RANGE] = FALSE;
+    } else if (gl_info->supported[APPLE_FLUSH_BUFFER_RANGE])
+    {
+    	    /* SI I want to reverse logic */
+    	gl_info->supported[ARB_MAP_BUFFER_RANGE] = TRUE;
+
     }
+
     if (gl_info->supported[ARB_TEXTURE_CUBE_MAP])
     {
         TRACE(" IMPLIED: NVIDIA (NV) Texture Gen Reflection support.\n");
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/wined3d/query.c /Users/sergey/src/crossover-2407/wine/dlls/wined3d/query.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/wined3d/query.c	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/dlls/wined3d/query.c	2025-02-23 20:13:03
@@ -216,7 +216,7 @@ enum wined3d_fence_result wined3d_fence_test(const str
                 break;
 
             case GL_TIMEOUT_EXPIRED:
-                ret = WINED3D_FENCE_WAITING;
+                ret = WINED3D_FENCE_NOT_STARTED; //WINED3D_FENCE_WAITING;;
                 break;
 
             case GL_WAIT_FAILED:
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/wined3d/utils.c /Users/sergey/src/crossover-2407/wine/dlls/wined3d/utils.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/wined3d/utils.c	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/dlls/wined3d/utils.c	2025-02-23 20:13:02
@@ -1174,8 +1174,21 @@ static BOOL color_in_range(const struct wined3d_color_
 {
     /* FIXME: Is this really how color keys are supposed to work? I think it
      * makes more sense to compare the individual channels. */
-    return color >= color_key->color_space_low_value
-            && color <= color_key->color_space_high_value;
+//    return color >= color_key->color_space_low_value
+//            && color <= color_key->color_space_high_value;
+	#define RED_KEY(x)   (x & 0xff0000)
+	#define GREEN_KEY(x) (x & 0x00ff00)
+	#define BLUE_KEY(x)  (x & 0x0000ff)
+	    return ((RED_KEY(color) >= RED_KEY(color_key->color_space_low_value)) &&
+	            (RED_KEY(color) <= RED_KEY(color_key->color_space_high_value)) &&
+	            (GREEN_KEY(color) >= GREEN_KEY(color_key->color_space_low_value)) &&
+	            (GREEN_KEY(color) <= GREEN_KEY(color_key->color_space_high_value)) &&
+	            (BLUE_KEY(color) >= BLUE_KEY(color_key->color_space_low_value)) &&
+	            (BLUE_KEY(color) <= BLUE_KEY(color_key->color_space_high_value)));
+	#undef RED_KEY
+	#undef GREEN_KEY
+	#undef BLUE_KEY
+
 }
 
 static void convert_b5g6r5_unorm_b5g5r5a1_unorm_color_key(const BYTE *src, unsigned int src_pitch,
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/winemac.drv/vulkan.c /Users/sergey/src/crossover-2407/wine/dlls/winemac.drv/vulkan.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/winemac.drv/vulkan.c	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/dlls/winemac.drv/vulkan.c	2025-02-23 20:13:02
@@ -42,6 +42,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
+#define SONAME_LIBMOLTENVK "libMoltenVK.dylib"
+
 #ifdef SONAME_LIBMOLTENVK
 
 WINE_DECLARE_DEBUG_CHANNEL(fps);
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/winemac.drv/window.c /Users/sergey/src/crossover-2407/wine/dlls/winemac.drv/window.c
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/dlls/winemac.drv/window.c	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/dlls/winemac.drv/window.c	2025-02-23 20:13:02
@@ -141,7 +141,8 @@ static inline BOOL can_window_become_foreground(HWND h
  */
 static inline BOOL can_window_become_foreground(HWND hwnd)
 {
-    LONG style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    //LONG style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    LONG style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
 
     if (!(style & WS_VISIBLE)) return FALSE;
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return FALSE;
@@ -184,7 +185,8 @@ static void get_mac_rect_offset(struct macdrv_win_data
 
     rect->top = rect->bottom = rect->left = rect->right = 0;
 
-    ex_style = NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE);
+    //ex_style = NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE);
+    ex_style = NtUserCallHwndParam( data->hwnd, GWL_EXSTYLE, 12 );
 
     if (!data->shaped)
     {
@@ -242,7 +244,8 @@ static void macdrv_mac_to_window_rect(struct macdrv_wi
 static void macdrv_mac_to_window_rect(struct macdrv_win_data *data, RECT *rect)
 {
     RECT rc;
-    DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    //DWORD style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+    DWORD style = NtUserCallHwndParam( data->hwnd, GWL_STYLE, 12 );
 
     if ((style & (WS_POPUP|WS_CHILD)) == WS_CHILD) return;
     if (IsRectEmpty(rect)) return;
@@ -397,8 +400,8 @@ static void set_cocoa_window_properties(struct macdrv_
     struct macdrv_window_features wf;
     struct macdrv_window_state state;
 
-    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
-    ex_style = NtUserGetWindowLongW(data->hwnd, GWL_EXSTYLE);
+    style = NtUserCallHwndParam(data->hwnd, GWL_STYLE, 12);
+    ex_style = NtUserCallHwndParam(data->hwnd, GWL_EXSTYLE, 12);
 
     owner = NtUserGetWindowRelative(data->hwnd, GW_OWNER);
     if (owner)
@@ -880,6 +883,7 @@ static struct macdrv_win_data *macdrv_create_win_data(
 {
     struct macdrv_win_data *data;
     HWND parent;
+    DWORD ex_style;
 
     if (NtUserGetWindowThread(hwnd, NULL) != GetCurrentThreadId()) return NULL;
 
@@ -897,6 +901,19 @@ static struct macdrv_win_data *macdrv_create_win_data(
     data->whole_rect = data->window_rect = *window_rect;
     data->client_rect = *client_rect;
 
+    /* - from 11819-4 */
+    ex_style = NtUserCallHwndParam( hwnd, GWL_EXSTYLE, 12 );
+    if (ex_style & WS_EX_TRANSPARENT)
+    {
+        FIXME("transparent window, fixing window rect\n");
+        data->window_rect.right = data->window_rect.left;
+        data->window_rect.bottom = data->window_rect.top;
+        data->whole_rect = data->window_rect;
+        data->client_rect.right = data->client_rect.left;
+        data->client_rect.bottom = data->client_rect.top;
+    }
+
+
     if (parent == NtUserGetDesktopWindow())
     {
         create_cocoa_window(data);
@@ -2141,7 +2158,8 @@ BOOL macdrv_WindowPosChanging(HWND hwnd, HWND insert_a
                               RECT *visible_rect, struct window_surface **surface)
 {
     struct macdrv_win_data *data = get_win_data(hwnd);
-    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    //DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    DWORD style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
     RECT surface_rect;
 
     TRACE("%p after %p swp %04x window %s client %s visible %s surface %p\n", hwnd, insert_after,
@@ -2195,8 +2213,10 @@ void macdrv_WindowPosChanged(HWND hwnd, HWND insert_af
 {
     struct macdrv_thread_data *thread_data;
     struct macdrv_win_data *data;
-    unsigned int new_style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    //unsigned int new_style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    unsigned int new_style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
     RECT old_window_rect, old_whole_rect, old_client_rect;
+    DWORD ex_style;
 
     if (!(data = get_win_data(hwnd))) return;
 
@@ -2237,6 +2257,21 @@ void macdrv_WindowPosChanged(HWND hwnd, HWND insert_af
            wine_dbgstr_rect(visible_rect), wine_dbgstr_rect(client_rect),
            new_style, swp_flags, surface);
 
+    /* - from 11819-4 */
+    //    ex_style = GetWindowLongW( hwnd, GWL_EXSTYLE );
+    ex_style = NtUserCallHwndParam( hwnd, GWL_EXSTYLE, 12 );
+    if (ex_style & WS_EX_TRANSPARENT)
+    {
+        FIXME("transparent window, fixing window rect\n");
+        data->window_rect.right = data->window_rect.left;
+        data->window_rect.bottom = data->window_rect.top;
+        data->whole_rect.right = data->whole_rect.left;
+        data->whole_rect.bottom = data->whole_rect.top;
+        data->client_rect.right = data->client_rect.left;
+        data->client_rect.bottom = data->client_rect.top;
+    }
+
+
     if (!IsRectEmpty(&valid_rects[0]))
     {
         macdrv_window window = data->cocoa_window;
@@ -2362,9 +2397,14 @@ void macdrv_window_frame_changed(HWND hwnd, const macd
     UINT flags = SWP_NOACTIVATE | SWP_NOZORDER;
     int width, height;
     BOOL being_dragged;
+    DWORD ex_style;
 
     if (!hwnd) return;
-    if (!(data = get_win_data(hwnd))) return;
+    //if (!(data = get_win_data(hwnd))) return;
+    if (!(data = get_win_data(hwnd))) {
+    	TRACE("no win_data\n");
+    	return;
+    }
     if (!data->on_screen || data->minimized)
     {
         release_win_data(data);
@@ -2383,6 +2423,15 @@ void macdrv_window_frame_changed(HWND hwnd, const macd
     macdrv_mac_to_window_rect(data, &rect);
     NtUserMapWindowPoints(0, parent, (POINT *)&rect, 2);
 
+       /* - from 11819-4 */
+    ex_style = NtUserCallHwndParam( hwnd, GWL_EXSTYLE, 12 );
+    if (ex_style & WS_EX_TRANSPARENT)
+    {
+        FIXME("transparent window, fixing window rect\n");
+        rect.right = rect.left;
+        rect.bottom = rect.top;
+    }
+
     width = rect.right - rect.left;
     height = rect.bottom - rect.top;
 
@@ -2424,7 +2473,8 @@ void macdrv_window_got_focus(HWND hwnd, const macdrv_e
  */
 void macdrv_window_got_focus(HWND hwnd, const macdrv_event *event)
 {
-    unsigned int style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    //unsigned int style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+	unsigned int style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
 
     if (!hwnd) return;
 
@@ -2548,7 +2598,8 @@ void macdrv_window_did_unminimize(HWND hwnd)
     if (!(data = get_win_data(hwnd))) return;
     if (!data->minimized) goto done;
 
-    style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    //style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
 
     data->minimized = FALSE;
     if ((style & (WS_MINIMIZE | WS_VISIBLE)) == (WS_MINIMIZE | WS_VISIBLE))
@@ -2601,7 +2652,8 @@ void macdrv_window_restore_requested(HWND hwnd, const 
 {
     if (event->window_restore_requested.keep_frame && hwnd)
     {
-        DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+        //DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+        DWORD style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
         struct macdrv_win_data *data;
 
         if ((style & WS_MAXIMIZE) && (style & WS_VISIBLE) && (data = get_win_data(hwnd)))
@@ -2630,7 +2682,8 @@ void macdrv_window_drag_begin(HWND hwnd, const macdrv_
  */
 void macdrv_window_drag_begin(HWND hwnd, const macdrv_event *event)
 {
-    DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    //DWORD style = NtUserGetWindowLongW(hwnd, GWL_STYLE);
+    DWORD style = NtUserCallHwndParam( hwnd, GWL_STYLE, 12 );
     struct macdrv_win_data *data;
     HANDLE drag_event = NULL;
     OBJECT_ATTRIBUTES attr;
@@ -2790,7 +2843,7 @@ BOOL query_resize_size(HWND hwnd, macdrv_query *query)
 
     if (send_message(hwnd, WM_SIZING, corner, (LPARAM)&rect))
     {
-        macdrv_window_to_mac_rect(data, NtUserGetWindowLongW(hwnd, GWL_STYLE), &rect,
+        macdrv_window_to_mac_rect(data, NtUserCallHwndParam(hwnd, GWL_STYLE, 12), &rect,
                                   &data->window_rect, &data->client_rect);
         query->resize_size.rect = cgrect_from_rect(rect);
         ret = TRUE;
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/fonts/Makefile.in /Users/sergey/src/crossover-2407/wine/fonts/Makefile.in
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/fonts/Makefile.in	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/fonts/Makefile.in	2025-02-18 20:04:25
@@ -1,4 +1,6 @@ SOURCES = \
 SOURCES = \
+	arial.sfd \
+	cour.sfd \
 	courier.sfd \
 	fixedsys.sfd \
 	fixedsys_jp.sfd \
@@ -10,5 +12,6 @@ SOURCES = \
 	system.sfd \
 	tahoma.sfd \
 	tahomabd.sfd \
+	times.sfd \
 	webdings.sfd \
 	wingding.sfd
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/include/Makefile.in /Users/sergey/src/crossover-2407/wine/include/Makefile.in
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/include/Makefile.in	2025-01-25 02:42:26
+++ /Users/sergey/src/crossover-2407/wine/include/Makefile.in	2025-02-16 13:36:20
@@ -240,6 +240,7 @@ SOURCES = \
 	directmanipulation.idl \
 	dispdib.h \
 	dispex.idl \
+	distversion.h \
 	dlgs.h \
 	dls1.h \
 	dls2.h \
diff -Nurpb /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/include/distversion.h /Users/sergey/src/crossover-2407/wine/include/distversion.h
--- /Volumes/Mojave/Users/sergey/src/Crossover-24.0.7/wine/include/distversion.h	1970-01-01 03:00:00
+++ /Users/sergey/src/crossover-2407/wine/include/distversion.h	2025-01-28 21:46:48
@@ -0,0 +1,13 @@
+/* ---------------------------------------------------------------
+*   distversion.c
+*
+* Copyright 2013, CodeWeavers, Inc.
+*
+* Information from DISTVERSION which needs to find
+* its way into the wine tree.
+* --------------------------------------------------------------- */
+
+#define WINDEBUG_WHAT_HAPPENED_MESSAGE "This can be caused by a problem in the program or a deficiency in Wine. You may want to check <a href=\"http://www.codeweavers.com/compatibility/\">http://www.codeweavers.com/compatibility/</a> for tips about running this application."
+
+#define WINDEBUG_USER_SUGGESTION_MESSAGE "If this problem is not present under Windows and has not been reported yet, you can save the detailed information to a file using the \"Save As\" button, then <a href=\"http://www.codeweavers.com/support/tickets/enter/\">file a bug report</a> and attach that file to the report."
+
