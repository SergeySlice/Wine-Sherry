diff --git a/LICENSE b/LICENSE
index 6dbf8c0..3f4841a 100644
--- a/LICENSE
+++ b/LICENSE
@@ -1,10 +1,15 @@
+All files unless stated otherwise (see exceptions below) are licensed
+under the following terms.
+
+-----------------------------------------------------------------------
+
 Copyright (c) 1993-2015 the Wine project authors (see the file AUTHORS
 for a complete list)
 
 Wine is free software; you can redistribute it and/or modify it under
 the terms of the GNU Lesser General Public License as published by the
 Free Software Foundation; either version 2.1 of the License, or (at
-your option) any later version. 
+your option) any later version.
 
 This program is distributed in the hope that it will be useful, but
 WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -15,3 +20,23 @@ A copy of the GNU Lesser General Public License is included in the
 Wine distribution in the file COPYING.LIB. If you did not receive this
 copy, write to the Free Software Foundation, Inc., 51 Franklin St,
 Fifth Floor, Boston, MA 02110-1301, USA.
+
+-----------------------------------------------------------------------
+
+Exceptions (for Wine Staging):
+
+The following files are shipped with Wine Staging, but are not linked to
+the rest of the project in any way. They are simply installed for
+end-user convenience and use a different license as explained below.
+
+    * fonts/arial.ttf and fonts/arial.sfd
+      The Liberation Sans font is licensed under the
+      LIBERATION FONT SOFTWARE LICENSE. See COPYING.arial.
+
+    * fonts/msyh.ttf and fonts/msyh.sfd
+      The WenQuanYi Micro Hei font is licensed under both the APACHE 2
+      license and GPLv3. See COPYING.msyh for GPLv3.
+
+    * fonts/cour.ttf and fonts/cour.sfd
+      The Courier Prime font is licensed under the OFLv1.1.
+      See COPYING.cour.
diff --git a/aclocal.m4 b/aclocal.m4
index 3d43721..adc6b04 100644
--- a/aclocal.m4
+++ b/aclocal.m4
@@ -617,6 +617,28 @@ $ac_dir/crosstest: $ac_dir/Makefile __builddeps__ dummy
         fi
 }
 
+wine_fn_config_resource ()
+{
+    ac_dir=$[1]
+    ac_name=$[2]
+    ac_flags=$[3]
+    ac_dll=$ac_name
+
+    case $ac_name in
+      *.*) ;;
+      *)   ac_dll=$ac_dll.dll ;;
+    esac
+
+    ac_clean=
+    test -n "$CROSSTARGET" && ac_clean=`expr $ac_dir/$ac_dll : "\\(.*\\)\\."`_crossres.`expr $ac_dll : ".*\\.\\(.*\\)"`
+    test -n "$DLLEXT" || ac_clean="$ac_dir/$ac_dll"
+
+    AS_VAR_IF([enable_tests],[no],[wine_fn_disabled_rules $ac_clean; return])
+
+    wine_fn_depend_rules
+    wine_fn_clean_rules $ac_clean
+}
+
 wine_fn_config_tool ()
 {
     ac_dir=$[1]
@@ -722,6 +744,15 @@ wine_fn_config_test $1 ac_name[]ac_suffix [$2]dnl
 m4_popdef([ac_suffix])dnl
 m4_popdef([ac_name])])
 
+dnl **** Create a test resource makefile from config.status ****
+dnl
+dnl Usage: WINE_CONFIG_RESOURCE(dir,flags)
+dnl
+AC_DEFUN([WINE_CONFIG_RESOURCE],[AC_REQUIRE([WINE_CONFIG_HELPERS])dnl
+m4_pushdef([ac_name],[m4_bpatsubst([$1],[.*/\([^/\]*\)$],[\1])])dnl
+wine_fn_config_resource $1 ac_name [$2]dnl
+m4_popdef([ac_name])])
+
 dnl **** Create a static lib makefile from config.status ****
 dnl
 dnl Usage: WINE_CONFIG_LIB(name,flags)
diff --git a/configure b/configure
index 17b5833..9cfe694 100755
--- a/configure
+++ b/configure
@@ -653,6 +653,8 @@ OSS4_CFLAGS
 ALSA_LIBS
 GSTREAMER_LIBS
 GSTREAMER_CFLAGS
+PULSEINCL
+PULSELIBS
 GETTEXTPO_LIBS
 Z_LIBS
 FREETYPE_LIBS
@@ -676,7 +678,6 @@ XSLT_LIBS
 XSLT_CFLAGS
 XML2_LIBS
 XML2_CFLAGS
-LIBPCAP
 X_EXTRA_LIBS
 X_LIBS
 X_PRE_LIBS
@@ -798,6 +799,7 @@ enable_win16
 enable_win64
 enable_tests
 enable_maintainer_mode
+enable_exagear_compat
 with_alsa
 with_capi
 with_cms
@@ -827,9 +829,11 @@ with_oss
 with_pcap
 with_png
 with_pthread
+with_pulse
 with_sane
 with_tiff
 with_v4l
+with_xattr
 with_xcomposite
 with_xcursor
 with_xinerama
@@ -843,6 +847,7 @@ with_xshm
 with_xslt
 with_xxf86vm
 with_zlib
+with_va
 with_wine_tools
 with_wine64
 enable_largefile
@@ -1050,6 +1055,7 @@ enable_explorerframe
 enable_ext_ms_win_gdi_devcaps_l1_1_0
 enable_faultrep
 enable_fltlib
+enable_fltmgr_sys
 enable_fntcache
 enable_fontsub
 enable_fusion
@@ -1184,6 +1190,9 @@ enable_ntdll
 enable_ntdsapi
 enable_ntoskrnl_exe
 enable_ntprint
+enable_win32
+enable_nvcuda
+enable_nvcuvid
 enable_objsel
 enable_odbc32
 enable_odbccp32
@@ -1288,6 +1297,7 @@ enable_windowscodecs
 enable_windowscodecsext
 enable_winealsa_drv
 enable_winecoreaudio_drv
+enable_wined3d_csmt
 enable_wined3d
 enable_winegstreamer
 enable_winejoystick_drv
@@ -1296,6 +1306,7 @@ enable_winemapi
 enable_winemp3_acm
 enable_wineoss_drv
 enable_wineps_drv
+enable_winepulse_drv
 enable_wineqtdecoder
 enable_winex11_drv
 enable_wing32
@@ -2105,6 +2116,8 @@ Optional Features:
   --disable-tests         do not build the regression tests
   --enable-maintainer-mode
                           enable maintainer-specific build rules
+  --enable-exagear-compat use workarounds for known problems in the Exagear
+                          emulator
   --disable-largefile     omit support for large files
 
 Optional Packages:
@@ -2139,9 +2152,11 @@ Optional Packages:
   --without-pcap          do not use the Packet Capture library
   --without-png           do not use PNG
   --without-pthread       do not use the pthread library
+  --without-pulse         do not use PulseAudio sound support
   --without-sane          do not use SANE (scanner support)
   --without-tiff          do not use TIFF
   --without-v4l           do not use v4l1 (v4l support)
+  --without-xattr         do not use xattr (security attributes support)
   --without-xcomposite    do not use the Xcomposite extension
   --without-xcursor       do not use the Xcursor extension
   --without-xinerama      do not use Xinerama (multi-monitor support)
@@ -2155,6 +2170,7 @@ Optional Packages:
   --without-xslt          do not use XSLT
   --without-xxf86vm       do not use XFree video mode extension
   --without-zlib          do not use Zlib (data compression)
+  --without-va            do not use VA (GPU video acceleration)
   --with-wine-tools=DIR   use Wine tools from directory DIR
   --with-wine64=DIR       use the 64-bit Wine in DIR for a Wow64 build
   --with-x                use the X Window System
@@ -3210,6 +3226,11 @@ if test "${enable_maintainer_mode+set}" = set; then :
   enableval=$enable_maintainer_mode;
 fi
 
+# Check whether --enable-exagear-compat was given.
+if test "${enable_exagear_compat+set}" = set; then :
+  enableval=$enable_exagear_compat;
+fi
+
 
 
 # Check whether --with-alsa was given.
@@ -3386,6 +3407,12 @@ if test "${with_pthread+set}" = set; then :
 fi
 
 
+# Check whether --with-pulse was given.
+if test "${with_pulse+set}" = set; then :
+  withval=$with_pulse;
+fi
+
+
 # Check whether --with-sane was given.
 if test "${with_sane+set}" = set; then :
   withval=$with_sane;
@@ -3404,6 +3431,12 @@ if test "${with_v4l+set}" = set; then :
 fi
 
 
+# Check whether --with-xattr was given.
+if test "${with_xattr+set}" = set; then :
+  withval=$with_xattr;
+fi
+
+
 # Check whether --with-xcomposite was given.
 if test "${with_xcomposite+set}" = set; then :
   withval=$with_xcomposite; if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi
@@ -3482,6 +3515,12 @@ if test "${with_zlib+set}" = set; then :
 fi
 
 
+# Check whether --with-va was given.
+if test "${with_va+set}" = set; then :
+  withval=$with_va; if test "x$withval" = "xno"; then ac_cv_header_va_va_x11_h=no; fi
+fi
+
+
 
 # Check whether --with-wine-tools was given.
 if test "${with_wine_tools+set}" = set; then :
@@ -4968,6 +5007,12 @@ esac
 
 enable_win16=${enable_win16:-no}
 enable_win64=${enable_win64:-no}
+if test "x$enable_win64" != "xyes"
+then
+  enable_win32="yes"
+else
+  enable_win32="no"
+fi
 
 enable_winetest=${enable_winetest:-$enable_tests}
 
@@ -6007,6 +6052,14 @@ esac
 fi
 
 
+if test "x$enable_exagear_compat" = "xyes"
+then
+
+$as_echo "#define EXAGEAR_COMPAT 1" >>confdefs.h
+
+fi
+
+
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for i386_set_ldt in -li386" >&5
 $as_echo_n "checking for i386_set_ldt in -li386... " >&6; }
 if ${ac_cv_lib_i386_i386_set_ldt+:} false; then :
@@ -6127,7 +6180,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6173,7 +6226,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6197,7 +6250,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6242,7 +6295,7 @@ else
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -6266,7 +6319,7 @@ rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
     We can't simply define LARGE_OFF_T to be 9223372036854775807,
     since some C++ compilers masquerading as C compilers
     incorrectly reject 9223372036854775807.  */
-#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + (((off_t) 1 << 31) << 31))
+#define LARGE_OFF_T (((off_t) 1 << 62) - 1 + ((off_t) 1 << 62))
   int off_t_is_large[(LARGE_OFF_T % 2147483629 == 721
 		       && LARGE_OFF_T % 2147483647 == 1)
 		      ? 1 : -1];
@@ -7049,6 +7102,64 @@ fi
 done
 
 
+if test "x$with_xattr" != "xno"
+then
+    for ac_header in attr/xattr.h sys/extattr.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ HAVE_XATTR=1
+fi
+
+done
+
+    for ac_header in sys/xattr.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "sys/xattr.h" "ac_cv_header_sys_xattr_h" "$ac_includes_default"
+if test "x$ac_cv_header_sys_xattr_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_SYS_XATTR_H 1
+_ACEOF
+ HAVE_XATTR=1
+        cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <sys/xattr.h>
+int
+main ()
+{
+getxattr("", "", "", 0, 0, 0);
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+$as_echo "#define XATTR_ADDITIONAL_OPTIONS 1" >>confdefs.h
+
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+
+done
+
+fi
+if test "x$with_xattr" = "xyes"
+then
+    if test "x$HAVE_XATTR" = "x"; then :
+  case "x$with_xattr" in
+  xno) ;;
+  *)   as_fn_error $? "xattr ${notice_platform}development files \
+not found. Wine will be built without extended attribute support, which probably isn't what you \
+want. You will need to install ${notice_platform}development packages of libattr at the very least.
+Use the --without-xattr option if you really want this." "$LINENO" 5 ;;
+esac
+fi
+fi
+
 
 dlldir="\${libdir}/wine"
 
@@ -7638,6 +7749,30 @@ $ac_dir/crosstest: $ac_dir/Makefile __builddeps__ dummy
         fi
 }
 
+wine_fn_config_resource ()
+{
+    ac_dir=$1
+    ac_name=$2
+    ac_flags=$3
+    ac_dll=$ac_name
+
+    case $ac_name in
+      *.*) ;;
+      *)   ac_dll=$ac_dll.dll ;;
+    esac
+
+    ac_clean=
+    test -n "$CROSSTARGET" && ac_clean=`expr $ac_dir/$ac_dll : "\\(.*\\)\\."`_crossres.`expr $ac_dll : ".*\\.\\(.*\\)"`
+    test -n "$DLLEXT" || ac_clean="$ac_dir/$ac_dll"
+
+    if test "x$enable_tests" = xno; then :
+  wine_fn_disabled_rules $ac_clean; return
+fi
+
+    wine_fn_depend_rules
+    wine_fn_clean_rules $ac_clean
+}
+
 wine_fn_config_tool ()
 {
     ac_dir=$1
@@ -8418,7 +8553,7 @@ eval ac_res=\$$as_ac_var
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`"
+  LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`:\$(DESTDIR)\$(libdir)"
                        LDRPATH_LOCAL="-Wl,--rpath,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"
 else
   as_ac_var=`$as_echo "ac_cv_cflags_-fPIC -Wl,-R,\\$ORIGIN/../lib" | $as_tr_sh`
@@ -8446,7 +8581,7 @@ eval ac_res=\$$as_ac_var
 	       { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_res" >&5
 $as_echo "$ac_res" >&6; }
 if eval test \"x\$"$as_ac_var"\" = x"yes"; then :
-  LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`"
+  LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`:\$(DESTDIR)\$(libdir)"
                             LDRPATH_LOCAL="-Wl,-R,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"
 fi
 fi
@@ -10634,6 +10769,196 @@ This is an error since --with-opengl was requested." "$LINENO" 5 ;;
 esac
 fi
 
+        for ac_header in va/va_x11.h va/va_drm.h
+do :
+  as_ac_Header=`$as_echo "ac_cv_header_$ac_header" | $as_tr_sh`
+ac_fn_c_check_header_mongrel "$LINENO" "$ac_header" "$as_ac_Header" "$ac_includes_default"
+if eval test \"x\$"$as_ac_Header"\" = x"yes"; then :
+  cat >>confdefs.h <<_ACEOF
+#define `$as_echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+    if test "$ac_cv_header_va_va_x11_h" = "yes" -a "$ac_cv_header_va_va_drm_h" = "yes"
+    then
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lva" >&5
+$as_echo_n "checking for -lva... " >&6; }
+if ${ac_cv_lib_soname_va+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lva $X_LIBS $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vaQuerySurfaceAttributes ();
+int
+main ()
+{
+return vaQuerySurfaceAttributes ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_va=`$ac_cv_path_LDD conftest.exe | grep "va" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_va=`otool -L conftest$ac_exeext | grep "libva\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libva\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_va=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libva\\.$LIBEXT" | sed -e "s/^.*\\[\\(libva\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_va:+false} :; then :
+  ac_cv_lib_soname_va=`$LDD conftest$ac_exeext | grep "libva\\.$LIBEXT" | sed -e "s/^.*\(libva\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_va:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_va" >&5
+$as_echo "$ac_cv_lib_soname_va" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBVA "$ac_cv_lib_soname_va"
+_ACEOF
+
+
+fi
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lva-x11" >&5
+$as_echo_n "checking for -lva-x11... " >&6; }
+if ${ac_cv_lib_soname_va_x11+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lva-x11 $X_LIBS -lva $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vaGetDisplay ();
+int
+main ()
+{
+return vaGetDisplay ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_va_x11=`$ac_cv_path_LDD conftest.exe | grep "va-x11" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_va_x11=`otool -L conftest$ac_exeext | grep "libva-x11\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libva-x11\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_va_x11=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libva-x11\\.$LIBEXT" | sed -e "s/^.*\\[\\(libva-x11\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_va_x11:+false} :; then :
+  ac_cv_lib_soname_va_x11=`$LDD conftest$ac_exeext | grep "libva-x11\\.$LIBEXT" | sed -e "s/^.*\(libva-x11\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_va_x11:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_va_x11" >&5
+$as_echo "$ac_cv_lib_soname_va_x11" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBVA_X11 "$ac_cv_lib_soname_va_x11"
+_ACEOF
+
+
+fi
+        { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lva-drm" >&5
+$as_echo_n "checking for -lva-drm... " >&6; }
+if ${ac_cv_lib_soname_va_drm+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-lva-drm $X_LIBS -lva $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char vaGetDisplayDRM ();
+int
+main ()
+{
+return vaGetDisplayDRM ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_va_drm=`$ac_cv_path_LDD conftest.exe | grep "va-drm" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_va_drm=`otool -L conftest$ac_exeext | grep "libva-drm\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libva-drm\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_va_drm=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libva-drm\\.$LIBEXT" | sed -e "s/^.*\\[\\(libva-drm\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_va_drm:+false} :; then :
+  ac_cv_lib_soname_va_drm=`$LDD conftest$ac_exeext | grep "libva-drm\\.$LIBEXT" | sed -e "s/^.*\(libva-drm\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_va_drm:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_va_drm" >&5
+$as_echo "$ac_cv_lib_soname_va_drm" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBVA_DRM "$ac_cv_lib_soname_va_drm"
+_ACEOF
+
+
+fi
+        if test "x$ac_cv_lib_soname_va" != "x" -a "x$ac_cv_lib_soname_va_x11" != "x" -a "x$ac_cv_lib_soname_va_drm" != "x"
+        then
+
+$as_echo "#define HAVE_VAAPI 1" >>confdefs.h
+
+        fi
+    fi
+    if test "x$ac_cv_lib_soname_va" = "x" -o "x$ac_cv_lib_soname_va_x11" = "x" -o "x$ac_cv_lib_soname_va_drm" = "x"; then :
+  case "x$with_va" in
+  x)   as_fn_append wine_notices "|libva ${notice_platform}development files not found, GPU video acceleration won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libva ${notice_platform}development files not found, GPU video acceleration won't be supported.
+This is an error since --with-va was requested." "$LINENO" 5 ;;
+esac
+fi
+
     CPPFLAGS="$ac_save_CPPFLAGS"
 else
     X_CFLAGS=""
@@ -10708,14 +11033,14 @@ test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes && enable_opencl=${enable_op
 
 if test "$ac_cv_header_pcap_pcap_h" = "yes"
 then
-    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pcap_create in -lpcap" >&5
-$as_echo_n "checking for pcap_create in -lpcap... " >&6; }
-if ${ac_cv_lib_pcap_pcap_create+:} false; then :
+    { $as_echo "$as_me:${as_lineno-$LINENO}: checking for -lpcap" >&5
+$as_echo_n "checking for -lpcap... " >&6; }
+if ${ac_cv_lib_soname_pcap+:} false; then :
   $as_echo_n "(cached) " >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
+  ac_check_soname_save_LIBS=$LIBS
 LIBS="-lpcap  $LIBS"
-cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
 /* end confdefs.h.  */
 
 /* Override any GCC internal prototype to avoid an error.
@@ -10734,23 +11059,35 @@ return pcap_create ();
 }
 _ACEOF
 if ac_fn_c_try_link "$LINENO"; then :
-  ac_cv_lib_pcap_pcap_create=yes
-else
-  ac_cv_lib_pcap_pcap_create=no
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_pcap=`$ac_cv_path_LDD conftest.exe | grep "pcap" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_pcap=`otool -L conftest$ac_exeext | grep "libpcap\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libpcap\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_pcap=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libpcap\\.$LIBEXT" | sed -e "s/^.*\\[\\(libpcap\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_pcap:+false} :; then :
+  ac_cv_lib_soname_pcap=`$LDD conftest$ac_exeext | grep "libpcap\\.$LIBEXT" | sed -e "s/^.*\(libpcap\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
 fi
 rm -f core conftest.err conftest.$ac_objext \
     conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+  LIBS=$ac_check_soname_save_LIBS
 fi
-{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pcap_pcap_create" >&5
-$as_echo "$ac_cv_lib_pcap_pcap_create" >&6; }
-if test "x$ac_cv_lib_pcap_pcap_create" = xyes; then :
-  LIBPCAP="-lpcap"
+if ${ac_cv_lib_soname_pcap:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_pcap" >&5
+$as_echo "$ac_cv_lib_soname_pcap" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBPCAP "$ac_cv_lib_soname_pcap"
+_ACEOF
 
-fi
 
 fi
-if test "x$ac_cv_lib_pcap_pcap_create" != xyes; then :
+fi
+if test "x$ac_cv_lib_soname_pcap" = "x"; then :
   case "x$with_pcap" in
   x)   as_fn_append wine_notices "|pcap ${notice_platform}development files not found, wpcap won't be supported." ;;
   xno) ;;
@@ -10758,7 +11095,7 @@ if test "x$ac_cv_lib_pcap_pcap_create" != xyes; then :
 This is an error since --with-pcap was requested." "$LINENO" 5 ;;
 esac
 fi
-test "x$ac_cv_lib_pcap_pcap_create" != xyes && enable_wpcap=${enable_wpcap:-no}
+test "x$ac_cv_lib_soname_pcap" = "x" && enable_wpcap=${enable_wpcap:-no}
 
 
 if test "x$with_xml" != "xno"
@@ -12373,6 +12710,87 @@ esac
 fi
 fi
 
+PULSELIBS=""
+
+PULSEINCL=""
+
+if test "x$with_pulse" != "xno";
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false";
+    then
+        ac_pulse_libs="`$PKG_CONFIG --libs libpulse 2>/dev/null`"
+        ac_pulse_cflags="`$PKG_CONFIG --cflags-only-I libpulse 2>/dev/null`"
+
+        CPPFLAGS="$CPPFLAGS $ac_pulse_cflags"
+        for ac_header in pulse/pulseaudio.h
+do :
+  ac_fn_c_check_header_mongrel "$LINENO" "pulse/pulseaudio.h" "ac_cv_header_pulse_pulseaudio_h" "$ac_includes_default"
+if test "x$ac_cv_header_pulse_pulseaudio_h" = xyes; then :
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_PULSE_PULSEAUDIO_H 1
+_ACEOF
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking for pa_stream_is_corked in -lpulse" >&5
+$as_echo_n "checking for pa_stream_is_corked in -lpulse... " >&6; }
+if ${ac_cv_lib_pulse_pa_stream_is_corked+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lpulse $ac_pulse_libs $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char pa_stream_is_corked ();
+int
+main ()
+{
+return pa_stream_is_corked ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_lib_pulse_pa_stream_is_corked=yes
+else
+  ac_cv_lib_pulse_pa_stream_is_corked=no
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_pulse_pa_stream_is_corked" >&5
+$as_echo "$ac_cv_lib_pulse_pa_stream_is_corked" >&6; }
+if test "x$ac_cv_lib_pulse_pa_stream_is_corked" = xyes; then :
+
+$as_echo "#define HAVE_PULSEAUDIO 1" >>confdefs.h
+
+                 PULSELIBS="$ac_pulse_libs"
+                 PULSEINCL="$ac_pulse_cflags"
+fi
+
+
+fi
+
+done
+
+    fi
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+if test "$ac_cv_lib_pulse_pa_stream_is_corked" != "yes"; then :
+  case "x$with_pulse" in
+  x)   as_fn_append wine_warnings "|libpulse ${notice_platform}development files not found or too old, Pulse won't be supported." ;;
+  xno) ;;
+  *)   as_fn_error $? "libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.
+This is an error since --with-pulse was requested." "$LINENO" 5 ;;
+esac
+fi
+
 if test "x$with_gstreamer" != "xno"
 then
     if ${GSTREAMER_CFLAGS:+false} :; then :
@@ -13302,6 +13720,60 @@ This is an error since --with-tiff was requested." "$LINENO" 5 ;;
 esac
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for -ltxc_dxtn" >&5
+$as_echo_n "checking for -ltxc_dxtn... " >&6; }
+if ${ac_cv_lib_soname_txc_dxtn+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_check_soname_save_LIBS=$LIBS
+LIBS="-ltxc_dxtn  $LIBS"
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+char tx_compress_dxtn ();
+int
+main ()
+{
+return tx_compress_dxtn ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  case "$LIBEXT" in
+    dll) ac_cv_lib_soname_txc_dxtn=`$ac_cv_path_LDD conftest.exe | grep "txc_dxtn" | sed -e "s/dll.*/dll/"';2,$d'` ;;
+    dylib) ac_cv_lib_soname_txc_dxtn=`otool -L conftest$ac_exeext | grep "libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.[0-9A-Za-z.]*dylib" | sed -e "s/^.*\/\(libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\.[0-9A-Za-z.]*dylib\).*$/\1/"';2,$d'` ;;
+    *) ac_cv_lib_soname_txc_dxtn=`$READELF -d conftest$ac_exeext | grep "NEEDED.*libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\\[\\(libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.$LIBEXT[^	 ]*\\)\\].*$/\1/"';2,$d'`
+       if ${ac_cv_lib_soname_txc_dxtn:+false} :; then :
+  ac_cv_lib_soname_txc_dxtn=`$LDD conftest$ac_exeext | grep "libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\\.$LIBEXT" | sed -e "s/^.*\(libtxc_dxtn\\(_s2tc\\)\\{0,1\\}\.$LIBEXT[^	 ]*\).*$/\1/"';2,$d'`
+fi ;;
+  esac
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+  LIBS=$ac_check_soname_save_LIBS
+fi
+if ${ac_cv_lib_soname_txc_dxtn:+false} :; then :
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: not found" >&5
+$as_echo "not found" >&6; }
+
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_soname_txc_dxtn" >&5
+$as_echo "$ac_cv_lib_soname_txc_dxtn" >&6; }
+
+cat >>confdefs.h <<_ACEOF
+#define SONAME_LIBTXC_DXTN "$ac_cv_lib_soname_txc_dxtn"
+_ACEOF
+
+
+fi
+
 if test "x$with_mpg123" != "xno"
 then
     if ${MPG123_CFLAGS:+false} :; then :
@@ -13684,12 +14156,13 @@ fi
 
 test -n "$ALSA_LIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
 test -n "$COREAUDIO_LIBS" || enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+test -n "$PULSELIBS" || enable_winepulse_drv=${enable_winepulse_drv:-no}
 test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes || enable_wineoss_drv=${enable_wineoss_drv:-no}
 test "$ac_cv_header_linux_joystick_h" = "yes" -o "$ac_cv_header_IOKit_hid_IOHIDLib_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
-if test "x$ALSA_LIBS$COREAUDIO_LIBS" = "x" -a \
+if test "x$ALSA_LIBS$COREAUDIO_LIBS$PULSELIBS" = "x" -a \
         "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes -a \
-        "x$with_alsa$with_coreaudio$with_oss" != xnonono
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
 then
     as_fn_append wine_warnings "|No sound system was found. Windows applications will be silent."
 fi
@@ -16554,6 +17027,138 @@ $as_echo "#define HAVE_ISNAN 1" >>confdefs.h
 
 fi
 
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for coshl" >&5
+$as_echo_n "checking for coshl... " >&6; }
+if ${ac_cv_have_coshl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <math.h>
+int
+main ()
+{
+float f = 0.0; return coshl(f)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_have_coshl="yes"
+else
+  ac_cv_have_coshl="no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_coshl" >&5
+$as_echo "$ac_cv_have_coshl" >&6; }
+if test "$ac_cv_have_coshl" = "yes"
+then
+
+$as_echo "#define HAVE_COSHL 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for sinhl" >&5
+$as_echo_n "checking for sinhl... " >&6; }
+if ${ac_cv_have_sinhl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <math.h>
+int
+main ()
+{
+float f = 0.0; return sinhl(f)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_have_sinhl="yes"
+else
+  ac_cv_have_sinhl="no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_sinhl" >&5
+$as_echo "$ac_cv_have_sinhl" >&6; }
+if test "$ac_cv_have_sinhl" = "yes"
+then
+
+$as_echo "#define HAVE_SINHL 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for expl" >&5
+$as_echo_n "checking for expl... " >&6; }
+if ${ac_cv_have_expl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <math.h>
+int
+main ()
+{
+float f = 0.0; return expl(f)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_have_expl="yes"
+else
+  ac_cv_have_expl="no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_expl" >&5
+$as_echo "$ac_cv_have_expl" >&6; }
+if test "$ac_cv_have_expl" = "yes"
+then
+
+$as_echo "#define HAVE_EXPL 1" >>confdefs.h
+
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for powl" >&5
+$as_echo_n "checking for powl... " >&6; }
+if ${ac_cv_have_powl+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+#include <math.h>
+int
+main ()
+{
+float f = 0.0; return powl(f, f)
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"; then :
+  ac_cv_have_powl="yes"
+else
+  ac_cv_have_powl="no"
+fi
+rm -f core conftest.err conftest.$ac_objext \
+    conftest$ac_exeext conftest.$ac_ext
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_have_powl" >&5
+$as_echo "$ac_cv_have_powl" >&6; }
+if test "$ac_cv_have_powl" = "yes"
+then
+
+$as_echo "#define HAVE_POWL 1" >>confdefs.h
+
+fi
+
 for ac_func in \
 	cbrt \
 	cbrtf \
@@ -17240,6 +17845,7 @@ wine_fn_config_dll dxgi enable_dxgi implib
 wine_fn_config_test dlls/dxgi/tests dxgi_test
 wine_fn_config_lib dxguid
 wine_fn_config_dll dxva2 enable_dxva2
+wine_fn_config_test dlls/dxva2/tests dxva2_test
 wine_fn_config_dll evr enable_evr
 wine_fn_config_dll explorerframe enable_explorerframe clean
 wine_fn_config_test dlls/explorerframe/tests explorerframe_test
@@ -17247,6 +17853,7 @@ wine_fn_config_dll ext-ms-win-gdi-devcaps-l1-1-0 enable_ext_ms_win_gdi_devcaps_l
 wine_fn_config_dll faultrep enable_faultrep implib
 wine_fn_config_test dlls/faultrep/tests faultrep_test
 wine_fn_config_dll fltlib enable_fltlib
+wine_fn_config_dll fltmgr.sys enable_fltmgr_sys
 wine_fn_config_dll fntcache enable_fntcache
 wine_fn_config_dll fontsub enable_fontsub
 wine_fn_config_dll fusion enable_fusion
@@ -17440,8 +18047,18 @@ wine_fn_config_test dlls/ntdll/tests ntdll_test
 wine_fn_config_dll ntdsapi enable_ntdsapi implib
 wine_fn_config_test dlls/ntdsapi/tests ntdsapi_test
 wine_fn_config_dll ntoskrnl.exe enable_ntoskrnl_exe implib
+wine_fn_config_test dlls/ntoskrnl.exe/tests ntoskrnl.exe_test
+wine_fn_config_resource dlls/ntoskrnl.exe/tests/driver.sys driver.sys
 wine_fn_config_dll ntprint enable_ntprint
 wine_fn_config_test dlls/ntprint/tests ntprint_test
+wine_fn_config_dll nvapi enable_win32
+wine_fn_config_test dlls/nvapi/tests nvapi_test
+wine_fn_config_dll nvapi64 enable_win64
+wine_fn_config_dll nvcuda enable_nvcuda
+wine_fn_config_test dlls/nvcuda/tests nvcuda_test
+wine_fn_config_dll nvcuvid enable_nvcuvid
+wine_fn_config_dll nvencodeapi enable_win32
+wine_fn_config_dll nvencodeapi64 enable_win64
 wine_fn_config_dll objsel enable_objsel clean
 wine_fn_config_dll odbc32 enable_odbc32 implib
 wine_fn_config_dll odbccp32 enable_odbccp32 implib
@@ -17593,7 +18210,8 @@ wine_fn_config_dll uxtheme enable_uxtheme implib
 wine_fn_config_test dlls/uxtheme/tests uxtheme_test
 wine_fn_config_dll vbscript enable_vbscript clean
 wine_fn_config_test dlls/vbscript/tests vbscript_test clean
-wine_fn_config_dll vcomp enable_vcomp
+wine_fn_config_dll vcomp enable_vcomp implib
+wine_fn_config_test dlls/vcomp/tests vcomp_test
 wine_fn_config_dll vcomp100 enable_vcomp100
 wine_fn_config_dll vcomp90 enable_vcomp90
 wine_fn_config_dll vdhcp.vxd enable_win16
@@ -17626,9 +18244,10 @@ wine_fn_config_dll windowscodecs enable_windowscodecs clean,implib
 wine_fn_config_test dlls/windowscodecs/tests windowscodecs_test
 wine_fn_config_dll windowscodecsext enable_windowscodecsext implib
 wine_fn_config_test dlls/windowscodecsext/tests windowscodecsext_test
-wine_fn_config_dll winealsa.drv enable_winealsa_drv
+wine_fn_config_dll winealsa.drv enable_winealsa_drv implib
 wine_fn_config_dll winecoreaudio.drv enable_winecoreaudio_drv
 wine_fn_config_lib winecrt0
+wine_fn_config_dll wined3d-csmt enable_wined3d_csmt
 wine_fn_config_dll wined3d enable_wined3d implib
 wine_fn_config_dll winegstreamer enable_winegstreamer
 wine_fn_config_dll winejoystick.drv enable_winejoystick_drv
@@ -17638,6 +18257,7 @@ wine_fn_config_dll winemp3.acm enable_winemp3_acm
 wine_fn_config_dll wineoss.drv enable_wineoss_drv
 wine_fn_config_dll wineps.drv enable_wineps_drv clean,po
 wine_fn_config_dll wineps16.drv16 enable_win16
+wine_fn_config_dll winepulse.drv enable_winepulse_drv
 wine_fn_config_dll wineqtdecoder enable_wineqtdecoder
 wine_fn_config_dll winex11.drv enable_winex11_drv
 wine_fn_config_dll wing.dll16 enable_win16
diff --git a/configure.ac b/configure.ac
index 688ab26..25d44fe 100644
--- a/configure.ac
+++ b/configure.ac
@@ -32,6 +32,7 @@ AC_ARG_ENABLE(win16, AS_HELP_STRING([--disable-win16],[do not include Win16 supp
 AC_ARG_ENABLE(win64, AS_HELP_STRING([--enable-win64],[build a Win64 emulator on AMD64 (won't run Win32 binaries)]))
 AC_ARG_ENABLE(tests, AS_HELP_STRING([--disable-tests],[do not build the regression tests]))
 AC_ARG_ENABLE(maintainer-mode, AS_HELP_STRING([--enable-maintainer-mode],[enable maintainer-specific build rules]))
+AC_ARG_ENABLE(exagear-compat, AS_HELP_STRING([--enable-exagear-compat],[use workarounds for known problems in the Exagear emulator]))
 
 AC_ARG_WITH(alsa,      AS_HELP_STRING([--without-alsa],[do not use the Alsa sound support]),
             [if test "x$withval" = "xno"; then ac_cv_header_sys_asoundlib_h=no; ac_cv_header_alsa_asoundlib_h=no; fi])
@@ -72,9 +73,11 @@ AC_ARG_WITH(pcap,      AS_HELP_STRING([--without-pcap],[do not use the Packet Ca
 AC_ARG_WITH(png,       AS_HELP_STRING([--without-png],[do not use PNG]))
 AC_ARG_WITH(pthread,   AS_HELP_STRING([--without-pthread],[do not use the pthread library]),
             [if test "x$withval" = "xno"; then ac_cv_header_pthread_h=no; fi])
+AC_ARG_WITH(pulse,     AC_HELP_STRING([--without-pulse],[do not use PulseAudio sound support]))
 AC_ARG_WITH(sane,      AS_HELP_STRING([--without-sane],[do not use SANE (scanner support)]))
 AC_ARG_WITH(tiff,      AS_HELP_STRING([--without-tiff],[do not use TIFF]))
 AC_ARG_WITH(v4l,       AS_HELP_STRING([--without-v4l],[do not use v4l1 (v4l support)]))
+AC_ARG_WITH(xattr,     AS_HELP_STRING([--without-xattr],[do not use xattr (security attributes support)]))
 AC_ARG_WITH(xcomposite,AS_HELP_STRING([--without-xcomposite],[do not use the Xcomposite extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xcomposite_h=no; fi])
 AC_ARG_WITH(xcursor,   AS_HELP_STRING([--without-xcursor],[do not use the Xcursor extension]),
@@ -99,6 +102,8 @@ AC_ARG_WITH(xxf86vm,   AS_HELP_STRING([--without-xxf86vm],[do not use XFree vide
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_xf86vmode_h=no; ac_cv_header_X11_extensions_xf86vmproto_h=no; fi])
 AC_ARG_WITH(zlib,      AS_HELP_STRING([--without-zlib],[do not use Zlib (data compression)]),
             [if test "x$withval" = "xno"; then ac_cv_header_zlib_h=no; fi])
+AC_ARG_WITH(va,        AS_HELP_STRING([--without-va],[do not use VA (GPU video acceleration)]),
+            [if test "x$withval" = "xno"; then ac_cv_header_va_va_x11_h=no; fi])
 
 AC_ARG_WITH(wine-tools,AS_HELP_STRING([--with-wine-tools=DIR],[use Wine tools from directory DIR]))
 AC_ARG_WITH(wine64,    AS_HELP_STRING([--with-wine64=DIR],[use the 64-bit Wine in DIR for a Wow64 build]))
@@ -190,6 +195,12 @@ esac
 dnl enable_win16 defaults to yes on x86, to no on other CPUs
 enable_win16=${enable_win16:-no}
 enable_win64=${enable_win64:-no}
+if test "x$enable_win64" != "xyes"
+then
+  enable_win32="yes"
+else
+  enable_win32="no"
+fi
 
 dnl Disable winetest too if tests are disabled
 enable_winetest=${enable_winetest:-$enable_tests}
@@ -369,6 +380,13 @@ fi
 WINE_WARNING_WITH(gettext,[test "$MSGFMT" = false],
                   [gettext tools not found (or too old), translations won't be built.])
 
+dnl **** Enable Exagear workarounds ****
+
+if test "x$enable_exagear_compat" = "xyes"
+then
+  AC_DEFINE(EXAGEAR_COMPAT, 1, [Define if you want to enable Exagear emulator workarounds])
+fi
+
 dnl **** Check for some libraries ****
 
 dnl Check for -li386 for NetBSD and OpenBSD
@@ -669,6 +687,20 @@ AC_CHECK_HEADERS([libprocstat.h],,,
 #include <sys/socket.h>
 #endif])
 
+if test "x$with_xattr" != "xno"
+then
+    AC_CHECK_HEADERS(attr/xattr.h sys/extattr.h, [HAVE_XATTR=1])
+    AC_CHECK_HEADERS(sys/xattr.h, [HAVE_XATTR=1]
+        [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/xattr.h>]], [[getxattr("", "", "", 0, 0, 0);]])],
+            [AC_DEFINE(XATTR_ADDITIONAL_OPTIONS, 1, [Define if xattr functions take additional arguments (Mac OS X)])])])
+fi
+if test "x$with_xattr" = "xyes"
+then
+    WINE_ERROR_WITH(xattr,[test "x$HAVE_XATTR" = "x"],[xattr ${notice_platform}development files \
+not found. Wine will be built without extended attribute support, which probably isn't what you \
+want. You will need to install ${notice_platform}development packages of libattr at the very least.])
+fi
+
 dnl **** Check for working dll ****
 
 AC_SUBST(dlldir,"\${libdir}/wine")
@@ -969,10 +1001,10 @@ wine-installed: main.o
                       [LDEXECFLAGS="-Wl,--export-dynamic"])
 
       WINE_TRY_CFLAGS([-fPIC -Wl,--rpath,\$ORIGIN/../lib],
-                      [LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`"
+                      [LDRPATH_INSTALL="-Wl,--rpath,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`:\$(DESTDIR)\$(libdir)"
                        LDRPATH_LOCAL="-Wl,--rpath,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"],
           [WINE_TRY_CFLAGS([-fPIC -Wl,-R,\$ORIGIN/../lib],
-                           [LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`"
+                           [LDRPATH_INSTALL="-Wl,-R,\\\$\$ORIGIN/\`\$(MAKEDEP) -R \$(bindir) \$(libdir)\`:\$(DESTDIR)\$(libdir)"
                             LDRPATH_LOCAL="-Wl,-R,\\\$\$ORIGIN/\$(top_builddir)/libs/wine"])])
 
       WINE_TRY_CFLAGS([-Wl,--enable-new-dtags],
@@ -1262,6 +1294,21 @@ This probably prevents linking to OpenGL. Try deleting the file and restarting c
     WINE_WARNING_WITH(opengl,[test -n "$opengl_msg"],[$opengl_msg
 OpenGL and Direct3D won't be supported.])
 
+    dnl **** Check for libva ****
+    AC_CHECK_HEADERS([va/va_x11.h va/va_drm.h])
+    if test "$ac_cv_header_va_va_x11_h" = "yes" -a "$ac_cv_header_va_va_drm_h" = "yes"
+    then
+        WINE_CHECK_SONAME(va,vaQuerySurfaceAttributes,,,[$X_LIBS])
+        WINE_CHECK_SONAME(va-x11,vaGetDisplay,,,[$X_LIBS -lva])
+        WINE_CHECK_SONAME(va-drm,vaGetDisplayDRM,,,[$X_LIBS -lva])
+        if test "x$ac_cv_lib_soname_va" != "x" -a "x$ac_cv_lib_soname_va_x11" != "x" -a "x$ac_cv_lib_soname_va_drm" != "x"
+        then
+            AC_DEFINE(HAVE_VAAPI, 1, [Define if you have the libva development files])
+        fi
+    fi
+    WINE_NOTICE_WITH(va,[test "x$ac_cv_lib_soname_va" = "x" -o "x$ac_cv_lib_soname_va_x11" = "x" -o "x$ac_cv_lib_soname_va_drm" = "x"],
+                     [libva ${notice_platform}development files not found, GPU video acceleration won't be supported.])
+
     CPPFLAGS="$ac_save_CPPFLAGS"
 else
     X_CFLAGS=""
@@ -1286,11 +1333,11 @@ test "x$ac_cv_lib_OpenCL_clGetPlatformInfo" != xyes && enable_opencl=${enable_op
 dnl **** Check for libpcap ****
 if test "$ac_cv_header_pcap_pcap_h" = "yes"
 then
-    AC_CHECK_LIB(pcap,pcap_create,[AC_SUBST(LIBPCAP,["-lpcap"])])
+    WINE_CHECK_SONAME(pcap,pcap_create,,,)
 fi
-WINE_NOTICE_WITH(pcap,[test "x$ac_cv_lib_pcap_pcap_create" != xyes],
+WINE_NOTICE_WITH(pcap,[test "x$ac_cv_lib_soname_pcap" = "x"],
                  [pcap ${notice_platform}development files not found, wpcap won't be supported.])
-test "x$ac_cv_lib_pcap_pcap_create" != xyes && enable_wpcap=${enable_wpcap:-no}
+test "x$ac_cv_lib_soname_pcap" = "x" && enable_wpcap=${enable_wpcap:-no}
 
 dnl **** Check for libxml2 ****
 
@@ -1549,6 +1596,30 @@ then
           [GetText ${notice_platform}development files not found (or too old), po files can't be rebuilt.])
 fi
 
+dnl **** Check for PulseAudio ****
+AC_SUBST(PULSELIBS,"")
+AC_SUBST(PULSEINCL,"")
+if test "x$with_pulse" != "xno";
+then
+    ac_save_CPPFLAGS="$CPPFLAGS"
+    if test "$PKG_CONFIG" != "false";
+    then
+        ac_pulse_libs="`$PKG_CONFIG --libs libpulse 2>/dev/null`"
+        ac_pulse_cflags="`$PKG_CONFIG --cflags-only-I libpulse 2>/dev/null`"
+
+        CPPFLAGS="$CPPFLAGS $ac_pulse_cflags"
+        AC_CHECK_HEADERS(pulse/pulseaudio.h,
+            [AC_CHECK_LIB(pulse, pa_stream_is_corked,
+                [AC_DEFINE(HAVE_PULSEAUDIO, 1, [Define if you have pulseaudio])
+                 PULSELIBS="$ac_pulse_libs"
+                 PULSEINCL="$ac_pulse_cflags"],,$ac_pulse_libs)
+        ])
+    fi
+    CPPFLAGS="$ac_save_CPPFLAGS"
+fi
+WINE_WARNING_WITH(pulse, [test "$ac_cv_lib_pulse_pa_stream_is_corked" != "yes"],
+        [libpulse ${notice_platform}development files not found or too old, Pulse won't be supported.])
+
 dnl **** Check for gstreamer ****
 if test "x$with_gstreamer" != "xno"
 then
@@ -1711,6 +1782,9 @@ fi
 WINE_NOTICE_WITH(tiff,[test "x$ac_cv_lib_soname_tiff" = "x"],
                  [libtiff ${notice_platform}development files not found, TIFF won't be supported.])
 
+dnl **** Check for libtxc_dxtn ****
+WINE_CHECK_SONAME(txc_dxtn,tx_compress_dxtn,,,,[[libtxc_dxtn\\(_s2tc\\)\\{0,1\\}]])
+
 dnl **** Check for mpg123 ****
 if test "x$with_mpg123" != "xno"
 then
@@ -1767,13 +1841,14 @@ fi
 dnl **** Disable unsupported winmm drivers ****
 test -n "$ALSA_LIBS" || enable_winealsa_drv=${enable_winealsa_drv:-no}
 test -n "$COREAUDIO_LIBS" || enable_winecoreaudio_drv=${enable_winecoreaudio_drv:-no}
+test -n "$PULSELIBS" || enable_winepulse_drv=${enable_winepulse_drv:-no}
 test "x$ac_cv_member_oss_sysinfo_numaudioengines" = xyes || enable_wineoss_drv=${enable_wineoss_drv:-no}
 test "$ac_cv_header_linux_joystick_h" = "yes" -o "$ac_cv_header_IOKit_hid_IOHIDLib_h" = "yes" || enable_winejoystick_drv=${enable_winejoystick_drv:-no}
 
 dnl **** Check for any sound system ****
-if test "x$ALSA_LIBS$COREAUDIO_LIBS" = "x" -a \
+if test "x$ALSA_LIBS$COREAUDIO_LIBS$PULSELIBS" = "x" -a \
         "x$ac_cv_member_oss_sysinfo_numaudioengines" != xyes -a \
-        "x$with_alsa$with_coreaudio$with_oss" != xnonono
+        "x$with_alsa$with_coreaudio$with_oss$with_pulse" != xnononono
 then
     WINE_WARNING([No sound system was found. Windows applications will be silent.])
 fi
@@ -2586,6 +2661,38 @@ then
     AC_DEFINE(HAVE_ISNAN, 1, [Define to 1 if you have the `isnan' function.])
 fi
 
+dnl Check for coshl
+AC_CACHE_CHECK([for coshl], ac_cv_have_coshl,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]], [[float f = 0.0; return coshl(f)]])],[ac_cv_have_coshl="yes"],[ac_cv_have_coshl="no"]))
+if test "$ac_cv_have_coshl" = "yes"
+then
+    AC_DEFINE(HAVE_COSHL, 1, [Define to 1 if you have the `coshl' function.])
+fi
+
+dnl Check for sinhl
+AC_CACHE_CHECK([for sinhl], ac_cv_have_sinhl,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]], [[float f = 0.0; return sinhl(f)]])],[ac_cv_have_sinhl="yes"],[ac_cv_have_sinhl="no"]))
+if test "$ac_cv_have_sinhl" = "yes"
+then
+    AC_DEFINE(HAVE_SINHL, 1, [Define to 1 if you have the `sinhl' function.])
+fi
+
+dnl Check for expl
+AC_CACHE_CHECK([for expl], ac_cv_have_expl,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]], [[float f = 0.0; return expl(f)]])],[ac_cv_have_expl="yes"],[ac_cv_have_expl="no"]))
+if test "$ac_cv_have_expl" = "yes"
+then
+    AC_DEFINE(HAVE_EXPL, 1, [Define to 1 if you have the `expl' function.])
+fi
+
+dnl Check for powl
+AC_CACHE_CHECK([for powl], ac_cv_have_powl,
+               AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <math.h>]], [[float f = 0.0; return powl(f, f)]])],[ac_cv_have_powl="yes"],[ac_cv_have_powl="no"]))
+if test "$ac_cv_have_powl" = "yes"
+then
+    AC_DEFINE(HAVE_POWL, 1, [Define to 1 if you have the `powl' function.])
+fi
+
 AC_CHECK_FUNCS(\
 	cbrt \
 	cbrtf \
@@ -2942,6 +3049,7 @@ WINE_CONFIG_DLL(dxgi,,[implib])
 WINE_CONFIG_TEST(dlls/dxgi/tests)
 WINE_CONFIG_LIB(dxguid)
 WINE_CONFIG_DLL(dxva2)
+WINE_CONFIG_TEST(dlls/dxva2/tests)
 WINE_CONFIG_DLL(evr)
 WINE_CONFIG_DLL(explorerframe,,[clean])
 WINE_CONFIG_TEST(dlls/explorerframe/tests)
@@ -2949,6 +3057,7 @@ WINE_CONFIG_DLL(ext-ms-win-gdi-devcaps-l1-1-0)
 WINE_CONFIG_DLL(faultrep,,[implib])
 WINE_CONFIG_TEST(dlls/faultrep/tests)
 WINE_CONFIG_DLL(fltlib)
+WINE_CONFIG_DLL(fltmgr.sys)
 WINE_CONFIG_DLL(fntcache)
 WINE_CONFIG_DLL(fontsub)
 WINE_CONFIG_DLL(fusion)
@@ -3142,8 +3251,18 @@ WINE_CONFIG_TEST(dlls/ntdll/tests)
 WINE_CONFIG_DLL(ntdsapi,,[implib])
 WINE_CONFIG_TEST(dlls/ntdsapi/tests)
 WINE_CONFIG_DLL(ntoskrnl.exe,,[implib])
+WINE_CONFIG_TEST(dlls/ntoskrnl.exe/tests)
+WINE_CONFIG_RESOURCE(dlls/ntoskrnl.exe/tests/driver.sys)
 WINE_CONFIG_DLL(ntprint)
 WINE_CONFIG_TEST(dlls/ntprint/tests)
+WINE_CONFIG_DLL(nvapi,enable_win32)
+WINE_CONFIG_TEST(dlls/nvapi/tests)
+WINE_CONFIG_DLL(nvapi64,enable_win64)
+WINE_CONFIG_DLL(nvcuda)
+WINE_CONFIG_TEST(dlls/nvcuda/tests)
+WINE_CONFIG_DLL(nvcuvid)
+WINE_CONFIG_DLL(nvencodeapi,enable_win32)
+WINE_CONFIG_DLL(nvencodeapi64,enable_win64)
 WINE_CONFIG_DLL(objsel,,[clean])
 WINE_CONFIG_DLL(odbc32,,[implib])
 WINE_CONFIG_DLL(odbccp32,,[implib])
@@ -3295,7 +3414,8 @@ WINE_CONFIG_DLL(uxtheme,,[implib])
 WINE_CONFIG_TEST(dlls/uxtheme/tests)
 WINE_CONFIG_DLL(vbscript,,[clean])
 WINE_CONFIG_TEST(dlls/vbscript/tests,[clean])
-WINE_CONFIG_DLL(vcomp)
+WINE_CONFIG_DLL(vcomp,,[implib])
+WINE_CONFIG_TEST(dlls/vcomp/tests)
 WINE_CONFIG_DLL(vcomp100)
 WINE_CONFIG_DLL(vcomp90)
 WINE_CONFIG_DLL(vdhcp.vxd,enable_win16)
@@ -3328,9 +3448,10 @@ WINE_CONFIG_DLL(windowscodecs,,[clean,implib])
 WINE_CONFIG_TEST(dlls/windowscodecs/tests)
 WINE_CONFIG_DLL(windowscodecsext,,[implib])
 WINE_CONFIG_TEST(dlls/windowscodecsext/tests)
-WINE_CONFIG_DLL(winealsa.drv)
+WINE_CONFIG_DLL(winealsa.drv,,[implib])
 WINE_CONFIG_DLL(winecoreaudio.drv)
 WINE_CONFIG_LIB(winecrt0)
+WINE_CONFIG_DLL(wined3d-csmt)
 WINE_CONFIG_DLL(wined3d,,[implib])
 WINE_CONFIG_DLL(winegstreamer)
 WINE_CONFIG_DLL(winejoystick.drv)
@@ -3340,6 +3461,7 @@ WINE_CONFIG_DLL(winemp3.acm)
 WINE_CONFIG_DLL(wineoss.drv)
 WINE_CONFIG_DLL(wineps.drv,,[clean,po])
 WINE_CONFIG_DLL(wineps16.drv16,enable_win16)
+WINE_CONFIG_DLL(winepulse.drv)
 WINE_CONFIG_DLL(wineqtdecoder)
 WINE_CONFIG_DLL(winex11.drv)
 WINE_CONFIG_DLL(wing.dll16,enable_win16)
@@ -3587,7 +3709,8 @@ then
 [wine_fn_output_makedep ()
 {
     AS_MKDIR_P(tools)
-    $CC -Iinclude -I$srcdir/include -D__WINESRC__ $EXTRACFLAGS $CPPFLAGS $CFLAGS -o tools/makedep$ac_exeext $srcdir/tools/makedep.c $LDFLAGS
+    @$CC -Iinclude -I$srcdir/include -D__WINESRC__ $EXTRACFLAGS $CPPFLAGS $CFLAGS -o tools/makedep$ac_exeext $srcdir/tools/makedep.c $LDFLAGS
+    @echo "[CC] makedep"
 }])
 fi
 
diff --git a/dlls/advapi32/crypt.c b/dlls/advapi32/crypt.c
index b2be5e3..50502b8 100644
--- a/dlls/advapi32/crypt.c
+++ b/dlls/advapi32/crypt.c
@@ -2378,7 +2378,8 @@ BOOLEAN WINAPI SystemFunction036(PVOID pbBuffer, ULONG dwLen)
     dev_random = open("/dev/urandom", O_RDONLY);
     if (dev_random != -1)
     {
-        if (read(dev_random, pbBuffer, dwLen) == (ssize_t)dwLen)
+        if (!IsBadWritePtr( pbBuffer, dwLen ) &&
+            read(dev_random, pbBuffer, dwLen) == (ssize_t)dwLen)
         {
             close(dev_random);
             return TRUE;
diff --git a/dlls/advapi32/lsa.c b/dlls/advapi32/lsa.c
index 2a8b791..2b2c6b6 100644
--- a/dlls/advapi32/lsa.c
+++ b/dlls/advapi32/lsa.c
@@ -29,6 +29,7 @@
 #include "winbase.h"
 #include "winreg.h"
 #include "winternl.h"
+#include "sddl.h"
 #include "advapi32_misc.h"
 
 #include "wine/debug.h"
@@ -404,14 +405,18 @@ NTSTATUS WINAPI LsaLookupNames2( LSA_HANDLE policy, ULONG flags, ULONG count,
     sid = (SID *)(*sids + count);
 
     /* use maximum domain count */
-    if (!(*domains = heap_alloc(sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION)*count +
-                                sid_size_total + domainname_size_total*sizeof(WCHAR))))
+    if (!(*domains = heap_alloc(sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION) * (count + 1) +
+                                sid_size_total + domainname_size_total * sizeof(WCHAR))))
     {
         heap_free(*sids);
         return STATUS_NO_MEMORY;
     }
     (*domains)->Entries = 0;
-    (*domains)->Domains = (LSA_TRUST_INFORMATION*)((char*)*domains + sizeof(LSA_REFERENCED_DOMAIN_LIST));
+    (*domains)->Domains = (LSA_TRUST_INFORMATION*)((char*)*domains +
+                          sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION));
+    (*domains)->Domains[-1].Sid = NULL;
+    RtlInitUnicodeStringEx(&(*domains)->Domains[-1].Name, NULL);
+
     domain_data = (char*)(*domains)->Domains + sizeof(LSA_TRUST_INFORMATION)*count;
 
     domain.Buffer = heap_alloc(domain_size_max*sizeof(WCHAR));
@@ -488,21 +493,24 @@ NTSTATUS WINAPI LsaLookupSids(
     if (!(*Names = heap_alloc(name_fullsize))) return STATUS_NO_MEMORY;
     /* maximum count of stored domain infos is Count, allocate it like that cause really needed
        count could only be computed after sid data is retrieved */
-    domain_fullsize = sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION)*Count;
+    domain_fullsize = sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION) * (Count + 1);
     if (!(*ReferencedDomains = heap_alloc(domain_fullsize)))
     {
         heap_free(*Names);
         return STATUS_NO_MEMORY;
     }
     (*ReferencedDomains)->Entries = 0;
-    (*ReferencedDomains)->Domains = (LSA_TRUST_INFORMATION*)((char*)*ReferencedDomains + sizeof(LSA_REFERENCED_DOMAIN_LIST));
+    (*ReferencedDomains)->Domains = (LSA_TRUST_INFORMATION*)((char*)*ReferencedDomains +
+                                    sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION));
+    (*ReferencedDomains)->Domains[-1].Sid = NULL;
+    RtlInitUnicodeStringEx(&(*ReferencedDomains)->Domains[-1].Name, NULL);
 
     /* Get full names data length and full length needed to store domain name and SID */
     for (i = 0; i < Count; i++)
     {
         (*Names)[i].Use = SidTypeUnknown;
         (*Names)[i].DomainIndex = -1;
-        (*Names)[i].Name.Buffer = NULL;
+        RtlInitUnicodeStringEx(&(*Names)[i].Name, NULL);
 
         memset(&(*ReferencedDomains)->Domains[i], 0, sizeof(LSA_TRUST_INFORMATION));
 
@@ -547,6 +555,21 @@ NTSTATUS WINAPI LsaLookupSids(
                 heap_free(name);
             }
         }
+        else
+        {
+            WCHAR *strsid = NULL;
+
+            if (ConvertSidToStringSidW(Sids[i], &strsid))
+            {
+                name_size = strlenW(strsid) + 1;
+
+                (*Names)[i].Name.Length = (name_size - 1) * sizeof(WCHAR);
+                (*Names)[i].Name.MaximumLength = name_size * sizeof(WCHAR);
+                name_fullsize += (*Names)[i].Name.MaximumLength;
+
+                LocalFree(strsid);
+            }
+        }
     }
 
     /* now we have full length needed for both */
@@ -555,7 +578,8 @@ NTSTATUS WINAPI LsaLookupSids(
 
     *ReferencedDomains = heap_realloc(*ReferencedDomains, domain_fullsize);
     /* fix pointer after reallocation */
-    (*ReferencedDomains)->Domains = (LSA_TRUST_INFORMATION*)((char*)*ReferencedDomains + sizeof(LSA_REFERENCED_DOMAIN_LIST));
+    (*ReferencedDomains)->Domains = (LSA_TRUST_INFORMATION*)((char*)*ReferencedDomains +
+                                    sizeof(LSA_REFERENCED_DOMAIN_LIST) + sizeof(LSA_TRUST_INFORMATION));
     domain_data = (char*)(*ReferencedDomains)->Domains + sizeof(LSA_TRUST_INFORMATION)*Count;
 
     mapped = 0;
@@ -585,6 +609,20 @@ NTSTATUS WINAPI LsaLookupSids(
                 heap_free(domain.Buffer);
             }
         }
+        else
+        {
+            WCHAR *strsid = NULL;
+
+            if (ConvertSidToStringSidW(Sids[i], &strsid))
+            {
+                name_size = strlenW(strsid) + 1;
+
+                (*Names)[i].Name.Buffer = name_buffer;
+                memcpy((*Names)[i].Name.Buffer, strsid, name_size * sizeof(WCHAR));
+
+                LocalFree(strsid);
+            }
+        }
 
         name_buffer += name_size;
     }
diff --git a/dlls/advapi32/tests/security.c b/dlls/advapi32/tests/security.c
index b43f212..f3fc682 100644
--- a/dlls/advapi32/tests/security.c
+++ b/dlls/advapi32/tests/security.c
@@ -2517,12 +2517,12 @@ static void test_process_security(void)
     PTOKEN_OWNER owner;
     PTOKEN_PRIMARY_GROUP group;
     PSID AdminSid = NULL, UsersSid = NULL;
-    PACL Acl = NULL;
-    SECURITY_DESCRIPTOR *SecurityDescriptor = NULL;
+    PACL Acl = NULL, ThreadAcl = NULL;
+    SECURITY_DESCRIPTOR *SecurityDescriptor = NULL, *ThreadSecurityDescriptor = NULL;
     char buffer[MAX_PATH];
     PROCESS_INFORMATION info;
     STARTUPINFOA startup;
-    SECURITY_ATTRIBUTES psa;
+    SECURITY_ATTRIBUTES psa, tsa;
     HANDLE token, event;
     DWORD size;
     SID_IDENTIFIER_AUTHORITY SIDAuthWorld = { SECURITY_WORLD_SID_AUTHORITY };
@@ -2643,11 +2643,36 @@ static void test_process_security(void)
     psa.lpSecurityDescriptor = SecurityDescriptor;
     psa.bInheritHandle = TRUE;
 
+    ThreadSecurityDescriptor = HeapAlloc( GetProcessHeap(), 0, SECURITY_DESCRIPTOR_MIN_LENGTH );
+    res = InitializeSecurityDescriptor( ThreadSecurityDescriptor, SECURITY_DESCRIPTOR_REVISION );
+    ok(res, "InitializeSecurityDescriptor failed with error %d\n", GetLastError());
+
+    ThreadAcl = HeapAlloc( GetProcessHeap(), 0, 256 );
+    res = InitializeAcl( ThreadAcl, 256, ACL_REVISION );
+    ok(res, "InitializeAcl failed with error %d\n", GetLastError());
+    res = AddAccessDeniedAce( ThreadAcl, ACL_REVISION, THREAD_SET_THREAD_TOKEN, AdminSid );
+    ok(res, "AddAccessDeniedAce failed with error %d\n", GetLastError() );
+    res = AddAccessAllowedAce( ThreadAcl, ACL_REVISION, THREAD_ALL_ACCESS, AdminSid );
+    ok(res, "AddAccessAllowedAce failed with error %d\n", GetLastError());
+
+    res = SetSecurityDescriptorOwner( ThreadSecurityDescriptor, AdminSid, FALSE );
+    ok(res, "SetSecurityDescriptorOwner failed with error %d\n", GetLastError());
+    res = SetSecurityDescriptorGroup( ThreadSecurityDescriptor, UsersSid, FALSE );
+    ok(res, "SetSecurityDescriptorGroup failed with error %d\n", GetLastError());
+    res = SetSecurityDescriptorDacl( ThreadSecurityDescriptor, TRUE, ThreadAcl, FALSE );
+    ok(res, "SetSecurityDescriptorDacl failed with error %d\n", GetLastError());
+
+    tsa.nLength = sizeof(tsa);
+    tsa.lpSecurityDescriptor = ThreadSecurityDescriptor;
+    tsa.bInheritHandle = TRUE;
+
     /* Doesn't matter what ACL say we should get full access for ourselves */
-    res = CreateProcessA( NULL, buffer, &psa, NULL, FALSE, 0, NULL, NULL, &startup, &info );
+    res = CreateProcessA( NULL, buffer, &psa, &tsa, FALSE, 0, NULL, NULL, &startup, &info );
     ok(res, "CreateProcess with err:%d\n", GetLastError());
     TEST_GRANTED_ACCESS2( info.hProcess, PROCESS_ALL_ACCESS_NT4,
                           STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL );
+    TEST_GRANTED_ACCESS2( info.hThread, THREAD_ALL_ACCESS_NT4,
+                          STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL );
     winetest_wait_child_process( info.hProcess );
 
     FreeSid(EveryoneSid);
@@ -2658,6 +2683,8 @@ static void test_process_security(void)
     HeapFree(GetProcessHeap(), 0, owner);
     HeapFree(GetProcessHeap(), 0, Acl);
     HeapFree(GetProcessHeap(), 0, SecurityDescriptor);
+    HeapFree(GetProcessHeap(), 0, ThreadAcl);
+    HeapFree(GetProcessHeap(), 0, ThreadSecurityDescriptor);
 }
 
 static void test_process_security_child(void)
@@ -2681,7 +2708,6 @@ static void test_process_security_child(void)
     ret = DuplicateHandle( GetCurrentProcess(), handle, GetCurrentProcess(),
                            &handle1, PROCESS_ALL_ACCESS, TRUE, 0 );
     err = GetLastError();
-    todo_wine
     ok(!ret && err == ERROR_ACCESS_DENIED, "duplicating handle should have failed "
        "with STATUS_ACCESS_DENIED, instead of err:%d\n", err);
 
@@ -2689,10 +2715,8 @@ static void test_process_security_child(void)
 
     /* These two should fail - they are denied by ACL */
     handle = OpenProcess( PROCESS_VM_READ, FALSE, GetCurrentProcessId() );
-    todo_wine
     ok(handle == NULL, "OpenProcess(PROCESS_VM_READ) should have failed\n");
     handle = OpenProcess( PROCESS_ALL_ACCESS, FALSE, GetCurrentProcessId() );
-    todo_wine
     ok(handle == NULL, "OpenProcess(PROCESS_ALL_ACCESS) should have failed\n");
 
     /* Documented privilege elevation */
@@ -2716,6 +2740,15 @@ static void test_process_security_child(void)
     TEST_GRANTED_ACCESS( handle1, PROCESS_VM_READ );
     CloseHandle( handle1 );
     CloseHandle( handle );
+
+    /* Test thread security */
+    handle = OpenThread( THREAD_TERMINATE, FALSE, GetCurrentThreadId() );
+    ok(handle != NULL, "OpenThread(THREAD_TERMINATE) with err:%d\n", GetLastError());
+    TEST_GRANTED_ACCESS( handle, PROCESS_TERMINATE );
+    CloseHandle( handle );
+
+    handle = OpenThread( THREAD_SET_THREAD_TOKEN, FALSE, GetCurrentThreadId() );
+    ok(handle == NULL, "OpenThread(THREAD_SET_THREAD_TOKEN) should have failed\n");
 }
 
 static void test_impersonation_level(void)
@@ -3264,7 +3297,7 @@ static void test_CreateDirectoryA(void)
     }
     ok(!error, "GetNamedSecurityInfo failed with error %d\n", error);
     test_inherited_dacl(pDacl, admin_sid, user_sid, OBJECT_INHERIT_ACE|CONTAINER_INHERIT_ACE,
-                        0x1f01ff, FALSE, TRUE, FALSE, __LINE__);
+                        0x1f01ff, FALSE, FALSE, FALSE, __LINE__);
     LocalFree(pSD);
 
     /* Test inheritance of ACLs in CreateFile without security descriptor */
@@ -3280,7 +3313,7 @@ static void test_CreateDirectoryA(void)
                                    (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
     ok(error == ERROR_SUCCESS, "Failed to get permissions on file\n");
     test_inherited_dacl(pDacl, admin_sid, user_sid, INHERITED_ACE,
-                        0x1f01ff, TRUE, TRUE, TRUE, __LINE__);
+                        0x1f01ff, FALSE, FALSE, FALSE, __LINE__);
     LocalFree(pSD);
     CloseHandle(hTemp);
 
@@ -3311,7 +3344,6 @@ static void test_CreateDirectoryA(void)
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
     bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
     ok(bret, "GetAclInformation failed\n");
-    todo_wine
     ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
                                acl_size.AceCount);
     LocalFree(pSD);
@@ -3319,17 +3351,13 @@ static void test_CreateDirectoryA(void)
     error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
                                    OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                    (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
-    todo_wine
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
-    if (error == ERROR_SUCCESS)
-    {
-        bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
-        ok(bret, "GetAclInformation failed\n");
-        todo_wine
-        ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
-                                   acl_size.AceCount);
-        LocalFree(pSD);
-    }
+    bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    todo_wine
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
     CloseHandle(hTemp);
 
     /* Test inheritance of ACLs in NtCreateFile without security descriptor */
@@ -3354,7 +3382,7 @@ static void test_CreateDirectoryA(void)
                                    (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
     ok(error == ERROR_SUCCESS, "Failed to get permissions on file\n");
     test_inherited_dacl(pDacl, admin_sid, user_sid, INHERITED_ACE,
-                        0x1f01ff, TRUE, TRUE, TRUE, __LINE__);
+                        0x1f01ff, FALSE, FALSE, FALSE, __LINE__);
     LocalFree(pSD);
     CloseHandle(hTemp);
 
@@ -3391,25 +3419,165 @@ static void test_CreateDirectoryA(void)
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
     bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
     ok(bret, "GetAclInformation failed\n");
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
+    bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
     todo_wine
     ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
                                acl_size.AceCount);
     LocalFree(pSD);
+    CloseHandle(hTemp);
+
+    /* Test inheritance of ACLs in CreateDirectory without security descriptor */
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir");
+    bret = CreateDirectoryA(tmpfile, NULL);
+    ok(bret == TRUE, "CreateDirectoryA failed with error %u\n", GetLastError());
 
     error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
                                    OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
                                    (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "Failed to get permissions on file\n");
+    test_inherited_dacl(pDacl, admin_sid, user_sid,
+                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERITED_ACE,
+                        0x1f01ff, FALSE, FALSE, FALSE, __LINE__);
+    LocalFree(pSD);
+    bret = RemoveDirectoryA(tmpfile);
+    ok(bret == TRUE, "RemoveDirectoryA failed with error %u\n", GetLastError());
+
+    /* Test inheritance of ACLs in CreateDirectory with security descriptor */
+    pSD = &sd;
+    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
+    pDacl = HeapAlloc(GetProcessHeap(), 0, sizeof(ACL));
+    bret = InitializeAcl(pDacl, sizeof(ACL), ACL_REVISION);
+    ok(bret, "Failed to initialize ACL\n");
+    bret = SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE);
+    ok(bret, "Failed to add ACL to security desciptor\n");
+
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir1");
+
+    sa.nLength = sizeof(sa);
+    sa.lpSecurityDescriptor = pSD;
+    sa.bInheritHandle = TRUE;
+    bret = CreateDirectoryA(tmpfile, &sa);
+    ok(bret == TRUE, "CreateDirectoryA failed with error %u\n", GetLastError());
+    HeapFree(GetProcessHeap(), 0, pDacl);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
+    bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
     todo_wine
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
+
+    SetLastError(0xdeadbeef);
+    bret = RemoveDirectoryA(tmpfile);
+    error = GetLastError();
+    ok(bret == FALSE, "RemoveDirectoryA unexpected succeeded\n");
+    ok(error == ERROR_ACCESS_DENIED, "expected ERROR_ACCESS_DENIED, got %u\n", error);
+
+    pSD = &sd;
+    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
+    pDacl = HeapAlloc(GetProcessHeap(), 0, 100);
+    bret = InitializeAcl(pDacl, 100, ACL_REVISION);
+    ok(bret, "Failed to initialize ACL.\n");
+    bret = pAddAccessAllowedAceEx(pDacl, ACL_REVISION, 0, GENERIC_ALL, user_sid);
+    ok(bret, "Failed to add Current User to ACL.\n");
+    bret = SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE);
+    ok(bret, "Failed to add ACL to security desciptor.\n");
+    error = pSetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT, DACL_SECURITY_INFORMATION, NULL,
+                                   NULL, pDacl, NULL);
+    ok(error == ERROR_SUCCESS, "SetNamedSecurityInfoA failed with error %u\n", error);
+    HeapFree(GetProcessHeap(), 0, pDacl);
+
+    bret = RemoveDirectoryA(tmpfile);
+    ok(bret == TRUE, "RemoveDirectoryA failed with error %u\n", GetLastError());
+
+    /* Test inheritance of ACLs in NtCreateFile(..., FILE_DIRECTORY_FILE, ...) without security descriptor */
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir");
+    get_nt_pathW(tmpfile, &tmpfileW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &tmpfileW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = pNtCreateFile(&hTemp, GENERIC_READ | DELETE, &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
+                           FILE_SHARE_READ, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE, NULL, 0);
+    ok(!status, "NtCreateFile failed with %08x\n", status);
+    RtlFreeUnicodeString(&tmpfileW);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "Failed to get permissions on file\n");
+    test_inherited_dacl(pDacl, admin_sid, user_sid,
+                        OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERITED_ACE,
+                        0x1f01ff, FALSE, FALSE, FALSE, __LINE__);
+    LocalFree(pSD);
+    CloseHandle(hTemp);
+
+    /* Test inheritance of ACLs in NtCreateFile(..., FILE_DIRECTORY_FILE, ...) with security descriptor */
+    pSD = &sd;
+    InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION);
+    pDacl = HeapAlloc(GetProcessHeap(), 0, sizeof(ACL));
+    bret = InitializeAcl(pDacl, sizeof(ACL), ACL_REVISION);
+    ok(bret, "Failed to initialize ACL\n");
+    bret = SetSecurityDescriptorDacl(pSD, TRUE, pDacl, FALSE);
+    ok(bret, "Failed to add ACL to security desciptor\n");
+
+    strcpy(tmpfile, tmpdir);
+    lstrcatA(tmpfile, "/tmpdir2");
+    get_nt_pathW(tmpfile, &tmpfileW);
+
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.ObjectName = &tmpfileW;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.SecurityDescriptor = pSD;
+    attr.SecurityQualityOfService = NULL;
+
+    status = pNtCreateFile(&hTemp, GENERIC_READ | DELETE, &attr, &io, NULL, FILE_ATTRIBUTE_NORMAL,
+                           FILE_SHARE_READ, FILE_CREATE, FILE_DIRECTORY_FILE | FILE_DELETE_ON_CLOSE, NULL, 0);
+    ok(!status, "NtCreateFile failed with %08x\n", status);
+    RtlFreeUnicodeString(&tmpfileW);
+    HeapFree(GetProcessHeap(), 0, pDacl);
+
+    error = pGetSecurityInfo(hTemp, SE_FILE_OBJECT,
+                             OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                             (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
     ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
-    if (error == ERROR_SUCCESS)
-    {
-        bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
-        ok(bret, "GetAclInformation failed\n");
-        todo_wine
-        ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
-                                   acl_size.AceCount);
-        LocalFree(pSD);
-    }
+    bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
+
+    error = pGetNamedSecurityInfoA(tmpfile, SE_FILE_OBJECT,
+                                   OWNER_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION,
+                                   (PSID *)&owner, NULL, &pDacl, NULL, &pSD);
+    ok(error == ERROR_SUCCESS, "GetNamedSecurityInfo failed with error %d\n", error);
+    bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    todo_wine
+    ok(acl_size.AceCount == 0, "GetAclInformation returned unexpected entry count (%d != 0).\n",
+                               acl_size.AceCount);
+    LocalFree(pSD);
     CloseHandle(hTemp);
 
 done:
@@ -3584,19 +3752,18 @@ static void test_GetNamedSecurityInfoA(void)
         bret = pGetAce(pDacl, 0, (VOID **)&ace);
         ok(bret, "Failed to get Current User ACE.\n");
         bret = EqualSid(&ace->SidStart, user_sid);
-        todo_wine ok(bret, "Current User ACE != Current User SID.\n");
+        ok(bret, "Current User ACE != Current User SID.\n");
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Current User ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
-        ok(ace->Mask == 0x1f01ff, "Current User ACE has unexpected mask (0x%x != 0x1f01ff)\n",
-                                  ace->Mask);
+        ok(ace->Mask == 0x1f01ff,
+           "Current User ACE has unexpected mask (0x%x != 0x1f01ff)\n", ace->Mask);
     }
     if (acl_size.AceCount > 1)
     {
         bret = pGetAce(pDacl, 1, (VOID **)&ace);
         ok(bret, "Failed to get Administators Group ACE.\n");
         bret = EqualSid(&ace->SidStart, admin_sid);
-        todo_wine ok(bret || broken(!bret) /* win2k */,
-                     "Administators Group ACE != Administators Group SID.\n");
+        ok(bret || broken(!bret) /* win2k */, "Administators Group ACE != Administators Group SID.\n");
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Administators Group ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
         ok(ace->Mask == 0x1f01ff || broken(ace->Mask == GENERIC_ALL) /* win2k */,
@@ -3623,8 +3790,8 @@ static void test_GetNamedSecurityInfoA(void)
     {
         bret = pGetAce(pDacl, 0, (VOID **)&ace);
         ok(bret, "Failed to get ACE.\n");
-        todo_wine ok(((ACE_HEADER *)ace)->AceFlags & INHERITED_ACE,
-                "ACE has unexpected flags: 0x%x\n", ((ACE_HEADER *)ace)->AceFlags);
+        ok(((ACE_HEADER *)ace)->AceFlags & INHERITED_ACE,
+           "ACE has unexpected flags: 0x%x\n", ((ACE_HEADER *)ace)->AceFlags);
     }
     LocalFree(pSD);
 
@@ -4260,11 +4427,17 @@ static void test_acls(void)
 
 static void test_GetSecurityInfo(void)
 {
+    char domain_users_ptr[sizeof(TOKEN_USER) + sizeof(SID) + sizeof(DWORD)*SID_MAX_SUB_AUTHORITIES];
     char b[sizeof(TOKEN_USER) + sizeof(SID) + sizeof(DWORD)*SID_MAX_SUB_AUTHORITIES];
     char admin_ptr[sizeof(SID)+sizeof(ULONG)*SID_MAX_SUB_AUTHORITIES], dacl[100];
+    PSID domain_users_sid = (PSID) domain_users_ptr, domain_sid;
+    SID_IDENTIFIER_AUTHORITY sia = { SECURITY_NT_AUTHORITY };
+    int domain_users_ace_id = -1, admins_ace_id = -1, i;
     DWORD sid_size = sizeof(admin_ptr), l = sizeof(b);
     PSID admin_sid = (PSID) admin_ptr, user_sid;
     char sd[SECURITY_DESCRIPTOR_MIN_LENGTH];
+    BOOL owner_defaulted, group_defaulted;
+    BOOL dacl_defaulted, dacl_present;
     ACL_SIZE_INFORMATION acl_size;
     PSECURITY_DESCRIPTOR pSD;
     ACCESS_ALLOWED_ACE *ace;
@@ -4272,6 +4445,7 @@ static void test_GetSecurityInfo(void)
     PSID owner, group;
     BOOL bret = TRUE;
     PACL pDacl;
+    BYTE flags;
     DWORD ret;
 
     if (!pGetSecurityInfo || !pSetSecurityInfo)
@@ -4370,25 +4544,103 @@ static void test_GetSecurityInfo(void)
         bret = pGetAce(pDacl, 0, (VOID **)&ace);
         ok(bret, "Failed to get Current User ACE.\n");
         bret = EqualSid(&ace->SidStart, user_sid);
-        todo_wine ok(bret, "Current User ACE != Current User SID.\n");
+        ok(bret, "Current User ACE != Current User SID.\n");
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Current User ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
         ok(ace->Mask == 0x1f01ff, "Current User ACE has unexpected mask (0x%x != 0x1f01ff)\n",
-                                    ace->Mask);
+                                  ace->Mask);
     }
     if (acl_size.AceCount > 1)
     {
         bret = pGetAce(pDacl, 1, (VOID **)&ace);
         ok(bret, "Failed to get Administators Group ACE.\n");
         bret = EqualSid(&ace->SidStart, admin_sid);
-        todo_wine ok(bret, "Administators Group ACE != Administators Group SID.\n");
+        ok(bret, "Administators Group ACE != Administators Group SID.\n");
         ok(((ACE_HEADER *)ace)->AceFlags == 0,
            "Administators Group ACE has unexpected flags (0x%x != 0x0)\n", ((ACE_HEADER *)ace)->AceFlags);
-        ok(ace->Mask == 0x1f01ff, "Administators Group ACE has unexpected mask (0x%x != 0x1f01ff)\n",
-                                  ace->Mask);
+        ok(ace->Mask == 0x1f01ff,
+                     "Administators Group ACE has unexpected mask (0x%x != 0x1f01ff)\n", ace->Mask);
     }
     LocalFree(pSD);
     CloseHandle(obj);
+
+    /* Obtain the "domain users" SID from the user SID */
+    if (!AllocateAndInitializeSid(&sia, 4, *GetSidSubAuthority(user_sid, 0),
+                                  *GetSidSubAuthority(user_sid, 1),
+                                  *GetSidSubAuthority(user_sid, 2),
+                                  *GetSidSubAuthority(user_sid, 3), 0, 0, 0, 0, &domain_sid))
+    {
+        win_skip("Failed to get current domain SID\n");
+        return;
+    }
+    sid_size = sizeof(domain_users_ptr);
+    pCreateWellKnownSid(WinAccountDomainUsersSid, domain_sid, domain_users_sid, &sid_size);
+    FreeSid(domain_sid);
+
+    /* Test querying the ownership of a process */
+    ret = pGetSecurityInfo(GetCurrentProcess(), SE_KERNEL_OBJECT,
+                           OWNER_SECURITY_INFORMATION|GROUP_SECURITY_INFORMATION,
+                           NULL, NULL, NULL, NULL, &pSD);
+    ok(!ret, "GetNamedSecurityInfo failed with error %d\n", ret);
+
+    bret = GetSecurityDescriptorOwner(pSD, &owner, &owner_defaulted);
+    ok(bret, "GetSecurityDescriptorOwner failed with error %d\n", GetLastError());
+    ok(owner != NULL, "owner should not be NULL\n");
+    ok(EqualSid(owner, admin_sid) || EqualSid(owner, user_sid),
+       "Process owner SID != Administrators SID.\n");
+
+    bret = GetSecurityDescriptorGroup(pSD, &group, &group_defaulted);
+    ok(bret, "GetSecurityDescriptorGroup failed with error %d\n", GetLastError());
+    ok(group != NULL, "group should not be NULL\n");
+    ok(EqualSid(group, domain_users_sid), "Process group SID != Domain Users SID.\n");
+    LocalFree(pSD);
+
+    /* Test querying the DACL of a process */
+    ret = pGetSecurityInfo(GetCurrentProcess(), SE_KERNEL_OBJECT, DACL_SECURITY_INFORMATION,
+                                   NULL, NULL, NULL, NULL, &pSD);
+    ok(!ret, "GetSecurityInfo failed with error %d\n", ret);
+
+    bret = GetSecurityDescriptorDacl(pSD, &dacl_present, &pDacl, &dacl_defaulted);
+    ok(bret, "GetSecurityDescriptorDacl failed with error %d\n", GetLastError());
+    ok(dacl_present, "DACL should be present\n");
+    ok(pDacl && IsValidAcl(pDacl), "GetSecurityDescriptorDacl returned invalid DACL.\n");
+    bret = pGetAclInformation(pDacl, &acl_size, sizeof(acl_size), AclSizeInformation);
+    ok(bret, "GetAclInformation failed\n");
+    ok(acl_size.AceCount != 0, "GetAclInformation returned no ACLs\n");
+    for (i=0; i<acl_size.AceCount; i++)
+    {
+        bret = pGetAce(pDacl, i, (VOID **)&ace);
+        ok(bret, "Failed to get ACE %d.\n", i);
+        bret = EqualSid(&ace->SidStart, domain_users_sid);
+        if (bret) domain_users_ace_id = i;
+        bret = EqualSid(&ace->SidStart, admin_sid);
+        if (bret) admins_ace_id = i;
+    }
+    ok(domain_users_ace_id != -1 || broken(domain_users_ace_id == -1) /* win2k */,
+       "Domain Users ACE not found.\n");
+    if (domain_users_ace_id != -1)
+    {
+        bret = pGetAce(pDacl, domain_users_ace_id, (VOID **)&ace);
+        ok(bret, "Failed to get Domain Users ACE.\n");
+        flags = ((ACE_HEADER *)ace)->AceFlags;
+        ok(flags == (INHERIT_ONLY_ACE|CONTAINER_INHERIT_ACE),
+           "Domain Users ACE has unexpected flags (0x%x != 0x%x)\n", flags,
+           INHERIT_ONLY_ACE|CONTAINER_INHERIT_ACE);
+        ok(ace->Mask == GENERIC_READ, "Domain Users ACE has unexpected mask (0x%x != 0x%x)\n",
+                                      ace->Mask, GENERIC_READ);
+    }
+    ok(admins_ace_id != -1 || broken(admins_ace_id == -1) /* xp */,
+       "Builtin Admins ACE not found.\n");
+    if (admins_ace_id != -1)
+    {
+        bret = pGetAce(pDacl, admins_ace_id, (VOID **)&ace);
+        ok(bret, "Failed to get Builtin Admins ACE.\n");
+        flags = ((ACE_HEADER *)ace)->AceFlags;
+        ok(flags == 0x0, "Builtin Admins ACE has unexpected flags (0x%x != 0x0)\n", flags);
+        ok(ace->Mask == PROCESS_ALL_ACCESS || broken(ace->Mask == 0x1f0fff) /* win2k */,
+           "Builtin Admins ACE has unexpected mask (0x%x != 0x%x)\n", ace->Mask, PROCESS_ALL_ACCESS);
+    }
+    LocalFree(pSD);
 }
 
 static void test_GetSidSubAuthority(void)
diff --git a/dlls/api-ms-win-core-file-l1-2-0/api-ms-win-core-file-l1-2-0.spec b/dlls/api-ms-win-core-file-l1-2-0/api-ms-win-core-file-l1-2-0.spec
index ebfd52e..cddf112 100644
--- a/dlls/api-ms-win-core-file-l1-2-0/api-ms-win-core-file-l1-2-0.spec
+++ b/dlls/api-ms-win-core-file-l1-2-0/api-ms-win-core-file-l1-2-0.spec
@@ -39,8 +39,8 @@
 @ stdcall GetFileSizeEx(long ptr) kernel32.GetFileSizeEx
 @ stdcall GetFileTime(long ptr ptr ptr) kernel32.GetFileTime
 @ stdcall GetFileType(long) kernel32.GetFileType
-@ stub GetFinalPathNameByHandleA
-@ stub GetFinalPathNameByHandleW
+@ stdcall GetFinalPathNameByHandleA(long ptr long long) kernel32.GetFinalPathNameByHandleA
+@ stdcall GetFinalPathNameByHandleW(long ptr long long) kernel32.GetFinalPathNameByHandleW
 @ stdcall GetFullPathNameA(str long ptr ptr) kernel32.GetFullPathNameA
 @ stdcall GetFullPathNameW(wstr long ptr ptr) kernel32.GetFullPathNameW
 @ stdcall GetLogicalDriveStringsW(long ptr) kernel32.GetLogicalDriveStringsW
diff --git a/dlls/api-ms-win-core-winrt-string-l1-1-0/api-ms-win-core-winrt-string-l1-1-0.spec b/dlls/api-ms-win-core-winrt-string-l1-1-0/api-ms-win-core-winrt-string-l1-1-0.spec
index 2361a1d..825980d 100644
--- a/dlls/api-ms-win-core-winrt-string-l1-1-0/api-ms-win-core-winrt-string-l1-1-0.spec
+++ b/dlls/api-ms-win-core-winrt-string-l1-1-0/api-ms-win-core-winrt-string-l1-1-0.spec
@@ -21,7 +21,7 @@
 @ stdcall WindowsPromoteStringBuffer(ptr ptr) combase.WindowsPromoteStringBuffer
 @ stub WindowsReplaceString
 @ stdcall WindowsStringHasEmbeddedNull(ptr ptr) combase.WindowsStringHasEmbeddedNull
-@ stub WindowsSubstring
+@ stdcall WindowsSubstring(ptr long ptr) combase.WindowsSubstring
 @ stub WindowsSubstringWithSpecifiedLength
 @ stub WindowsTrimStringEnd
 @ stub WindowsTrimStringStart
diff --git a/dlls/browseui/browseui.rc b/dlls/browseui/browseui.rc
index 833b139..64b859d 100644
--- a/dlls/browseui/browseui.rc
+++ b/dlls/browseui/browseui.rc
@@ -25,6 +25,11 @@ LANGUAGE LANG_ENGLISH, SUBLANG_DEFAULT
 STRINGTABLE
 {
     IDS_CANCELLING    "Canceling..."
+    IDS_REMAINING1    "%u %s remaining"
+    IDS_REMAINING2    "%u %s and %u %s remaining"
+    IDS_SECONDS       "seconds"
+    IDS_MINUTES       "minutes"
+    IDS_HOURS         "hours"
 }
 
 IDD_PROGRESS_DLG DIALOG 0, 0, 260, 85
diff --git a/dlls/browseui/progressdlg.c b/dlls/browseui/progressdlg.c
index 70c78c9..e97ea4e 100644
--- a/dlls/browseui/progressdlg.c
+++ b/dlls/browseui/progressdlg.c
@@ -73,6 +73,9 @@ typedef struct tagProgressDialog {
     ULONGLONG ullCompleted;
     ULONGLONG ullTotal;
     HWND hwndDisabledParent;    /* For modal dialog: the parent that need to be re-enabled when the dialog ends */
+    ULONGLONG startTime;
+    LPWSTR remainingMsg[2];
+    LPWSTR timeMsg[3];
 } ProgressDialog;
 
 static inline ProgressDialog *impl_from_IProgressDialog(IProgressDialog *iface)
@@ -175,6 +178,7 @@ static INT_PTR CALLBACK dialog_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM l
         case WM_INITDIALOG:
         {
             struct create_params *params = (struct create_params *)lParam;
+            LONG_PTR style;
 
             /* Note: until we set the hEvent, the object is protected by
              * the critical section held by StartProgress */
@@ -191,6 +195,10 @@ static INT_PTR CALLBACK dialog_proc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM l
             if (This->dwFlags & PROGDLG_NOMINIMIZE)
                 SetWindowLongW(hwnd, GWL_STYLE, GetWindowLongW(hwnd, GWL_STYLE) & (~WS_MINIMIZEBOX));
 
+            style = GetWindowLongPtrW(GetDlgItem(hwnd, IDC_ANIMATION), GWL_STYLE);
+            style |= ACS_AUTOPLAY | ACS_TRANSPARENT;
+            SetWindowLongPtrW(GetDlgItem(hwnd, IDC_ANIMATION), GWL_STYLE, style);
+
             update_dialog(This, 0xffffffff);
             This->dwUpdate = 0;
             This->isCancelled = FALSE;
@@ -259,14 +267,18 @@ static DWORD WINAPI dialog_thread(LPVOID lpParameter)
 
 static void ProgressDialog_Destructor(ProgressDialog *This)
 {
+    int i;
     TRACE("destroying %p\n", This);
     if (This->hwnd)
         end_dialog(This);
-    heap_free(This->lines[0]);
-    heap_free(This->lines[1]);
-    heap_free(This->lines[2]);
+    for (i = 0; i < 3; i++)
+        heap_free(This->lines[i]);
     heap_free(This->cancelMsg);
     heap_free(This->title);
+    for (i = 0; i < 2; i++)
+        heap_free(This->remainingMsg[i]);
+    for (i = 0; i < 3; i++)
+        heap_free(This->timeMsg[i]);
     This->cs.DebugInfo->Spare[0] = 0;
     DeleteCriticalSection(&This->cs);
     heap_free(This);
@@ -328,8 +340,6 @@ static HRESULT WINAPI ProgressDialog_StartProgressDialog(IProgressDialog *iface,
     TRACE("(%p, %p, %x, %p)\n", iface, punkEnableModeless, dwFlags, reserved);
     if (punkEnableModeless || reserved)
         FIXME("Reserved parameters not null (%p, %p)\n", punkEnableModeless, reserved);
-    if (dwFlags & PROGDLG_AUTOTIME)
-        FIXME("Flags PROGDLG_AUTOTIME not supported\n");
     if (dwFlags & PROGDLG_NOTIME)
         FIXME("Flags PROGDLG_NOTIME not supported\n");
 
@@ -364,6 +374,7 @@ static HRESULT WINAPI ProgressDialog_StartProgressDialog(IProgressDialog *iface,
             This->hwndDisabledParent = hwndDisable;
     }
 
+    This->startTime = GetTickCount64();
     LeaveCriticalSection(&This->cs);
 
     return S_OK;
@@ -402,7 +413,16 @@ static HRESULT WINAPI ProgressDialog_SetTitle(IProgressDialog *iface, LPCWSTR pw
 
 static HRESULT WINAPI ProgressDialog_SetAnimation(IProgressDialog *iface, HINSTANCE hInstance, UINT uiResourceId)
 {
-    FIXME("(%p, %p, %d) - stub\n", iface, hInstance, uiResourceId);
+    ProgressDialog *This = impl_from_IProgressDialog(iface);
+
+    TRACE("(%p, %p, %d)\n", iface, hInstance, uiResourceId);
+
+    if (uiResourceId & ~0xFFFF)
+        return S_OK;
+
+    if (!SendDlgItemMessageW(This->hwnd, IDC_ANIMATION, ACM_OPENW, (WPARAM)hInstance, uiResourceId))
+        WARN("Failed to load animation\n");
+
     return S_OK;
 }
 
@@ -412,6 +432,52 @@ static BOOL WINAPI ProgressDialog_HasUserCancelled(IProgressDialog *iface)
     return This->isCancelled;
 }
 
+static void load_time_strings(ProgressDialog *This)
+{
+    int i;
+
+    for (i = 0; i < 2; i++)
+    {
+        if (!This->remainingMsg[i])
+            This->remainingMsg[i] = load_string(BROWSEUI_hinstance, IDS_REMAINING1 + i);
+    }
+    for (i = 0; i < 3; i++)
+    {
+        if (!This->timeMsg[i])
+            This->timeMsg[i] = load_string(BROWSEUI_hinstance, IDS_SECONDS + i);
+    }
+}
+
+static void update_time_remaining(ProgressDialog *This, ULONGLONG ullCompleted, ULONGLONG ullTotal)
+{
+    unsigned int remaining, remainder = 0;
+    ULONGLONG elapsed;
+    WCHAR line[128];
+    int i;
+
+    if (!This->startTime || !ullCompleted || !ullTotal)
+        return;
+
+    load_time_strings(This);
+
+    elapsed = GetTickCount64() - This->startTime;
+    remaining = (elapsed * ullTotal / ullCompleted - elapsed) / 1000;
+
+    for (i = 0; remaining >= 60 && i < 2; i++)
+    {
+        remainder = remaining % 60;
+        remaining /= 60;
+    }
+
+    if (i > 0 && remaining < 2 && remainder != 0)
+        wsprintfW(line, This->remainingMsg[1], remaining, This->timeMsg[i], remainder, This->timeMsg[i-1]);
+    else
+        wsprintfW(line, This->remainingMsg[0], remaining, This->timeMsg[i]);
+
+    set_buffer(&This->lines[2], line);
+    This->dwUpdate |= UPDATE_LINE3;
+}
+
 static HRESULT WINAPI ProgressDialog_SetProgress64(IProgressDialog *iface, ULONGLONG ullCompleted, ULONGLONG ullTotal)
 {
     ProgressDialog *This = impl_from_IProgressDialog(iface);
@@ -424,6 +490,8 @@ static HRESULT WINAPI ProgressDialog_SetProgress64(IProgressDialog *iface, ULONG
     This->ullCompleted = ullCompleted;
     This->dwUpdate |= UPDATE_PROGRESS;
     hwnd = This->hwnd;
+    if (This->dwFlags & PROGDLG_AUTOTIME)
+        update_time_remaining(This, ullCompleted, ullTotal);
     LeaveCriticalSection(&This->cs);
 
     if (hwnd)
diff --git a/dlls/browseui/resids.h b/dlls/browseui/resids.h
index cd44a8e..865cdd1 100644
--- a/dlls/browseui/resids.h
+++ b/dlls/browseui/resids.h
@@ -21,6 +21,11 @@
 #include "commctrl.h"
 
 #define IDS_CANCELLING      16
+#define IDS_REMAINING1      17
+#define IDS_REMAINING2      18
+#define IDS_SECONDS         19
+#define IDS_MINUTES         20
+#define IDS_HOURS           21
 
 #define IDC_ANIMATION           100
 #define IDC_PROGRESS_BAR        102
diff --git a/dlls/combase/combase.spec b/dlls/combase/combase.spec
index ac095ce..48c3a7e 100644
--- a/dlls/combase/combase.spec
+++ b/dlls/combase/combase.spec
@@ -302,7 +302,7 @@
 @ stdcall WindowsPromoteStringBuffer(ptr ptr)
 @ stub WindowsReplaceString
 @ stdcall WindowsStringHasEmbeddedNull(ptr ptr)
-@ stub WindowsSubstring
+@ stdcall WindowsSubstring(ptr long ptr)
 @ stub WindowsSubstringWithSpecifiedLength
 @ stub WindowsTrimStringEnd
 @ stub WindowsTrimStringStart
diff --git a/dlls/combase/string.c b/dlls/combase/string.c
index 7054af6..33e5100 100644
--- a/dlls/combase/string.c
+++ b/dlls/combase/string.c
@@ -255,6 +255,25 @@ HRESULT WINAPI WindowsStringHasEmbeddedNull(HSTRING str, BOOL *out)
 }
 
 /***********************************************************************
+ *      WindowsSubstring (combase.@)
+ */
+HRESULT WINAPI WindowsSubstring(HSTRING str, UINT32 start, HSTRING *out)
+{
+    struct hstring_private *priv = impl_from_HSTRING(str);
+    UINT32 len = WindowsGetStringLen(str);
+    if (out == NULL)
+        return E_INVALIDARG;
+    if (start > len)
+        return E_BOUNDS;
+    if (start == len)
+    {
+        *out = NULL;
+        return S_OK;
+    }
+    return WindowsCreateString(&priv->buffer[start], len - start, out);
+}
+
+/***********************************************************************
  *      WindowsIsStringEmpty (combase.@)
  */
 BOOL WINAPI WindowsIsStringEmpty(HSTRING str)
diff --git a/dlls/combase/tests/string.c b/dlls/combase/tests/string.c
index 72eaa84..c46d04e 100644
--- a/dlls/combase/tests/string.c
+++ b/dlls/combase/tests/string.c
@@ -38,6 +38,7 @@ static BOOL    (WINAPI *pWindowsIsStringEmpty)(HSTRING);
 static HRESULT (WINAPI *pWindowsPreallocateStringBuffer)(UINT32, WCHAR **, HSTRING_BUFFER *);
 static HRESULT (WINAPI *pWindowsPromoteStringBuffer)(HSTRING_BUFFER, HSTRING *);
 static HRESULT (WINAPI *pWindowsStringHasEmbeddedNull)(HSTRING, BOOL *);
+static HRESULT (WINAPI *pWindowsSubstring)(HSTRING, UINT32, HSTRING *);
 
 #define SET(x) p##x = (void*)GetProcAddress(hmod, #x)
 
@@ -60,6 +61,7 @@ static BOOL init_functions(void)
     SET(WindowsPreallocateStringBuffer);
     SET(WindowsPromoteStringBuffer);
     SET(WindowsStringHasEmbeddedNull);
+    SET(WindowsSubstring);
     return TRUE;
 }
 
@@ -92,6 +94,7 @@ static void _check_string(int line, HSTRING str, LPCWSTR content, UINT32 length,
 static const WCHAR input_string[] = { 'a', 'b', 'c', 'd', 'e', 'f', '\0', '\0' };
 static const WCHAR input_empty_string[] = { '\0' };
 static const WCHAR input_embed_null[] = { 'a', '\0', 'c', '\0', 'e', 'f', '\0' };
+static const WCHAR output_substring[] = { 'c', 'd', 'e', 'f', '\0' };
 
 static void test_create_delete(void)
 {
@@ -236,6 +239,62 @@ static void test_string_buffer(void)
     ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
 }
 
+static void test_substring(void)
+{
+    HSTRING str, substr;
+    HSTRING_HEADER header;
+
+    /* Test substring of string buffers */
+    ok(pWindowsCreateString(input_string, 6, &str) == S_OK, "Failed to create string\n");
+    ok(pWindowsSubstring(str, 2, &substr) == S_OK, "Failed to create substring!\n");
+    check_string(substr, output_substring, 4, FALSE);
+    ok(pWindowsDeleteString(substr) == S_OK, "Failed to delete string\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
+
+    /* Test duplication of string using substring */
+    ok(pWindowsCreateString(input_string, 6, &str) == S_OK, "Failed to create string\n");
+    ok(pWindowsSubstring(str, 0, &substr) == S_OK, "Failed to create substring!\n");
+    ok(str != substr, "Duplicated string didn't create new string\n");
+    check_string(substr, input_string, 6, FALSE);
+    ok(pWindowsDeleteString(substr) == S_OK, "Failed to delete string\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
+
+    /* Test substring of string reference */
+    ok(pWindowsCreateStringReference(input_string, 6, &header, &str) == S_OK, "Failed to create string ref\n");
+    ok(pWindowsSubstring(str, 2, &substr) == S_OK, "Failed to create substring of string ref!\n");
+    check_string(substr, output_substring, 4, FALSE);
+    ok(pWindowsDeleteString(substr) == S_OK, "Failed to delete string\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string ref\n");
+
+    /* Test duplication of string reference using substring */
+    ok(pWindowsCreateStringReference(input_string, 6, &header, &str) == S_OK, "Failed to create string ref\n");
+    ok(pWindowsSubstring(str, 0, &substr) == S_OK, "Failed to create substring of string ref!\n");
+    ok(str != substr, "Duplicated string ref didn't create new string\n");
+    check_string(substr, input_string, 6, FALSE);
+    ok(pWindowsDeleteString(substr) == S_OK, "Failed to delete string\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
+
+    /* Test get Substring of empty string */
+    ok(pWindowsSubstring(NULL, 0, &substr) == S_OK, "Failed to duplicate NULL string\n");
+    ok(substr == NULL, "Substring created new string\n");
+
+    /* Test get empty Substring of string */
+    ok(pWindowsCreateString(input_string, 6, &str) == S_OK, "Failed to create string\n");
+    ok(pWindowsSubstring(str, 6, &substr) == S_OK, "Failed to create substring!\n");
+    ok(substr == NULL, "Substring created new string\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
+
+    /* Test handling of using to high startIndex */
+    ok(pWindowsCreateString(input_string, 6, &str) == S_OK, "Failed to create string\n");
+    ok(pWindowsSubstring(str, 7, &substr) == E_BOUNDS, "Incorrect error handling\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
+
+    /* Test handling of a NULL string  */
+    ok(pWindowsCreateString(input_string, 6, &str) == S_OK, "Failed to create string\n");
+    ok(pWindowsSubstring(str, 7, NULL) == E_INVALIDARG, "Incorrect error handling\n");
+    ok(pWindowsDeleteString(str) == S_OK, "Failed to delete string\n");
+}
+
 START_TEST(string)
 {
     if (!init_functions())
@@ -244,4 +303,5 @@ START_TEST(string)
     test_duplicate();
     test_access();
     test_string_buffer();
+    test_substring();
 }
diff --git a/dlls/comctl32/Makefile.in b/dlls/comctl32/Makefile.in
index 27f9741..235e535 100644
--- a/dlls/comctl32/Makefile.in
+++ b/dlls/comctl32/Makefile.in
@@ -16,6 +16,7 @@ C_SRCS = \
 	flatsb.c \
 	header.c \
 	hotkey.c \
+	icon.c \
 	imagelist.c \
 	ipaddress.c \
 	listview.c \
diff --git a/dlls/comctl32/comctl32.spec b/dlls/comctl32/comctl32.spec
index 1e92e5f..e61dfbf 100644
--- a/dlls/comctl32/comctl32.spec
+++ b/dlls/comctl32/comctl32.spec
@@ -88,6 +88,7 @@
 375 stdcall -noname -private StrCSpnIW(wstr wstr)
 376 stdcall -noname -private IntlStrEqWorkerA(long str str long)
 377 stdcall -noname -private IntlStrEqWorkerW(long wstr wstr long)
+380 stdcall LoadIconMetric(ptr wstr long ptr)
 381 stdcall -ordinal LoadIconWithScaleDown(ptr wstr long long ptr)
 382 stdcall -noname SmoothScrollWindow(ptr)
 383 stub -noname DoReaderMode
diff --git a/dlls/comctl32/tests/misc.c b/dlls/comctl32/tests/misc.c
index 280b46c..e4d65ec 100644
--- a/dlls/comctl32/tests/misc.c
+++ b/dlls/comctl32/tests/misc.c
@@ -20,6 +20,7 @@
 
 #include <stdio.h>
 #include <windows.h>
+#include <commctrl.h>
 
 #include "wine/test.h"
 #include "v6util.h"
@@ -34,6 +35,8 @@ static BOOL (WINAPI * pStr_SetPtrA)(LPSTR, LPCSTR);
 static INT (WINAPI * pStr_GetPtrW)(LPCWSTR, LPWSTR, INT);
 static BOOL (WINAPI * pStr_SetPtrW)(LPWSTR, LPCWSTR);
 
+static HRESULT (WINAPI * LoadIconMetric)(HINSTANCE, PCWSTR, INT, HICON*);
+
 static HMODULE hComctl32 = 0;
 
 #define COMCTL32_GET_PROC(ordinal, func) \
@@ -205,6 +208,86 @@ static void test_TaskDialogIndirect(void)
     ok(ptr == ptr2, "got wrong pointer for ordinal 345, %p expected %p\n", ptr2, ptr);
 }
 
+static void test_LoadIconMetric(void)
+{
+    static const WCHAR nonExistingFile[] = {'d','o','e','s','n','o','t','e','x','i','s','t','.','i','c','o','\0'};
+    HINSTANCE hinst;
+    void *ptr;
+    HICON icon;
+    HRESULT result;
+    ICONINFO info;
+    BOOL res;
+    INT bytes;
+    BITMAP bmp;
+
+    hinst = LoadLibraryA("comctl32.dll");
+
+    LoadIconMetric = (void *)GetProcAddress(hinst, "LoadIconMetric");
+    if (!LoadIconMetric)
+    {
+        win_skip("LoadIconMetric not exported by name\n");
+        return;
+    }
+
+    ptr = GetProcAddress(hinst, (const CHAR*)380);
+    ok(ptr == LoadIconMetric, "got wrong pointer for ordinal 380, %p expected %p\n",
+       ptr, LoadIconMetric);
+
+    result = LoadIconMetric(NULL, (PCWSTR)IDI_APPLICATION, LIM_SMALL, &icon);
+    ok(result == S_OK, "Expected S_OK, got %x\n", result);
+    if (result == S_OK)
+    {
+        res = GetIconInfo(icon, &info);
+        ok(res, "Failed to get icon info\n");
+        if (res && info.hbmColor)
+        {
+            bytes = GetObjectA(info.hbmColor, sizeof(bmp), &bmp);
+            ok(bytes > 0, "Failed to get bitmap info for icon\n");
+            if (bytes > 0)
+            {
+                ok(bmp.bmWidth  == GetSystemMetrics( SM_CXSMICON ), "Wrong icon width\n");
+                ok(bmp.bmHeight == GetSystemMetrics( SM_CYSMICON ), "Wrong icon height\n");
+            }
+        }
+        DestroyIcon(icon);
+    }
+
+    result = LoadIconMetric(NULL, (PCWSTR)IDI_APPLICATION, LIM_LARGE, &icon);
+    ok(result == S_OK, "Expected S_OK, got %x\n", result);
+    if (result == S_OK)
+    {
+        res = GetIconInfo(icon, &info);
+        ok(res, "Failed to get icon info\n");
+        if (res && info.hbmColor)
+        {
+            bytes = GetObjectA(info.hbmColor, sizeof(bmp), &bmp);
+            ok(bytes > 0, "Failed to get bitmap info for icon\n");
+            if (bytes > 0)
+            {
+                ok(bmp.bmWidth  == GetSystemMetrics( SM_CXICON ), "Wrong icon width\n");
+                ok(bmp.bmHeight == GetSystemMetrics( SM_CYICON ), "Wrong icon height\n");
+            }
+        }
+        DestroyIcon(icon);
+    }
+
+    result = LoadIconMetric(NULL, (PCWSTR)IDI_APPLICATION, 0x100, &icon);
+    ok(result == E_INVALIDARG, "Expected E_INVALIDARG, got %x\n", result);
+    if (result == S_OK) DestroyIcon(icon);
+
+    icon = (HICON)0x1234;
+    result = LoadIconMetric(NULL, NULL, LIM_LARGE, &icon);
+    ok(result == E_INVALIDARG, "Expected E_INVALIDARG, got %x\n", result);
+    ok(icon == (HICON)0, "Expected 0x0, got %p\n", icon);
+    if (result == S_OK) DestroyIcon(icon);
+
+    result = LoadIconMetric(NULL, nonExistingFile, LIM_LARGE, &icon);
+    ok(result == HRESULT_FROM_WIN32(ERROR_RESOURCE_TYPE_NOT_FOUND),
+       "Expected 80070715, got %x\n", result);
+    if (result == S_OK) DestroyIcon(icon);
+}
+
+
 START_TEST(misc)
 {
     ULONG_PTR ctx_cookie;
@@ -220,6 +303,7 @@ START_TEST(misc)
         return;
 
     test_TaskDialogIndirect();
+    test_LoadIconMetric();
 
     unload_v6_module(ctx_cookie, hCtx);
 }
diff --git a/dlls/d3d11/d3d11.spec b/dlls/d3d11/d3d11.spec
index 52d7bcb..2d6c877 100644
--- a/dlls/d3d11/d3d11.spec
+++ b/dlls/d3d11/d3d11.spec
@@ -3,7 +3,7 @@
 @ stub D3D11CoreGetLayeredDeviceSize
 @ stub D3D11CoreRegisterLayers
 @ stdcall D3D11CreateDevice(ptr long ptr long ptr long long ptr ptr ptr)
-@ stub D3D11CreateDeviceAndSwapChain
+@ stdcall D3D11CreateDeviceAndSwapChain(ptr long ptr long ptr long long ptr ptr ptr ptr ptr)
 @ stub D3DKMTCloseAdapter
 @ stub D3DKMTCreateAllocation
 @ stub D3DKMTCreateContext
diff --git a/dlls/d3d11/d3d11_main.c b/dlls/d3d11/d3d11_main.c
index ec8236f..63f6309 100644
--- a/dlls/d3d11/d3d11_main.c
+++ b/dlls/d3d11/d3d11_main.c
@@ -54,3 +54,16 @@ HRESULT WINAPI D3D11CreateDevice(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_t
             flags, feature_levels, levels, sdk_version, device, feature_level, context);
     return E_OUTOFMEMORY;
 }
+
+HRESULT WINAPI D3D11CreateDeviceAndSwapChain(IDXGIAdapter *adapter, D3D_DRIVER_TYPE driver_type,
+                                             HMODULE swrast, UINT flags, const D3D_FEATURE_LEVEL *feature_levels, UINT levels,
+                                             UINT sdk_version, const DXGI_SWAP_CHAIN_DESC *swapchain_desc, IDXGISwapChain **swapchain,
+                                             ID3D11Device **device, D3D_FEATURE_LEVEL *feature_level, ID3D11DeviceContext **immediate_context)
+{
+  FIXME("adapter %p, driver_type %s, swrast %p, flags %#x, feature_levels %p, levels %#x, sdk_version %d,\n"
+        "\tswapchain_desc %p, swapchain %p, device %p, feature_level %p, immediate_context%p \n",
+        adapter, debug_d3d_driver_type(driver_type), swrast, flags, feature_levels, levels, sdk_version,
+        swapchain_desc, swapchain, device, feature_level, immediate_context);
+  return E_INVALIDARG;
+}
+
diff --git a/dlls/d3d8/swapchain.c b/dlls/d3d8/swapchain.c
index 067a3e0..44fc02a 100644
--- a/dlls/d3d8/swapchain.c
+++ b/dlls/d3d8/swapchain.c
@@ -86,7 +86,7 @@ static ULONG WINAPI d3d8_swapchain_Release(IDirect3DSwapChain8 *iface)
     return ref;
 }
 
-static HRESULT WINAPI d3d8_swapchain_Present(IDirect3DSwapChain8 *iface,
+static HRESULT WINAPI DECLSPEC_HOTPATCH d3d8_swapchain_Present(IDirect3DSwapChain8 *iface,
         const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
         const RGNDATA *dirty_region)
 {
diff --git a/dlls/d3d8/tests/device.c b/dlls/d3d8/tests/device.c
index 64c2911..0f6dcc2 100644
--- a/dlls/d3d8/tests/device.c
+++ b/dlls/d3d8/tests/device.c
@@ -6447,37 +6447,37 @@ static void test_pixel_format(void)
     }
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice8_SetVertexShader(device, D3DFVF_XYZ);
     ok(SUCCEEDED(hr), "Failed to set FVF, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice8_BeginScene(device);
     ok(SUCCEEDED(hr), "BeginScene failed %#x\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice8_DrawPrimitiveUP(device, D3DPT_POINTLIST, 1, point, 3 * sizeof(float));
     ok(SUCCEEDED(hr), "Failed to draw, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice8_EndScene(device);
     ok(SUCCEEDED(hr), "EndScene failed %#x\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Present failed %#x\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -6485,10 +6485,10 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Present failed %#x\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
     }
 
 cleanup:
diff --git a/dlls/d3d8/tests/visual.c b/dlls/d3d8/tests/visual.c
index 737bb91..0b6d8c0 100644
--- a/dlls/d3d8/tests/visual.c
+++ b/dlls/d3d8/tests/visual.c
@@ -5116,7 +5116,11 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
+#if defined(STAGING_CSMT)
+    todo_wine ok(color_match(color, 0x00ff0000, 1),
+#else  /* STAGING_CSMT */
     ok(color_match(color, 0x00ff0000, 1),
+#endif /* STAGING_CSMT */
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
diff --git a/dlls/d3d9/device.c b/dlls/d3d9/device.c
index 0b1a77a..5225ec9 100644
--- a/dlls/d3d9/device.c
+++ b/dlls/d3d9/device.c
@@ -71,6 +71,8 @@ D3DFORMAT d3dformat_from_wined3dformat(enum wined3d_format_id format)
         case WINED3DFMT_R16G16_SNORM: return D3DFMT_V16U16;
         case WINED3DFMT_R10G10B10_SNORM_A2_UNORM: return D3DFMT_A2W10V10U10;
         case WINED3DFMT_D16_LOCKABLE: return D3DFMT_D16_LOCKABLE;
+        case WINED3DFMT_D32_LOCKABLE: return D3DFMT_D32_LOCKABLE;
+        case WINED3DFMT_S8_LOCKABLE: return D3DFMT_S8_LOCKABLE;
         case WINED3DFMT_D32_UNORM: return D3DFMT_D32;
         case WINED3DFMT_S1_UINT_D15_UNORM: return D3DFMT_D15S1;
         case WINED3DFMT_D24_UNORM_S8_UINT: return D3DFMT_D24S8;
@@ -136,6 +138,8 @@ enum wined3d_format_id wined3dformat_from_d3dformat(D3DFORMAT format)
         case D3DFMT_V16U16: return WINED3DFMT_R16G16_SNORM;
         case D3DFMT_A2W10V10U10: return WINED3DFMT_R10G10B10_SNORM_A2_UNORM;
         case D3DFMT_D16_LOCKABLE: return WINED3DFMT_D16_LOCKABLE;
+        case D3DFMT_D32_LOCKABLE: return WINED3DFMT_D32_LOCKABLE;
+        case D3DFMT_S8_LOCKABLE: return WINED3DFMT_S8_LOCKABLE;
         case D3DFMT_D32: return WINED3DFMT_D32_UNORM;
         case D3DFMT_D15S1: return WINED3DFMT_S1_UINT_D15_UNORM;
         case D3DFMT_D24S8: return WINED3DFMT_D24_UNORM_S8_UINT;
@@ -871,7 +875,9 @@ static HRESULT WINAPI d3d9_device_CreateVolumeTexture(IDirect3DDevice9Ex *iface,
             iface, width, height, depth, levels);
     TRACE("usage %#x, format %#x, pool %#x, texture %p, shared_handle %p.\n",
             usage, format, pool, texture, shared_handle);
-
+//trace:d3d9:d3d9_device_CreateVolumeTexture iface 0x19b768, width 4, height 4, depth 4, levels 3
+//trace:d3d9:d3d9_device_CreateVolumeTexture usage 0, format 0x31545844, pool 0, texture 0xc4ce4224, shared_handle 0x0.
+//D3DPOOL_DEFAULT = 0
     *texture = NULL;
     if (shared_handle)
     {
@@ -892,7 +898,7 @@ static HRESULT WINAPI d3d9_device_CreateVolumeTexture(IDirect3DDevice9Ex *iface,
     object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
     if (!object)
         return D3DERR_OUTOFVIDEOMEMORY;
-
+//fixme:d3d_texture:volumetexture_init create dxtn texture 0x31545844.
     hr = volumetexture_init(object, device, width, height, depth, levels, usage, format, pool);
     if (FAILED(hr))
     {
@@ -900,7 +906,7 @@ static HRESULT WINAPI d3d9_device_CreateVolumeTexture(IDirect3DDevice9Ex *iface,
         HeapFree(GetProcessHeap(), 0, object);
         return hr;
     }
-
+//
     TRACE("Created volume texture %p.\n", object);
     *texture = (IDirect3DVolumeTexture9 *)&object->IDirect3DBaseTexture9_iface;
 
@@ -963,6 +969,7 @@ static HRESULT WINAPI d3d9_device_CreateVertexBuffer(IDirect3DDevice9Ex *iface,
 
     TRACE("iface %p, size %u, usage %#x, fvf %#x, pool %#x, buffer %p, shared_handle %p.\n",
             iface, size, usage, fvf, pool, buffer, shared_handle);
+//trace:d3d9:d3d9_device_CreateVertexBuffer iface 0x19b768, size 20000000, usage 0x8, fvf 0, pool 0, buffer 0x32d468, shared_handle 0x0.
 
     if (shared_handle)
     {
@@ -1507,6 +1514,9 @@ static HRESULT WINAPI d3d9_device_BeginScene(IDirect3DDevice9Ex *iface)
     HRESULT hr;
 
     TRACE("iface %p.\n", iface);
+  if (!device)
+    return D3DERR_INVALIDCALL;
+
 
     wined3d_mutex_lock();
     if (SUCCEEDED(hr = wined3d_device_begin_scene(device->wined3d_device)))
@@ -3526,6 +3536,7 @@ static HRESULT CDECL device_parent_volume_created(struct wined3d_device_parent *
         return E_OUTOFMEMORY;
 
     volume_init(d3d_volume, container_parent, volume, parent_ops);
+    //Slice - what if volume_init fails?
     *parent = d3d_volume;
     TRACE("Created volume %p.\n", d3d_volume);
 
diff --git a/dlls/d3d9/surface.c b/dlls/d3d9/surface.c
index e5eb11f..e9aa510 100644
--- a/dlls/d3d9/surface.c
+++ b/dlls/d3d9/surface.c
@@ -91,6 +91,12 @@ static ULONG WINAPI d3d9_surface_Release(IDirect3DSurface9 *iface)
         return IDirect3DBaseTexture9_Release(&surface->texture->IDirect3DBaseTexture9_iface);
     }
 
+    if (!surface->resource.refcount)
+    {
+        ERR("Surface doesn't have any references.\n");
+        return 0;
+    }
+
     refcount = InterlockedDecrement(&surface->resource.refcount);
     TRACE("%p decreasing refcount to %u.\n", iface, refcount);
 
@@ -349,7 +355,7 @@ void surface_init(struct d3d9_surface *surface, IUnknown *container_parent,
         struct wined3d_surface *wined3d_surface, const struct wined3d_parent_ops **parent_ops)
 {
     struct wined3d_resource_desc desc;
-    IDirect3DBaseTexture9 *texture;
+    IDirect3DBaseTexture9 *texture = NULL;
 
     surface->IDirect3DSurface9_iface.lpVtbl = &d3d9_surface_vtbl;
     d3d9_resource_init(&surface->resource);
@@ -389,6 +395,10 @@ static void STDMETHODCALLTYPE view_wined3d_object_destroyed(void *parent)
 {
     struct d3d9_surface *surface = parent;
 
+  if (!surface) {
+    return;
+  }
+
     /* If the surface reference count drops to zero, we release our reference
      * to the view, but don't clear the pointer yet, in case e.g. a
      * GetRenderTarget() call brings the surface back before the view is
@@ -411,6 +421,10 @@ struct wined3d_rendertarget_view *d3d9_surface_get_rendertarget_view(struct d3d9
 {
     HRESULT hr;
 
+  if (!surface) {
+    return NULL;
+  }
+
     if (surface->wined3d_rtv)
         return surface->wined3d_rtv;
 
diff --git a/dlls/d3d9/tests/d3d9ex.c b/dlls/d3d9/tests/d3d9ex.c
index 0a7fe90..8048bdc 100644
--- a/dlls/d3d9/tests/d3d9ex.c
+++ b/dlls/d3d9/tests/d3d9ex.c
@@ -2160,10 +2160,11 @@ static void test_wndproc(void)
         }
     }
 
+    IDirect3D9Ex_Release(d3d9ex);
+
     if (!d3d_width)
     {
         skip("Could not find adequate modes, skipping mode tests.\n");
-        IDirect3D9Ex_Release(d3d9ex);
         return;
     }
 
diff --git a/dlls/d3d9/tests/device.c b/dlls/d3d9/tests/device.c
index 4d48ea8..705a85f 100644
--- a/dlls/d3d9/tests/device.c
+++ b/dlls/d3d9/tests/device.c
@@ -2199,6 +2199,8 @@ static void test_display_modes(void)
     TEST_FMT(D3DFMT_R8G8_B8G8, D3DERR_INVALIDCALL);
 
     TEST_FMT(D3DFMT_D16_LOCKABLE, D3DERR_INVALIDCALL);
+    TEST_FMT(D3DFMT_D32_LOCKABLE, D3DERR_INVALIDCALL);
+    TEST_FMT(D3DFMT_S8_LOCKABLE, D3DERR_INVALIDCALL);
     TEST_FMT(D3DFMT_D32, D3DERR_INVALIDCALL);
     TEST_FMT(D3DFMT_D15S1, D3DERR_INVALIDCALL);
     TEST_FMT(D3DFMT_D24S8, D3DERR_INVALIDCALL);
@@ -7788,8 +7790,14 @@ static void test_surface_blocks(void)
                     break;
 
                 default:
+                    hr = E_FAIL;
                     break;
             }
+            if (FAILED(hr))
+            {
+                skip("Failed to create surface, skipping tests.\n");
+                continue;
+            }
 
             if (formats[i].block_width > 1)
             {
@@ -8670,6 +8678,11 @@ static void test_volume_blocks(void)
         hr = IDirect3DDevice9_CreateVolumeTexture(device, 24, 8, 8, 1, 0,
                 formats[i].fmt, D3DPOOL_SCRATCH, &texture, NULL);
         ok(SUCCEEDED(hr), "Failed to create volume texture, hr %#x.\n", hr);
+        if (FAILED(hr))
+        {
+            skip("Failed to create texture, skipping tests.\n");
+            continue;
+        }
 
         /* Test lockrect offset */
         for (j = 0; j < sizeof(offset_tests) / sizeof(*offset_tests); j++)
@@ -9161,37 +9174,37 @@ static void test_pixel_format(void)
     }
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice9_SetFVF(device, D3DFVF_XYZ);
     ok(SUCCEEDED(hr), "Failed to set FVF, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice9_BeginScene(device);
     ok(SUCCEEDED(hr), "BeginScene failed %#x\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice9_DrawPrimitiveUP(device, D3DPT_POINTLIST, 1, point, 3 * sizeof(float));
     ok(SUCCEEDED(hr), "Failed to draw, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice9_EndScene(device);
     ok(SUCCEEDED(hr), "EndScene failed %#x\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Present failed %#x\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -9199,10 +9212,10 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Present failed %#x\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
     }
 
 cleanup:
diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
index 518a48a..43b804a 100644
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -28,6 +28,8 @@
  * causes visible results in games can be tested in a way that does not depend on pixel exactness
  */
 
+#include <math.h>
+
 #define COBJMACROS
 #include <d3d9.h>
 #include "wine/test.h"
@@ -262,6 +264,7 @@ static void lighting_test(void)
     ULONG refcount;
     HWND window;
     HRESULT hr;
+    unsigned int i;
 
     static const D3DMATRIX mat =
     {{{
@@ -275,7 +278,7 @@ static void lighting_test(void)
         1.0f, 0.0f, 1.0f, 0.0f,
         0.0f, 1.0f, 0.0f, 0.0f,
         1.0f, 0.0f, 1.0f, 0.0f,
-        0.0f, 0.0f, 0.0f, 1.0f,
+        0.0f, 0.0f, 0.5f, 1.0f,
     }}},
     mat_transf =
     {{{
@@ -283,6 +286,13 @@ static void lighting_test(void)
          0.0f,  1.0f,  0.0f, 0.0f,
         -1.0f,  0.0f,  0.0f, 0.0f,
          10.f, 10.0f, 10.0f, 1.0f,
+    }}},
+    mat_nonaffine =
+    {{{
+        1.0f,  0.0f,  0.0f,  0.0f,
+        0.0f,  1.0f,  0.0f,  0.0f,
+        0.0f,  0.0f,  1.0f, -1.0f,
+        10.f, 10.0f, 10.0f,  0.0f,
     }}};
     static const struct
     {
@@ -343,8 +353,30 @@ static void lighting_test(void)
         {{-10.0f,  -9.0f, 11.0f}, {-1.0f, 0.0f, 0.0f}, 0xff0000ff},
         {{-10.0f,  -9.0f,  9.0f}, {-1.0f, 0.0f, 0.0f}, 0xff0000ff},
         {{-10.0f, -11.0f,  9.0f}, {-1.0f, 0.0f, 0.0f}, 0xff0000ff},
+    },
+    translatedquad[] =
+    {
+        {{-11.0f, -11.0f, -10.0f}, {0.0f, 0.0f, -1.0f}, 0xff0000ff},
+        {{-11.0f,  -9.0f, -10.0f}, {0.0f, 0.0f, -1.0f}, 0xff0000ff},
+        {{ -9.0f,  -9.0f, -10.0f}, {0.0f, 0.0f, -1.0f}, 0xff0000ff},
+        {{ -9.0f, -11.0f, -10.0f}, {0.0f, 0.0f, -1.0f}, 0xff0000ff},
     };
     static const WORD indices[] = {0, 1, 2, 2, 3, 0};
+    static const struct
+    {
+        const D3DMATRIX *world_matrix;
+        const void *quad;
+        unsigned int size;
+        DWORD expected;
+        const char *message;
+    }
+    tests[] =
+    {
+        {&mat, nquad, sizeof(nquad[0]), 0x000000ff, "Lit quad with light"},
+        {&mat_singular, nquad, sizeof(nquad[0]), 0x000000ff, "Lit quad with singular world matrix"},
+        {&mat_transf, rotatedquad, sizeof(rotatedquad[0]), 0x000000ff, "Lit quad with transformation matrix"},
+        {&mat_nonaffine, translatedquad, sizeof(translatedquad[0]), 0x00000000, "Lit quad with non-affine matrix"},
+    };
 
     window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
             0, 0, 640, 480, NULL, NULL, NULL, NULL);
@@ -424,49 +456,12 @@ static void lighting_test(void)
 
     IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
 
-    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_LIGHTING, TRUE);
-    ok(SUCCEEDED(hr), "Failed to enable lighting, hr %#x.\n", hr);
     hr = IDirect3DDevice9_LightEnable(device, 0, TRUE);
     ok(SUCCEEDED(hr), "Failed to enable light 0, hr %#x.\n", hr);
 
-    hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffffffff, 0.0, 0);
-    ok(SUCCEEDED(hr), "Failed to clear, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_BeginScene(device);
-    ok(SUCCEEDED(hr), "Failed to begin scene, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_DrawIndexedPrimitiveUP(device, D3DPT_TRIANGLELIST, 0, 4,
-            2, indices, D3DFMT_INDEX16, nquad, sizeof(nquad[0]));
-    ok(SUCCEEDED(hr), "Failed to draw, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_EndScene(device);
-    ok(SUCCEEDED(hr), "Failed to end scene, hr %#x.\n", hr);
-
-    color = getPixelColor(device, 320, 240);
-    ok(color == 0x000000ff, "Lit quad with light has color 0x%08x.\n", color);
-
-    hr = IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, &mat_singular);
-    ok(SUCCEEDED(hr), "Failed to set world transform, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffffffff, 0.0, 0);
-    ok(SUCCEEDED(hr), "Failed to clear, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_BeginScene(device);
-    ok(SUCCEEDED(hr), "Failed to begin scene, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_DrawIndexedPrimitiveUP(device, D3DPT_TRIANGLELIST, 0, 4,
-            2, indices, D3DFMT_INDEX16, nquad, sizeof(nquad[0]));
-    ok(SUCCEEDED(hr), "Failed to draw, hr %#x.\n", hr);
-
-    hr = IDirect3DDevice9_EndScene(device);
-    ok(SUCCEEDED(hr), "Failed to end scene, hr %#x.\n", hr);
-
-    color = getPixelColor(device, 160, 240);
-    ok(color == 0x00ffffff, "Cleared area has color 0x%08x.\n", color);
-    color = getPixelColor(device, 480, 240);
-    ok(color == 0x000000ff, "Lit quad with singular world matrix has color 0x%08x.\n", color);
-
-    hr = IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, &mat_transf);
+    for (i = 0; i < sizeof(tests) / sizeof(tests[0]); ++i)
+    {
+        hr = IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, tests[i].world_matrix);
     ok(SUCCEEDED(hr), "Failed to set world transform, hr %#x.\n", hr);
 
     hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffffffff, 0.0, 0);
@@ -476,14 +471,15 @@ static void lighting_test(void)
     ok(SUCCEEDED(hr), "Failed to begin scene, hr %#x.\n", hr);
 
     hr = IDirect3DDevice9_DrawIndexedPrimitiveUP(device, D3DPT_TRIANGLELIST, 0, 4,
-            2, indices, D3DFMT_INDEX16, rotatedquad, sizeof(rotatedquad[0]));
+                2, indices, D3DFMT_INDEX16, tests[i].quad, tests[i].size);
     ok(SUCCEEDED(hr), "Failed to draw, hr %#x.\n", hr);
 
     hr = IDirect3DDevice9_EndScene(device);
     ok(SUCCEEDED(hr), "Failed to end scene, hr %#x.\n", hr);
 
     color = getPixelColor(device, 320, 240);
-    ok(color == 0x000000ff, "Lit quad with transformation matrix has color 0x%08x.\n", color);
+        ok(color == tests[i].expected, "%s has color 0x%08x.\n", tests[i].message, color);
+    }
 
     hr = IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, &mat);
     ok(SUCCEEDED(hr), "Failed to set world transform, hr %#x.\n", hr);
@@ -543,6 +539,302 @@ done:
     DestroyWindow(window);
 }
 
+static void test_specular_lighting(void)
+{
+    static const unsigned int vertices_side = 5;
+    const unsigned int indices_count = (vertices_side - 1) * (vertices_side - 1) * 2 * 3;
+    static const DWORD fvf = D3DFVF_XYZ | D3DFVF_NORMAL;
+    static const D3DMATRIX mat =
+    {{{
+        1.0f, 0.0f, 0.0f, 0.0f,
+        0.0f, 1.0f, 0.0f, 0.0f,
+        0.0f, 0.0f, 1.0f, 0.0f,
+        0.0f, 0.0f, 0.0f, 1.0f,
+    }}};
+    static const D3DLIGHT9 directional =
+    {
+        D3DLIGHT_DIRECTIONAL,
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {1.0f, 1.0f, 1.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 1.0f},
+    },
+    point =
+    {
+        D3DLIGHT_POINT,
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {1.0f, 1.0f, 1.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f},
+        100.0f,
+        0.0f,
+        0.0f, 0.0f, 1.0f,
+    },
+    spot =
+    {
+        D3DLIGHT_SPOT,
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {1.0f, 1.0f, 1.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 1.0f},
+        100.0f,
+        1.0f,
+        0.0f, 0.0f, 1.0f,
+        M_PI / 12.0f, M_PI / 3.0f
+    },
+    /* The chosen range value makes the test fail when using a manhattan
+     * distance metric vs the correct euclidean distance. */
+    point_range =
+    {
+        D3DLIGHT_POINT,
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {1.0f, 1.0f, 1.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f},
+        {0.0f, 0.0f, 0.0f},
+        1.2f,
+        0.0f,
+        0.0f, 0.0f, 1.0f,
+    };
+    static const struct expected_color
+    {
+        unsigned int x, y;
+        D3DCOLOR color;
+    }
+    expected_directional[] =
+    {
+        {160, 120, 0x00ffffff},
+        {320, 120, 0x00ffffff},
+        {480, 120, 0x00ffffff},
+        {160, 240, 0x00ffffff},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x00ffffff},
+        {160, 360, 0x00ffffff},
+        {320, 360, 0x00ffffff},
+        {480, 360, 0x00ffffff},
+    },
+    expected_directional_local[] =
+    {
+        {160, 120, 0x003c3c3c},
+        {320, 120, 0x00717171},
+        {480, 120, 0x003c3c3c},
+        {160, 240, 0x00717171},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x00717171},
+        {160, 360, 0x003c3c3c},
+        {320, 360, 0x00717171},
+        {480, 360, 0x003c3c3c},
+    },
+    expected_point[] =
+    {
+        {160, 120, 0x00282828},
+        {320, 120, 0x005a5a5a},
+        {480, 120, 0x00282828},
+        {160, 240, 0x005a5a5a},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x005a5a5a},
+        {160, 360, 0x00282828},
+        {320, 360, 0x005a5a5a},
+        {480, 360, 0x00282828},
+    },
+    expected_point_local[] =
+    {
+        {160, 120, 0x00000000},
+        {320, 120, 0x00070707},
+        {480, 120, 0x00000000},
+        {160, 240, 0x00070707},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x00070707},
+        {160, 360, 0x00000000},
+        {320, 360, 0x00070707},
+        {480, 360, 0x00000000},
+    },
+    expected_spot[] =
+    {
+        {160, 120, 0x00000000},
+        {320, 120, 0x00141414},
+        {480, 120, 0x00000000},
+        {160, 240, 0x00141414},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x00141414},
+        {160, 360, 0x00000000},
+        {320, 360, 0x00141414},
+        {480, 360, 0x00000000},
+    },
+    expected_spot_local[] =
+    {
+        {160, 120, 0x00000000},
+        {320, 120, 0x00020202},
+        {480, 120, 0x00000000},
+        {160, 240, 0x00020202},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x00020202},
+        {160, 360, 0x00000000},
+        {320, 360, 0x00020202},
+        {480, 360, 0x00000000},
+    },
+    expected_point_range[] =
+    {
+        {160, 120, 0x00000000},
+        {320, 120, 0x005a5a5a},
+        {480, 120, 0x00000000},
+        {160, 240, 0x005a5a5a},
+        {320, 240, 0x00ffffff},
+        {480, 240, 0x005a5a5a},
+        {160, 360, 0x00000000},
+        {320, 360, 0x005a5a5a},
+        {480, 360, 0x00000000},
+    };
+    static const struct
+    {
+        const D3DLIGHT9 *light;
+        BOOL local_viewer;
+        const struct expected_color *expected;
+        unsigned int expected_count;
+    }
+    tests[] =
+    {
+        {&directional, FALSE, expected_directional,
+                sizeof(expected_directional) / sizeof(expected_directional[0])},
+        {&directional, TRUE, expected_directional_local,
+                sizeof(expected_directional_local) / sizeof(expected_directional_local[0])},
+        {&point, FALSE, expected_point,
+                sizeof(expected_point) / sizeof(expected_point[0])},
+        {&point, TRUE, expected_point_local,
+                sizeof(expected_point_local) / sizeof(expected_point_local[0])},
+        {&spot, FALSE, expected_spot,
+                sizeof(expected_spot) / sizeof(expected_spot[0])},
+        {&spot, TRUE, expected_spot_local,
+                sizeof(expected_spot_local) / sizeof(expected_spot_local[0])},
+        {&point_range, FALSE, expected_point_range,
+                sizeof(expected_point_range) / sizeof(expected_point_range[0])},
+    };
+    IDirect3DDevice9 *device;
+    D3DMATERIAL9 material;
+    IDirect3D9 *d3d;
+    D3DCOLOR color;
+    ULONG refcount;
+    HWND window;
+    HRESULT hr;
+    unsigned int i, j, x, y;
+    struct
+    {
+        struct vec3 position;
+        struct vec3 normal;
+    } *quad;
+    WORD *indices;
+
+    quad = HeapAlloc(GetProcessHeap(), 0, vertices_side * vertices_side * sizeof(*quad));
+    indices = HeapAlloc(GetProcessHeap(), 0, indices_count * sizeof(*indices));
+    for (i = 0, y = 0; y < vertices_side; ++y)
+    {
+        for (x = 0; x < vertices_side; ++x)
+        {
+            quad[i].position.x = x * 2.0f / (vertices_side - 1) - 1.0f;
+            quad[i].position.y = y * 2.0f / (vertices_side - 1) - 1.0f;
+            quad[i].position.z = 1.0f;
+            quad[i].normal.x = 0.0f;
+            quad[i].normal.y = 0.0f;
+            quad[i++].normal.z = -1.0f;
+        }
+    }
+    for (i = 0, y = 0; y < (vertices_side - 1); ++y)
+    {
+        for (x = 0; x < (vertices_side - 1); ++x)
+        {
+            indices[i++] = y * vertices_side + x + 1;
+            indices[i++] = y * vertices_side + x;
+            indices[i++] = (y + 1) * vertices_side + x;
+            indices[i++] = y * vertices_side + x + 1;
+            indices[i++] = (y + 1) * vertices_side + x;
+            indices[i++] = (y + 1) * vertices_side + x + 1;
+        }
+    }
+
+    window = CreateWindowA("static", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    d3d = Direct3DCreate9(D3D_SDK_VERSION);
+    ok(!!d3d, "Failed to create a D3D object.\n");
+    if (!(device = create_device(d3d, window, window, TRUE)))
+    {
+        skip("Failed to create a D3D device, skipping tests.\n");
+        goto done;
+    }
+
+    hr = IDirect3DDevice9_SetTransform(device, D3DTS_WORLD, &mat);
+    ok(SUCCEEDED(hr), "Failed to set world transform, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_SetTransform(device, D3DTS_VIEW, &mat);
+    ok(SUCCEEDED(hr), "Failed to set view transform, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_SetTransform(device, D3DTS_PROJECTION, &mat);
+    ok(SUCCEEDED(hr), "Failed to set projection transform, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_CLIPPING, FALSE);
+    ok(SUCCEEDED(hr), "Failed to disable clipping, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_ZENABLE, FALSE);
+    ok(SUCCEEDED(hr), "Failed to disable z test, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_FOGENABLE, FALSE);
+    ok(SUCCEEDED(hr), "Failed to disable fog, hr %#x.\n", hr);
+
+    hr = IDirect3DDevice9_SetFVF(device, fvf);
+    ok(SUCCEEDED(hr), "Failed to set FVF, hr %#x.\n", hr);
+
+    memset(&material, 0, sizeof(material));
+    material.Specular.r = 1.0f;
+    material.Specular.g = 1.0f;
+    material.Specular.b = 1.0f;
+    material.Specular.a = 1.0f;
+    material.Power = 30.0f;
+    hr = IDirect3DDevice9_SetMaterial(device, &material);
+    ok(SUCCEEDED(hr), "Failed to set material, hr %#x.\n", hr);
+
+    hr = IDirect3DDevice9_LightEnable(device, 0, TRUE);
+    ok(SUCCEEDED(hr), "Failed to enable light 0, hr %#x.\n", hr);
+    hr = IDirect3DDevice9_SetRenderState(device, D3DRS_SPECULARENABLE, TRUE);
+    ok(SUCCEEDED(hr), "Failed to enable specular lighting, hr %#x.\n", hr);
+
+    for (i = 0; i < sizeof(tests) / sizeof(tests[0]); ++i)
+    {
+        hr = IDirect3DDevice9_SetLight(device, 0, tests[i].light);
+        ok(SUCCEEDED(hr), "Failed to set light parameters, hr %#x.\n", hr);
+
+        hr = IDirect3DDevice9_SetRenderState(device, D3DRS_LOCALVIEWER, tests[i].local_viewer);
+        ok(SUCCEEDED(hr), "Failed to set local viewer state, hr %#x.\n", hr);
+
+        hr = IDirect3DDevice9_Clear(device, 0, NULL, D3DCLEAR_TARGET, 0xffffffff, 0.0, 0);
+        ok(SUCCEEDED(hr), "Failed to clear, hr %#x.\n", hr);
+
+        hr = IDirect3DDevice9_BeginScene(device);
+        ok(SUCCEEDED(hr), "Failed to begin scene, hr %#x.\n", hr);
+
+        hr = IDirect3DDevice9_DrawIndexedPrimitiveUP(device, D3DPT_TRIANGLELIST,
+                0, vertices_side * vertices_side, indices_count / 3, indices,
+                D3DFMT_INDEX16, quad, sizeof(quad[0]));
+        ok(SUCCEEDED(hr), "Failed to draw, hr %#x.\n", hr);
+
+        hr = IDirect3DDevice9_EndScene(device);
+        ok(SUCCEEDED(hr), "Failed to end scene, hr %#x.\n", hr);
+
+        for (j = 0; j < tests[i].expected_count; ++j)
+        {
+            color = getPixelColor(device, tests[i].expected[j].x, tests[i].expected[j].y);
+            ok(color_match(color, tests[i].expected[j].color, 1),
+                    "Expected color 0x%08x at location (%u, %u), got 0x%08x, case %u.\n",
+                    tests[i].expected[j].color, tests[i].expected[j].x,
+                    tests[i].expected[j].y, color, i);
+        }
+    }
+
+    refcount = IDirect3DDevice9_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+done:
+    IDirect3D9_Release(d3d);
+    DestroyWindow(window);
+    HeapFree(GetProcessHeap(), 0, indices);
+    HeapFree(GetProcessHeap(), 0, quad);
+}
+
 static void clear_test(void)
 {
     /* Tests the correctness of clearing parameters */
@@ -11254,7 +11546,7 @@ static void yuv_layout_test(void)
     IDirect3D9 *d3d;
     D3DCOLOR color;
     DWORD ref_color;
-    BYTE *buf, *chroma_buf, *u_buf, *v_buf;
+    BYTE *buf, *chroma_buf, *u_buf = NULL, *v_buf = NULL;
     UINT width = 20, height = 16;
     IDirect3DDevice9 *device;
     ULONG refcount;
@@ -16585,7 +16877,11 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
+#if defined(STAGING_CSMT)
+    todo_wine ok(color_match(color, 0x00ff0000, 1),
+#else  /* STAGING_CSMT */
     ok(color_match(color, 0x00ff0000, 1),
+#endif /* STAGING_CSMT */
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
@@ -18000,6 +18296,7 @@ START_TEST(visual)
     depth_clamp_test();
     stretchrect_test();
     lighting_test();
+    test_specular_lighting();
     clear_test();
     color_fill_test();
     fog_test();
diff --git a/dlls/d3d9/texture.c b/dlls/d3d9/texture.c
index c1a0277..d339a25 100644
--- a/dlls/d3d9/texture.c
+++ b/dlls/d3d9/texture.c
@@ -273,6 +273,10 @@ static D3DTEXTUREFILTERTYPE WINAPI d3d9_texture_2d_GetAutoGenFilterType(IDirect3
 
 static void WINAPI d3d9_texture_2d_GenerateMipSubLevels(IDirect3DTexture9 *iface)
 {
+/*  An application can generate mipmap sublevels at any time by calling GenerateMipSubLevels.
+    To have mipmap sublevels generated automatically at texture creation time (see Automatic Generation of Mipmaps (Direct3D 9)),
+    specify D3DUSAGE_AUTOGENMIPMAP during CreateTexture, CreateCubeTexture, and CreateVolumeTexture.
+    For more information about usage constants, see D3DUSAGE. */
     struct d3d9_texture *texture = impl_from_IDirect3DTexture9(iface);
 
     TRACE("iface %p.\n", iface);
@@ -1174,6 +1178,11 @@ static HRESULT WINAPI d3d9_texture_3d_LockBox(IDirect3DVolumeTexture9 *iface,
     else
     {
         volume_impl = wined3d_resource_get_parent(sub_resource);
+        if (!volume_impl) {
+          wined3d_mutex_unlock();
+          ERR("no volume from sub_resource\n");
+          return D3DERR_INVALIDCALL;
+        }
         hr = IDirect3DVolume9_LockBox(&volume_impl->IDirect3DVolume9_iface, locked_box, box, flags);
     }
     wined3d_mutex_unlock();
diff --git a/dlls/d3d9/vertexdeclaration.c b/dlls/d3d9/vertexdeclaration.c
index cc7998d..f36f50a 100644
--- a/dlls/d3d9/vertexdeclaration.c
+++ b/dlls/d3d9/vertexdeclaration.c
@@ -322,7 +322,7 @@ static const struct wined3d_parent_ops d3d9_vertexdeclaration_wined3d_parent_ops
 static HRESULT convert_to_wined3d_declaration(const D3DVERTEXELEMENT9 *d3d9_elements,
         struct wined3d_vertex_element **wined3d_elements, UINT *element_count)
 {
-    const D3DVERTEXELEMENT9* element;
+    D3DVERTEXELEMENT9* element;
     UINT count = 1;
     UINT i;
 
diff --git a/dlls/d3d9/volume.c b/dlls/d3d9/volume.c
index 4b22f20..5a67ac1 100644
--- a/dlls/d3d9/volume.c
+++ b/dlls/d3d9/volume.c
@@ -146,7 +146,7 @@ static HRESULT WINAPI d3d9_volume_LockBox(IDirect3DVolume9 *iface,
 
     TRACE("iface %p, locked_box %p, box %p, flags %#x.\n",
             iface, locked_box, box, flags);
-
+//trace:d3d9:d3d9_volume_LockBox iface 0x17ca50, locked_box 0x33f63c, box 0x0, flags 0x2000. WINED3D_MAP_DISCARD
     wined3d_mutex_lock();
     hr = wined3d_volume_map(volume->wined3d_volume, &map_desc, (const struct wined3d_box *)box, flags);
     wined3d_mutex_unlock();
diff --git a/dlls/d3drm/d3drm.spec b/dlls/d3drm/d3drm.spec
index 4108a72..e83fb0b 100644
--- a/dlls/d3drm/d3drm.spec
+++ b/dlls/d3drm/d3drm.spec
@@ -19,5 +19,5 @@
 @ stdcall D3DRMVectorScale(ptr ptr float)
 @ stdcall D3DRMVectorSubtract(ptr ptr ptr)
 @ stdcall Direct3DRMCreate(ptr)
-@ stub DllCanUnloadNow
-@ stub DllGetClassObject
+@ stub -private DllCanUnloadNow
+@ stub -private DllGetClassObject
diff --git a/dlls/d3dx9_24/d3dx9_24.spec b/dlls/d3dx9_24/d3dx9_24.spec
index f111618..6c8741a 100644
--- a/dlls/d3dx9_24/d3dx9_24.spec
+++ b/dlls/d3dx9_24/d3dx9_24.spec
@@ -22,7 +22,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
@@ -43,21 +43,21 @@
 @ stdcall D3DXCreateCubeTextureFromResourceExW(ptr long long long long long long long long long long ptr ptr ptr) d3dx9_36.D3DXCreateCubeTextureFromResourceExW
 @ stdcall D3DXCreateCubeTextureFromResourceW(ptr long ptr ptr) d3dx9_36.D3DXCreateCubeTextureFromResourceW
 @ stdcall D3DXCreateCylinder(ptr long long long long long ptr ptr) d3dx9_36.D3DXCreateCylinder
-@ stdcall D3DXCreateEffect(ptr ptr long ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffect
+@ stdcall D3DXCreateEffect(ptr ptr long ptr ptr long ptr ptr ptr) d3dx9_25.D3DXCreateEffect
 @ stdcall D3DXCreateEffectCompiler(ptr long ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompiler
 @ stdcall D3DXCreateEffectCompilerFromFileA(str ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromFileA
 @ stdcall D3DXCreateEffectCompilerFromFileW(wstr ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromFileW
 @ stdcall D3DXCreateEffectCompilerFromResourceA(long str ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromResourceA
 @ stdcall D3DXCreateEffectCompilerFromResourceW(long wstr ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromResourceW
-@ stdcall D3DXCreateEffectEx(ptr ptr long ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectEx
-@ stdcall D3DXCreateEffectFromFileA(ptr str ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileA
-@ stdcall D3DXCreateEffectFromFileExA(ptr str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileExA
-@ stdcall D3DXCreateEffectFromFileExW(ptr str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileExW
-@ stdcall D3DXCreateEffectFromFileW(ptr wstr ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileW
-@ stdcall D3DXCreateEffectFromResourceA(ptr long str ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceA
-@ stdcall D3DXCreateEffectFromResourceExA(ptr long str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceExA
-@ stdcall D3DXCreateEffectFromResourceExW(ptr long str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceExW
-@ stdcall D3DXCreateEffectFromResourceW(ptr long wstr ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceW
+@ stdcall D3DXCreateEffectEx(ptr ptr long ptr ptr str long ptr ptr ptr) d3dx9_25.D3DXCreateEffectEx
+@ stdcall D3DXCreateEffectFromFileA(ptr str ptr ptr long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromFileA
+@ stdcall D3DXCreateEffectFromFileExA(ptr str ptr ptr str long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromFileExA
+@ stdcall D3DXCreateEffectFromFileExW(ptr str ptr ptr str long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromFileExW
+@ stdcall D3DXCreateEffectFromFileW(ptr wstr ptr ptr long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromFileW
+@ stdcall D3DXCreateEffectFromResourceA(ptr long str ptr ptr long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromResourceA
+@ stdcall D3DXCreateEffectFromResourceExA(ptr long str ptr ptr str long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromResourceExA
+@ stdcall D3DXCreateEffectFromResourceExW(ptr long str ptr ptr str long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromResourceExW
+@ stdcall D3DXCreateEffectFromResourceW(ptr long wstr ptr ptr long ptr ptr ptr) d3dx9_25.D3DXCreateEffectFromResourceW
 @ stdcall D3DXCreateEffectPool(ptr) d3dx9_36.D3DXCreateEffectPool
 @ stdcall D3DXCreateFontA(ptr long long long long long long long long long str ptr) d3dx9_36.D3DXCreateFontA
 @ stdcall D3DXCreateFontIndirectA(ptr ptr ptr) d3dx9_36.D3DXCreateFontIndirectA
@@ -115,7 +115,7 @@
 @ stdcall D3DXCreateVolumeTextureFromResourceW(ptr long ptr ptr) d3dx9_36.D3DXCreateVolumeTextureFromResourceW
 @ stdcall D3DXDebugMute(long) d3dx9_36.D3DXDebugMute
 @ stdcall D3DXDeclaratorFromFVF(long ptr) d3dx9_36.D3DXDeclaratorFromFVF
-@ stdcall D3DXDisassembleEffect(ptr long ptr) d3dx9_36.D3DXDisassembleEffect
+@ stdcall D3DXDisassembleEffect(ptr long ptr) d3dx9_25.D3DXDisassembleEffect
 @ stdcall D3DXDisassembleShader(ptr long str ptr) d3dx9_36.D3DXDisassembleShader
 @ stdcall D3DXFileCreate(ptr) d3dx9_36.D3DXFileCreate
 @ stdcall D3DXFillCubeTexture(ptr ptr ptr) d3dx9_36.D3DXFillCubeTexture
diff --git a/dlls/d3dx9_25/Makefile.in b/dlls/d3dx9_25/Makefile.in
index a41cbc2..79e1c6b 100644
--- a/dlls/d3dx9_25/Makefile.in
+++ b/dlls/d3dx9_25/Makefile.in
@@ -1,7 +1,8 @@
 MODULE    = d3dx9_25.dll
-IMPORTS   = d3d9
+IMPORTS   = d3d9 d3dx9
 
 C_SRCS = \
-	d3dx9_25_main.c
+	d3dx9_25_main.c \
+	effect.c
 
 RC_SRCS = version.rc
diff --git a/dlls/d3dx9_25/d3dx9_25.spec b/dlls/d3dx9_25/d3dx9_25.spec
index c328108..498da0d 100644
--- a/dlls/d3dx9_25/d3dx9_25.spec
+++ b/dlls/d3dx9_25/d3dx9_25.spec
@@ -22,7 +22,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
@@ -43,21 +43,21 @@
 @ stdcall D3DXCreateCubeTextureFromResourceExW(ptr long long long long long long long long long long ptr ptr ptr) d3dx9_36.D3DXCreateCubeTextureFromResourceExW
 @ stdcall D3DXCreateCubeTextureFromResourceW(ptr long ptr ptr) d3dx9_36.D3DXCreateCubeTextureFromResourceW
 @ stdcall D3DXCreateCylinder(ptr long long long long long ptr ptr) d3dx9_36.D3DXCreateCylinder
-@ stdcall D3DXCreateEffect(ptr ptr long ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffect
+@ stdcall D3DXCreateEffect(ptr ptr long ptr ptr long ptr ptr ptr) D3DXCreateEffect25
 @ stdcall D3DXCreateEffectCompiler(ptr long ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompiler
 @ stdcall D3DXCreateEffectCompilerFromFileA(str ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromFileA
 @ stdcall D3DXCreateEffectCompilerFromFileW(wstr ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromFileW
 @ stdcall D3DXCreateEffectCompilerFromResourceA(long str ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromResourceA
 @ stdcall D3DXCreateEffectCompilerFromResourceW(long wstr ptr ptr long ptr ptr) d3dx9_36.D3DXCreateEffectCompilerFromResourceW
-@ stdcall D3DXCreateEffectEx(ptr ptr long ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectEx
-@ stdcall D3DXCreateEffectFromFileA(ptr str ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileA
-@ stdcall D3DXCreateEffectFromFileExA(ptr str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileExA
-@ stdcall D3DXCreateEffectFromFileExW(ptr str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileExW
-@ stdcall D3DXCreateEffectFromFileW(ptr wstr ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromFileW
-@ stdcall D3DXCreateEffectFromResourceA(ptr long str ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceA
-@ stdcall D3DXCreateEffectFromResourceExA(ptr long str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceExA
-@ stdcall D3DXCreateEffectFromResourceExW(ptr long str ptr ptr str long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceExW
-@ stdcall D3DXCreateEffectFromResourceW(ptr long wstr ptr ptr long ptr ptr ptr) d3dx9_36.D3DXCreateEffectFromResourceW
+@ stdcall D3DXCreateEffectEx(ptr ptr long ptr ptr str long ptr ptr ptr) D3DXCreateEffectEx25
+@ stdcall D3DXCreateEffectFromFileA(ptr str ptr ptr long ptr ptr ptr) D3DXCreateEffectFromFileA25
+@ stdcall D3DXCreateEffectFromFileExA(ptr str ptr ptr str long ptr ptr ptr) D3DXCreateEffectFromFileExA25
+@ stdcall D3DXCreateEffectFromFileExW(ptr str ptr ptr str long ptr ptr ptr) D3DXCreateEffectFromFileExW25
+@ stdcall D3DXCreateEffectFromFileW(ptr wstr ptr ptr long ptr ptr ptr) D3DXCreateEffectFromFileW25
+@ stdcall D3DXCreateEffectFromResourceA(ptr long str ptr ptr long ptr ptr ptr) D3DXCreateEffectFromResourceA25
+@ stdcall D3DXCreateEffectFromResourceExA(ptr long str ptr ptr str long ptr ptr ptr) D3DXCreateEffectFromResourceExA25
+@ stdcall D3DXCreateEffectFromResourceExW(ptr long str ptr ptr str long ptr ptr ptr) D3DXCreateEffectFromResourceExW25
+@ stdcall D3DXCreateEffectFromResourceW(ptr long wstr ptr ptr long ptr ptr ptr) D3DXCreateEffectFromResourceW25
 @ stdcall D3DXCreateEffectPool(ptr) d3dx9_36.D3DXCreateEffectPool
 @ stdcall D3DXCreateFontA(ptr long long long long long long long long long str ptr) d3dx9_36.D3DXCreateFontA
 @ stdcall D3DXCreateFontIndirectA(ptr ptr ptr) d3dx9_36.D3DXCreateFontIndirectA
@@ -115,7 +115,7 @@
 @ stdcall D3DXCreateVolumeTextureFromResourceW(ptr long ptr ptr) d3dx9_36.D3DXCreateVolumeTextureFromResourceW
 @ stdcall D3DXDebugMute(long) d3dx9_36.D3DXDebugMute
 @ stdcall D3DXDeclaratorFromFVF(long ptr) d3dx9_36.D3DXDeclaratorFromFVF
-@ stdcall D3DXDisassembleEffect(ptr long ptr) d3dx9_36.D3DXDisassembleEffect
+@ stdcall D3DXDisassembleEffect(ptr long ptr) D3DXDisassembleEffect25
 @ stdcall D3DXDisassembleShader(ptr long str ptr) d3dx9_36.D3DXDisassembleShader
 @ stdcall D3DXFileCreate(ptr) d3dx9_36.D3DXFileCreate
 @ stdcall D3DXFillCubeTexture(ptr ptr ptr) d3dx9_36.D3DXFillCubeTexture
diff --git a/dlls/d3dx9_26/d3dx9_26.spec b/dlls/d3dx9_26/d3dx9_26.spec
index 4c469d6..1d7b802 100644
--- a/dlls/d3dx9_26/d3dx9_26.spec
+++ b/dlls/d3dx9_26/d3dx9_26.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_27/d3dx9_27.spec b/dlls/d3dx9_27/d3dx9_27.spec
index 4c469d6..1d7b802 100644
--- a/dlls/d3dx9_27/d3dx9_27.spec
+++ b/dlls/d3dx9_27/d3dx9_27.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_28/d3dx9_28.spec b/dlls/d3dx9_28/d3dx9_28.spec
index 8e1ea9e..083667c 100644
--- a/dlls/d3dx9_28/d3dx9_28.spec
+++ b/dlls/d3dx9_28/d3dx9_28.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_29/d3dx9_29.spec b/dlls/d3dx9_29/d3dx9_29.spec
index 8e1ea9e..083667c 100644
--- a/dlls/d3dx9_29/d3dx9_29.spec
+++ b/dlls/d3dx9_29/d3dx9_29.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_30/d3dx9_30.spec b/dlls/d3dx9_30/d3dx9_30.spec
index 922f1d0..eb39c0f 100644
--- a/dlls/d3dx9_30/d3dx9_30.spec
+++ b/dlls/d3dx9_30/d3dx9_30.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_31/d3dx9_31.spec b/dlls/d3dx9_31/d3dx9_31.spec
index 616dc0a..1667a51 100644
--- a/dlls/d3dx9_31/d3dx9_31.spec
+++ b/dlls/d3dx9_31/d3dx9_31.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_32/d3dx9_32.spec b/dlls/d3dx9_32/d3dx9_32.spec
index d940bde..f1c4b62 100644
--- a/dlls/d3dx9_32/d3dx9_32.spec
+++ b/dlls/d3dx9_32/d3dx9_32.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_33/d3dx9_33.spec b/dlls/d3dx9_33/d3dx9_33.spec
index d940bde..f1c4b62 100644
--- a/dlls/d3dx9_33/d3dx9_33.spec
+++ b/dlls/d3dx9_33/d3dx9_33.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_34/d3dx9_34.spec b/dlls/d3dx9_34/d3dx9_34.spec
index d940bde..f1c4b62 100644
--- a/dlls/d3dx9_34/d3dx9_34.spec
+++ b/dlls/d3dx9_34/d3dx9_34.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_35/d3dx9_35.spec b/dlls/d3dx9_35/d3dx9_35.spec
index d940bde..f1c4b62 100644
--- a/dlls/d3dx9_35/d3dx9_35.spec
+++ b/dlls/d3dx9_35/d3dx9_35.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_36/Makefile.in b/dlls/d3dx9_36/Makefile.in
index 5958c57..fd710c2 100644
--- a/dlls/d3dx9_36/Makefile.in
+++ b/dlls/d3dx9_36/Makefile.in
@@ -1,8 +1,9 @@
 MODULE    = d3dx9_36.dll
 IMPORTLIB = d3dx9
-IMPORTS   = d3d9 d3dcompiler dxguid d3dxof ole32 gdi32 user32
+IMPORTS   = d3d9 d3dcompiler dxguid d3dxof ole32 gdi32 user32 wined3d
 
 C_SRCS = \
+	animation.c \
 	core.c \
 	d3dx9_36_main.c \
 	effect.c \
diff --git a/dlls/d3dx9_36/core.c b/dlls/d3dx9_36/core.c
index 53e9531..f1ae58f 100644
--- a/dlls/d3dx9_36/core.c
+++ b/dlls/d3dx9_36/core.c
@@ -66,7 +66,7 @@ static ULONG WINAPI ID3DXBufferImpl_AddRef(ID3DXBuffer *iface)
     struct ID3DXBufferImpl *This = impl_from_ID3DXBuffer(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
 
-    TRACE("%p increasing refcount to %u\n", This, ref);
+//    TRACE("%p increasing refcount to %u\n", This, ref);
 
     return ref;
 }
@@ -76,7 +76,7 @@ static ULONG WINAPI ID3DXBufferImpl_Release(ID3DXBuffer *iface)
     struct ID3DXBufferImpl *This = impl_from_ID3DXBuffer(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %u\n", This, ref);
+//    TRACE("%p decreasing refcount to %u\n", This, ref);
 
     if (ref == 0)
     {
diff --git a/dlls/d3dx9_36/d3dx9_36.spec b/dlls/d3dx9_36/d3dx9_36.spec
index 15d693c..c3035f8 100644
--- a/dlls/d3dx9_36/d3dx9_36.spec
+++ b/dlls/d3dx9_36/d3dx9_36.spec
@@ -22,15 +22,15 @@
 @ stub D3DXComputeIMTFromPerTexelSignal(ptr long ptr long long long long long ptr ptr ptr)
 @ stub D3DXComputeIMTFromSignal(ptr long long long long ptr ptr ptr ptr ptr)
 @ stub D3DXComputeIMTFromTexture(ptr ptr long long ptr ptr ptr)
-@ stub D3DXComputeNormalMap(ptr ptr ptr long long long)
-@ stub D3DXComputeNormals(ptr ptr)
+@ stdcall D3DXComputeNormalMap(ptr ptr ptr long long float)
+@ stdcall D3DXComputeNormals(ptr ptr)
 @ stub D3DXComputeTangent(ptr long long long long ptr)
 @ stub D3DXComputeTangentFrame(ptr long)
-@ stub D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr)
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr)
 @ stub D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr)
 @ stub D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr)
 @ stub D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr)
-@ stub D3DXCreateAnimationController(long long long long ptr)
+@ stdcall D3DXCreateAnimationController(long long long long ptr)
 @ stdcall D3DXCreateBox(ptr float float float ptr ptr)
 @ stdcall D3DXCreateBuffer(long ptr)
 @ stub D3DXCreateCompressedAnimationSet(ptr long long ptr long ptr ptr)
@@ -135,7 +135,7 @@
 @ stub D3DXFrameAppendChild(ptr ptr)
 @ stub D3DXFrameCalculateBoundingSphere(ptr ptr ptr)
 @ stdcall D3DXFrameDestroy(ptr ptr)
-@ stub D3DXFrameFind(ptr ptr)
+@ stdcall D3DXFrameFind(ptr str)
 @ stub D3DXFrameNumNamedMatrices(ptr)
 @ stub D3DXFrameRegisterNamedMatrices(ptr ptr)
 @ stdcall D3DXFresnelTerm(float float)
@@ -159,13 +159,13 @@
 @ stdcall D3DXGetPixelShaderProfile(ptr)
 @ stdcall D3DXGetShaderConstantTable(ptr ptr)
 @ stdcall D3DXGetShaderConstantTableEx(ptr long ptr)
-@ stub D3DXGetShaderInputSemantics(ptr ptr ptr)
-@ stub D3DXGetShaderOutputSemantics(ptr ptr ptr)
+@ stdcall D3DXGetShaderInputSemantics(ptr ptr ptr)
+@ stdcall D3DXGetShaderOutputSemantics(ptr ptr ptr)
 @ stdcall D3DXGetShaderSamplers(ptr ptr ptr)
 @ stdcall D3DXGetShaderSize(ptr)
 @ stdcall D3DXGetShaderVersion(ptr)
 @ stdcall D3DXGetVertexShaderProfile(ptr)
-@ stub D3DXIntersect(ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr)
+@ stdcall D3DXIntersect(ptr ptr ptr ptr ptr ptr ptr ptr ptr ptr)
 @ stub D3DXIntersectSubset(ptr long ptr ptr ptr ptr ptr ptr ptr ptr ptr)
 @ stdcall D3DXIntersectTri(ptr ptr ptr ptr ptr ptr ptr ptr)
 @ stdcall D3DXLoadMeshFromXA(str long ptr ptr ptr ptr ptr ptr)
diff --git a/dlls/d3dx9_36/d3dx9_36_private.h b/dlls/d3dx9_36/d3dx9_36_private.h
index 79f3b76..edac24d 100644
--- a/dlls/d3dx9_36/d3dx9_36_private.h
+++ b/dlls/d3dx9_36/d3dx9_36_private.h
@@ -97,6 +97,10 @@ HRESULT load_volume_from_dds(IDirect3DVolume9 *dst_volume, const PALETTEENTRY *d
     const D3DXIMAGE_INFO *src_info) DECLSPEC_HIDDEN;
 HRESULT load_volume_texture_from_dds(IDirect3DVolumeTexture9 *volume_texture, const void *src_data,
     const PALETTEENTRY *palette, DWORD filter, DWORD color_key, const D3DXIMAGE_INFO *src_info) DECLSPEC_HIDDEN;
+HRESULT save_dds_texture_to_memory(ID3DXBuffer **dst_buffer, IDirect3DBaseTexture9 *src_texture,
+    const PALETTEENTRY *src_palette) DECLSPEC_HIDDEN;
+HRESULT save_dds_volume_to_memory(ID3DXBuffer **dst_buffer, IDirect3DVolume9 *src_volume,
+    UINT levels, const D3DBOX *src_box)  DECLSPEC_HIDDEN;
 
 unsigned short float_32_to_16(const float in) DECLSPEC_HIDDEN;
 float float_16_to_32(const unsigned short in) DECLSPEC_HIDDEN;
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 8e2f850..2b1ed58 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -27,6 +27,11 @@
 #include "wingdi.h"
 #include "d3dx9_36_private.h"
 #include "d3dcompiler.h"
+#include "initguid.h"
+
+/* d3dx9_26 provides an ID3DXEffect interface where the last function SetRawValue
+ * is missing. Since its otherwise identical, we just use the same vtable. */
+DEFINE_GUID(IID_ID3DXEffect26, 0xc7b17651, 0x5420, 0x490e, 0x8a, 0x7f, 0x92, 0x36, 0x75, 0xa2, 0xd6, 0x87);
 
 /* Constants for special INT/FLOAT conversation */
 #define INT_FLOAT_MULTI 255.0f
@@ -2501,7 +2506,8 @@ static HRESULT WINAPI ID3DXEffectImpl_QueryInterface(ID3DXEffect *iface, REFIID
     TRACE("(%p)->(%s, %p)\n", iface, debugstr_guid(riid), object);
 
     if (IsEqualGUID(riid, &IID_IUnknown) ||
-        IsEqualGUID(riid, &IID_ID3DXEffect))
+        IsEqualGUID(riid, &IID_ID3DXEffect) ||
+        IsEqualGUID(riid, &IID_ID3DXEffect26))
     {
         iface->lpVtbl->AddRef(iface);
         *object = iface;
@@ -3122,13 +3128,41 @@ static HRESULT WINAPI ID3DXEffectImpl_ValidateTechnique(ID3DXEffect* iface, D3DX
     return D3D_OK;
 }
 
-static HRESULT WINAPI ID3DXEffectImpl_FindNextValidTechnique(ID3DXEffect* iface, D3DXHANDLE technique, D3DXHANDLE* next_technique)
+static HRESULT WINAPI ID3DXEffectImpl_FindNextValidTechnique(ID3DXEffect *iface,
+        D3DXHANDLE technique, D3DXHANDLE *next_technique)
 {
     struct ID3DXEffectImpl *This = impl_from_ID3DXEffect(iface);
+    struct d3dx9_base_effect *base_effect = &This->base_effect;
+    UINT i = 0;
 
-    FIXME("(%p)->(%p, %p): stub\n", This, technique, next_technique);
+    TRACE("iface %p, technique %p, next_technique %p\n", iface, technique, next_technique);
 
-    return E_NOTIMPL;
+    if (!next_technique)
+        return D3DERR_INVALIDCALL;
+
+    if (technique)
+    {
+        for (; i < base_effect->technique_count; i++)
+        {
+            if (technique == get_technique_handle(&base_effect->techniques[i]))
+            {
+                i++; /* Go to next technique */
+                break;
+            }
+        }
+    }
+
+    for (; i < base_effect->technique_count; i++)
+    {
+        if (SUCCEEDED(iface->lpVtbl->ValidateTechnique(iface, get_technique_handle(&base_effect->techniques[i]))))
+        {
+            *next_technique = get_technique_handle(&base_effect->techniques[i]);
+            return D3D_OK;
+        }
+    }
+
+    *next_technique = NULL;
+    return S_FALSE;
 }
 
 static BOOL WINAPI ID3DXEffectImpl_IsParameterUsed(ID3DXEffect* iface, D3DXHANDLE parameter, D3DXHANDLE technique)
@@ -3363,7 +3397,12 @@ static HRESULT WINAPI ID3DXEffectImpl_CloneEffect(ID3DXEffect *iface,
 
     FIXME("(%p)->(%p, %p): stub\n", This, device, effect);
 
-    return E_NOTIMPL;
+    if (!effect)
+        return D3DXERR_INVALIDDATA;
+
+    iface->lpVtbl->AddRef(iface);
+    *effect = iface;
+    return S_OK;
 }
 
 static HRESULT WINAPI ID3DXEffectImpl_SetRawValue(ID3DXEffect *iface,
diff --git a/dlls/d3dx9_36/font.c b/dlls/d3dx9_36/font.c
index dd1243e..5d83b87 100644
--- a/dlls/d3dx9_36/font.c
+++ b/dlls/d3dx9_36/font.c
@@ -36,8 +36,29 @@ struct d3dx_font
 
     HDC hdc;
     HFONT hfont;
+
+    UINT tex_width;
+    UINT tex_height;
+    IDirect3DTexture9 *texture;
+    HBITMAP bitmap;
+    BYTE *bits;
 };
 
+/* Returns the smallest power of 2 which is greater than or equal to num */
+static UINT make_pow2(UINT num)
+{
+    UINT result = 1;
+
+    /* In the unlikely event somebody passes a large value, make sure we don't enter an infinite loop */
+    if (num >= 0x80000000)
+        return 0x80000000;
+
+    while (result < num)
+        result <<= 1;
+
+    return result;
+}
+
 static inline struct d3dx_font *impl_from_ID3DXFont(ID3DXFont *iface)
 {
     return CONTAINING_RECORD(iface, struct d3dx_font, ID3DXFont_iface);
@@ -64,19 +85,27 @@ static HRESULT WINAPI ID3DXFontImpl_QueryInterface(ID3DXFont *iface, REFIID riid
 static ULONG WINAPI ID3DXFontImpl_AddRef(ID3DXFont *iface)
 {
     struct d3dx_font *This = impl_from_ID3DXFont(iface);
-    ULONG ref=InterlockedIncrement(&This->ref);
-    TRACE("%p increasing refcount to %u\n", iface, ref);
+    ULONG ref = InterlockedIncrement(&This->ref);
+
+//    TRACE("%p increasing refcount to %u\n", iface, ref);
+
     return ref;
 }
 
 static ULONG WINAPI ID3DXFontImpl_Release(ID3DXFont *iface)
 {
     struct d3dx_font *This = impl_from_ID3DXFont(iface);
-    ULONG ref=InterlockedDecrement(&This->ref);
+    ULONG ref = InterlockedDecrement(&This->ref);
 
-    TRACE("%p decreasing refcount to %u\n", iface, ref);
+//    TRACE("%p decreasing refcount to %u\n", iface, ref);
 
-    if(ref==0) {
+    if (!ref)
+    {
+        if (This->texture)
+        {
+            IDirect3DTexture9_Release(This->texture);
+            DeleteObject(This->bitmap);
+        }
         DeleteObject(This->hfont);
         DeleteDC(This->hdc);
         IDirect3DDevice9_Release(This->device);
@@ -179,17 +208,177 @@ static HRESULT WINAPI ID3DXFontImpl_PreloadTextW(ID3DXFont *iface, const WCHAR *
 static INT WINAPI ID3DXFontImpl_DrawTextA(ID3DXFont *iface, ID3DXSprite *sprite,
         const char *string, INT count, RECT *rect, DWORD format, D3DCOLOR color)
 {
-    FIXME("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x stub!\n",
+    LPWSTR stringW;
+    INT countW, ret = 0;
+
+    TRACE("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x\n",
             iface,  sprite, debugstr_a(string), count, wine_dbgstr_rect(rect), format, color);
-    return 1;
+
+    if (!string || !count)
+        return 0;
+
+    countW = MultiByteToWideChar(CP_ACP, 0, string, count, NULL, 0);
+    stringW = HeapAlloc(GetProcessHeap(), 0, countW * sizeof(WCHAR));
+    if (stringW)
+    {
+        MultiByteToWideChar(CP_ACP, 0, string, count, stringW, countW);
+        ret = ID3DXFont_DrawTextW(iface, sprite, stringW, countW, rect, format, color);
+        HeapFree(GetProcessHeap(), 0, stringW);
+    }
+
+    return ret;
 }
 
 static INT WINAPI ID3DXFontImpl_DrawTextW(ID3DXFont *iface, ID3DXSprite *sprite,
         const WCHAR *string, INT count, RECT *rect, DWORD format, D3DCOLOR color)
 {
-    FIXME("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x stub!\n",
+    struct d3dx_font *This = impl_from_ID3DXFont(iface);
+    RECT calc_rect = *rect;
+    INT height;
+
+    TRACE("iface %p, sprite %p, string %s, count %d, rect %s, format %#x, color 0x%08x\n",
             iface,  sprite, debugstr_w(string), count, wine_dbgstr_rect(rect), format, color);
-    return 1;
+
+    if (!string || !count)
+        return 0;
+
+    /* Strip terminating NULL characters */
+    while (count > 0 && !string[count-1])
+        count--;
+
+    height = DrawTextW(This->hdc, string, count, &calc_rect, format | DT_CALCRECT);
+
+    if (format & DT_CALCRECT)
+    {
+        *rect = calc_rect;
+        return height;
+    }
+
+    if (format & DT_CENTER)
+    {
+        UINT new_width = calc_rect.right - calc_rect.left;
+        calc_rect.left = (rect->right + rect->left - new_width) / 2;
+        calc_rect.right = calc_rect.left + new_width;
+    }
+
+    if (height && (calc_rect.left < calc_rect.right))
+    {
+        D3DLOCKED_RECT locked_rect;
+        D3DXVECTOR3 position;
+        UINT text_width, text_height;
+        RECT text_rect;
+        ID3DXSprite *target = sprite;
+        HRESULT hr;
+        int i, j;
+
+        /* Get rect position and dimensions */
+        position.x = calc_rect.left;
+        position.y = calc_rect.top;
+        position.z = 0;
+        text_width = calc_rect.right - calc_rect.left;
+        text_height = calc_rect.bottom - calc_rect.top;
+        text_rect.left = 0;
+        text_rect.top = 0;
+        text_rect.right = text_width;
+        text_rect.bottom = text_height;
+
+        /* We need to flush as it seems all draws in the begin/end sequence use only the latest updated texture */
+        if (sprite)
+            ID3DXSprite_Flush(sprite);
+
+        /* Extend texture and DIB section to contain text */
+        if ((text_width > This->tex_width) || (text_height > This->tex_height))
+        {
+            BITMAPINFOHEADER header;
+
+            if (text_width > This->tex_width)
+                This->tex_width = make_pow2(text_width);
+            if (text_height > This->tex_height)
+                This->tex_height = make_pow2(text_height);
+
+            if (This->texture)
+            {
+                IDirect3DTexture9_Release(This->texture);
+                DeleteObject(This->bitmap);
+            }
+
+            hr = D3DXCreateTexture(This->device, This->tex_width, This->tex_height, 1, 0,
+                                   D3DFMT_A8R8G8B8, D3DPOOL_DEFAULT, &This->texture);
+            if (FAILED(hr))
+            {
+                This->texture = NULL;
+                return 0;
+            }
+
+            header.biSize = sizeof(header);
+            header.biWidth = This->tex_width;
+            header.biHeight = -This->tex_height;
+            header.biPlanes = 1;
+            header.biBitCount = 32;
+            header.biCompression = BI_RGB;
+            header.biSizeImage = sizeof(DWORD) * This->tex_width * This->tex_height;
+            header.biXPelsPerMeter = 0;
+            header.biYPelsPerMeter = 0;
+            header.biClrUsed = 0;
+            header.biClrImportant = 0;
+
+            This->bitmap = CreateDIBSection(This->hdc, (const BITMAPINFO*)&header,
+                                            DIB_RGB_COLORS, (void**)&This->bits, NULL, 0);
+            if (!This->bitmap)
+            {
+                IDirect3DTexture9_Release(This->texture);
+                This->texture = NULL;
+                return 0;
+            }
+
+            SelectObject(This->hdc, This->bitmap);
+        }
+
+        if (FAILED(IDirect3DTexture9_LockRect(This->texture, 0, &locked_rect, &text_rect, D3DLOCK_DISCARD)))
+            return 0;
+
+        /* Clear rect */
+        for (i = 0; i < text_height; i++)
+            memset(This->bits + i * This->tex_width * sizeof(DWORD), 0,
+                   text_width * sizeof(DWORD));
+
+        DrawTextW(This->hdc, string, count, &text_rect, format);
+
+        /* All RGB components are equal so take one as alpha and set RGB
+         * color to white, so it can be modulated with color parameter */
+        for (i = 0; i < text_height; i++)
+        {
+            DWORD *src = (DWORD *)This->bits + i * This->tex_width;
+            DWORD *dst = (DWORD *)((BYTE *)locked_rect.pBits + i * locked_rect.Pitch);
+            for (j = 0; j < text_width; j++)
+            {
+                *dst++ = (*src++ << 24) | 0xFFFFFF;
+            }
+        }
+
+        IDirect3DTexture9_UnlockRect(This->texture, 0);
+
+        if (!sprite)
+        {
+            hr = D3DXCreateSprite(This->device, &target);
+            if (FAILED(hr))
+                 return 0;
+            ID3DXSprite_Begin(target, 0);
+        }
+
+        hr = target->lpVtbl->Draw(target, This->texture, &text_rect, NULL, &position, color);
+
+        if (!sprite)
+        {
+            ID3DXSprite_End(target);
+            ID3DXSprite_Release(target);
+        }
+
+        if (FAILED(hr))
+            return 0;
+    }
+
+    return height;
 }
 
 static HRESULT WINAPI ID3DXFontImpl_OnLostDevice(ID3DXFont *iface)
@@ -303,46 +492,55 @@ HRESULT WINAPI D3DXCreateFontIndirectW(IDirect3DDevice9 *device, const D3DXFONT_
 
     TRACE("(%p, %p, %p)\n", device, desc, font);
 
-    if( !device || !desc || !font ) return D3DERR_INVALIDCALL;
+    if (!device || !desc || !font) return D3DERR_INVALIDCALL;
+
+    TRACE("desc: %d %d %d %d %d %d %d %d %d %s\n", desc->Height, desc->Width, desc->Weight, desc->MipLevels, desc->Italic,
+            desc->CharSet, desc->OutputPrecision, desc->Quality, desc->PitchAndFamily, debugstr_w(desc->FaceName));
 
-    /* the device MUST support D3DFMT_A8R8G8B8 */
+    /* The device MUST support D3DFMT_A8R8G8B8 */
     IDirect3DDevice9_GetDirect3D(device, &d3d);
     IDirect3DDevice9_GetCreationParameters(device, &cpars);
     IDirect3DDevice9_GetDisplayMode(device, 0, &mode);
     hr = IDirect3D9_CheckDeviceFormat(d3d, cpars.AdapterOrdinal, cpars.DeviceType, mode.Format, 0, D3DRTYPE_TEXTURE, D3DFMT_A8R8G8B8);
-    if(FAILED(hr)) {
+    if (FAILED(hr))
+    {
         IDirect3D9_Release(d3d);
         return D3DXERR_INVALIDDATA;
     }
     IDirect3D9_Release(d3d);
 
-    object = HeapAlloc(GetProcessHeap(), 0, sizeof(struct d3dx_font));
-    if(object==NULL) {
-        *font=NULL;
+    object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct d3dx_font));
+    if (!object)
+    {
+        *font = NULL;
         return E_OUTOFMEMORY;
     }
     object->ID3DXFont_iface.lpVtbl = &D3DXFont_Vtbl;
-    object->ref=1;
-    object->device=device;
-    object->desc=*desc;
+    object->ref = 1;
+    object->device = device;
+    object->desc = *desc;
 
     object->hdc = CreateCompatibleDC(NULL);
-    if( !object->hdc ) {
+    if (!object->hdc)
+    {
         HeapFree(GetProcessHeap(), 0, object);
         return D3DXERR_INVALIDDATA;
     }
 
     object->hfont = CreateFontW(desc->Height, desc->Width, 0, 0, desc->Weight, desc->Italic, FALSE, FALSE, desc->CharSet,
                                 desc->OutputPrecision, CLIP_DEFAULT_PRECIS, desc->Quality, desc->PitchAndFamily, desc->FaceName);
-    if( !object->hfont ) {
+    if (!object->hfont)
+    {
         DeleteDC(object->hdc);
         HeapFree(GetProcessHeap(), 0, object);
         return D3DXERR_INVALIDDATA;
     }
     SelectObject(object->hdc, object->hfont);
+    SetTextColor(object->hdc, 0x00ffffff);
+    SetBkColor(object->hdc, 0x00000000);
 
     IDirect3DDevice9_AddRef(device);
-    *font=&object->ID3DXFont_iface;
+    *font = &object->ID3DXFont_iface;
 
     return D3D_OK;
 }
diff --git a/dlls/d3dx9_36/line.c b/dlls/d3dx9_36/line.c
index 5de44f4..2bdbe79 100644
--- a/dlls/d3dx9_36/line.c
+++ b/dlls/d3dx9_36/line.c
@@ -59,7 +59,7 @@ static ULONG WINAPI d3dx9_line_AddRef(ID3DXLine *iface)
     struct d3dx9_line *line = impl_from_ID3DXLine(iface);
     ULONG refcount = InterlockedIncrement(&line->ref);
 
-    TRACE("%p increasing refcount to %u.\n", line, refcount);
+//    TRACE("%p increasing refcount to %u.\n", line, refcount);
 
     return refcount;
 }
@@ -69,7 +69,7 @@ static ULONG WINAPI d3dx9_line_Release(ID3DXLine *iface)
     struct d3dx9_line *line = impl_from_ID3DXLine(iface);
     ULONG refcount = InterlockedDecrement(&line->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", line, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", line, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/d3dx9_36/mesh.c b/dlls/d3dx9_36/mesh.c
index 746b479..99653e6 100644
--- a/dlls/d3dx9_36/mesh.c
+++ b/dlls/d3dx9_36/mesh.c
@@ -118,7 +118,7 @@ static ULONG WINAPI d3dx9_mesh_AddRef(ID3DXMesh *iface)
     struct d3dx9_mesh *mesh = impl_from_ID3DXMesh(iface);
     ULONG refcount = InterlockedIncrement(&mesh->ref);
 
-    TRACE("%p increasing refcount to %u.\n", mesh, refcount);
+//    TRACE("%p increasing refcount to %u.\n", mesh, refcount);
 
     return refcount;
 }
@@ -128,7 +128,7 @@ static ULONG WINAPI d3dx9_mesh_Release(ID3DXMesh *iface)
     struct d3dx9_mesh *mesh = impl_from_ID3DXMesh(iface);
     ULONG refcount = InterlockedDecrement(&mesh->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", mesh, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", mesh, refcount);
 
     if (!refcount)
     {
@@ -4044,6 +4044,12 @@ HRESULT WINAPI D3DXFrameDestroy(D3DXFRAME *frame, ID3DXAllocateHierarchy *alloc_
     return D3D_OK;
 }
 
+D3DXFRAME* WINAPI D3DXFrameFind(const D3DXFRAME *frame_root, const char *name)
+{
+    FIXME("frame_root %p, name %s stub.\n", frame_root, debugstr_a(name));
+    return NULL;
+}
+
 HRESULT WINAPI D3DXLoadMeshFromXA(const char *filename, DWORD options, struct IDirect3DDevice9 *device,
         struct ID3DXBuffer **adjacency, struct ID3DXBuffer **materials, struct ID3DXBuffer **effect_instances,
         DWORD *num_materials, struct ID3DXMesh **mesh)
@@ -5171,6 +5177,9 @@ HRESULT WINAPI D3DXCreateTextA(struct IDirect3DDevice9 *device, HDC hdc, const c
 
     len = MultiByteToWideChar(CP_ACP, 0, text, -1, NULL, 0);
     textW = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+  if (!textW) {
+    return E_OUTOFMEMORY;
+  }
     MultiByteToWideChar(CP_ACP, 0, text, -1, textW, len);
 
     hr = D3DXCreateTextW(device, hdc, textW, deviation, extrusion,
@@ -7234,3 +7243,59 @@ HRESULT WINAPI D3DXOptimizeFaces(const void *indices, UINT num_faces,
 error:
     return hr;
 }
+
+/*************************************************************************
+ * D3DXComputeTangentFrameEx    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeTangentFrameEx(ID3DXMesh *Mesh, DWORD TextureInSemantic, DWORD TextureInIndex,
+               DWORD UPartialOutSemantic, DWORD UPartialOutIndex, DWORD VPartialOutSemantic, DWORD VPartialOutIndex,
+               DWORD NormalOutSemantic, DWORD NormalOutIndex, DWORD options, const DWORD *adjacency,
+               FLOAT PartialEdgeThreshold, FLOAT SingularPointThreshold, FLOAT NormalEdgeThreshold,
+               ID3DXMesh **MeshOut, ID3DXBuffer **VertexMapping)
+{
+    FIXME("Mesh %p, TextureInSemantic %u, TextureInIndex %u, UPartialOutSemantic %u, UPartialOutIndex %u, "
+            "VPartialOutSemantic %u, VPartialOutIndex %u, NormalOutSemantic %u, NormalOutIndex %u, "
+            "options %x, adjacency %p, PartialEdgeThreshold %f, SingularPointThreshold %f, NormalEdgeThreshold %f, "
+            "MeshOut %p, VertexMapping %p stub.\n",
+            Mesh, TextureInSemantic, TextureInIndex, UPartialOutSemantic, UPartialOutIndex, VPartialOutSemantic,
+            VPartialOutIndex, NormalOutSemantic, NormalOutIndex, options, adjacency, PartialEdgeThreshold,
+            SingularPointThreshold, NormalEdgeThreshold, MeshOut, VertexMapping);
+
+    return E_NOTIMPL;
+}
+
+/*************************************************************************
+ * D3DXComputeNormals    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeNormals(ID3DXBaseMesh *mesh, const DWORD *adjacency)
+{
+    TRACE("mesh %p, adjacency %p.\n", mesh, adjacency);
+
+    return D3DXComputeTangentFrameEx((ID3DXMesh *)mesh, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0, D3DX_DEFAULT, 0,
+                                     D3DDECLUSAGE_NORMAL, 0, D3DXTANGENT_GENERATE_IN_PLACE | D3DXTANGENT_CALCULATE_NORMALS,
+                                     adjacency, -1.01f, -0.01f, -1.01f, NULL, NULL);
+}
+
+/*************************************************************************
+ * D3DXComputeNormalMap    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXComputeNormalMap(IDirect3DTexture9 *texture, IDirect3DTexture9 *src_texture,
+        const PALETTEENTRY *src_palette, DWORD flags, DWORD channel, FLOAT amplitude)
+{
+    FIXME("texture %p, src_texture %p, src_palette %p, flags %#x, channel %u, amplitude %f stub.\n",
+            texture, src_texture, src_palette, flags, channel, amplitude);
+
+    return D3D_OK;
+}
+
+/*************************************************************************
+ * D3DXIntersect    (D3DX9_36.@)
+ */
+HRESULT WINAPI D3DXIntersect(ID3DXBaseMesh *Mesh, const D3DXVECTOR3 *RayPos, const D3DXVECTOR3 *RayDir, BOOL *Hit,
+        DWORD *FaceIndex, FLOAT *U, FLOAT *V, FLOAT *Dist, ID3DXBuffer **AllHits, DWORD *CountOfHits)
+{
+    FIXME("Mesh %p, RayPos %p, RayDir %p, Hit %p, FaceIndex %p, U %p, V %p, Dist %p, AllHits %p, CountOfHits %p stub.\n",
+            Mesh, RayPos, RayDir, Hit, FaceIndex, U, V, Dist, AllHits, CountOfHits);
+
+    return E_NOTIMPL;
+}
diff --git a/dlls/d3dx9_36/render.c b/dlls/d3dx9_36/render.c
index cca6b44..0bf52b9 100644
--- a/dlls/d3dx9_36/render.c
+++ b/dlls/d3dx9_36/render.c
@@ -151,7 +151,7 @@ static ULONG WINAPI D3DXRenderToSurface_AddRef(ID3DXRenderToSurface *iface)
     struct render_to_surface *render = impl_from_ID3DXRenderToSurface(iface);
     ULONG ref = InterlockedIncrement(&render->ref);
 
-    TRACE("%p increasing refcount to %u\n", iface, ref);
+//    TRACE("%p increasing refcount to %u\n", iface, ref);
 
     return ref;
 }
@@ -161,7 +161,7 @@ static ULONG WINAPI D3DXRenderToSurface_Release(ID3DXRenderToSurface *iface)
     struct render_to_surface *render = impl_from_ID3DXRenderToSurface(iface);
     ULONG ref = InterlockedDecrement(&render->ref);
 
-    TRACE("%p decreasing refcount to %u\n", iface, ref);
+//    TRACE("%p decreasing refcount to %u\n", iface, ref);
 
     if (!ref)
     {
@@ -488,7 +488,7 @@ static ULONG WINAPI D3DXRenderToEnvMap_AddRef(ID3DXRenderToEnvMap *iface)
     struct render_to_envmap *render = impl_from_ID3DXRenderToEnvMap(iface);
     ULONG ref = InterlockedIncrement(&render->ref);
 
-    TRACE("%p increasing refcount to %u\n", iface, ref);
+//    TRACE("%p increasing refcount to %u\n", iface, ref);
 
     return ref;
 }
@@ -498,7 +498,7 @@ static ULONG WINAPI D3DXRenderToEnvMap_Release(ID3DXRenderToEnvMap *iface)
     struct render_to_envmap *render = impl_from_ID3DXRenderToEnvMap(iface);
     ULONG ref = InterlockedDecrement(&render->ref);
 
-    TRACE("%p decreasing refcount to %u\n", iface, ref);
+//    TRACE("%p decreasing refcount to %u\n", iface, ref);
 
     if (!ref)
     {
diff --git a/dlls/d3dx9_36/shader.c b/dlls/d3dx9_36/shader.c
index cdc470b..186610b 100644
--- a/dlls/d3dx9_36/shader.c
+++ b/dlls/d3dx9_36/shader.c
@@ -1,6 +1,7 @@
 /*
  * Copyright 2008 Luis Busquets
  * Copyright 2009 Matteo Bruni
+ * Copyright 2010, 2013 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -448,6 +449,41 @@ HRESULT WINAPI D3DXCompileShader(const char *data, UINT length, const D3DXMACRO
         }
     }
 
+    /* Filter out D3DCompile warning messages that are not present with D3DCompileShader */
+    if (SUCCEEDED(hr) && error_msgs && *error_msgs)
+    {
+        char *messages = ID3DXBuffer_GetBufferPointer(*error_msgs);
+        DWORD size     = ID3DXBuffer_GetBufferSize(*error_msgs);
+
+        /* Ensure messages are null terminated for safe processing */
+        if (size) messages[size - 1] = 0;
+
+        while (size > 1)
+        {
+            char *prev, *next;
+
+            /* Warning has the form "warning X3206: ... implicit truncation of vector type"
+               but we only search for "X3206:" in case d3dcompiler_43 has localization */
+            prev = next = strstr(messages, "X3206:");
+            if (!prev) break;
+
+            /* get pointer to beginning and end of current line */
+            while (prev > messages && *(prev - 1) != '\n') prev--;
+            while (next < messages + size - 1 && *next != '\n') next++;
+            if (next < messages + size - 1 && *next == '\n') next++;
+
+            memmove(prev, next, messages + size - next);
+            size -= (next - prev);
+        }
+
+        /* Only return a buffer if the resulting string is not empty as some apps depend on that */
+        if (size <= 1)
+        {
+            ID3DXBuffer_Release(*error_msgs);
+            *error_msgs = NULL;
+        }
+    }
+
     return hr;
 }
 
@@ -2130,3 +2166,112 @@ HRESULT WINAPI D3DXDisassembleShader(const DWORD *shader, BOOL colorcode, const
    FIXME("%p %d %s %p: stub\n", shader, colorcode, debugstr_a(comments), disassembly);
    return E_OUTOFMEMORY;
 }
+
+const DWORD* skip_instruction(const DWORD *byte_code, UINT shader_model)
+{
+    TRACE("Shader model %u\n", shader_model);
+
+    /* Handle all special instructions whose arguments may contain D3DSIO_DCL */
+    if ((*byte_code & D3DSI_OPCODE_MASK) == D3DSIO_COMMENT)
+    {
+        byte_code += 1 + ((*byte_code & D3DSI_COMMENTSIZE_MASK) >> D3DSI_COMMENTSIZE_SHIFT);
+    }
+    else if (shader_model >= 2)
+    {
+        byte_code += 1 + ((*byte_code & D3DSI_INSTLENGTH_MASK) >> D3DSI_INSTLENGTH_SHIFT);
+    }
+    else if ((*byte_code & D3DSI_OPCODE_MASK) == D3DSIO_DEF)
+    {
+        byte_code += 1 + 5;
+    }
+    else
+    {
+        /* Handle remaining safe instructions */
+        while (*++byte_code & (1 << 31));
+    }
+
+    return byte_code;
+}
+
+static UINT get_shader_semantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, BOOL input)
+{
+    const DWORD *ptr = byte_code;
+    UINT shader_model = (*ptr >> 8) & 0xff;
+    UINT i = 0;
+
+    TRACE("Shader version: %#x\n", *ptr);
+    ptr++;
+
+    while (*ptr != D3DSIO_END)
+    {
+        if (*ptr & (1 << 31))
+        {
+            FIXME("Opcode expected but got %#x\n", *ptr);
+            return 0;
+        }
+        else if ((*ptr & D3DSI_OPCODE_MASK) == D3DSIO_DCL)
+        {
+            DWORD param1 = *++ptr;
+            DWORD param2 = *++ptr;
+            DWORD usage = param1 & 0x1f;
+            DWORD usage_index = (param1 >> 16) & 0xf;
+            DWORD reg_type = (((param2 >> 11) & 0x3) << 3) | ((param2 >> 28) & 0x7);
+
+            TRACE("D3DSIO_DCL param1: %#x, param2: %#x, usage: %u, usage_index: %u, reg_type: %u\n",
+                   param1, param2, usage, usage_index, reg_type);
+
+            if ((input && (reg_type == D3DSPR_INPUT)) || (!input && (reg_type == D3DSPR_OUTPUT)))
+            {
+                if (semantics)
+                {
+                    semantics[i].Usage = usage;
+                    semantics[i].UsageIndex = usage_index;
+                }
+                i++;
+            }
+
+            ptr++;
+        }
+        else
+        {
+            ptr = skip_instruction(ptr, shader_model);
+        }
+    }
+
+    return i;
+}
+
+HRESULT WINAPI D3DXGetShaderInputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count)
+{
+    UINT nb_semantics;
+
+    TRACE("byte_code %p, semantics %p, count %p\n", byte_code, semantics, count);
+
+    if (!byte_code)
+        return D3DERR_INVALIDCALL;
+
+    nb_semantics = get_shader_semantics(byte_code, semantics, TRUE);
+
+    if (count)
+        *count = nb_semantics;
+
+    return D3D_OK;
+}
+
+
+HRESULT WINAPI D3DXGetShaderOutputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count)
+{
+    UINT nb_semantics;
+
+    TRACE("byte_code %p, semantics %p, count %p\n", byte_code, semantics, count);
+
+    if (!byte_code)
+        return D3DERR_INVALIDCALL;
+
+    nb_semantics = get_shader_semantics(byte_code, semantics, FALSE);
+
+    if (count)
+        *count = nb_semantics;
+
+    return D3D_OK;
+}
diff --git a/dlls/d3dx9_36/skin.c b/dlls/d3dx9_36/skin.c
index 9b93af6..ccccc03 100644
--- a/dlls/d3dx9_36/skin.c
+++ b/dlls/d3dx9_36/skin.c
@@ -2,6 +2,7 @@
  * Skin Info operations specific to D3DX9.
  *
  * Copyright (C) 2011 Dylan Smith
+ * Copyright (C) 2013 Christian Costa
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -70,7 +71,7 @@ static ULONG WINAPI d3dx9_skin_info_AddRef(ID3DXSkinInfo *iface)
     struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
     ULONG refcount = InterlockedIncrement(&skin->ref);
 
-    TRACE("%p increasing refcount to %u.\n", skin, refcount);
+//    TRACE("%p increasing refcount to %u.\n", skin, refcount);
 
     return refcount;
 }
@@ -80,7 +81,7 @@ static ULONG WINAPI d3dx9_skin_info_Release(ID3DXSkinInfo *iface)
     struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
     ULONG refcount = InterlockedDecrement(&skin->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", skin, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", skin, refcount);
 
     if (!refcount)
     {
@@ -375,10 +376,89 @@ static HRESULT WINAPI d3dx9_skin_info_GetDeclaration(ID3DXSkinInfo *iface,
 static HRESULT WINAPI d3dx9_skin_info_UpdateSkinnedMesh(ID3DXSkinInfo *iface, const D3DXMATRIX *bone_transforms,
         const D3DXMATRIX *bone_inv_transpose_transforms, const void *src_vertices, void *dst_vertices)
 {
-    FIXME("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p stub!\n",
-            iface, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+    struct d3dx9_skin_info *skin = impl_from_ID3DXSkinInfo(iface);
+    DWORD size = D3DXGetFVFVertexSize(skin->fvf);
+    DWORD i, j;
 
-    return E_NOTIMPL;
+    TRACE("iface %p, bone_transforms %p, bone_inv_transpose_transforms %p, src_vertices %p, dst_vertices %p\n",
+            skin, bone_transforms, bone_inv_transpose_transforms, src_vertices, dst_vertices);
+
+    if (bone_inv_transpose_transforms)
+        FIXME("Skinning vertices with two position elements not supported\n");
+
+    if ((skin->fvf & D3DFVF_POSITION_MASK) != D3DFVF_XYZ) {
+        FIXME("Vertex type %#x not supported\n", skin->fvf & D3DFVF_POSITION_MASK);
+        return E_FAIL;
+    }
+
+    /* Reset all positions */
+    for (i = 0; i < skin->num_vertices; i++) {
+        D3DXVECTOR3 *position = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i);
+        position->x = 0.0f;
+        position->y = 0.0f;
+        position->z = 0.0f;
+    }
+
+    /* Update positions that are influenced by bones */
+    for (i = 0; i < skin->num_bones; i++) {
+        D3DXMATRIX bone_inverse, matrix;
+
+        D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+        D3DXMatrixMultiply(&matrix, &bone_transforms[i], &bone_inverse);
+        D3DXMatrixMultiply(&matrix, &matrix, &skin->bones[i].transform);
+
+        for (j = 0; j < skin->bones[i].num_influences; j++) {
+            D3DXVECTOR3 position;
+            D3DXVECTOR3 *position_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j]);
+            D3DXVECTOR3 *position_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j]);
+            FLOAT weight = skin->bones[i].weights[j];
+
+            D3DXVec3TransformCoord(&position, position_src, &matrix);
+            position_dest->x += weight * position.x;
+            position_dest->y += weight * position.y;
+            position_dest->z += weight * position.z;
+        }
+    }
+
+    if (skin->fvf & D3DFVF_NORMAL) {
+        /* Reset all normals */
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * i + sizeof(D3DXVECTOR3));
+            normal->x = 0.0f;
+            normal->y = 0.0f;
+            normal->z = 0.0f;
+        }
+
+        /* Update normals that are influenced by bones */
+        for (i = 0; i < skin->num_bones; i++) {
+            D3DXMATRIX bone_inverse, matrix;
+
+            D3DXMatrixInverse(&bone_inverse, NULL, &skin->bones[i].transform);
+            D3DXMatrixMultiply(&matrix, &skin->bones[i].transform, &bone_transforms[i]);
+
+            for (j = 0; j < skin->bones[i].num_influences; j++) {
+                D3DXVECTOR3 normal;
+                D3DXVECTOR3 *normal_src = (D3DXVECTOR3*)((BYTE*)src_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + size * skin->bones[i].vertices[j] + sizeof(D3DXVECTOR3));
+                FLOAT weight = skin->bones[i].weights[j];
+
+                D3DXVec3TransformNormal(&normal, normal_src, &bone_inverse);
+                D3DXVec3TransformNormal(&normal, &normal, &matrix);
+                normal_dest->x += weight * normal.x;
+                normal_dest->y += weight * normal.y;
+                normal_dest->z += weight * normal.z;
+            }
+        }
+
+        /* Normalize all normals that are influenced by bones*/
+        for (i = 0; i < skin->num_vertices; i++) {
+            D3DXVECTOR3 *normal_dest = (D3DXVECTOR3*)((BYTE*)dst_vertices + (i * size) + sizeof(D3DXVECTOR3));
+            if ((normal_dest->x != 0.0f) && (normal_dest->y != 0.0f) && (normal_dest->z != 0.0f))
+                D3DXVec3Normalize(normal_dest, normal_dest);
+        }
+    }
+
+    return D3D_OK;
 }
 
 static HRESULT WINAPI d3dx9_skin_info_ConvertToBlendedMesh(ID3DXSkinInfo *iface, ID3DXMesh *mesh_in,
diff --git a/dlls/d3dx9_36/sprite.c b/dlls/d3dx9_36/sprite.c
index 8fbabc3..4878ec9 100644
--- a/dlls/d3dx9_36/sprite.c
+++ b/dlls/d3dx9_36/sprite.c
@@ -94,7 +94,7 @@ static ULONG WINAPI d3dx9_sprite_AddRef(ID3DXSprite *iface)
     struct d3dx9_sprite *sprite = impl_from_ID3DXSprite(iface);
     ULONG refcount = InterlockedIncrement(&sprite->ref);
 
-    TRACE("%p increasing refcount to %u.\n", sprite, refcount);
+//    TRACE("%p increasing refcount to %u.\n", sprite, refcount);
 
     return refcount;
 }
@@ -104,7 +104,7 @@ static ULONG WINAPI d3dx9_sprite_Release(ID3DXSprite *iface)
     struct d3dx9_sprite *sprite = impl_from_ID3DXSprite(iface);
     ULONG refcount = InterlockedDecrement(&sprite->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", sprite, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", sprite, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/d3dx9_36/surface.c b/dlls/d3dx9_36/surface.c
index 295ef63..63e471d 100644
--- a/dlls/d3dx9_36/surface.c
+++ b/dlls/d3dx9_36/surface.c
@@ -18,6 +18,7 @@
  *
  */
 
+#include "config.h"
 #include "wine/debug.h"
 #include "wine/unicode.h"
 #include "d3dx9_36_private.h"
@@ -26,6 +27,9 @@
 #include "ole2.h"
 #include "wincodec.h"
 
+#include "wine/wined3d.h"
+#include "d3d9-dxtn.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
 
@@ -77,7 +81,7 @@ static const GUID *d3dformat_to_wic_guid(D3DFORMAT format)
 /* dds_header.flags */
 #define DDS_CAPS 0x1
 #define DDS_HEIGHT 0x2
-#define DDS_WIDTH 0x2
+#define DDS_WIDTH 0x4
 #define DDS_PITCH 0x8
 #define DDS_PIXELFORMAT 0x1000
 #define DDS_MIPMAPCOUNT 0x20000
@@ -88,6 +92,7 @@ static const GUID *d3dformat_to_wic_guid(D3DFORMAT format)
 #define DDS_CAPS_COMPLEX 0x8
 #define DDS_CAPS_TEXTURE 0x1000
 #define DDS_CAPS_MIPMAP 0x400000
+#define DDS_SURFACE_FLAGS_CUBEMAP 0x00000008 // DDS_CAPS_COMPLEX
 
 /* dds_header.caps2 */
 #define DDS_CAPS2_CUBEMAP 0x200
@@ -125,22 +130,47 @@ struct dds_pixel_format
 
 struct dds_header
 {
-    DWORD signature;
-    DWORD size;
-    DWORD flags;
-    DWORD height;
-    DWORD width;
-    DWORD pitch_or_linear_size;
-    DWORD depth;
-    DWORD miplevels;
+    DWORD signature;  //44 44 53 20  = "DDS "
+    DWORD size;       //7C 00 00 00  = 124
+    DWORD flags;      //07 10 08 00 = 00081007 = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PIXELFORMAT | DDS_LINEARSIZE
+    DWORD height;     //00 01 00 00  = 256
+    DWORD width;      //00 01 00 00 
+    DWORD pitch_or_linear_size; //00 04 00 00 = 1024
+    DWORD depth;      //00 00 00 00
+    DWORD miplevels;  //00 00 00 00 
     DWORD reserved[11];
-    struct dds_pixel_format pixel_format;
-    DWORD caps;
-    DWORD caps2;
+    struct dds_pixel_format pixel_format; //SIZE=32 FLAGS=DDS_PF_FOURCC 'DXT5' 
+    DWORD caps; //dwSurfaceFlags  //00 10 00 00 = DDS_CAPS_TEXTURE
+    DWORD caps2; //dwCubemapFlags = 0
     DWORD caps3;
     DWORD caps4;
     DWORD reserved2;
 };
+/*
+Volume DDS DX5 miplevels
+ 44 44 53 20 = DDS
+ 7C 00 00 00 = 124
+ 07 10 82 00 = 821007 = DDS_DEPTH | DDS_MIPMAPCOUNT | DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PIXELFORMAT
+ 00 01 00 00 = 256
+ 00 01 00 00 = 256
+ 00 00 00 00 = pitch = 0
+ 08 00 00 00 = depth = 8
+ 09 00 00 00 = miplevels = 9
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
+00 00 00 00 00 00 00 00 00 00 00 00 
+ Pixel_format
+ 20 00 00 00 size  = 32
+ 04 00 00 00 flags = DDS_PF_FOURCC
+ 44 58 54 35 DXT5
+ 00 00 00 00 bpp = 0
+ 00 00 00 00 r,g,b mask = 0
+ 00 00 00 00 00 00 00 00 00 00 00 00 
+ 
+ 08 10 40 00 caps = 401008 = DDS_CAPS_COMPLEX | DDS_CAPS_TEXTURE | DDS_CAPS_MIPMAP
+ 00 00 20 00 caps2 = DDS_CAPS2_VOLUME
+ 00 00 00 00 00 00 00 00 00 00 00 00
+ */
 
 static D3DFORMAT dds_fourcc_to_d3dformat(DWORD fourcc)
 {
@@ -311,6 +341,14 @@ static HRESULT d3dformat_to_dds_pixel_format(struct dds_pixel_format *pixel_form
         }
     }
 
+    /* Reuse dds_fourcc_to_d3dformat as D3DFORMAT and FOURCC are DWORD with same values */
+    if (dds_fourcc_to_d3dformat(d3dformat) != D3DFMT_UNKNOWN)
+    {
+        pixel_format->flags |= DDS_PF_FOURCC;
+        pixel_format->fourcc = d3dformat;
+        return D3D_OK;
+    }
+
     WARN("Unknown pixel format %#x\n", d3dformat);
     return E_NOTIMPL;
 }
@@ -319,9 +357,18 @@ static HRESULT calculate_dds_surface_size(D3DFORMAT format, UINT width, UINT hei
     UINT *pitch, UINT *size)
 {
     const struct pixel_format_desc *format_desc = get_format_info(format);
+  TRACE("%#x, %d*%d ", format, width, height);
+//trace:d3dx:calculate_dds_surface_size 0x31545844, 256*256 block_byte_count=8 block_width=4 block_height=4 bpp=1
+//trace:d3dx:calculate_dds_surface_size return pitch=512 size=32768
+//trace:d3dx:D3DXLoadSurfaceFromMemory (0x205ce8, 0x0, (null), 0xafeab0, 0x31545844, 512, 0x0, (0,0)-(256,256), 0x4, 0x00000000)
+//trace:d3dx:D3DXLoadSurfaceFromMemory 1
+//wine: Unhandled page fault on execute access to 0x14002044 at address 0x14002044 (thread 0023), starting debugger...
+
     if (format_desc->type == FORMAT_UNKNOWN)
         return E_NOTIMPL;
-
+  TRACE("block_byte_count=%d block_width=%d block_height=%d bpp=%d\n", format_desc->block_byte_count,
+        format_desc->block_width, format_desc->block_height, format_desc->bytes_per_pixel);
+  
     if (format_desc->block_width != 1 || format_desc->block_height != 1)
     {
         *pitch = format_desc->block_byte_count
@@ -334,7 +381,7 @@ static HRESULT calculate_dds_surface_size(D3DFORMAT format, UINT width, UINT hei
         *pitch = width * format_desc->bytes_per_pixel;
         *size = *pitch * height;
     }
-
+  TRACE("return pitch=%d size=%d\n", *pitch, *size);
     return D3D_OK;
 }
 
@@ -389,7 +436,7 @@ static HRESULT get_image_info_from_dds(const void *buffer, UINT length, D3DXIMAG
 
     info->Width = header->width;
     info->Height = header->height;
-    info->Depth = 1;
+    info->Depth = header->depth ? header->depth: 1;
     info->MipLevels = (header->flags & DDS_MIPMAPCOUNT) ?  header->miplevels : 1;
 
     info->Format = dds_pixel_format_to_d3dformat(&header->pixel_format);
@@ -475,7 +522,7 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     if (pixel_format->type == FORMAT_UNKNOWN) return E_NOTIMPL;
 
     file_size = calculate_dds_file_size(src_desc.Format, src_desc.Width, src_desc.Height, 1, 1, 1);
-
+  TRACE("format %#x file_size=%d\n", src_desc.Format, file_size);
     hr = calculate_dds_surface_size(src_desc.Format, src_desc.Width, src_desc.Height, &dst_pitch, &surface_size);
     if (FAILED(hr)) return hr;
 
@@ -487,13 +534,14 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
 
     memset(header, 0, sizeof(*header));
     header->signature = MAKEFOURCC('D','D','S',' ');
-    header->size = sizeof(*header);
-    header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PITCH | DDS_PIXELFORMAT | DDS_MIPMAPCOUNT;
+    /* The signature is not really part of the DDS header */
+    header->size = sizeof(*header) - sizeof(header->signature);
+    header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_PIXELFORMAT;
+    /* Note that native does not set DDS_LINEARSIZE flag nor pitch_or_linear_size field for DXTn */
+    header->flags |= (pixel_format->block_width != 1) || (pixel_format->block_height != 1) ? DDS_LINEARSIZE : DDS_PITCH;
     header->height = src_desc.Height;
     header->width = src_desc.Width;
     header->pitch_or_linear_size = dst_pitch;
-    header->depth = 1;
-    header->miplevels = 1;
     header->caps = DDS_CAPS_TEXTURE;
     hr = d3dformat_to_dds_pixel_format(&header->pixel_format, src_desc.Format);
     if (FAILED(hr))
@@ -521,6 +569,201 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     return D3D_OK;
 }
 
+HRESULT save_dds_volume_to_memory(ID3DXBuffer **dst_buffer, IDirect3DVolume9 *src_volume, UINT levels, const D3DBOX *src_box)
+{
+  HRESULT hr;
+  UINT dst_pitch, slice_size, file_size;
+  D3DVOLUME_DESC src_desc;
+  D3DLOCKED_BOX locked_box;
+  ID3DXBuffer *buffer;
+  struct dds_header *header;
+  BYTE *pixels;
+  struct volume volume;
+  const struct pixel_format_desc *pixel_format;
+  
+  if (src_box)
+  {
+    FIXME("Saving a part of a volume to a DDS file is not implemented yet\n");
+    return E_NOTIMPL;
+  }
+  
+  hr = IDirect3DVolume9_GetDesc(src_volume, &src_desc);
+  if (FAILED(hr)) return hr;
+  
+  pixel_format = get_format_info(src_desc.Format);
+  if (pixel_format->type == FORMAT_UNKNOWN) return E_NOTIMPL;
+  
+  file_size = calculate_dds_file_size(src_desc.Format, src_desc.Width, src_desc.Height, src_desc.Depth, levels, 1);
+  TRACE("format %#x file_size=%d\n", src_desc.Format, file_size);
+  hr = calculate_dds_surface_size(src_desc.Format, src_desc.Width, src_desc.Height, &dst_pitch, &slice_size);
+  if (FAILED(hr)) return hr;
+  
+  hr = D3DXCreateBuffer(file_size, &buffer);
+  if (FAILED(hr)) return hr;
+  
+  header = ID3DXBuffer_GetBufferPointer(buffer);
+  pixels = (BYTE *)(header + 1);
+  
+  memset(header, 0, sizeof(*header));
+  header->signature = MAKEFOURCC('D','D','S',' ');
+  /* The signature is not really part of the DDS header */
+  header->size = sizeof(*header) - sizeof(header->signature);
+  header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_DEPTH | DDS_PIXELFORMAT | DDS_MIPMAPCOUNT;
+  /* Note that native does not set DDS_LINEARSIZE flag nor pitch_or_linear_size field for DXTn */
+  header->flags |= (pixel_format->block_width != 1) || (pixel_format->block_height != 1) ? DDS_LINEARSIZE : DDS_PITCH;
+  header->height = src_desc.Height;
+  header->width = src_desc.Width;
+  header->depth = src_desc.Depth;
+  header->miplevels = levels;
+  header->pitch_or_linear_size = dst_pitch;
+  header->caps = DDS_CAPS_TEXTURE;
+  header->caps2 = DDS_CAPS2_VOLUME;
+  hr = d3dformat_to_dds_pixel_format(&header->pixel_format, src_desc.Format);
+  if (FAILED(hr))
+  {
+    ID3DXBuffer_Release(buffer);
+    return hr;
+  }
+  
+  hr = IDirect3DVolume9_LockBox(src_volume, &locked_box, NULL, D3DLOCK_READONLY);
+  if (FAILED(hr))
+  {
+    ID3DXBuffer_Release(buffer);
+    return hr;
+  }
+  
+  volume.width = src_desc.Width;
+  volume.height = src_desc.Height;
+  volume.depth = src_desc.Depth;
+  copy_pixels(locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, pixels, dst_pitch, slice_size,
+              &volume, pixel_format);
+
+  IDirect3DVolume9_UnlockBox(src_volume);
+  
+  *dst_buffer = buffer;
+  return D3D_OK;
+}
+
+static HRESULT get_surface(D3DRESOURCETYPE type, struct IDirect3DBaseTexture9 *tex,
+        int face, UINT level, struct IDirect3DSurface9 **surf)
+{
+//  HRESULT hr = D3D_OK;
+    switch (type)
+    {
+        case D3DRTYPE_TEXTURE:
+            return IDirect3DTexture9_GetSurfaceLevel((IDirect3DTexture9*) tex, level, surf);
+        case D3DRTYPE_CUBETEXTURE:
+            return IDirect3DCubeTexture9_GetCubeMapSurface((IDirect3DCubeTexture9*) tex, face, level, surf);
+        default:
+            ERR("Unexpected texture type\n");
+            return E_NOTIMPL;
+    }
+}
+
+HRESULT save_dds_texture_to_memory(ID3DXBuffer **dst_buffer, IDirect3DBaseTexture9 *src_texture, const PALETTEENTRY *src_palette)
+{
+    HRESULT hr = D3DERR_INVALIDCALL;
+    D3DRESOURCETYPE type;
+    UINT mip_level;
+    UINT mip_levels;
+    UINT src_slice_pitch;
+    UINT src_row_pitch;
+    D3DVOLUME_DESC vol_desc;
+    UINT file_size;
+    IDirect3DSurface9 *surface = NULL;
+    IDirect3DVolume9 *volume = NULL;
+    struct volume volume_box;
+    D3DLOCKED_BOX locked_box;
+    ID3DXBuffer *buffer;
+    struct dds_header *header;
+    BYTE *pixels = NULL;
+    const struct pixel_format_desc *pixel_format = NULL;
+
+    type = IDirect3DBaseTexture9_GetType(src_texture);
+
+    if ((type !=  D3DRTYPE_TEXTURE) && (type != D3DRTYPE_CUBETEXTURE) && (type != D3DRTYPE_VOLUMETEXTURE))
+        return D3DERR_INVALIDCALL;
+
+    mip_levels = IDirect3DTexture9_GetLevelCount(src_texture);
+
+    if (src_palette)
+    {
+        FIXME("Saving surfaces with palettized pixel formats not implemented yet\n");
+        return E_NOTIMPL;
+    }
+
+    if (type == D3DRTYPE_VOLUMETEXTURE)
+    {
+        for (mip_level = 0; mip_level < mip_levels; mip_level++)
+        {
+            hr = IDirect3DVolumeTexture9_GetVolumeLevel((IDirect3DVolumeTexture9*)src_texture, mip_level, &volume);
+            if (FAILED(hr)) break;
+
+            hr = IDirect3DVolume9_GetDesc(volume, &vol_desc);
+            if (FAILED(hr)) return hr;
+            if (!mip_level) {
+                pixel_format = get_format_info(vol_desc.Format);
+                file_size = calculate_dds_file_size(vol_desc.Format, vol_desc.Width, vol_desc.Height, vol_desc.Depth, mip_levels, 1);
+                hr = D3DXCreateBuffer(file_size, &buffer);
+                if (FAILED(hr)) return hr;
+                header = ID3DXBuffer_GetBufferPointer(buffer);
+                pixels = (BYTE *)(header + 1);
+
+                memset(header, 0, sizeof(*header));
+                header->signature = MAKEFOURCC('D','D','S',' ');
+                /* The signature is not really part of the DDS header */
+                header->size = sizeof(*header) - sizeof(header->signature);
+                header->flags = DDS_CAPS | DDS_HEIGHT | DDS_WIDTH | DDS_DEPTH | DDS_PIXELFORMAT | DDS_MIPMAPCOUNT;
+
+                //header->flags |= (pixel_format->block_width != 1) || (pixel_format->block_height != 1) ? DDS_LINEARSIZE : DDS_PITCH;
+                header->height = vol_desc.Height;
+                header->width = vol_desc.Width;
+                header->depth = vol_desc.Depth;
+                header->miplevels = mip_levels;
+                header->pitch_or_linear_size = 0; //file_size;
+                header->caps = DDS_CAPS_COMPLEX | DDS_CAPS_TEXTURE | DDS_CAPS_MIPMAP;
+                header->caps2 = DDS_CAPS2_VOLUME;
+                hr = d3dformat_to_dds_pixel_format(&header->pixel_format, vol_desc.Format);
+                if (FAILED(hr))
+                {
+                    ID3DXBuffer_Release(buffer);
+                    return hr;
+                }
+            }
+            hr = calculate_dds_surface_size(vol_desc.Format, vol_desc.Width, vol_desc.Height, &src_row_pitch, &src_slice_pitch);
+            hr = IDirect3DVolume9_LockBox(volume, &locked_box, NULL, D3DLOCK_READONLY);
+            if (FAILED(hr))
+            {
+                ID3DXBuffer_Release(buffer);
+                return hr;
+            }
+
+            volume_box.width = vol_desc.Width;
+            volume_box.height = vol_desc.Height;
+            volume_box.depth = vol_desc.Depth;
+            copy_pixels(locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch,
+                        pixels, src_row_pitch, src_slice_pitch,
+                        &volume_box, pixel_format);
+     //       TRACE("pixels %p\n", pixels);
+            pixels += src_slice_pitch * vol_desc.Depth;
+            
+            IDirect3DVolume9_UnlockBox(volume);
+            IDirect3DVolume9_Release(volume);
+        }
+        *dst_buffer = buffer;
+    }
+    else
+    {
+    hr = get_surface(type, src_texture, D3DCUBEMAP_FACE_POSITIVE_X, 0, &surface);
+
+    if (SUCCEEDED(hr))
+    {
+        hr = save_dds_surface_to_memory(dst_buffer, surface, NULL);
+        IDirect3DSurface9_Release(surface);
+    }
+  }
+    return hr;
+}
 HRESULT load_volume_from_dds(IDirect3DVolume9 *dst_volume, const PALETTEENTRY *dst_palette,
     const D3DBOX *dst_box, const void *src_data, const D3DBOX *src_box, DWORD filter, D3DCOLOR color_key,
     const D3DXIMAGE_INFO *src_info)
@@ -531,7 +774,7 @@ HRESULT load_volume_from_dds(IDirect3DVolume9 *dst_volume, const PALETTEENTRY *d
 
     if (src_info->ResourceType != D3DRTYPE_VOLUMETEXTURE)
         return D3DXERR_INVALIDDATA;
-
+    //TODO - there may be linear_size or depth
     if (FAILED(calculate_dds_surface_size(src_info->Format, src_info->Width, src_info->Height, &row_pitch, &slice_pitch)))
         return E_NOTIMPL;
 
@@ -1502,8 +1745,21 @@ void copy_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pitch,
     UINT row, slice;
     BYTE *dst_addr;
     const BYTE *src_addr;
-    UINT row_block_count = (size->width + format->block_width - 1) / format->block_width;
-    UINT row_count = (size->height + format->block_height - 1) / format->block_height;
+    UINT row_block_count, row_count;
+    if (!format || !format->block_width || !format->block_height) {
+        if (format) {
+            ERR("block undefined for the format %#x\n", format->format);
+        } else {
+            ERR("no format\n");
+        }        
+        return;
+    }
+    if (!size) {
+        ERR("invalid call\n");
+        return;
+    }
+    row_block_count = (size->width + format->block_width - 1) / format->block_width;
+    row_count = (size->height + format->block_height - 1) / format->block_height;
 
     for (slice = 0; slice < size->depth; slice++)
     {
@@ -1716,6 +1972,28 @@ void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slic
     }
 }
 
+/*typedef BOOL (*dxtn_conversion_func)(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                                     enum wined3d_format_id format, unsigned int w, unsigned int h);
+ //format must be WINED3DFMT_B8G8R8A8_UNORM
+*/
+dxtn_conversion_func get_dxtn_conversion_func(D3DFORMAT format, BOOL encode)
+{
+    switch (format)
+    {
+        case D3DFMT_DXT1:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt1_encode : wined3d_dxt1_decode;
+        case D3DFMT_DXT3:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt3_encode : wined3d_dxt3_decode;
+        case D3DFMT_DXT5:
+            if (!wined3d_dxtn_supported()) return NULL;
+            return encode ? wined3d_dxt5_encode : wined3d_dxt5_decode;
+        default:
+            return NULL;
+    }
+}
+
 /************************************************************
  * D3DXLoadSurfaceFromMemory
  *
@@ -1757,11 +2035,13 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     D3DSURFACE_DESC surfdesc;
     D3DLOCKED_RECT lockrect;
     struct volume src_size, dst_size;
+    HRESULT ret = D3D_OK;
+    RECT tmp_rect;
 
     TRACE("(%p, %p, %s, %p, %#x, %u, %p, %s, %#x, 0x%08x)\n",
             dst_surface, dst_palette, wine_dbgstr_rect(dst_rect), src_memory, src_format,
             src_pitch, src_palette, wine_dbgstr_rect(src_rect), filter, color_key);
-
+//(0x1e6158, 0x0, (null), 0x76b4020, 0x14, 9327, 0x0, (0,0)-(3109,2199), 0xffffffff, 0x00000000)
     if (!dst_surface || !src_memory || !src_rect)
     {
         WARN("Invalid argument specified.\n");
@@ -1787,6 +2067,10 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     {
         dst_size.width = surfdesc.Width;
         dst_size.height = surfdesc.Height;
+        tmp_rect.left = 0;
+        tmp_rect.right = dst_size.width;
+        tmp_rect.top = 0;
+        tmp_rect.bottom = dst_size.height;
     }
     else
     {
@@ -1803,6 +2087,7 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
             return D3D_OK;
     }
     dst_size.depth = 1;
+    TRACE("dst_size = (%d, %d, %d)\n", dst_size.width, dst_size.height, dst_size.depth);
 
     srcformatdesc = get_format_info(src_format);
     destformatdesc = get_format_info(surfdesc.Format);
@@ -1833,41 +2118,120 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
 
         copy_pixels(src_memory, src_pitch, 0, lockrect.pBits, lockrect.Pitch, 0,
                 &src_size, srcformatdesc);
-
+      TRACE("simple copy done\n");
         IDirect3DSurface9_UnlockRect(dst_surface);
     }
     else /* Stretching or format conversion. */
     {
-        if (((srcformatdesc->type != FORMAT_ARGB) && (srcformatdesc->type != FORMAT_INDEX)) ||
-            (destformatdesc->type != FORMAT_ARGB))
+        dxtn_conversion_func pre_convert, post_convert;
+        void *tmp_src_memory = NULL, *tmp_dst_memory = NULL;
+        UINT tmp_src_pitch, tmp_dst_pitch;
+
+        pre_convert  = get_dxtn_conversion_func(srcformatdesc->format, FALSE);
+        post_convert = get_dxtn_conversion_func(destformatdesc->format, TRUE);
+
+        if ((!pre_convert && (srcformatdesc->type != FORMAT_ARGB) && (srcformatdesc->type != FORMAT_INDEX)) ||
+            (!post_convert && (destformatdesc->type != FORMAT_ARGB)))
         {
             FIXME("Format conversion missing %#x -> %#x\n", src_format, surfdesc.Format);
             return E_NOTIMPL;
         }
+      TRACE("Format conversion %#x -> %#x\n", src_format, surfdesc.Format);
+        //Format conversion 0x14 -> 0x16
+        if (!dst_rect) {
+            if (FAILED(IDirect3DSurface9_LockRect(dst_surface, &lockrect, &tmp_rect, 0)))
+                return D3DXERR_INVALIDDATA;
+        } else
+            if (FAILED(IDirect3DSurface9_LockRect(dst_surface, &lockrect, dst_rect, 0)))
+                return D3DXERR_INVALIDDATA;
+
+        /* handle pre-conversion */
+        if (pre_convert)
+        {
+          static int once;
+            tmp_src_memory = HeapAlloc(GetProcessHeap(), 0, src_size.width * src_size.height * sizeof(DWORD));
+            if (!tmp_src_memory)
+            {
+                ret = E_OUTOFMEMORY;
+                goto error;
+            }
+            tmp_src_pitch = src_size.width * sizeof(DWORD);
+          if (!once++) {
+            FIXME("decode dxtn from pitch=%d to %d\n", src_pitch, tmp_src_pitch);
+          }
+            if (!pre_convert(src_memory, tmp_src_memory, src_pitch, tmp_src_pitch,
+                    WINED3DFMT_B8G8R8A8_UNORM, src_size.width, src_size.height))
+            {
+                ret = E_FAIL;
+              ERR("pre_convert fails\n");
+                goto error;
+            }
+            srcformatdesc = get_format_info(D3DFMT_A8R8G8B8);
+        }
+        else
+        {
+            tmp_src_memory = (void *)src_memory;
+            tmp_src_pitch  = src_pitch;
+        }
 
-        if (FAILED(IDirect3DSurface9_LockRect(dst_surface, &lockrect, dst_rect, 0)))
-            return D3DXERR_INVALIDDATA;
-
+        /* handle post-conversion */
+        if (post_convert)
+        {
+            tmp_dst_memory = HeapAlloc(GetProcessHeap(), 0, dst_size.width * dst_size.height * sizeof(DWORD));
+            if (!tmp_dst_memory)
+            {
+                ret = E_OUTOFMEMORY;
+                goto error;
+            }
+            tmp_dst_pitch = dst_size.width * sizeof(DWORD);
+            destformatdesc = get_format_info(D3DFMT_A8R8G8B8);
+        }
+        else
+        {
+            tmp_dst_memory = lockrect.pBits;
+            tmp_dst_pitch  = lockrect.Pitch;
+        }
+      TRACE("filtering. %p, %d %p, %d\n", tmp_src_memory, tmp_src_pitch, tmp_dst_memory, tmp_dst_pitch);
+        //filtering. 0x76b4020, 9327 0x21b0030, 16384
         if ((filter & 0xf) == D3DX_FILTER_NONE)
         {
-            convert_argb_pixels(src_memory, src_pitch, 0, &src_size, srcformatdesc,
-                    lockrect.pBits, lockrect.Pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+            convert_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, srcformatdesc,
+                    tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
         }
         else /* if ((filter & 0xf) == D3DX_FILTER_POINT) */
         {
             if ((filter & 0xf) != D3DX_FILTER_POINT)
                 FIXME("Unhandled filter %#x.\n", filter);
-
+            //Unhandled filter 0x80004. = D3DX_FILTER_TRIANGLE | D3DX_FILTER_DITHER
+            // 0x5 = D3DX_FILTER_BOX
+            TRACE("src_size = (%d, %d, %d) pitch = %d\n", src_size.width, src_size.height, src_size.depth, tmp_src_pitch);
+            TRACE("dst_size = (%d, %d, %d) pitch = %d\n", dst_size.width, dst_size.height, dst_size.depth, tmp_dst_pitch);
             /* Always apply a point filter until D3DX_FILTER_LINEAR,
              * D3DX_FILTER_TRIANGLE and D3DX_FILTER_BOX are implemented. */
-            point_filter_argb_pixels(src_memory, src_pitch, 0, &src_size, srcformatdesc,
-                    lockrect.pBits, lockrect.Pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
+            point_filter_argb_pixels(tmp_src_memory, tmp_src_pitch, 0, &src_size, srcformatdesc,
+                    tmp_dst_memory, tmp_dst_pitch, 0, &dst_size, destformatdesc, color_key, src_palette);
         }
 
+        /* handle post-conversion */
+        if (post_convert)
+        {
+            if (!post_convert(tmp_dst_memory, lockrect.pBits, tmp_dst_pitch, lockrect.Pitch,
+                    WINED3DFMT_B8G8R8A8_UNORM, dst_size.width, dst_size.height))
+            {
+                ret = E_FAIL;
+                goto error;
+            }
+        } //else convert_argb_pixels from UNORM to dst_fmt
+
+error:
+        if (pre_convert)
+            HeapFree(GetProcessHeap(), 0, tmp_src_memory);
+        if (post_convert)
+            HeapFree(GetProcessHeap(), 0, tmp_dst_memory);
         IDirect3DSurface9_UnlockRect(dst_surface);
     }
-
-    return D3D_OK;
+  TRACE("Surface loaded\n");
+    return ret;
 }
 
 /************************************************************
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index 482f064..1bac9f0 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -2692,6 +2692,65 @@ static void test_effect_compilation_errors(IDirect3DDevice9 *device)
     effect->lpVtbl->Release(effect);
 }
 
+/*
+ * fxc.exe /Tfx_2_0
+ */
+#if 0
+technique t1 { pass p { ZEnable = TRUE; } }
+technique t2 { pass p { ZEnable = FALSE; } }
+#endif
+static const DWORD test_effect_technique_validation_blob[] =
+{
+0xfeff0901, 0x00000064, 0x00000000, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000,
+0x00000000, 0x00000001, 0x00000001, 0x00000002, 0x00000070, 0x00000003, 0x00003174, 0x00000000,
+0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00000002,
+0x00000070, 0x00000003, 0x00003274, 0x00000000, 0x00000002, 0x00000002, 0x00000001, 0x0000002c,
+0x00000000, 0x00000001, 0x00000024, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000008,
+0x00000004, 0x0000005c, 0x00000000, 0x00000001, 0x00000054, 0x00000000, 0x00000001, 0x00000000,
+0x00000000, 0x00000038, 0x00000034, 0x00000000, 0x00000000
+};
+
+static void test_effect_technique_validation(IDirect3DDevice9 *device)
+{
+    ID3DXEffect *effect;
+    ULONG count;
+    D3DXHANDLE technique1, technique2, technique;
+    HRESULT hr;
+
+    hr = D3DXCreateEffect(device, test_effect_technique_validation_blob,
+            sizeof(test_effect_technique_validation_blob), NULL, NULL, 0, NULL, &effect, NULL);
+    ok(hr == D3D_OK, "D3DXCreateEffect failed, got %#x, expected %#x\n", hr, D3D_OK);
+
+    technique1 = effect->lpVtbl->GetTechniqueByName(effect, "t1");
+    ok(technique1 != NULL, "Failed to get technique\n");
+    technique2 = effect->lpVtbl->GetTechniqueByName(effect, "t2");
+    ok(technique2 != NULL, "Failed to get technique\n");
+
+#if 0 /* This crashes on Windows */
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, (D3DXHANDLE)0xdeadbeef, &technique);
+#endif
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, NULL, NULL);
+    ok(hr == D3DERR_INVALIDCALL, "FindNextValidTechnique, got %#x, expected %#x\n", hr, D3DERR_INVALIDCALL);
+
+    technique = (D3DXHANDLE)0xdeadbeef;
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, NULL, &technique);
+    ok(hr == D3D_OK, "FindNextValidTechnique failed, got %#x, expected %#x\n", hr, D3D_OK);
+    ok(technique == technique1, "Technique returned %p, expected %p\n", technique, technique1);
+
+    technique = (D3DXHANDLE)0xdeadbeef;
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, technique1, &technique);
+    ok(hr == D3D_OK, "FindNextValidTechnique failed, got %#x, expected %#x\n", hr, D3D_OK);
+    ok(technique == technique2, "Technique returned %p, expected %p\n", technique, technique2);
+
+    technique = (D3DXHANDLE)0xdeadbeef;
+    hr = effect->lpVtbl->FindNextValidTechnique(effect, technique2, &technique);
+    ok(hr == S_FALSE, "FindNextValidTechnique, got %#x, expected %#x\n", hr, S_FALSE);
+    ok(technique == NULL, "Technique returned %p, expected %p\n", technique, NULL);
+
+    count = effect->lpVtbl->Release(effect);
+    ok(!count, "Release failed %u\n", count);
+}
+
 START_TEST(effect)
 {
     HWND wnd;
@@ -2730,6 +2789,7 @@ START_TEST(effect)
     test_effect_parameter_value(device);
     test_effect_variable_names(device);
     test_effect_compilation_errors(device);
+    test_effect_technique_validation(device);
 
     count = IDirect3DDevice9_Release(device);
     ok(count == 0, "The device was not properly freed: refcount %u\n", count);
diff --git a/dlls/d3dx9_36/tests/mesh.c b/dlls/d3dx9_36/tests/mesh.c
index dac0f60..21e6154 100644
--- a/dlls/d3dx9_36/tests/mesh.c
+++ b/dlls/d3dx9_36/tests/mesh.c
@@ -5308,6 +5308,88 @@ static void test_create_skin_info(void)
     ok(hr == D3DERR_INVALIDCALL, "Expected D3DERR_INVALIDCALL, got %#x\n", hr);
 }
 
+static void test_update_skinned_mesh(void)
+{
+    static DWORD bone0_vertices[2] = { 1, 3 };
+    static FLOAT bone0_weights[2] = { 1.0f, 0.5f };
+    static DWORD bone1_vertices[2] = { 2, 3 };
+    static FLOAT bone1_weights[2] = { 1.0f, 0.5f };
+    static D3DMATRIX bones_matrix[2] =
+    { { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+               2.0f,  2.0f,  4.0f,  1.0f
+      } } },
+      { { {
+               1.0f,  0.0f,  0.0f,  0.0f,
+               0.0f,  1.0f,  0.0f,  0.0f,
+               0.0f,  0.0f,  1.0f,  0.0f,
+              -4.0f, -4.0f,  4.0f,  1.0f
+      } } } };
+    static D3DVECTOR vertices_src[] = {{  1.0f,  1.0f,  1.0f },
+                                       {  1.0f,  0.0f,  0.0f },
+                                       {  1.0f,  1.0f, -1.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -1.0f, -1.0f,  1.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -1.0f, -1.0f, -1.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    static D3DVECTOR vertices_ref[] = {{  0.0f,  0.0f,  0.0f },
+                                       {  0.0f,  0.0f,  0.0f },
+                                       {  3.0f,  3.0f,  3.0f },
+                                       {  0.0f,  1.0f,  0.0f },
+                                       { -5.0f, -5.0f,  5.0f },
+                                       {  0.0f,  0.0f,  1.0f },
+                                       { -2.0f, -2.0f,  3.0f },
+                                       { -1.0f,  0.0f,  0.0f },
+                                      };
+    D3DVECTOR vertices_dest[8];
+    HRESULT hr;
+    ID3DXSkinInfo *skin_info;
+    D3DXMATRIX matrix;
+    int i;
+
+    D3DXMatrixIdentity(&matrix);
+    for (i = 0; i < 8; i++)
+    {
+        vertices_dest[i].x = 10000.0f;
+        vertices_dest[i].y = 10000.0f;
+        vertices_dest[i].z = 10000.0f;
+    }
+
+    hr = D3DXCreateSkinInfoFVF(4, D3DFVF_XYZ | D3DFVF_NORMAL, 2, &skin_info);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 0, 2, bone0_vertices, bone0_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 0, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->SetBoneInfluence(skin_info, 1, 2, bone1_vertices, bone1_weights);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->SetBoneOffsetMatrix(skin_info, 1, &matrix);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    skin_info->lpVtbl->UpdateSkinnedMesh(skin_info, bones_matrix, NULL, vertices_src, vertices_dest);
+    ok(hr == D3D_OK, "Expected D3D_OK, got %#x\n", hr);
+    for (i = 0; i < 4; i++)
+    {
+        ok(compare(vertices_dest[i*2].x, vertices_ref[i*2].x), "Vertex[%d].position.x: got %g, expected %g\n",
+           i, vertices_dest[i*2].x, vertices_ref[i*2].x);
+        ok(compare(vertices_dest[i*2].y, vertices_ref[i*2].y), "Vertex[%d].position.y: got %g, expected %g\n",
+           i, vertices_dest[i*2].y, vertices_ref[i*2].y);
+        ok(compare(vertices_dest[i*2].z, vertices_ref[i*2].z), "Vertex[%d].position.z: got %g, expected %g\n",
+           i, vertices_dest[i*2].z, vertices_ref[i*2].z);
+        ok(compare(vertices_dest[i*2+1].x, vertices_ref[i*2+1].x), "Vertex[%d].normal.x: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].x, vertices_ref[i*2+1].x);
+        ok(compare(vertices_dest[i*2+1].y, vertices_ref[i*2+1].y), "Vertex[%d].normal.y: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].y, vertices_ref[i*2+1].y);
+        ok(compare(vertices_dest[i*2+1].z, vertices_ref[i*2+1].z), "Vertex[%d].normal.z: got %g, expected %g\n",
+           i, vertices_dest[i*2+1].z, vertices_ref[i*2+1].z);
+    }
+    skin_info->lpVtbl->Release(skin_info);
+}
+
 static void test_convert_adjacency_to_point_reps(void)
 {
     HRESULT hr;
@@ -10625,6 +10707,7 @@ START_TEST(mesh)
     D3DXGenerateAdjacencyTest();
     test_update_semantics();
     test_create_skin_info();
+    test_update_skinned_mesh();
     test_convert_adjacency_to_point_reps();
     test_convert_point_reps_to_adjacency();
     test_weld_vertices();
diff --git a/dlls/d3dx9_36/tests/shader.c b/dlls/d3dx9_36/tests/shader.c
index 694540c..728cd86 100644
--- a/dlls/d3dx9_36/tests/shader.c
+++ b/dlls/d3dx9_36/tests/shader.c
@@ -1,5 +1,6 @@
 /*
  * Copyright 2008 Luis Busquets
+ * Copyright 2010, 2013 Christian Costa
  * Copyright 2011 Travis Athougies
  *
  * This library is free software; you can redistribute it and/or
@@ -299,6 +300,26 @@ static const DWORD fx_shader_with_ctab[] =
     0x0000ffff                                                              /* END                      */
 };
 
+static const DWORD semantics_vs11[] = {
+    0xfffe0101,                                                             /* vs_1_1                       */
+    0x0001fffe, D3DSIO_DCL,                                                 /* Comment                      */
+    0x00000051, 0xa00f0001, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, /* def c1 = dcl, dcl, dcl, dcl  */
+    0x0000001f, 0x80000000, 0x900f0000,                                     /* dcl_position0 v0 (input)     */
+    0x0000001f, 0x80000005, 0x900f0001,                                     /* dcl_texcoord0 v1 (input)     */
+    0x0000001f, 0x80010005, 0x900f0002,                                     /* dcl_texcoord1 v2 (input)     */
+    0x0000001f, 0x8000000a, 0xe00f0000,                                     /* dcl_color0    oD0 (output)   */
+    0x0000ffff};                                                            /* END                          */
+
+static const DWORD semantics_vs30[] = {
+    0xfffe0300,                                                             /* vs_3_0                       */
+    0x0001fffe, D3DSIO_DCL,                                                 /* Comment                      */
+    0x05000051, 0xa00f0001, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, D3DSIO_DCL, /* def c1 = dcl, dcl, dcl, dcl  */
+    0x0200001f, 0x80000000, 0x900f0000,                                     /* dcl_position0 v0 (input)     */
+    0x0200001f, 0x80000005, 0x900f0001,                                     /* dcl_texcoord0 v1 (input)     */
+    0x0200001f, 0x80010005, 0x900f0002,                                     /* dcl_texcoord1 v2 (input)     */
+    0x0200001f, 0x8000000a, 0xe00f0000,                                     /* dcl_color0    o0 (output)    */
+    0x0000ffff};                                                            /* END                          */
+
 static void test_get_shader_size(void)
 {
     UINT shader_size, expected;
@@ -6489,6 +6510,70 @@ static void test_registerset_defaults(void)
     if (wnd) DestroyWindow(wnd);
 }
 
+static void test_get_shader_semantics(void)
+{
+    HRESULT ret;
+    D3DXSEMANTIC semantics[MAXD3DDECLLENGTH];
+    UINT count;
+
+    /* Test D3DXGetShaderInputSemantics */
+
+    /* Check wrong parameters */
+    ret = D3DXGetShaderInputSemantics(NULL, NULL, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, NULL, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, semantics, NULL);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(NULL, semantics, &count);
+    ok(ret == D3DERR_INVALIDCALL, "Returned %#x, expected %#x\n", ret, D3DERR_INVALIDCALL);
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, NULL, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+
+    /* Check null semantics pointer */
+    count = 0xdeadbeef;
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, NULL, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+
+    /* Check null count pointer */
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, semantics, NULL);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Check with vs11 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs11, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+
+    /* Check with vs30 shader */
+    count = 0xdeadbeef;
+    memset(semantics, 0xcc, sizeof(semantics));
+    ret = D3DXGetShaderInputSemantics(semantics_vs30, semantics, &count);
+    ok(ret == D3D_OK, "Failed with %#x\n", ret);
+    ok(count == 3, "Got %u, expected 3\n", count);
+    ok(semantics[0].Usage == D3DDECLUSAGE_POSITION, "Got %u, expected %u\n", semantics[0].Usage, D3DDECLUSAGE_POSITION);
+    ok(semantics[0].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[1].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[1].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[1].UsageIndex == 0, "Got %u, expected 0\n", semantics[0].UsageIndex);
+    ok(semantics[2].Usage == D3DDECLUSAGE_TEXCOORD, "Got %u, expected %u\n", semantics[2].Usage, D3DDECLUSAGE_TEXCOORD);
+    ok(semantics[2].UsageIndex == 1, "Got %u, expected 1\n", semantics[0].UsageIndex);
+}
+
 START_TEST(shader)
 {
     test_get_shader_size();
@@ -6502,4 +6587,5 @@ START_TEST(shader)
     test_get_shader_constant_variables();
     test_registerset();
     test_registerset_defaults();
+    test_get_shader_semantics();
 }
diff --git a/dlls/d3dx9_36/tests/surface.c b/dlls/d3dx9_36/tests/surface.c
index 7a4dff8..87c3eb7 100644
--- a/dlls/d3dx9_36/tests/surface.c
+++ b/dlls/d3dx9_36/tests/surface.c
@@ -1103,7 +1103,7 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT3 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT3 format.\n");
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
         }
@@ -1129,7 +1129,7 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT5 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT5 format.\n");
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
         }
@@ -1142,10 +1142,10 @@ static void test_D3DXLoadSurface(IDirect3DDevice9 *device)
             hr = IDirect3DTexture9_GetSurfaceLevel(tex, 0, &newsurf);
             ok(SUCCEEDED(hr), "Failed to get the surface, hr %#x.\n", hr);
             hr = D3DXLoadSurfaceFromSurface(newsurf, NULL, NULL, surf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels to DXT1 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels to DXT1 format.\n");
 
             hr = D3DXLoadSurfaceFromSurface(surf, NULL, NULL, newsurf, NULL, NULL, D3DX_FILTER_NONE, 0);
-            todo_wine ok(SUCCEEDED(hr), "Failed to convert pixels from DXT1 format.\n");
+            ok(SUCCEEDED(hr), "Failed to convert pixels from DXT1 format.\n");
 
             check_release((IUnknown*)newsurf, 1);
             check_release((IUnknown*)tex, 0);
diff --git a/dlls/d3dx9_36/tests/texture.c b/dlls/d3dx9_36/tests/texture.c
index c90e2d5..59cb00e 100644
--- a/dlls/d3dx9_36/tests/texture.c
+++ b/dlls/d3dx9_36/tests/texture.c
@@ -25,7 +25,7 @@
 #include "d3dx9tex.h"
 #include "resources.h"
 
-static int has_2d_dxt3, has_2d_dxt5, has_cube_dxt5;
+static int has_2d_dxt3, has_2d_dxt5, has_cube_dxt5, has_3d_dxt3;
 
 /* 2x2 16-bit dds, no mipmaps */
 static const unsigned char dds_16bit[] = {
@@ -384,6 +384,16 @@ static void test_D3DXCheckTextureRequirements(IDirect3DDevice9 *device)
         ok(height == 4, "Returned height %d, expected %d\n", height, 4);
         ok(mipmaps == 1, "Returned mipmaps %d, expected %d\n", mipmaps, 1);
         ok(format == D3DFMT_DXT5, "Returned format %u, expected %u\n", format, D3DFMT_DXT5);
+
+        format = D3DFMT_DXT5;
+        width = 5; height = 5;
+        mipmaps = 1;
+        hr = D3DXCheckTextureRequirements(device, &width, &height, &mipmaps, 0, &format, D3DPOOL_DEFAULT);
+        ok(hr == D3D_OK, "D3DXCheckTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
+        ok(width == 8, "Returned width %d, expected %d\n", width, 8);
+        ok(height == 8, "Returned height %d, expected %d\n", height, 8);
+        ok(mipmaps == 1, "Returned mipmaps %d, expected %d\n", mipmaps, 1);
+        ok(format == D3DFMT_DXT5, "Returned format %u, expected %u\n", format, D3DFMT_DXT5);
     }
     else
     {
@@ -575,6 +585,14 @@ static void test_D3DXCheckVolumeTextureRequirements(IDirect3DDevice9 *device)
     ok(hr == D3D_OK, "D3DXCheckVolumeTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
     ok(format == D3DFMT_X8R8G8B8, "Returned format %u, expected %u\n", format, D3DFMT_X8R8G8B8);
 
+    format = D3DFMT_DXT3;
+    hr = D3DXCheckVolumeTextureRequirements(device, NULL, NULL, NULL, NULL, 0, &format, D3DPOOL_DEFAULT);
+    ok(hr == D3D_OK, "D3DXCheckVolumeTextureRequirements returned %#x, expected %#x\n", hr, D3D_OK);
+    if (has_3d_dxt3)
+        ok(format == D3DFMT_DXT3, "Returned format %u, expected %u\n", format, D3DFMT_DXT3);
+    else
+        todo_wine ok(format == D3DFMT_A8R8G8B8, "Returned format %u, expected %u\n", format, D3DFMT_A8R8G8B8);
+
     /* mipmaps */
     if (!(caps.TextureCaps & D3DPTEXTURECAPS_MIPVOLUMEMAP))
     {
@@ -1774,7 +1792,7 @@ static void test_D3DXCreateVolumeTextureFromFileInMemory(IDirect3DDevice9 *devic
     ok(hr == D3DERR_INVALIDCALL, "D3DXCreateVolumeTextureFromFileInMemory returned %#x, expected %#x\n", hr, D3DERR_INVALIDCALL);
 
     hr = D3DXCreateVolumeTextureFromFileInMemory(device, dds_volume_map, sizeof(dds_volume_map), &volume_texture);
-    if (has_2d_dxt3)
+    if (has_3d_dxt3)
         ok(hr == D3D_OK, "D3DXCreateVolumeTextureFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
     else
         todo_wine ok(hr == D3D_OK, "D3DXCreateVolumeTextureFromFileInMemory returned %#x, expected %#x\n", hr, D3D_OK);
@@ -1788,6 +1806,7 @@ static void test_D3DXCreateVolumeTextureFromFileInMemory(IDirect3DDevice9 *devic
         ok(volume_desc.Width == 4, "Got width %u, expected 4\n", volume_desc.Width);
         ok(volume_desc.Height == 4, "Got height %u, expected 4\n", volume_desc.Height);
         ok(volume_desc.Depth == 2, "Got depth %u, expected 2\n", volume_desc.Depth);
+        ok(volume_desc.Pool == D3DPOOL_MANAGED, "Got pool %u, expected D3DPOOL_MANAGED\n", volume_desc.Pool);
 
         hr = IDirect3DVolumeTexture9_GetLevelDesc(volume_texture, 1, &volume_desc);
         ok(hr == D3D_OK, "GetLevelDesc returned %#x, expected %#x\n", hr, D3D_OK);
@@ -2031,6 +2050,8 @@ START_TEST(texture)
     hr = IDirect3D9_CheckDeviceFormat(d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
             D3DFMT_X8R8G8B8, 0, D3DRTYPE_CUBETEXTURE, D3DFMT_DXT5);
     has_cube_dxt5 = SUCCEEDED(hr);
+    has_3d_dxt3 = SUCCEEDED(IDirect3D9_CheckDeviceFormat(d3d, D3DADAPTER_DEFAULT, D3DDEVTYPE_HAL,
+            D3DFMT_X8R8G8B8, 0, D3DRTYPE_VOLUMETEXTURE, D3DFMT_DXT3));
 
     test_D3DXCheckTextureRequirements(device);
     test_D3DXCheckCubeTextureRequirements(device);
diff --git a/dlls/d3dx9_36/texture.c b/dlls/d3dx9_36/texture.c
index 38349e2..7fa963c 100644
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -334,10 +334,10 @@ HRESULT WINAPI D3DXCheckTextureRequirements(struct IDirect3DDevice9 *device, UIN
 
     if (fmt->block_width != 1 || fmt->block_height != 1)
     {
-        if (w < fmt->block_width)
-            w = fmt->block_width;
-        if (h < fmt->block_height)
-            h = fmt->block_height;
+        if (w % fmt->block_width)
+            w += fmt->block_width - w % fmt->block_width;
+        if (h % fmt->block_height)
+            h += fmt->block_height - h % fmt->block_height;
     }
 
     if ((caps.TextureCaps & D3DPTEXTURECAPS_POW2) && (!is_pow2(w)))
@@ -529,6 +529,7 @@ HRESULT WINAPI D3DXCreateTexture(struct IDirect3DDevice9 *device, UINT width, UI
 
     TRACE("device %p, width %u, height %u, miplevels %u, usage %#x, format %#x, pool %#x, texture %p.\n",
             device, width, height, miplevels, usage, format, pool, texture);
+    //device 0x13a688, width 4096, height 4096, miplevels 13, usage 0, format 0x16, pool 0x1, texture 0x32f66c.
 
     if (!device || !texture)
         return D3DERR_INVALIDCALL;
@@ -1869,14 +1870,11 @@ HRESULT WINAPI D3DXSaveTextureToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE
 
     TRACE("(%p, %#x, %p, %p)\n",
         dst_buffer, file_format, src_texture, src_palette);
-
+//trace:d3dx:D3DXSaveTextureToFileInMemory (0x33f71c, 0x4, 0xafe670, 0x0)
     if (!dst_buffer || !src_texture) return D3DERR_INVALIDCALL;
 
     if (file_format == D3DXIFF_DDS)
-    {
-        FIXME("DDS file format isn't supported yet\n");
-        return E_NOTIMPL;
-    }
+        return save_dds_texture_to_memory(dst_buffer, src_texture, src_palette);
 
     type = IDirect3DBaseTexture9_GetType(src_texture);
     switch (type)
@@ -1886,7 +1884,7 @@ HRESULT WINAPI D3DXSaveTextureToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE
             hr = get_surface(type, src_texture, D3DCUBEMAP_FACE_POSITIVE_X, 0, &surface);
             break;
         case D3DRTYPE_VOLUMETEXTURE:
-            FIXME("Volume textures aren't supported yet\n");
+            FIXME("Volume textures supported only to dds file format\n");
             return E_NOTIMPL;
         default:
             return D3DERR_INVALIDCALL;
diff --git a/dlls/d3dx9_36/volume.c b/dlls/d3dx9_36/volume.c
index fae8542..1cab903 100644
--- a/dlls/d3dx9_36/volume.c
+++ b/dlls/d3dx9_36/volume.c
@@ -16,11 +16,83 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
 #include "wine/debug.h"
 #include "d3dx9_36_private.h"
 
+#include "wine/wined3d.h"
+#include "d3d9-dxtn.h"
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
+enum wined3d_format_id wined3dformat_from_d3dformat(D3DFORMAT format)
+{
+  BYTE *c = (BYTE *)&format;
+
+  /* Don't translate FOURCC formats */
+  if (isprint(c[0]) && isprint(c[1]) && isprint(c[2]) && isprint(c[3])) return (enum wined3d_format_id)format;
+
+  switch(format)
+  {
+    case D3DFMT_UNKNOWN: return WINED3DFMT_UNKNOWN;
+    case D3DFMT_R8G8B8: return WINED3DFMT_B8G8R8_UNORM;
+    case D3DFMT_A8R8G8B8: return WINED3DFMT_B8G8R8A8_UNORM;
+    case D3DFMT_X8R8G8B8: return WINED3DFMT_B8G8R8X8_UNORM;
+    case D3DFMT_R5G6B5: return WINED3DFMT_B5G6R5_UNORM;
+    case D3DFMT_X1R5G5B5: return WINED3DFMT_B5G5R5X1_UNORM;
+    case D3DFMT_A1R5G5B5: return WINED3DFMT_B5G5R5A1_UNORM;
+    case D3DFMT_A4R4G4B4: return WINED3DFMT_B4G4R4A4_UNORM;
+    case D3DFMT_R3G3B2: return WINED3DFMT_B2G3R3_UNORM;
+    case D3DFMT_A8: return WINED3DFMT_A8_UNORM;
+    case D3DFMT_A8R3G3B2: return WINED3DFMT_B2G3R3A8_UNORM;
+    case D3DFMT_X4R4G4B4: return WINED3DFMT_B4G4R4X4_UNORM;
+    case D3DFMT_A2B10G10R10: return WINED3DFMT_R10G10B10A2_UNORM;
+    case D3DFMT_A8B8G8R8: return WINED3DFMT_R8G8B8A8_UNORM;
+    case D3DFMT_X8B8G8R8: return WINED3DFMT_R8G8B8X8_UNORM;
+    case D3DFMT_G16R16: return WINED3DFMT_R16G16_UNORM;
+    case D3DFMT_A2R10G10B10: return WINED3DFMT_B10G10R10A2_UNORM;
+    case D3DFMT_A16B16G16R16: return WINED3DFMT_R16G16B16A16_UNORM;
+    case D3DFMT_A8P8: return WINED3DFMT_P8_UINT_A8_UNORM;
+    case D3DFMT_P8: return WINED3DFMT_P8_UINT;
+    case D3DFMT_L8: return WINED3DFMT_L8_UNORM;
+    case D3DFMT_A8L8: return WINED3DFMT_L8A8_UNORM;
+    case D3DFMT_A4L4: return WINED3DFMT_L4A4_UNORM;
+    case D3DFMT_V8U8: return WINED3DFMT_R8G8_SNORM;
+    case D3DFMT_L6V5U5: return WINED3DFMT_R5G5_SNORM_L6_UNORM;
+    case D3DFMT_X8L8V8U8: return WINED3DFMT_R8G8_SNORM_L8X8_UNORM;
+    case D3DFMT_Q8W8V8U8: return WINED3DFMT_R8G8B8A8_SNORM;
+    case D3DFMT_V16U16: return WINED3DFMT_R16G16_SNORM;
+    case D3DFMT_A2W10V10U10: return WINED3DFMT_R10G10B10_SNORM_A2_UNORM;
+    case D3DFMT_D16_LOCKABLE: return WINED3DFMT_D16_LOCKABLE;
+    case D3DFMT_D32_LOCKABLE: return WINED3DFMT_D32_LOCKABLE;
+    case D3DFMT_S8_LOCKABLE: return WINED3DFMT_S8_LOCKABLE;
+    case D3DFMT_D32: return WINED3DFMT_D32_UNORM;
+    case D3DFMT_D15S1: return WINED3DFMT_S1_UINT_D15_UNORM;
+    case D3DFMT_D24S8: return WINED3DFMT_D24_UNORM_S8_UINT;
+    case D3DFMT_D24X8: return WINED3DFMT_X8D24_UNORM;
+    case D3DFMT_D24X4S4: return WINED3DFMT_S4X4_UINT_D24_UNORM;
+    case D3DFMT_D16: return WINED3DFMT_D16_UNORM;
+    case D3DFMT_L16: return WINED3DFMT_L16_UNORM;
+    case D3DFMT_D32F_LOCKABLE: return WINED3DFMT_D32_FLOAT;
+    case D3DFMT_D24FS8: return WINED3DFMT_S8_UINT_D24_FLOAT;
+    case D3DFMT_VERTEXDATA: return WINED3DFMT_VERTEXDATA;
+    case D3DFMT_INDEX16: return WINED3DFMT_R16_UINT;
+    case D3DFMT_INDEX32: return WINED3DFMT_R32_UINT;
+    case D3DFMT_Q16W16V16U16: return WINED3DFMT_R16G16B16A16_SNORM;
+    case D3DFMT_R16F: return WINED3DFMT_R16_FLOAT;
+    case D3DFMT_G16R16F: return WINED3DFMT_R16G16_FLOAT;
+    case D3DFMT_A16B16G16R16F: return WINED3DFMT_R16G16B16A16_FLOAT;
+    case D3DFMT_R32F: return WINED3DFMT_R32_FLOAT;
+    case D3DFMT_G32R32F: return WINED3DFMT_R32G32_FLOAT;
+    case D3DFMT_A32B32G32R32F: return WINED3DFMT_R32G32B32A32_FLOAT;
+    case D3DFMT_CxV8U8: return WINED3DFMT_R8G8_SNORM_Cx;
+    default:
+      FIXME("Unhandled D3DFORMAT %#x\n", format);
+      return WINED3DFMT_UNKNOWN;
+  }
+}
+
+
 HRESULT WINAPI D3DXLoadVolumeFromFileA(IDirect3DVolume9 *dst_volume,
                                        const PALETTEENTRY *dst_palette,
                                        const D3DBOX *dst_box,
@@ -79,7 +151,16 @@ HRESULT WINAPI D3DXLoadVolumeFromFileW(IDirect3DVolume9 *dst_volume,
 
     return hr;
 }
-
+/*
+SrcRowPitch [in]
+Type: UINT
+Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one row of cells, in bytes.
+SrcSlicePitch [in]
+Type: UINT
+Pitch of source image, in bytes. For DXT formats (compressed texture formats), this number should represent the size of one slice of cells, in bytes.
+ 
+ Assumed sizes for uncompressed image. Real file size is smaller.
+*/
 HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
                                         const PALETTEENTRY *dst_palette,
                                         const D3DBOX *dst_box,
@@ -95,15 +176,17 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
     HRESULT hr;
     D3DVOLUME_DESC desc;
     D3DLOCKED_BOX locked_box;
+    D3DBOX tmp_box;
     struct volume dst_size, src_size;
     const struct pixel_format_desc *src_format_desc, *dst_format_desc;
-
+//hr = D3DXLoadVolumeFromMemory(volume, NULL, &dst_box, pixels, D3DFMT_A8R8G8B8, 16, 32, NULL, &src_box, D3DX_DEFAULT, 0);
     TRACE("(%p, %p, %p, %p, %#x, %u, %u, %p, %p, %x, %x)\n", dst_volume, dst_palette, dst_box,
             src_memory, src_format, src_row_pitch, src_slice_pitch, src_palette, src_box,
             filter, color_key);
-
+    // (0x1df440, 0x0, 0x33f668, 0xa640030, 0x16, 8192, 0, 0x0, 0x33f650, ffffffff, 0) -- WOW, src_slice_pitch == 0
+    // this is 256x256x8 mips=1 DXT1,  8192=(256/4) * (256/4) * 2
     if (!dst_volume || !src_memory || !src_box) return D3DERR_INVALIDCALL;
-
+//set_box(&src_box, 1, 1, 7, 7, 0, 1);
     if (src_format == D3DFMT_UNKNOWN
             || src_box->Left >= src_box->Right
             || src_box->Top >= src_box->Bottom
@@ -124,6 +207,12 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
         dst_size.width = desc.Width;
         dst_size.height = desc.Height;
         dst_size.depth = desc.Depth;
+        tmp_box.Left = 0;
+        tmp_box.Right = dst_size.width;
+        tmp_box.Bottom = dst_size.height;
+        tmp_box.Top  = 0;
+        tmp_box.Front  = 0;
+        tmp_box.Back = dst_size.depth;
     }
     else
     {
@@ -143,6 +232,14 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
     if (src_format_desc->type == FORMAT_UNKNOWN)
         return E_NOTIMPL;
 
+    if (src_slice_pitch == 0)
+    {
+ //       src_slice_pitch = src_row_pitch * max(1, (src_size.height + src_format_desc->block_height - 1) / src_format_desc->block_height);
+        src_slice_pitch = src_row_pitch * src_size.height; //this is in bytes, not in blocks
+        WARN("workaround for src_slice_pitch = %d\n", src_slice_pitch);
+        //workaround for src_slice_pitch = 8388608
+    }
+
     dst_format_desc = get_format_info(desc.Format);
     if (dst_format_desc->type == FORMAT_UNKNOWN)
         return E_NOTIMPL;
@@ -183,45 +280,158 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
     }
     else
     {
+        //4 steps
+        //1. Convert from src_format to WINED3DFMT_B8G8R8A8_UNORM (so Float will not be supported?)
+        //or 2. pre-convert from DXT1 to WINED3DFMT_B8G8R8A8_UNORM
+        //3. convert to DXT5 if dst=DXT5
+        //or 4. post-convert from WINED3DFMT_B8G8R8A8_UNORM to dst_format
         const BYTE *src_addr;
-
-
-        if (((src_format_desc->type != FORMAT_ARGB) && (src_format_desc->type != FORMAT_INDEX)) ||
-            (dst_format_desc->type != FORMAT_ARGB))
+        dxtn_conversion_func pre_convert, post_convert;
+        void *tmp_src_memory = NULL;
+        BYTE *tmp_memory;
+        D3DFORMAT tmp_format = D3DFMT_A8R8G8B8;
+        struct pixel_format_desc *tmp_format_desc;
+        UINT tmp_row_pitch, tmp_slice_pitch, slice_n;
+        int tmp_size = 1;
+        
+        //assume DXT1,3,5 formats, else NULL
+        pre_convert  = get_dxtn_conversion_func(src_format_desc->format, FALSE); //decompress
+        post_convert = get_dxtn_conversion_func(dst_format_desc->format, TRUE); //compress
+        
+        if ((!pre_convert && (src_format_desc->type != FORMAT_ARGB) && (src_format_desc->type != FORMAT_INDEX)) ||
+            (!post_convert && (dst_format_desc->type != FORMAT_ARGB)))
         {
             FIXME("Pixel format conversion is not implemented %#x -> %#x\n",
-                    src_format_desc->format, dst_format_desc->format);
+                  src_format_desc->format, dst_format_desc->format);
             return E_NOTIMPL;
         }
-
+        FIXME("convert volume tex from 0x%x to 0x%x\n", src_format_desc->format, dst_format_desc->format);
+        if (!dst_box) {
+            hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, &tmp_box, 0);
+        } else 
+            hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
+        if (FAILED(hr)) {
+            ERR("fail to LockBox\n");
+            return hr;
+        }
+        
+        //this is initial shift of source pixels
         src_addr = src_memory;
         src_addr += src_box->Front * src_slice_pitch;
-        src_addr += src_box->Top * src_row_pitch;
-        src_addr += src_box->Left * src_format_desc->bytes_per_pixel;
-
-        hr = IDirect3DVolume9_LockBox(dst_volume, &locked_box, dst_box, 0);
-        if (FAILED(hr)) return hr;
-
-        if ((filter & 0xf) == D3DX_FILTER_NONE)
+        src_addr += (src_box->Top / src_format_desc->block_height) * src_row_pitch;
+        src_addr += (src_box->Left / src_format_desc->block_width) * src_format_desc->block_byte_count;
+        TRACE("src_memory %p, src_addr %p, src_row_pitch=%d src_slice_pitch=%d\n",
+              src_memory, src_addr, src_row_pitch, src_slice_pitch);
+        
+        /* handle pre-conversion from src_fmt to D3DFMT_A8R8G8B8 */
+        tmp_format_desc = get_format_info(tmp_format);
+        tmp_size = src_size.depth?src_size.depth:1;
+        tmp_row_pitch = src_size.width * tmp_format_desc->bytes_per_pixel;
+        tmp_slice_pitch = src_slice_pitch;
+        //I think it is compressing factor src_format_desc->block_byte_count
+        slice_n = tmp_slice_pitch * tmp_size * tmp_format_desc->bytes_per_pixel;
+        tmp_src_memory = HeapAlloc(GetProcessHeap(), 0, slice_n);
+        TRACE("allocated memory %p size=%d\n", tmp_src_memory, slice_n);
+        if (!tmp_src_memory)
         {
-            convert_argb_pixels(src_memory, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
-                    locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, &dst_size, dst_format_desc, color_key,
-                    src_palette);
+            hr = E_OUTOFMEMORY;
+            goto error;
+        }
+        tmp_memory = tmp_src_memory;
+        if (pre_convert)
+        {
+            //calculate_dds - for reference
+            for (slice_n = 0; slice_n < tmp_size; slice_n++)
+            {
+                if (!pre_convert(src_addr, tmp_memory, src_row_pitch, tmp_row_pitch,
+                                 WINED3DFMT_B8G8R8A8_UNORM,
+                                 src_size.width, src_size.height))
+                {
+                    hr = E_FAIL;
+                    ERR("fail to pre_convert\n");
+                    goto error;
+                }
+                src_addr += src_slice_pitch / src_format_desc->block_byte_count;
+                tmp_memory += tmp_slice_pitch;
+            }
+            src_format_desc = get_format_info(src_format_desc->format);
         }
         else
         {
-            if ((filter & 0xf) != D3DX_FILTER_POINT)
-                FIXME("Unhandled filter %#x.\n", filter);
-
-            point_filter_argb_pixels(src_addr, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
-                    locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch, &dst_size, dst_format_desc, color_key,
-                    src_palette);
+            if ((filter & 0xf) == D3DX_FILTER_NONE)
+            {
+                convert_argb_pixels(src_addr, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
+                                    tmp_memory, tmp_row_pitch, tmp_slice_pitch, &dst_size,
+                                    tmp_format_desc, color_key, src_palette);
+            }
+            else
+            {
+                if ((filter & 0xf) != D3DX_FILTER_POINT)
+                    FIXME("Unhandled filter %#x.\n", filter);
+                TRACE("row_pitch=%d slice_pitch=%d, whole_size=%d\n",
+                      tmp_row_pitch, tmp_slice_pitch, tmp_slice_pitch * dst_size.depth);
+                point_filter_argb_pixels(src_addr, src_row_pitch, src_slice_pitch, &src_size, src_format_desc,
+                                         tmp_memory, tmp_row_pitch, tmp_slice_pitch, &dst_size,
+                                         tmp_format_desc, color_key, src_palette);
+            }
         }
-
+        tmp_memory = tmp_src_memory;
+        /* handle post-conversion from D3DFMT_A8R8G8B8 to dst_fmt*/
+        if (post_convert)
+        {
+            dst_format_desc = get_format_info(dst_format_desc->format);
+            src_addr = locked_box.pBits;
+            tmp_row_pitch = dst_format_desc->block_byte_count *
+            max(1, (dst_size.width + dst_format_desc->block_width - 1) / dst_format_desc->block_width);
+            for (slice_n = 0; slice_n < tmp_size; slice_n++)
+            {
+                if (!post_convert(tmp_memory, src_addr, tmp_row_pitch, locked_box.RowPitch,
+                                  WINED3DFMT_B8G8R8A8_UNORM,
+                                  dst_size.width, dst_size.height))
+                {
+                    hr = E_FAIL;
+                    ERR("fail to post_convert\n");
+                    goto error;
+                }
+                src_addr += src_slice_pitch / src_format_desc->block_byte_count;
+                tmp_memory += tmp_slice_pitch;
+            }
+        }
+        else
+        {
+            //convert from WINED3DFMT_B8G8R8A8_UNORM to dst_fmt if not DXTn
+            if ((filter & 0xf) == D3DX_FILTER_NONE)
+            {
+                convert_argb_pixels(tmp_memory, tmp_row_pitch, tmp_slice_pitch, &src_size, src_format_desc,
+                                    locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch,
+                                    &dst_size, dst_format_desc, color_key, src_palette);
+            }
+            else /* if ((filter & 0xf) == D3DX_FILTER_POINT) */
+            {
+                if ((filter & 0xf) != D3DX_FILTER_POINT)
+                    FIXME("Unhandled filter %#x.\n", filter);
+                
+                /* Always apply a point filter until D3DX_FILTER_LINEAR,
+                 * D3DX_FILTER_TRIANGLE and D3DX_FILTER_BOX are implemented. */
+                point_filter_argb_pixels(tmp_memory, tmp_row_pitch, tmp_slice_pitch, &src_size, src_format_desc,
+                                         locked_box.pBits, locked_box.RowPitch, locked_box.SlicePitch,
+                                         &dst_size, dst_format_desc, color_key, src_palette);
+            }
+        }
+        
+        TRACE("format converted from 0x%x to 0x%x\n",
+              src_format_desc->format, dst_format_desc->format);
+        
+    error:
+        if (tmp_src_memory) {
+            TRACE("heap_free %p end at %p\n", tmp_src_memory, tmp_memory);
+            HeapFree(GetProcessHeap(), 0, tmp_src_memory); //crash
+        }
+        TRACE("UnlockBox\n");
         IDirect3DVolume9_UnlockBox(dst_volume);
     }
-
-    return D3D_OK;
+    TRACE("return %#x\n", hr);
+    return hr;
 }
 
 HRESULT WINAPI D3DXLoadVolumeFromFileInMemory(IDirect3DVolume9 *dst_volume,
@@ -325,3 +535,84 @@ HRESULT WINAPI D3DXLoadVolumeFromVolume(IDirect3DVolume9 *dst_volume,
     IDirect3DVolume9_UnlockBox(src_volume);
     return hr;
 }
+
+
+HRESULT WINAPI D3DXSaveVolumeToFileA(const char *dst_filename, D3DXIMAGE_FILEFORMAT file_format,
+                                      IDirect3DVolume9 *srcvolume, const PALETTEENTRY *src_palette, const D3DBOX *srcbox)
+{
+  int len;
+  WCHAR *filename;
+  HRESULT hr;
+  ID3DXBuffer *buffer;
+  
+  TRACE("(%s, %#x, %p, %p, %p): relay\n",
+        wine_dbgstr_a(dst_filename), file_format, srcvolume, src_palette, srcbox);
+  
+  if (!dst_filename) return D3DERR_INVALIDCALL;
+  
+  len = MultiByteToWideChar(CP_ACP, 0, dst_filename, -1, NULL, 0);
+  filename = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+  if (!filename) return E_OUTOFMEMORY;
+  MultiByteToWideChar(CP_ACP, 0, dst_filename, -1, filename, len);
+  
+  hr = D3DXSaveVolumeToFileInMemory(&buffer, file_format, srcvolume, src_palette, srcbox);
+  if (SUCCEEDED(hr))
+  {
+    hr = write_buffer_to_file(filename, buffer);
+    ID3DXBuffer_Release(buffer);
+  }
+  
+  HeapFree(GetProcessHeap(), 0, filename);
+  return hr;
+}
+
+HRESULT WINAPI D3DXSaveVolumeToFileW(const WCHAR *dst_filename, D3DXIMAGE_FILEFORMAT file_format,
+                                      IDirect3DVolume9 *srcvolume, const PALETTEENTRY *src_palette, const D3DBOX *srcbox)
+{
+  HRESULT hr;
+  ID3DXBuffer *buffer;
+  
+  TRACE("(%s, %#x, %p, %p, %p): relay\n",
+        wine_dbgstr_w(dst_filename), file_format, srcvolume, src_palette, srcbox);
+  
+  if (!dst_filename) return D3DERR_INVALIDCALL;
+  
+  hr = D3DXSaveVolumeToFileInMemory(&buffer, file_format, srcvolume, src_palette, srcbox);
+  if (SUCCEEDED(hr))
+  {
+    hr = write_buffer_to_file(dst_filename, buffer);
+    ID3DXBuffer_Release(buffer);
+  }
+  
+  return hr;
+}
+
+HRESULT WINAPI D3DXSaveVolumeToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE_FILEFORMAT file_format,
+                                             IDirect3DVolume9 *srcvolume, const PALETTEENTRY *src_palette, const D3DBOX *srcbox)
+{
+  TRACE("(%p, %#x, %p, %p, %p)\n",
+        dst_buffer, file_format, srcvolume, src_palette, srcbox);
+  
+  if (!dst_buffer || !srcvolume) return D3DERR_INVALIDCALL;
+  
+  if (src_palette)
+  {
+    FIXME("Saving volume with palettized pixel formats is not implemented yet\n");
+    return D3DERR_INVALIDCALL;
+  }
+  
+  switch (file_format)
+  {
+    case D3DXIFF_DDS:
+      return save_dds_volume_to_memory(dst_buffer, srcvolume, 1, srcbox); 
+    case D3DXIFF_HDR:
+    case D3DXIFF_PFM:
+    case D3DXIFF_TGA:
+    case D3DXIFF_PPM:
+      FIXME("File format %#x is not supported yet\n", file_format);
+      return E_NOTIMPL;
+    default:
+      return D3DERR_INVALIDCALL;
+  }
+}
+
diff --git a/dlls/d3dx9_36/xfile.c b/dlls/d3dx9_36/xfile.c
index eda0d7e..0f037c1 100644
--- a/dlls/d3dx9_36/xfile.c
+++ b/dlls/d3dx9_36/xfile.c
@@ -110,7 +110,7 @@ static ULONG WINAPI d3dx9_file_data_AddRef(ID3DXFileData *iface)
     struct d3dx9_file_data *file_data = impl_from_ID3DXFileData(iface);
     ULONG refcount = InterlockedIncrement(&file_data->ref);
 
-    TRACE("%p increasing refcount to %u.\n", file_data, refcount);
+//    TRACE("%p increasing refcount to %u.\n", file_data, refcount);
 
     return refcount;
 }
@@ -120,7 +120,7 @@ static ULONG WINAPI d3dx9_file_data_Release(ID3DXFileData *iface)
     struct d3dx9_file_data *file_data = impl_from_ID3DXFileData(iface);
     ULONG refcount = InterlockedDecrement(&file_data->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", file_data, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", file_data, refcount);
 
     if (!refcount)
     {
@@ -412,7 +412,7 @@ static ULONG WINAPI d3dx9_file_enum_object_AddRef(ID3DXFileEnumObject *iface)
     struct d3dx9_file_enum_object *file_enum = impl_from_ID3DXFileEnumObject(iface);
     ULONG refcount = InterlockedIncrement(&file_enum->ref);
 
-    TRACE("%p increasing refcount to %u.\n", file_enum, refcount);
+//    TRACE("%p increasing refcount to %u.\n", file_enum, refcount);
 
     return refcount;
 }
@@ -422,7 +422,7 @@ static ULONG WINAPI d3dx9_file_enum_object_Release(ID3DXFileEnumObject *iface)
     struct d3dx9_file_enum_object *file_enum = impl_from_ID3DXFileEnumObject(iface);
     ULONG refcount = InterlockedDecrement(&file_enum->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", file_enum, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", file_enum, refcount);
 
     if (!refcount)
     {
@@ -527,7 +527,7 @@ static ULONG WINAPI d3dx9_file_AddRef(ID3DXFile *iface)
     struct d3dx9_file *file = impl_from_ID3DXFile(iface);
     ULONG refcount = InterlockedIncrement(&file->ref);
 
-    TRACE("%p increasing refcount to %u.\n", file, refcount);
+//    TRACE("%p increasing refcount to %u.\n", file, refcount);
 
     return refcount;
 }
@@ -537,7 +537,7 @@ static ULONG WINAPI d3dx9_file_Release(ID3DXFile *iface)
     struct d3dx9_file *file = impl_from_ID3DXFile(iface);
     ULONG refcount = InterlockedDecrement(&file->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", file, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", file, refcount);
 
     if (!refcount)
     {
diff --git a/dlls/d3dx9_37/d3dx9_37.spec b/dlls/d3dx9_37/d3dx9_37.spec
index 502ccb2..324855e 100644
--- a/dlls/d3dx9_37/d3dx9_37.spec
+++ b/dlls/d3dx9_37/d3dx9_37.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_38/d3dx9_38.spec b/dlls/d3dx9_38/d3dx9_38.spec
index 502ccb2..324855e 100644
--- a/dlls/d3dx9_38/d3dx9_38.spec
+++ b/dlls/d3dx9_38/d3dx9_38.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_39/d3dx9_39.spec b/dlls/d3dx9_39/d3dx9_39.spec
index 502ccb2..324855e 100644
--- a/dlls/d3dx9_39/d3dx9_39.spec
+++ b/dlls/d3dx9_39/d3dx9_39.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_40/d3dx9_40.spec b/dlls/d3dx9_40/d3dx9_40.spec
index 502ccb2..324855e 100644
--- a/dlls/d3dx9_40/d3dx9_40.spec
+++ b/dlls/d3dx9_40/d3dx9_40.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_41/d3dx9_41.spec b/dlls/d3dx9_41/d3dx9_41.spec
index 502ccb2..324855e 100644
--- a/dlls/d3dx9_41/d3dx9_41.spec
+++ b/dlls/d3dx9_41/d3dx9_41.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_42/d3dx9_42.spec b/dlls/d3dx9_42/d3dx9_42.spec
index 502ccb2..324855e 100644
--- a/dlls/d3dx9_42/d3dx9_42.spec
+++ b/dlls/d3dx9_42/d3dx9_42.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/d3dx9_43/d3dx9_43.spec b/dlls/d3dx9_43/d3dx9_43.spec
index 89f5430..9da1640 100644
--- a/dlls/d3dx9_43/d3dx9_43.spec
+++ b/dlls/d3dx9_43/d3dx9_43.spec
@@ -26,7 +26,7 @@
 @ stdcall D3DXComputeNormals(ptr ptr) d3dx9_36.D3DXComputeNormals
 @ stdcall D3DXComputeTangent(ptr long long long long ptr) d3dx9_36.D3DXComputeTangent
 @ stdcall D3DXComputeTangentFrame(ptr long) d3dx9_36.D3DXComputeTangentFrame
-@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr long long long ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
+@ stdcall D3DXComputeTangentFrameEx(ptr long long long long long long long long long ptr float float float ptr ptr) d3dx9_36.D3DXComputeTangentFrameEx
 @ stdcall D3DXConcatenateMeshes(ptr long long ptr ptr ptr ptr ptr) d3dx9_36.D3DXConcatenateMeshes
 @ stdcall D3DXConvertMeshSubsetToSingleStrip(ptr long long ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToSingleStrip
 @ stdcall D3DXConvertMeshSubsetToStrips(ptr long long ptr ptr ptr ptr) d3dx9_36.D3DXConvertMeshSubsetToStrips
diff --git a/dlls/dbghelp/Makefile.in b/dlls/dbghelp/Makefile.in
index e5d40b1..cfb5b3e 100644
--- a/dlls/dbghelp/Makefile.in
+++ b/dlls/dbghelp/Makefile.in
@@ -1,6 +1,6 @@
 MODULE    = dbghelp.dll
 IMPORTLIB = dbghelp
-EXTRADEFS = -D_IMAGEHLP_SOURCE_ -DDLLPREFIX='"$(DLLPREFIX)"'
+EXTRADEFS = -D_IMAGEHLP_SOURCE_ -DDLLPREFIX='"$(DLLPREFIX)"' -DBINDIR="\"${bindir}\""
 IMPORTS   = psapi
 DELAYIMPORTS = version
 EXTRALIBS = $(Z_LIBS)
diff --git a/dlls/dbghelp/elf_module.c b/dlls/dbghelp/elf_module.c
index b176143..8e22265 100644
--- a/dlls/dbghelp/elf_module.c
+++ b/dlls/dbghelp/elf_module.c
@@ -1486,9 +1486,11 @@ static BOOL elf_search_and_load_file(struct process* pcs, const WCHAR* filename,
     if (!ret && !strchrW(filename, '/'))
     {
         ret = elf_load_file_from_path(pcs, filename, load_offset, dyn_addr,
-                                      getenv("PATH"), elf_info) ||
-            elf_load_file_from_path(pcs, filename, load_offset, dyn_addr,
-                                    getenv("LD_LIBRARY_PATH"), elf_info);
+                                      getenv("PATH"), elf_info);
+        if (!ret) ret = elf_load_file_from_path(pcs, filename, load_offset, dyn_addr,
+                                                getenv("LD_LIBRARY_PATH"), elf_info);
+        if (!ret) ret = elf_load_file_from_path(pcs, filename, load_offset, dyn_addr,
+                                                BINDIR, elf_info);
         if (!ret) ret = elf_load_file_from_dll_path(pcs, filename,
                                                     load_offset, dyn_addr, elf_info);
     }
diff --git a/dlls/dbghelp/path.c b/dlls/dbghelp/path.c
index 5bd260e..94b0e0e 100644
--- a/dlls/dbghelp/path.c
+++ b/dlls/dbghelp/path.c
@@ -541,6 +541,8 @@ static BOOL CALLBACK module_find_cb(PCWSTR buffer, PVOID user)
             struct pdb_lookup           pdb_lookup;
             char                        fn[MAX_PATH];
 
+          memset(&pdb_lookup, 0, sizeof(struct pdb_lookup));
+
             WideCharToMultiByte(CP_ACP, 0, buffer, -1, fn, MAX_PATH, NULL, NULL);
             pdb_lookup.filename = fn;
 
diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index 31ec6bf..b860834 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -3119,46 +3119,97 @@ static HRESULT WINAPI ddraw7_EnumSurfaces(IDirectDraw7 *iface, DWORD Flags,
 {
     struct ddraw *ddraw = impl_from_IDirectDraw7(iface);
     struct ddraw_surface *surf;
-    BOOL all, nomatch;
-    DDSURFACEDESC2 desc;
-    struct list *entry, *entry2;
+    DWORD match_flags = Flags & (DDENUMSURFACES_ALL | DDENUMSURFACES_NOMATCH | DDENUMSURFACES_MATCH);
 
     TRACE("iface %p, flags %#x, surface_desc %p, context %p, callback %p.\n",
             iface, Flags, DDSD, Context, Callback);
 
-    all = Flags & DDENUMSURFACES_ALL;
-    nomatch = Flags & DDENUMSURFACES_NOMATCH;
-
     if (!Callback)
         return DDERR_INVALIDPARAMS;
 
-    wined3d_mutex_lock();
-
-    /* Use the _SAFE enumeration, the app may destroy enumerated surfaces */
-    LIST_FOR_EACH_SAFE(entry, entry2, &ddraw->surface_list)
+    if (Flags & DDENUMSURFACES_CANBECREATED)
     {
-        surf = LIST_ENTRY(entry, struct ddraw_surface, surface_list_entry);
+         IDirectDrawSurface7 *surface;
+         DDSURFACEDESC2 testdesc;
+
+        if (match_flags != DDENUMSURFACES_MATCH)
+            return DDERR_INVALIDPARAMS;
+
+        if (!DDSD)
+            return DDERR_INVALIDPARAMS;
+
+        memcpy(&testdesc, DDSD, sizeof(testdesc));
+
+        if (!(testdesc.dwFlags & DDSD_WIDTH))
+        {
+            testdesc.dwFlags |= DDSD_WIDTH;
+            testdesc.dwWidth = 512;
+        }
 
-        if (!surf->iface_count)
+        if (!(testdesc.dwFlags & DDSD_HEIGHT))
         {
-            WARN("Not enumerating surface %p because it doesn't have any references.\n", surf);
-            continue;
+            testdesc.dwFlags |= DDSD_HEIGHT;
+            testdesc.dwHeight = 512;
         }
 
-        if (all || (nomatch != ddraw_match_surface_desc(DDSD, &surf->surface_desc)))
+        if (IDirectDraw7_CreateSurface(iface, &testdesc, &surface, NULL) == DD_OK)
+        {
+            surf = unsafe_impl_from_IDirectDrawSurface7(surface);
+            Callback(NULL, &surf->surface_desc, Context);
+            IDirectDrawSurface7_Release(surface);
+        }
+        else
+            FIXME("Failed to create surface!\n");
+    }
+    else if (Flags & DDENUMSURFACES_DOESEXIST)
+    {
+        DDSURFACEDESC2 desc;
+        struct list *entry, *entry2;
+        BOOL nomatch, all;
+
+        /* a combination of match flags is not allowed */
+        if (match_flags != 0 &&
+                match_flags != DDENUMSURFACES_ALL &&
+                match_flags != DDENUMSURFACES_MATCH &&
+                match_flags != DDENUMSURFACES_NOMATCH)
+            return DDERR_INVALIDPARAMS;
+
+        all = (Flags & DDENUMSURFACES_ALL) != 0;
+        nomatch = (Flags & DDENUMSURFACES_NOMATCH) != 0;
+
+        if (!all && !DDSD)
+            return DDERR_INVALIDPARAMS;
+
+        wined3d_mutex_lock();
+
+        /* Use the _SAFE enumeration, the app may destroy enumerated surfaces */
+        LIST_FOR_EACH_SAFE(entry, entry2, &ddraw->surface_list)
         {
-            TRACE("Enumerating surface %p.\n", surf);
-            desc = surf->surface_desc;
-            IDirectDrawSurface7_AddRef(&surf->IDirectDrawSurface7_iface);
-            if (Callback(&surf->IDirectDrawSurface7_iface, &desc, Context) != DDENUMRET_OK)
+            surf = LIST_ENTRY(entry, struct ddraw_surface, surface_list_entry);
+
+            if (!surf->iface_count)
             {
-                wined3d_mutex_unlock();
-                return DD_OK;
+                WARN("Not enumerating surface %p because it doesn't have any references.\n", surf);
+                continue;
+            }
+
+            if (all || (nomatch != ddraw_match_surface_desc(DDSD, &surf->surface_desc)))
+            {
+                TRACE("Enumerating surface %p.\n", surf);
+                desc = surf->surface_desc;
+                IDirectDrawSurface7_AddRef(&surf->IDirectDrawSurface7_iface);
+                if (Callback(&surf->IDirectDrawSurface7_iface, &desc, Context) != DDENUMRET_OK)
+                {
+                    wined3d_mutex_unlock();
+                    return DD_OK;
+                }
             }
         }
-    }
 
-    wined3d_mutex_unlock();
+        wined3d_mutex_unlock();
+    }
+    else
+        return DDERR_INVALIDPARAMS;
 
     return DD_OK;
 }
diff --git a/dlls/ddraw/executebuffer.c b/dlls/ddraw/executebuffer.c
index fb52ffd..509b897 100644
--- a/dlls/ddraw/executebuffer.c
+++ b/dlls/ddraw/executebuffer.c
@@ -147,9 +147,10 @@ HRESULT d3d_execute_buffer_execute(struct d3d_execute_buffer *buffer,
                     buffer->indices[(i * 3) + 2] = ci->u3.v3;
                     instr += size;
                 }
-                IDirect3DDevice7_DrawIndexedPrimitive(&device->IDirect3DDevice7_iface,
-                        D3DPT_TRIANGLELIST, D3DFVF_TLVERTEX, tl_vx, buffer->nb_vertices,
-                        buffer->indices, count * 3, 0);
+                if (count)
+                    IDirect3DDevice7_DrawIndexedPrimitive(&device->IDirect3DDevice7_iface,
+                            D3DPT_TRIANGLELIST, D3DFVF_TLVERTEX, tl_vx, buffer->nb_vertices,
+                            buffer->indices, count * 3, 0);
 	    } break;
 
 	    case D3DOP_MATRIXLOAD:
diff --git a/dlls/ddraw/main.c b/dlls/ddraw/main.c
index 2f5d113..0d2a18d 100644
--- a/dlls/ddraw/main.c
+++ b/dlls/ddraw/main.c
@@ -251,6 +251,11 @@ DDRAW_Create(const GUID *guid,
     {
         device_type = WINED3D_DEVICE_TYPE_HAL;
     }
+    else if(guid && guid->Data1 == 0xaeb2cdd4)
+    {
+      FIXME("call to 0xaeb2cdd4\n");
+      device_type = WINED3D_DEVICE_TYPE_HAL;
+    }
     else
     {
         device_type = 0;
@@ -936,8 +941,8 @@ BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
                 desc.dwSize = sizeof(desc);
                 for(i = 0; i <= 1; i++)
                 {
-                    hr = IDirectDraw7_EnumSurfaces(&ddraw->IDirectDraw7_iface, DDENUMSURFACES_ALL,
-                            &desc, ddraw, DestroyCallback);
+                    hr = IDirectDraw7_EnumSurfaces(&ddraw->IDirectDraw7_iface,
+                            DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL, &desc, ddraw, DestroyCallback);
                     if(hr != D3D_OK)
                         ERR("(%p) EnumSurfaces failed, prepare for trouble\n", ddraw);
                 }
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index 0d2d731..ef17a14 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -688,6 +688,10 @@ static ULONG WINAPI d3d_texture2_Release(IDirect3DTexture2 *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture2(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p.\n", iface);
 
     return IUnknown_Release(surface->texture_outer);
@@ -697,6 +701,10 @@ static ULONG WINAPI d3d_texture1_Release(IDirect3DTexture *iface)
 {
     struct ddraw_surface *surface = impl_from_IDirect3DTexture(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p.\n", iface);
 
     return IUnknown_Release(surface->texture_outer);
@@ -737,6 +745,10 @@ static HRESULT WINAPI ddraw_surface7_GetAttachedSurface(IDirectDrawSurface7 *ifa
     DDSCAPS2 our_caps;
     int i;
 
+  if (!This) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, Caps, Surface);
 
     wined3d_mutex_lock();
@@ -824,6 +836,10 @@ static HRESULT WINAPI ddraw_surface4_GetAttachedSurface(IDirectDrawSurface4 *ifa
     IDirectDrawSurface7 *attachment7;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     hr = ddraw_surface7_GetAttachedSurface(&surface->IDirectDrawSurface7_iface,
@@ -850,6 +866,10 @@ static HRESULT WINAPI ddraw_surface3_GetAttachedSurface(IDirectDrawSurface3 *ifa
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -881,6 +901,10 @@ static HRESULT WINAPI ddraw_surface2_GetAttachedSurface(IDirectDrawSurface2 *ifa
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -912,6 +936,10 @@ static HRESULT WINAPI ddraw_surface1_GetAttachedSurface(IDirectDrawSurface *ifac
     DDSCAPS2 caps2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, caps %p, attachment %p.\n", iface, caps, attachment);
 
     caps2.dwCaps  = caps->dwCaps;
@@ -1034,6 +1062,10 @@ static HRESULT WINAPI ddraw_surface7_Lock(IDirectDrawSurface7 *iface,
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface7(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1052,6 +1084,10 @@ static HRESULT WINAPI ddraw_surface4_Lock(IDirectDrawSurface4 *iface, RECT *rect
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1072,6 +1108,10 @@ static HRESULT WINAPI ddraw_surface3_Lock(IDirectDrawSurface3 *iface, RECT *rect
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1098,6 +1138,10 @@ static HRESULT WINAPI ddraw_surface2_Lock(IDirectDrawSurface2 *iface, RECT *rect
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
 
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1123,6 +1167,10 @@ static HRESULT WINAPI ddraw_surface1_Lock(IDirectDrawSurface *iface, RECT *rect,
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
     DDSURFACEDESC2 surface_desc2;
     HRESULT hr;
+  if (!surface) {
+    return DDERR_INVALIDPARAMS;
+  }
+  
     TRACE("iface %p, rect %s, surface_desc %p, flags %#x, h %p.\n",
             iface, wine_dbgstr_rect(rect), surface_desc, flags, h);
 
@@ -1155,11 +1203,15 @@ static HRESULT WINAPI ddraw_surface1_Lock(IDirectDrawSurface *iface, RECT *rect,
  *  For more details, see IWineD3DSurface::UnlockRect
  *
  *****************************************************************************/
-static HRESULT WINAPI ddraw_surface7_Unlock(IDirectDrawSurface7 *iface, RECT *pRect)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_Unlock(IDirectDrawSurface7 *iface, RECT *pRect)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface7(iface);
     HRESULT hr;
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, rect %s.\n", iface, wine_dbgstr_rect(pRect));
 
     wined3d_mutex_lock();
@@ -1171,46 +1223,63 @@ static HRESULT WINAPI ddraw_surface7_Unlock(IDirectDrawSurface7 *iface, RECT *pR
     return hr;
 }
 
-static HRESULT WINAPI ddraw_surface4_Unlock(IDirectDrawSurface4 *iface, RECT *pRect)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_Unlock(IDirectDrawSurface4 *iface, RECT *pRect)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, rect %p.\n", iface, pRect);
 
     return ddraw_surface7_Unlock(&surface->IDirectDrawSurface7_iface, pRect);
 }
 
-static HRESULT WINAPI ddraw_surface3_Unlock(IDirectDrawSurface3 *iface, void *data)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_Unlock(IDirectDrawSurface3 *iface, void *data)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
     return ddraw_surface7_Unlock(&surface->IDirectDrawSurface7_iface, NULL);
 }
 
-static HRESULT WINAPI ddraw_surface2_Unlock(IDirectDrawSurface2 *iface, void *data)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_Unlock(IDirectDrawSurface2 *iface, void *data)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
     return ddraw_surface7_Unlock(&surface->IDirectDrawSurface7_iface, NULL);
 }
 
-static HRESULT WINAPI ddraw_surface1_Unlock(IDirectDrawSurface *iface, void *data)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_Unlock(IDirectDrawSurface *iface, void *data)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
 
+  if (!surface) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, data %p.\n", iface, data);
 
     /* data might not be the LPRECT of later versions, so drop it. */
     return ddraw_surface7_Unlock(&surface->IDirectDrawSurface7_iface, NULL);
 }
 
-static HRESULT WINAPI ddraw_surface7_Flip(IDirectDrawSurface7 *iface, IDirectDrawSurface7 *src, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_Flip(IDirectDrawSurface7 *iface,
+        IDirectDrawSurface7 *src, DWORD flags)
 {
     struct ddraw_surface *dst_impl = impl_from_IDirectDrawSurface7(iface);
     struct ddraw_surface *src_impl = unsafe_impl_from_IDirectDrawSurface7(src);
@@ -1218,10 +1287,14 @@ static HRESULT WINAPI ddraw_surface7_Flip(IDirectDrawSurface7 *iface, IDirectDra
     struct ddraw_texture *ddraw_texture, *prev_ddraw_texture;
     DDSCAPS2 caps = {DDSCAPS_FLIP, 0, 0, {0}};
     struct wined3d_texture *texture;
-    IDirectDrawSurface7 *current;
+    IDirectDrawSurface7 *current = NULL;
     struct wined3d_surface *tmp;
     HRESULT hr;
 
+  if (!src_impl || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, src %p, flags %#x.\n", iface, src, flags);
 
     if (src == iface || !(dst_impl->surface_desc.ddsCaps.dwCaps & (DDSCAPS_FRONTBUFFER | DDSCAPS_OVERLAY)))
@@ -1332,44 +1405,64 @@ static HRESULT WINAPI ddraw_surface7_Flip(IDirectDrawSurface7 *iface, IDirectDra
     return hr;
 }
 
-static HRESULT WINAPI ddraw_surface4_Flip(IDirectDrawSurface4 *iface, IDirectDrawSurface4 *dst, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_Flip(IDirectDrawSurface4 *iface,
+        IDirectDrawSurface4 *dst, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface4(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
             dst_impl ? &dst_impl->IDirectDrawSurface7_iface : NULL, flags);
 }
 
-static HRESULT WINAPI ddraw_surface3_Flip(IDirectDrawSurface3 *iface, IDirectDrawSurface3 *dst, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_Flip(IDirectDrawSurface3 *iface,
+        IDirectDrawSurface3 *dst, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface3(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
             dst_impl ? &dst_impl->IDirectDrawSurface7_iface : NULL, flags);
 }
 
-static HRESULT WINAPI ddraw_surface2_Flip(IDirectDrawSurface2 *iface, IDirectDrawSurface2 *dst, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_Flip(IDirectDrawSurface2 *iface,
+        IDirectDrawSurface2 *dst, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface2(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
             dst_impl ? &dst_impl->IDirectDrawSurface7_iface : NULL, flags);
 }
 
-static HRESULT WINAPI ddraw_surface1_Flip(IDirectDrawSurface *iface, IDirectDrawSurface *dst, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_Flip(IDirectDrawSurface *iface,
+        IDirectDrawSurface *dst, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
     struct ddraw_surface *dst_impl = unsafe_impl_from_IDirectDrawSurface(dst);
 
+  if (!surface || !dst_impl) {
+    return DD_OK;
+  }
+  
     TRACE("iface %p, dst %p, flags %#x.\n", iface, dst, flags);
 
     return ddraw_surface7_Flip(&surface->IDirectDrawSurface7_iface,
@@ -1514,7 +1607,7 @@ static HRESULT ddraw_surface_blt_clipped(struct ddraw_surface *dst_surface, cons
  *  See IWineD3DSurface::Blt for more details
  *
  *****************************************************************************/
-static HRESULT WINAPI ddraw_surface7_Blt(IDirectDrawSurface7 *iface, RECT *DestRect,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_Blt(IDirectDrawSurface7 *iface, RECT *DestRect,
         IDirectDrawSurface7 *SrcSurface, RECT *SrcRect, DWORD Flags, DDBLTFX *DDBltFx)
 {
     struct ddraw_surface *dst_surface = impl_from_IDirectDrawSurface7(iface);
@@ -1640,7 +1733,7 @@ static HRESULT WINAPI ddraw_surface7_Blt(IDirectDrawSurface7 *iface, RECT *DestR
     }
 }
 
-static HRESULT WINAPI ddraw_surface4_Blt(IDirectDrawSurface4 *iface, RECT *dst_rect,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_Blt(IDirectDrawSurface4 *iface, RECT *dst_rect,
         IDirectDrawSurface4 *src_surface, RECT *src_rect, DWORD flags, DDBLTFX *fx)
 {
     struct ddraw_surface *dst = impl_from_IDirectDrawSurface4(iface);
@@ -1653,7 +1746,7 @@ static HRESULT WINAPI ddraw_surface4_Blt(IDirectDrawSurface4 *iface, RECT *dst_r
             src ? &src->IDirectDrawSurface7_iface : NULL, src_rect, flags, fx);
 }
 
-static HRESULT WINAPI ddraw_surface3_Blt(IDirectDrawSurface3 *iface, RECT *dst_rect,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_Blt(IDirectDrawSurface3 *iface, RECT *dst_rect,
         IDirectDrawSurface3 *src_surface, RECT *src_rect, DWORD flags, DDBLTFX *fx)
 {
     struct ddraw_surface *dst = impl_from_IDirectDrawSurface3(iface);
@@ -1666,7 +1759,7 @@ static HRESULT WINAPI ddraw_surface3_Blt(IDirectDrawSurface3 *iface, RECT *dst_r
             src_impl ? &src_impl->IDirectDrawSurface7_iface : NULL, src_rect, flags, fx);
 }
 
-static HRESULT WINAPI ddraw_surface2_Blt(IDirectDrawSurface2 *iface, RECT *dst_rect,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_Blt(IDirectDrawSurface2 *iface, RECT *dst_rect,
         IDirectDrawSurface2 *src_surface, RECT *src_rect, DWORD flags, DDBLTFX *fx)
 {
     struct ddraw_surface *dst = impl_from_IDirectDrawSurface2(iface);
@@ -1679,7 +1772,7 @@ static HRESULT WINAPI ddraw_surface2_Blt(IDirectDrawSurface2 *iface, RECT *dst_r
             src_impl ? &src_impl->IDirectDrawSurface7_iface : NULL, src_rect, flags, fx);
 }
 
-static HRESULT WINAPI ddraw_surface1_Blt(IDirectDrawSurface *iface, RECT *dst_rect,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_Blt(IDirectDrawSurface *iface, RECT *dst_rect,
         IDirectDrawSurface *src_surface, RECT *src_rect, DWORD flags, DDBLTFX *fx)
 {
     struct ddraw_surface *dst = impl_from_IDirectDrawSurface(iface);
@@ -2640,7 +2733,7 @@ static HRESULT WINAPI ddraw_surface2_PageUnlock(IDirectDrawSurface2 *iface, DWOR
  *  DDERR_UNSUPPORTED
  *
  *****************************************************************************/
-static HRESULT WINAPI ddraw_surface7_BltBatch(IDirectDrawSurface7 *iface, DDBLTBATCH *Batch, DWORD Count, DWORD Flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_BltBatch(IDirectDrawSurface7 *iface, DDBLTBATCH *Batch, DWORD Count, DWORD Flags)
 {
     TRACE("iface %p, batch %p, count %u, flags %#x.\n", iface, Batch, Count, Flags);
 
@@ -2648,7 +2741,7 @@ static HRESULT WINAPI ddraw_surface7_BltBatch(IDirectDrawSurface7 *iface, DDBLTB
     return DDERR_UNSUPPORTED;
 }
 
-static HRESULT WINAPI ddraw_surface4_BltBatch(IDirectDrawSurface4 *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_BltBatch(IDirectDrawSurface4 *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface4(iface);
 
@@ -2657,7 +2750,7 @@ static HRESULT WINAPI ddraw_surface4_BltBatch(IDirectDrawSurface4 *iface, DDBLTB
     return ddraw_surface7_BltBatch(&surface->IDirectDrawSurface7_iface, batch, count, flags);
 }
 
-static HRESULT WINAPI ddraw_surface3_BltBatch(IDirectDrawSurface3 *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_BltBatch(IDirectDrawSurface3 *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface3(iface);
 
@@ -2666,7 +2759,7 @@ static HRESULT WINAPI ddraw_surface3_BltBatch(IDirectDrawSurface3 *iface, DDBLTB
     return ddraw_surface7_BltBatch(&surface->IDirectDrawSurface7_iface, batch, count, flags);
 }
 
-static HRESULT WINAPI ddraw_surface2_BltBatch(IDirectDrawSurface2 *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_BltBatch(IDirectDrawSurface2 *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface2(iface);
 
@@ -2675,7 +2768,7 @@ static HRESULT WINAPI ddraw_surface2_BltBatch(IDirectDrawSurface2 *iface, DDBLTB
     return ddraw_surface7_BltBatch(&surface->IDirectDrawSurface7_iface, batch, count, flags);
 }
 
-static HRESULT WINAPI ddraw_surface1_BltBatch(IDirectDrawSurface *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_BltBatch(IDirectDrawSurface *iface, DDBLTBATCH *batch, DWORD count, DWORD flags)
 {
     struct ddraw_surface *surface = impl_from_IDirectDrawSurface(iface);
 
@@ -4093,7 +4186,7 @@ static HRESULT WINAPI ddraw_surface7_GetLOD(IDirectDrawSurface7 *iface, DWORD *M
  *  For more details, see IWineD3DSurface::BltFast
  *
  *****************************************************************************/
-static HRESULT WINAPI ddraw_surface7_BltFast(IDirectDrawSurface7 *iface, DWORD dstx, DWORD dsty,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface7_BltFast(IDirectDrawSurface7 *iface, DWORD dstx, DWORD dsty,
         IDirectDrawSurface7 *Source, RECT *rsrc, DWORD trans)
 {
     struct ddraw_surface *This = impl_from_IDirectDrawSurface7(iface);
@@ -4165,7 +4258,7 @@ static HRESULT WINAPI ddraw_surface7_BltFast(IDirectDrawSurface7 *iface, DWORD d
     }
 }
 
-static HRESULT WINAPI ddraw_surface4_BltFast(IDirectDrawSurface4 *iface, DWORD dst_x, DWORD dst_y,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface4_BltFast(IDirectDrawSurface4 *iface, DWORD dst_x, DWORD dst_y,
         IDirectDrawSurface4 *src_surface, RECT *src_rect, DWORD flags)
 {
     struct ddraw_surface *dst_impl = impl_from_IDirectDrawSurface4(iface);
@@ -4178,7 +4271,7 @@ static HRESULT WINAPI ddraw_surface4_BltFast(IDirectDrawSurface4 *iface, DWORD d
             src_impl ? &src_impl->IDirectDrawSurface7_iface : NULL, src_rect, flags);
 }
 
-static HRESULT WINAPI ddraw_surface3_BltFast(IDirectDrawSurface3 *iface, DWORD dst_x, DWORD dst_y,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface3_BltFast(IDirectDrawSurface3 *iface, DWORD dst_x, DWORD dst_y,
         IDirectDrawSurface3 *src_surface, RECT *src_rect, DWORD flags)
 {
     struct ddraw_surface *dst_impl = impl_from_IDirectDrawSurface3(iface);
@@ -4191,7 +4284,7 @@ static HRESULT WINAPI ddraw_surface3_BltFast(IDirectDrawSurface3 *iface, DWORD d
             src_impl ? &src_impl->IDirectDrawSurface7_iface : NULL, src_rect, flags);
 }
 
-static HRESULT WINAPI ddraw_surface2_BltFast(IDirectDrawSurface2 *iface, DWORD dst_x, DWORD dst_y,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface2_BltFast(IDirectDrawSurface2 *iface, DWORD dst_x, DWORD dst_y,
         IDirectDrawSurface2 *src_surface, RECT *src_rect, DWORD flags)
 {
     struct ddraw_surface *dst_impl = impl_from_IDirectDrawSurface2(iface);
@@ -4204,7 +4297,7 @@ static HRESULT WINAPI ddraw_surface2_BltFast(IDirectDrawSurface2 *iface, DWORD d
             src_impl ? &src_impl->IDirectDrawSurface7_iface : NULL, src_rect, flags);
 }
 
-static HRESULT WINAPI ddraw_surface1_BltFast(IDirectDrawSurface *iface, DWORD dst_x, DWORD dst_y,
+static HRESULT WINAPI DECLSPEC_HOTPATCH ddraw_surface1_BltFast(IDirectDrawSurface *iface, DWORD dst_x, DWORD dst_y,
         IDirectDrawSurface *src_surface, RECT *src_rect, DWORD flags)
 {
     struct ddraw_surface *dst_impl = impl_from_IDirectDrawSurface(iface);
@@ -6209,6 +6302,10 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
     DDSURFACEDESC2 *desc = &surface->surface_desc;
     struct wined3d_resource_desc wined3d_desc;
     unsigned int version = texture->version;
+    UINT row_pitch, slice_pitch;
+    struct wined3d_resource *resource = wined3d_surface_get_resource(wined3d_surface);
+
+    wined3d_resource_get_pitch(resource, &row_pitch, &slice_pitch);
 
     surface->IDirectDrawSurface7_iface.lpVtbl = &ddraw_surface7_vtbl;
     surface->IDirectDrawSurface4_iface.lpVtbl = &ddraw_surface4_vtbl;
@@ -6239,7 +6336,7 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
     }
 
     *desc = texture->surface_desc;
-    wined3d_resource_get_desc(wined3d_surface_get_resource(wined3d_surface), &wined3d_desc);
+    wined3d_resource_get_desc(resource, &wined3d_desc);
     desc->dwWidth = wined3d_desc.width;
     desc->dwHeight = wined3d_desc.height;
     surface->first_attached = surface;
@@ -6249,14 +6346,16 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
         if (desc->dwFlags & DDSD_LPSURFACE)
             desc->u1.dwLinearSize = ~0u;
         else
-            desc->u1.dwLinearSize = wined3d_surface_get_pitch(wined3d_surface) * ((desc->dwHeight + 3) / 4);
+        {
+            desc->u1.dwLinearSize = row_pitch * ((desc->dwHeight + 3) / 4);
+        }
         desc->dwFlags |= DDSD_LINEARSIZE;
         desc->dwFlags &= ~(DDSD_LPSURFACE | DDSD_PITCH);
     }
     else
     {
         if (!(desc->dwFlags & DDSD_LPSURFACE))
-            desc->u1.lPitch = wined3d_surface_get_pitch(wined3d_surface);
+            desc->u1.lPitch = row_pitch;
         desc->dwFlags |= DDSD_PITCH;
         desc->dwFlags &= ~(DDSD_LPSURFACE | DDSD_LINEARSIZE);
     }
diff --git a/dlls/ddraw/tests/d3d.c b/dlls/ddraw/tests/d3d.c
index ec4197a..457ebbc 100644
--- a/dlls/ddraw/tests/d3d.c
+++ b/dlls/ddraw/tests/d3d.c
@@ -57,6 +57,11 @@ typedef struct {
     int total;
 } D3D7ECancelTest;
 
+typedef struct {
+    UINT found;
+    UINT surfaces;
+} EnumSurfaceTest;
+
 #define MAX_ENUMERATION_COUNT 10
 typedef struct
 {
@@ -85,17 +90,21 @@ static ULONG getRefcount(IUnknown *iface)
 
 static HRESULT WINAPI SurfaceCounter(IDirectDrawSurface7 *surface, DDSURFACEDESC2 *desc, void *context)
 {
-    UINT *num = context;
-    (*num)++;
-    IDirectDrawSurface_Release(surface);
+    EnumSurfaceTest *count = context;
+    count->found++;
+    if (surface)
+    {
+        count->surfaces++;
+        IDirectDrawSurface_Release(surface);
+    }
     return DDENUMRET_OK;
 }
 
 static BOOL CreateDirect3D(void)
 {
     HRESULT rc;
-    DDSURFACEDESC2 ddsd;
-    UINT num;
+    DDSURFACEDESC2 ddsd, ddsd2;
+    EnumSurfaceTest count;
 
     rc = pDirectDrawCreateEx(NULL, (void**)&lpDD,
         &IID_IDirectDraw7, NULL);
@@ -122,9 +131,174 @@ static BOOL CreateDirect3D(void)
     if (FAILED(rc))
         return FALSE;
 
-    num = 0;
-    IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_ALL | DDENUMSURFACES_DOESEXIST, NULL, &num, SurfaceCounter);
-    ok(num == 1, "Has %d surfaces, expected 1\n", num);
+    memset(&ddsd2, 0, sizeof(ddsd2));
+    ddsd2.dwSize = sizeof(ddsd2);
+    ddsd2.dwFlags = DDSD_WIDTH | DDSD_HEIGHT;
+    ddsd2.dwWidth = 256;
+    ddsd2.dwHeight = 256;
+
+    /* without search type flags */
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, 0, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, 0, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_ALL, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_MATCH, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_NOMATCH, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    /* search type DDENUMSURFACES_DOESEXIST */
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST, &ddsd2, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL, NULL, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_MATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_NOMATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_MATCH, &ddsd2, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 1, "Has %d surfaces, expected 1\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_NOMATCH, &ddsd2, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL | DDENUMSURFACES_MATCH,
+                                   NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_ALL | DDENUMSURFACES_NOMATCH,
+                                   NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_MATCH | DDENUMSURFACES_NOMATCH,
+                                   NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    /* search type DDENUMSURFACES_CANBECREATED */
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_ALL, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_NOMATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_MATCH, NULL, &count, SurfaceCounter);
+    ok(rc == DDERR_INVALIDPARAMS, "Expected DDERR_INVALIDPARAMS, got %x\n", rc);
+    ok(count.found == 0, "Has %d surface descriptions, expected 0\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_MATCH, &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
+
+    /* combination of DDENUMSURFACES_DOESEXIST and DDENUMSURFACES_CANBECREATED */
+
+    count.found = 0;
+    count.surfaces = 0;
+    rc = IDirectDraw7_EnumSurfaces(lpDD, DDENUMSURFACES_DOESEXIST | DDENUMSURFACES_CANBECREATED | DDENUMSURFACES_MATCH,
+                                   &ddsd, &count, SurfaceCounter);
+    ok(rc == DD_OK, "Expected DD_OK, got %x\n", rc);
+    ok(count.found == 1, "Has %d surface descriptions, expected 1\n", count.found);
+    ok(count.surfaces == 0, "Has %d surfaces, expected 0\n", count.surfaces);
 
     memset(&ddsd, 0, sizeof(ddsd));
     ddsd.dwSize = sizeof(ddsd);
diff --git a/dlls/ddraw/tests/ddraw1.c b/dlls/ddraw/tests/ddraw1.c
index 597251c..7c46075 100644
--- a/dlls/ddraw/tests/ddraw1.c
+++ b/dlls/ddraw/tests/ddraw1.c
@@ -4700,7 +4700,7 @@ static void test_pixel_format(void)
     }
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -4710,7 +4710,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -4725,7 +4725,7 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to create surface, hr %#x.\n",hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -4739,7 +4739,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -4751,12 +4751,12 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
         test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
     }
 
 cleanup:
diff --git a/dlls/ddraw/tests/ddraw2.c b/dlls/ddraw/tests/ddraw2.c
index 104bf5b..ded82b9 100644
--- a/dlls/ddraw/tests/ddraw2.c
+++ b/dlls/ddraw/tests/ddraw2.c
@@ -5782,7 +5782,7 @@ static void test_pixel_format(void)
     }
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -5792,7 +5792,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -5807,7 +5807,7 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to create surface, hr %#x.\n",hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -5821,7 +5821,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -5833,12 +5833,12 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
         test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
     }
 
 cleanup:
diff --git a/dlls/ddraw/tests/ddraw4.c b/dlls/ddraw/tests/ddraw4.c
index ac31e24..055f598 100644
--- a/dlls/ddraw/tests/ddraw4.c
+++ b/dlls/ddraw/tests/ddraw4.c
@@ -6763,7 +6763,7 @@ static void test_pixel_format(void)
     }
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -6773,7 +6773,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -6788,7 +6788,7 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to create surface, hr %#x.\n",hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -6802,7 +6802,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -6814,12 +6814,12 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
         test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
     }
 
 cleanup:
diff --git a/dlls/ddraw/tests/ddraw7.c b/dlls/ddraw/tests/ddraw7.c
index 8d679ca..1ec6d16 100644
--- a/dlls/ddraw/tests/ddraw7.c
+++ b/dlls/ddraw/tests/ddraw7.c
@@ -6585,7 +6585,7 @@ static void test_pixel_format(void)
     }
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -6595,7 +6595,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper window, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -6610,7 +6610,7 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to create surface, hr %#x.\n",hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
@@ -6624,7 +6624,7 @@ static void test_pixel_format(void)
         ok(SUCCEEDED(hr), "Failed to set clipper, hr %#x.\n", hr);
 
         test_format = GetPixelFormat(hdc);
-        ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
         test_format = GetPixelFormat(hdc2);
         ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
@@ -6636,12 +6636,12 @@ static void test_pixel_format(void)
     ok(SUCCEEDED(hr), "Failed to clear source surface, hr %#x.\n", hr);
 
     test_format = GetPixelFormat(hdc);
-    ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
+    todo_wine ok(test_format == format, "window has pixel format %d, expected %d\n", test_format, format);
 
     if (hdc2)
     {
         test_format = GetPixelFormat(hdc2);
-        ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
+        todo_wine ok(test_format == format, "second window has pixel format %d, expected %d\n", test_format, format);
     }
 
 cleanup:
diff --git a/dlls/dinput/device.c b/dlls/dinput/device.c
index ab43029..dc90155 100644
--- a/dlls/dinput/device.c
+++ b/dlls/dinput/device.c
@@ -1631,8 +1631,14 @@ HRESULT WINAPI IDirectInputDevice2WImpl_Poll(LPDIRECTINPUTDEVICE8W iface)
     IDirectInputDeviceImpl *This = impl_from_IDirectInputDevice8W(iface);
 
     if (!This->acquired) return DIERR_NOTACQUIRED;
-    /* Because wine devices do not need to be polled, just return DI_NOEFFECT */
+
+#ifndef __REACTOS__
+    __wine_check_for_events( QS_ALLINPUT );
+    return DI_OK;
+#else
+    /* Devices do not need to be polled on ReactOS. */
     return DI_NOEFFECT;
+#endif
 }
 
 HRESULT WINAPI IDirectInputDevice2AImpl_Poll(LPDIRECTINPUTDEVICE8A iface)
diff --git a/dlls/dinput/joystick_osx.c b/dlls/dinput/joystick_osx.c
index 6a8926d..d8ce99d 100644
--- a/dlls/dinput/joystick_osx.c
+++ b/dlls/dinput/joystick_osx.c
@@ -702,7 +702,7 @@ static void poll_osx_device_state(LPDIRECTINPUTDEVICE8A iface)
         for ( idx = 0; idx < cnt; idx++ )
         {
             IOHIDValueRef valueRef;
-            int val, oldVal, newVal;
+            int val, oldVal = 0, newVal;
             IOHIDElementRef element = ( IOHIDElementRef ) CFArrayGetValueAtIndex( device->elements, idx );
             int type = IOHIDElementGetType( element );
 
diff --git a/dlls/dinput/keyboard.c b/dlls/dinput/keyboard.c
index a5967d7..d099601 100644
--- a/dlls/dinput/keyboard.c
+++ b/dlls/dinput/keyboard.c
@@ -335,6 +335,10 @@ static HRESULT WINAPI SysKeyboardWImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W ifac
     if (len != This->base.data_format.user_df->dwDataSize )
         return DIERR_INVALIDPARAM;
 
+#ifndef __REACTOS__
+    __wine_check_for_events( QS_ALLINPUT );
+#endif
+
     EnterCriticalSection(&This->base.crit);
 
     if (TRACE_ON(dinput)) {
@@ -527,6 +531,29 @@ static HRESULT WINAPI SysKeyboardAImpl_GetProperty(LPDIRECTINPUTDEVICE8A iface,
     return SysKeyboardWImpl_GetProperty(IDirectInputDevice8W_from_impl(This), rguid, pdiph);
 }
 
+static HRESULT WINAPI SysKeyboardWImpl_Acquire(LPDIRECTINPUTDEVICE8W iface)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8W(iface);
+    HRESULT res;
+
+    TRACE("(%p)\n", This);
+
+    res = IDirectInputDevice2WImpl_Acquire(iface);
+    if (res == DI_OK)
+    {
+        TRACE("clearing keystate\n");
+        memset(This->DInputKeyState, 0, sizeof(This->DInputKeyState));
+    }
+
+    return res;
+}
+
+static HRESULT WINAPI SysKeyboardAImpl_Acquire(LPDIRECTINPUTDEVICE8A iface)
+{
+    SysKeyboardImpl *This = impl_from_IDirectInputDevice8A(iface);
+    return SysKeyboardWImpl_Acquire(IDirectInputDevice8W_from_impl(This));
+}
+
 static HRESULT WINAPI SysKeyboardWImpl_BuildActionMap(LPDIRECTINPUTDEVICE8W iface,
                                                       LPDIACTIONFORMATW lpdiaf,
                                                       LPCWSTR lpszUserName,
@@ -615,7 +642,7 @@ static const IDirectInputDevice8AVtbl SysKeyboardAvt =
     IDirectInputDevice2AImpl_EnumObjects,
     SysKeyboardAImpl_GetProperty,
     IDirectInputDevice2AImpl_SetProperty,
-    IDirectInputDevice2AImpl_Acquire,
+    SysKeyboardAImpl_Acquire,
     IDirectInputDevice2AImpl_Unacquire,
     SysKeyboardAImpl_GetDeviceState,
     IDirectInputDevice2AImpl_GetDeviceData,
@@ -651,7 +678,7 @@ static const IDirectInputDevice8WVtbl SysKeyboardWvt =
     IDirectInputDevice2WImpl_EnumObjects,
     SysKeyboardWImpl_GetProperty,
     IDirectInputDevice2WImpl_SetProperty,
-    IDirectInputDevice2WImpl_Acquire,
+    SysKeyboardWImpl_Acquire,
     IDirectInputDevice2WImpl_Unacquire,
     SysKeyboardWImpl_GetDeviceState,
     IDirectInputDevice2WImpl_GetDeviceData,
diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
index 132efce..8249513 100644
--- a/dlls/dinput/mouse.c
+++ b/dlls/dinput/mouse.c
@@ -552,6 +552,10 @@ static HRESULT WINAPI SysMouseWImpl_GetDeviceState(LPDIRECTINPUTDEVICE8W iface,
 
     if(This->base.acquired == 0) return DIERR_NOTACQUIRED;
 
+#ifndef __REACTOS__
+    __wine_check_for_events( QS_ALLINPUT );
+#endif
+
     TRACE("(this=%p,0x%08x,%p):\n", This, len, ptr);
     _dump_mouse_state(&This->m_state);
 
diff --git a/dlls/dinput/tests/keyboard.c b/dlls/dinput/tests/keyboard.c
index ef5f06a..eaec276 100644
--- a/dlls/dinput/tests/keyboard.c
+++ b/dlls/dinput/tests/keyboard.c
@@ -91,6 +91,26 @@ static void acquire_tests(IDirectInputA *pDI, HWND hwnd)
     for (i = 0; i < sizeof(custom_state) / sizeof(custom_state[0]); i++)
         ok(custom_state[i] == 0, "Should be zeroed, got 0x%08x\n", custom_state[i]);
 
+    /* simulate some keyboard input */
+    SetFocus(hwnd);
+    keybd_event('Q', 0, 0, 0);
+    hr = IDirectInputDevice_GetDeviceState(pKeyboard, sizeof(custom_state), custom_state);
+    ok(SUCCEEDED(hr), "IDirectInputDevice_GetDeviceState(4,) failed: %08x\n", hr);
+    if (!custom_state[0])
+        win_skip("Keyboard event not processed, skipping test\n");
+    else
+    {
+        /* unacquiring should reset the device state */
+        hr = IDirectInputDevice_Unacquire(pKeyboard);
+        ok(SUCCEEDED(hr), "IDirectInputDevice_Unacquire() failed: %08x\n", hr);
+        hr = IDirectInputDevice_Acquire(pKeyboard);
+        ok(SUCCEEDED(hr), "IDirectInputDevice_Acquire() failed: %08x\n", hr);
+        hr = IDirectInputDevice_GetDeviceState(pKeyboard, sizeof(custom_state), custom_state);
+        ok(SUCCEEDED(hr), "IDirectInputDevice_GetDeviceState failed: %08x\n", hr);
+        for (i = 0; i < sizeof(custom_state) / sizeof(custom_state[0]); i++)
+            ok(custom_state[i] == 0, "Should be zeroed, got 0x%08x\n", custom_state[i]);
+    }
+
     if (pKeyboard) IUnknown_Release(pKeyboard);
 }
 
diff --git a/dlls/dsound/Makefile.in b/dlls/dsound/Makefile.in
index 6cb653f..1c04bf3 100644
--- a/dlls/dsound/Makefile.in
+++ b/dlls/dsound/Makefile.in
@@ -9,6 +9,7 @@ C_SRCS = \
 	dsound_convert.c \
 	dsound_main.c \
 	duplex.c \
+	eax.c \
 	mixer.c \
 	primary.c \
 	propset.c \
diff --git a/dlls/dsound/buffer.c b/dlls/dsound/buffer.c
index d735dc3..ca6a5b5 100644
--- a/dlls/dsound/buffer.c
+++ b/dlls/dsound/buffer.c
@@ -35,6 +35,7 @@
 #include "dsconf.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dsound);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 /*******************************************************************************
  *		IDirectSoundNotify
@@ -1119,6 +1120,8 @@ HRESULT IDirectSoundBufferImpl_Create(
 
 	/* register buffer if not primary */
 	if (!(dsbd->dwFlags & DSBCAPS_PRIMARYBUFFER)) {
+        init_eax_buffer(dsb);
+
 		err = DirectSoundDevice_AddBuffer(device, dsb);
 		if (err != DS_OK) {
 			HeapFree(GetProcessHeap(),0,dsb->buffer->memory);
@@ -1167,6 +1170,8 @@ void secondarybuffer_destroy(IDirectSoundBufferImpl *This)
         HeapFree(GetProcessHeap(), 0, This->filters);
     }
 
+    free_eax_buffer(This);
+
     HeapFree(GetProcessHeap(), 0, This);
 
     TRACE("(%p) released\n", This);
@@ -1181,7 +1186,7 @@ HRESULT IDirectSoundBufferImpl_Duplicate(
     HRESULT hres = DS_OK;
     TRACE("(%p,%p,%p)\n", device, ppdsb, pdsb);
 
-    dsb = HeapAlloc(GetProcessHeap(),0,sizeof(*dsb));
+    dsb = HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,sizeof(*dsb));
     if (dsb == NULL) {
         WARN("out of memory\n");
         *ppdsb = NULL;
@@ -1218,6 +1223,8 @@ HRESULT IDirectSoundBufferImpl_Duplicate(
 
     RtlInitializeResource(&dsb->lock);
 
+    init_eax_buffer(dsb); /* FIXME: should we duplicate EAX properties? */
+
     /* register buffer */
     hres = DirectSoundDevice_AddBuffer(device, dsb);
     if (hres != DS_OK) {
@@ -1298,6 +1305,9 @@ static HRESULT WINAPI IKsPropertySetImpl_Get(IKsPropertySet *iface, REFGUID guid
     TRACE("(iface=%p,guidPropSet=%s,dwPropID=%d,pInstanceData=%p,cbInstanceData=%d,pPropData=%p,cbPropData=%d,pcbReturned=%p)\n",
     This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData,pcbReturned);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet))
+        return EAX_Get(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData, pcbReturned);
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -1309,6 +1319,9 @@ static HRESULT WINAPI IKsPropertySetImpl_Set(IKsPropertySet *iface, REFGUID guid
 
     TRACE("(%p,%s,%d,%p,%d,%p,%d)\n",This,debugstr_guid(guidPropSet),dwPropID,pInstanceData,cbInstanceData,pPropData,cbPropData);
 
+    if (IsEqualGUID(&DSPROPSETID_EAX_ReverbProperties, guidPropSet) || IsEqualGUID(&DSPROPSETID_EAXBUFFER_ReverbProperties, guidPropSet))
+        return EAX_Set(This, guidPropSet, dwPropID, pInstanceData, cbInstanceData, pPropData, cbPropData);
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
@@ -1319,6 +1332,13 @@ static HRESULT WINAPI IKsPropertySetImpl_QuerySupport(IKsPropertySet *iface, REF
 
     TRACE("(%p,%s,%d,%p)\n",This,debugstr_guid(guidPropSet),dwPropID,pTypeSupport);
 
+    if (EAX_QuerySupport(guidPropSet, dwPropID, pTypeSupport)) {
+        static int once;
+        if (!once++)
+            FIXME_(winediag)("EAX sound effects are enabled - try to disable it if your app crashes unexpectedly\n");
+        return S_OK;
+    }
+
     return E_PROP_ID_UNSUPPORTED;
 }
 
diff --git a/dlls/dsound/dsound.c b/dlls/dsound/dsound.c
index f77d2ea..4abb142 100644
--- a/dlls/dsound/dsound.c
+++ b/dlls/dsound/dsound.c
@@ -186,6 +186,8 @@ static HRESULT DirectSoundDevice_Create(DirectSoundDevice ** ppDevice)
 
     RtlInitializeResource(&(device->buffer_list_lock));
 
+    init_eax_device(device);
+
    *ppDevice = device;
 
     return DS_OK;
@@ -238,6 +240,7 @@ static ULONG DirectSoundDevice_Release(DirectSoundDevice * device)
         if(device->volume)
             IAudioStreamVolume_Release(device->volume);
 
+        HeapFree(GetProcessHeap(), 0, device->dsp_buffer);
         HeapFree(GetProcessHeap(), 0, device->tmp_buffer);
         HeapFree(GetProcessHeap(), 0, device->mix_buffer);
         HeapFree(GetProcessHeap(), 0, device->buffer);
diff --git a/dlls/dsound/dsound_main.c b/dlls/dsound/dsound_main.c
index cb46301..4b7e7b0 100644
--- a/dlls/dsound/dsound_main.c
+++ b/dlls/dsound/dsound_main.c
@@ -94,8 +94,13 @@ WCHAR wine_vxd_drv[] = { 'w','i','n','e','m','m','.','v','x','d', 0 };
 /* All default settings, you most likely don't want to touch these, see wiki on UsefulRegistryKeys */
 int ds_hel_buflen = 32768 * 2;
 int ds_snd_queue_max = 10;
+int ds_hq_buffers_max = 4;
+BOOL ds_eax_enabled = FALSE;
 static HINSTANCE instance;
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
 /*
  * Get a config key from either the app-specific or the default config
  */
@@ -108,7 +113,6 @@ static inline DWORD get_config_key( HKEY defkey, HKEY appkey, const char *name,
     return ERROR_FILE_NOT_FOUND;
 }
 
-
 /*
  * Setup the dsound options.
  */
@@ -149,12 +153,19 @@ void setup_dsound_options(void)
     if (!get_config_key( hkey, appkey, "SndQueueMax", buffer, MAX_PATH ))
         ds_snd_queue_max = atoi(buffer);
 
+    if (!get_config_key( hkey, appkey, "HQBuffersMax", buffer, MAX_PATH ))
+        ds_hq_buffers_max = atoi(buffer);
+
+    if (!get_config_key( hkey, appkey, "EAXEnabled", buffer, MAX_PATH ))
+        ds_eax_enabled = IS_OPTION_TRUE( buffer[0] );
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
     TRACE("ds_hel_buflen = %d\n", ds_hel_buflen);
     TRACE("ds_snd_queue_max = %d\n", ds_snd_queue_max);
+    TRACE("ds_hq_buffers_max = %d\n", ds_hq_buffers_max);
+    TRACE("ds_eax_enabled = %u\n", ds_eax_enabled);
 }
 
 static const char * get_device_id(LPCGUID pGuid)
diff --git a/dlls/dsound/dsound_private.h b/dlls/dsound/dsound_private.h
index 9c001ed..5c21d1f 100644
--- a/dlls/dsound/dsound_private.h
+++ b/dlls/dsound/dsound_private.h
@@ -29,6 +29,7 @@
 #include "mediaobj.h"
 #include "mmsystem.h"
 #include "uuids.h"
+#include "dsound_eax.h"
 
 #include "wine/list.h"
 
@@ -36,6 +37,8 @@
 
 extern int ds_hel_buflen DECLSPEC_HIDDEN;
 extern int ds_snd_queue_max DECLSPEC_HIDDEN;
+extern int ds_hq_buffers_max DECLSPEC_HIDDEN;
+extern BOOL ds_eax_enabled DECLSPEC_HIDDEN;
 
 /*****************************************************************************
  * Predeclare the interface implementation structures
@@ -90,13 +93,15 @@ struct DirectSoundDevice
     int                         speaker_num[DS_MAX_CHANNELS];
     int                         num_speakers;
     int                         lfe_channel;
-    float *mix_buffer, *tmp_buffer;
-    DWORD                       tmp_buffer_len, mix_buffer_len;
+    float                      *mix_buffer, *tmp_buffer, *dsp_buffer;
+    DWORD                       mix_buffer_len, tmp_buffer_len, dsp_buffer_len;
 
     DSVOLUMEPAN                 volpan;
 
     normfunc normfunction;
 
+    eax_info                    eax;
+
     /* DirectSound3DListener fields */
     DS3DLISTENER                ds3dl;
     BOOL                        ds3dl_need_recalc;
@@ -172,6 +177,8 @@ struct IDirectSoundBufferImpl
     int                         num_filters;
     DSFilter*                   filters;
 
+    eax_buffer_info             eax;
+
     struct list entry;
 };
 
@@ -227,6 +234,19 @@ LONG capped_refcount_dec(LONG *ref) DECLSPEC_HIDDEN;
 
 HRESULT DSOUND_FullDuplexCreate(REFIID riid, void **ppv) DECLSPEC_HIDDEN;
 
+/* eax.c */
+BOOL WINAPI EAX_QuerySupport(REFGUID guidPropSet, ULONG dwPropID, ULONG *pTypeSupport) DECLSPEC_HIDDEN;
+HRESULT WINAPI EAX_Get(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData, ULONG *pcbReturned) DECLSPEC_HIDDEN;
+HRESULT WINAPI EAX_Set(IDirectSoundBufferImpl *buf, REFGUID guidPropSet,
+        ULONG dwPropID, void *pInstanceData, ULONG cbInstanceData, void *pPropData,
+        ULONG cbPropData) DECLSPEC_HIDDEN;
+void init_eax_device(DirectSoundDevice *dev) DECLSPEC_HIDDEN;
+void free_eax_buffer(IDirectSoundBufferImpl *dsb) DECLSPEC_HIDDEN;
+void init_eax_buffer(IDirectSoundBufferImpl *dsb) DECLSPEC_HIDDEN;
+void process_eax_buffer(IDirectSoundBufferImpl *dsb, float *buf, DWORD count) DECLSPEC_HIDDEN;
+
 /* mixer.c */
 void DSOUND_CheckEvent(const IDirectSoundBufferImpl *dsb, DWORD playpos, int len) DECLSPEC_HIDDEN;
 void DSOUND_RecalcVolPan(PDSVOLUMEPAN volpan) DECLSPEC_HIDDEN;
diff --git a/dlls/dsound/mixer.c b/dlls/dsound/mixer.c
index 85ab14a..b159834 100644
--- a/dlls/dsound/mixer.c
+++ b/dlls/dsound/mixer.c
@@ -266,23 +266,62 @@ static inline float get_current_sample(const IDirectSoundBufferImpl *dsb,
     return dsb->get(dsb, mixpos % dsb->buflen, channel);
 }
 
-static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, UINT count)
+static UINT cp_fields_noresample(IDirectSoundBufferImpl *dsb, bitsputfunc put, UINT ostride, UINT count)
 {
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
     DWORD channel, i;
     for (i = 0; i < count; i++)
         for (channel = 0; channel < dsb->mix_channels; channel++)
-            dsb->put(dsb, i * ostride, channel, get_current_sample(dsb,
-                    dsb->sec_mixpos + i * istride, channel));
+            put(dsb, i * ostride, channel, get_current_sample(dsb,
+                dsb->sec_mixpos + i * istride, channel));
     return count;
 }
 
-static UINT cp_fields_resample(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static UINT cp_fields_resample_lq(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                                  UINT ostride, UINT count, LONG64 *freqAccNum)
+{
+    UINT i, channel;
+    UINT istride = dsb->pwfx->nBlockAlign;
+    UINT channels = dsb->mix_channels;
+
+    LONG64 freqAcc_start = *freqAccNum;
+    LONG64 freqAcc_end = freqAcc_start + count * dsb->freqAdjustNum;
+    UINT max_ipos = freqAcc_end / dsb->freqAdjustDen;
+
+    for (i = 0; i < count; ++i) {
+        float cur_freqAcc = (freqAcc_start + i * dsb->freqAdjustNum) / (float)dsb->freqAdjustDen;
+        float cur_freqAcc2;
+        UINT ipos = cur_freqAcc;
+        UINT idx = dsb->sec_mixpos + ipos * istride;
+        cur_freqAcc -= (int)cur_freqAcc;
+        cur_freqAcc2 = 1.0f - cur_freqAcc;
+        for (channel = 0; channel < channels; channel++) {
+            /**
+             * Generally we cannot cache the result of get_current_sample().
+             * Consider the case of resampling from 192000 Hz to 44100 Hz -
+             * none of the values will get reused for the next value of i.
+             * OTOH, for resampling from 44100 Hz to 192000 Hz both values
+             * will likely be reused.
+             *
+             * So far, this possibility of saving calls to
+             * get_current_sample() is ignored.
+             */
+            float s1 = get_current_sample(dsb, idx, channel);
+            float s2 = get_current_sample(dsb, idx + istride, channel);
+            float result = s1 * cur_freqAcc2 + s2 * cur_freqAcc;
+            put(dsb, i * ostride, channel, result);
+        }
+    }
+
+    *freqAccNum = freqAcc_end % dsb->freqAdjustDen;
+    return max_ipos;
+}
+
+static UINT cp_fields_resample_hq(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                                  UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     UINT i, channel;
     UINT istride = dsb->pwfx->nBlockAlign;
-    UINT ostride = dsb->device->pwfx->nChannels * sizeof(float);
 
     LONG64 freqAcc_start = *freqAccNum;
     LONG64 freqAcc_end = freqAcc_start + count * dsb->freqAdjustNum;
@@ -332,7 +371,7 @@ static UINT cp_fields_resample(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *
             float* cache = &intermediate[channel * required_input + ipos];
             for (j = 0; j < fir_used; j++)
                 sum += fir_copy[j] * cache[j];
-            dsb->put(dsb, i * ostride, channel, sum * dsb->firgain);
+            put(dsb, i * ostride, channel, sum * dsb->firgain);
         }
     }
 
@@ -344,14 +383,17 @@ static UINT cp_fields_resample(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *
     return max_ipos;
 }
 
-static void cp_fields(IDirectSoundBufferImpl *dsb, UINT count, LONG64 *freqAccNum)
+static void cp_fields(IDirectSoundBufferImpl *dsb, bitsputfunc put,
+                      UINT ostride, UINT count, LONG64 *freqAccNum)
 {
     DWORD ipos, adv;
 
     if (dsb->freqAdjustNum == dsb->freqAdjustDen)
-        adv = cp_fields_noresample(dsb, count); /* *freqAccNum is unmodified */
+        adv = cp_fields_noresample(dsb, put, ostride, count); /* *freqAcc is unmodified */
+    else if (dsb->device->nrofbuffers > ds_hq_buffers_max)
+        adv = cp_fields_resample_lq(dsb, put, ostride, count, freqAccNum);
     else
-        adv = cp_fields_resample(dsb, count, freqAccNum);
+        adv = cp_fields_resample_hq(dsb, put, ostride, count, freqAccNum);
 
     ipos = dsb->sec_mixpos + adv * dsb->pwfx->nBlockAlign;
     if (ipos >= dsb->buflen) {
@@ -381,6 +423,21 @@ static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
 		return buflen + ptr1 - ptr2;
 	}
 }
+
+static float getieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD channel)
+{
+    const BYTE *buf = (BYTE *)dsb->device->dsp_buffer;
+    const float *fbuf = (const float*)(buf + pos + sizeof(float) * channel);
+    return *fbuf;
+}
+
+static void putieee32_dsp(const IDirectSoundBufferImpl *dsb, DWORD pos, DWORD channel, float value)
+{
+    BYTE *buf = (BYTE *)dsb->device->dsp_buffer;
+    float *fbuf = (float*)(buf + pos + sizeof(float) * channel);
+    *fbuf = value;
+}
+
 /**
  * Mix at most the given amount of data into the allocated temporary buffer
  * of the given secondary buffer, starting from the dsb's first currently
@@ -396,32 +453,64 @@ static inline DWORD DSOUND_BufPtrDiff(DWORD buflen, DWORD ptr1, DWORD ptr2)
  */
 static void DSOUND_MixToTemporary(IDirectSoundBufferImpl *dsb, DWORD frames)
 {
-	UINT size_bytes = frames * sizeof(float) * dsb->device->pwfx->nChannels;
+    BOOL using_filters = dsb->num_filters > 0 || dsb->device->eax.using_eax;
+    UINT istride, ostride, size_bytes;
+    DWORD channel, i;
+    bitsputfunc put;
 	HRESULT hr;
-	int i;
 
-	if (dsb->device->tmp_buffer_len < size_bytes || !dsb->device->tmp_buffer)
-	{
-		dsb->device->tmp_buffer_len = size_bytes;
+    put = dsb->put;
+    ostride = dsb->device->pwfx->nChannels * sizeof(float);
+    size_bytes = frames * ostride;
+
+    if (dsb->device->tmp_buffer_len < size_bytes || !dsb->device->tmp_buffer) {
 		if (dsb->device->tmp_buffer)
 			dsb->device->tmp_buffer = HeapReAlloc(GetProcessHeap(), 0, dsb->device->tmp_buffer, size_bytes);
 		else
 			dsb->device->tmp_buffer = HeapAlloc(GetProcessHeap(), 0, size_bytes);
+        dsb->device->tmp_buffer_len = size_bytes;
 	}
 
-	cp_fields(dsb, frames, &dsb->freqAccNum);
+    if (using_filters) {
+        put = putieee32_dsp;
+        ostride = dsb->mix_channels * sizeof(float);
+        size_bytes = frames * ostride;
+
+        if (dsb->device->dsp_buffer_len < size_bytes || !dsb->device->dsp_buffer) {
+            if (dsb->device->dsp_buffer)
+                dsb->device->dsp_buffer = HeapReAlloc(GetProcessHeap(), 0, dsb->device->dsp_buffer, size_bytes);
+            else
+                dsb->device->dsp_buffer = HeapAlloc(GetProcessHeap(), 0, size_bytes);
+            dsb->device->dsp_buffer_len = size_bytes;
+        }
+    }
 
-	if (size_bytes > 0) {
-		for (i = 0; i < dsb->num_filters; i++) {
-			if (dsb->filters[i].inplace) {
-				hr = IMediaObjectInPlace_Process(dsb->filters[i].inplace, size_bytes, (BYTE*)dsb->device->tmp_buffer, 0, DMO_INPLACE_NORMAL);
+    cp_fields(dsb, put, ostride, frames, &dsb->freqAccNum);
+
+    if (using_filters) {
+        if (frames > 0) {
+            for (i = 0; i < dsb->num_filters; i++) {
+                if (dsb->filters[i].inplace) {
+                    hr = IMediaObjectInPlace_Process(dsb->filters[i].inplace, frames * sizeof(float) * dsb->mix_channels,
+                                                     (BYTE *)dsb->device->dsp_buffer, 0, DMO_INPLACE_NORMAL);
+                    if (FAILED(hr))
+                        WARN("IMediaObjectInPlace_Process failed for filter %u\n", i);
+                } else
+                    WARN("filter %u has no inplace object - unsupported\n", i);
+            }
+        }
 
-				if (FAILED(hr))
-					WARN("IMediaObjectInPlace_Process failed for filter %u\n", i);
-			} else
-				WARN("filter %u has no inplace object - unsupported\n", i);
-		}
-	}
+        if (dsb->device->eax.using_eax)
+            process_eax_buffer(dsb, dsb->device->dsp_buffer, frames * dsb->mix_channels);
+
+        istride = ostride;
+        ostride = dsb->device->pwfx->nChannels * sizeof(float);
+        for (i = 0; i < frames; i++) {
+            for (channel = 0; channel < dsb->mix_channels; channel++) {
+                dsb->put(dsb, i * ostride, channel, getieee32_dsp(dsb, i * istride, channel));
+            }
+        }
+    }
 }
 
 static void DSOUND_MixerVol(const IDirectSoundBufferImpl *dsb, INT frames)
diff --git a/dlls/dxgi/output.c b/dlls/dxgi/output.c
index 6ff10a9..7488fa4 100644
--- a/dlls/dxgi/output.c
+++ b/dlls/dxgi/output.c
@@ -121,9 +121,34 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetParent(IDXGIOutput *iface,
 
 static HRESULT STDMETHODCALLTYPE dxgi_output_GetDesc(IDXGIOutput *iface, DXGI_OUTPUT_DESC *desc)
 {
-    FIXME("iface %p, desc %p stub!\n", iface, desc);
+    struct dxgi_output *This = impl_from_IDXGIOutput(iface);
+    struct wined3d *wined3d;
+    MONITORINFOEXW monitor_info;
 
-    return E_NOTIMPL;
+    FIXME("iface %p, desc %p semi-stub!\n", iface, desc);
+
+    if (!desc)
+        return DXGI_ERROR_INVALID_CALL;
+
+    wined3d = This->adapter->parent->wined3d;
+
+    EnterCriticalSection(&dxgi_cs);
+    desc->Monitor = wined3d_get_adapter_monitor(wined3d, This->adapter->ordinal);
+    LeaveCriticalSection(&dxgi_cs);
+
+    if (!desc->Monitor)
+        return DXGI_ERROR_INVALID_CALL;
+
+    monitor_info.cbSize = sizeof(monitor_info);
+    if (!GetMonitorInfoW(desc->Monitor, (MONITORINFO *)&monitor_info))
+        return DXGI_ERROR_INVALID_CALL;
+
+    memcpy(&desc->DeviceName, &monitor_info.szDevice, sizeof(desc->DeviceName));
+    memcpy(&desc->DesktopCoordinates, &monitor_info.rcMonitor, sizeof(RECT));
+    desc->AttachedToDesktop = TRUE;
+    desc->Rotation = DXGI_MODE_ROTATION_IDENTITY;
+
+    return S_OK;
 }
 
 static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList(IDXGIOutput *iface,
@@ -188,6 +213,20 @@ static HRESULT STDMETHODCALLTYPE dxgi_output_GetDisplayModeList(IDXGIOutput *ifa
         desc[i].RefreshRate.Numerator = mode.refresh_rate;
         desc[i].RefreshRate.Denominator = 1;
         desc[i].Format = format;
+/*      enum wined3d_scanline_ordering
+      {
+        WINED3D_SCANLINE_ORDERING_UNKNOWN       = 0,
+        WINED3D_SCANLINE_ORDERING_PROGRESSIVE   = 1,
+        WINED3D_SCANLINE_ORDERING_INTERLACED    = 2,
+      };
+
+      typedef enum DXGI_MODE_SCANLINE_ORDER {
+        DXGI_MODE_SCANLINE_ORDER_UNSPECIFIED        = 0,
+        DXGI_MODE_SCANLINE_ORDER_PROGRESSIVE        = 1,
+        DXGI_MODE_SCANLINE_ORDER_UPPER_FIELD_FIRST  = 2,
+        DXGI_MODE_SCANLINE_ORDER_LOWER_FIELD_FIRST  = 3,
+      } DXGI_MODE_SCANLINE_ORDER;
+*/
         desc[i].ScanlineOrdering = mode.scanline_ordering;
         desc[i].Scaling = DXGI_MODE_SCALING_UNSPECIFIED; /* FIXME */
     }
diff --git a/dlls/dxva2/Makefile.in b/dlls/dxva2/Makefile.in
index 7b9ef6f..69ce4c8 100644
--- a/dlls/dxva2/Makefile.in
+++ b/dlls/dxva2/Makefile.in
@@ -1,4 +1,15 @@
 MODULE = dxva2.dll
+IMPORTS = ole32 advapi32
+
+IDL_SRCS = \
+	backend.idl
 
 C_SRCS = \
-	main.c
+	devicemanager.c \
+	genericdecoder.c \
+	main.c \
+	softwareprocessor.c \
+	vaapi.c \
+	vaapi-h264.c \
+	vaapi-mpeg2.c \
+	videoservices.c \
diff --git a/dlls/dxva2/main.c b/dlls/dxva2/main.c
index b4704f0..0442c63 100644
--- a/dlls/dxva2/main.c
+++ b/dlls/dxva2/main.c
@@ -19,8 +19,11 @@
 #include <stdarg.h>
 #include "windef.h"
 #include "winbase.h"
+
+#define INITGUID
 #include "d3d9.h"
 #include "dxva2api.h"
+#include "dxva2_private.h"
 #include "physicalmonitorenumerationapi.h"
 #include "lowlevelmonitorconfigurationapi.h"
 #include "highlevelmonitorconfigurationapi.h"
@@ -29,6 +32,10 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dxva2);
 
+BOOL config_vaapi_enabled = FALSE;
+BOOL config_vaapi_drm = FALSE;
+char config_vaapi_drm_path[MAX_PATH] = "";
+
 BOOL WINAPI CapabilitiesRequestAndCapabilitiesReply( HMONITOR monitor, LPSTR buffer, DWORD length )
 {
     FIXME("(%p, %p, %d): stub\n", monitor, buffer, length);
@@ -39,16 +46,16 @@ BOOL WINAPI CapabilitiesRequestAndCapabilitiesReply( HMONITOR monitor, LPSTR buf
 
 HRESULT WINAPI DXVA2CreateDirect3DDeviceManager9( UINT *resetToken, IDirect3DDeviceManager9 **dxvManager )
 {
-    FIXME("(%p, %p): stub\n", resetToken, dxvManager);
+    TRACE("(%p, %p)\n", resetToken, dxvManager);
 
-    return E_NOTIMPL;
+    return devicemanager_create( resetToken, (void **)dxvManager );
 }
 
 HRESULT WINAPI DXVA2CreateVideoService( IDirect3DDevice9 *device, REFIID riid, void **ppv )
 {
-    FIXME("(%p, %s, %p): stub\n", device, debugstr_guid(riid), ppv);
+    TRACE("(%p, %s, %p)\n", device, debugstr_guid(riid), ppv);
 
-    return E_NOTIMPL;
+    return videoservice_create( device, riid, ppv );
 }
 
 BOOL WINAPI DegaussMonitor( HMONITOR monitor )
@@ -320,16 +327,82 @@ BOOL WINAPI SetVCPFeature( HMONITOR monitor, BYTE vcpCode, DWORD value )
     return FALSE;
 }
 
-BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+static BOOL get_app_key( HKEY *defkey, HKEY *appkey )
+{
+    char buffer[MAX_PATH+16];
+    DWORD len;
+
+    *appkey = 0;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\DXVA2 */
+    if (RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\DXVA2", defkey))
+        *defkey = 0;
+
+    len = GetModuleFileNameA(0, buffer, MAX_PATH);
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\DXVA2 */
+        if (!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey))
+        {
+            char *p, *appname = buffer;
+            if ((p = strrchr(appname, '/'))) appname = p + 1;
+            if ((p = strrchr(appname, '\\'))) appname = p + 1;
+            strcat(appname, "\\DXVA2");
+
+            if (RegOpenKeyA(tmpkey, appname, appkey)) *appkey = 0;
+            RegCloseKey(tmpkey);
+        }
+    }
+
+    return *defkey || *appkey;
+}
+
+static BOOL get_config_key( HKEY defkey, HKEY appkey, const char *name, char *buffer, DWORD size )
+{
+    if (appkey && !RegQueryValueExA( appkey, name, 0, NULL, (LPBYTE)buffer, &size ))
+        return TRUE;
+
+    if (defkey && !RegQueryValueExA( defkey, name, 0, NULL, (LPBYTE)buffer, &size ))
+        return TRUE;
+
+    return FALSE;
+}
+
+static void dxva2_init( void )
+{
+    HKEY defkey, appkey;
+    char buffer[MAX_PATH];
+
+    if (!get_app_key(&defkey, &appkey))
+        return;
+
+    if (get_config_key(defkey, appkey, "backend", buffer, sizeof(buffer)))
+        config_vaapi_enabled = !strcmp(buffer, "va");
+
+    if (get_config_key(defkey, appkey, "va_mode", buffer, sizeof(buffer)))
+        config_vaapi_drm = !strcmp(buffer, "drm");
+
+    if (!get_config_key(defkey, appkey, "va_drm_device", config_vaapi_drm_path, sizeof(config_vaapi_drm_path)))
+        strcpy(config_vaapi_drm_path, "/dev/dri/card0");
+
+    if (defkey) RegCloseKey(defkey);
+    if (appkey) RegCloseKey(appkey);
+}
+
+BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
 {
     TRACE("%p,%x,%p\n", hinstDLL, fdwReason, lpvReserved);
 
-    switch (fdwReason) {
-        case DLL_WINE_PREATTACH:
-            return FALSE;  /* prefer native version */
+    switch (fdwReason)
+    {
         case DLL_PROCESS_ATTACH:
+            dxva2_init();
             DisableThreadLibraryCalls(hinstDLL);
             break;
+        case DLL_PROCESS_DETACH:
+            break;
     }
 
     return TRUE;
diff --git a/dlls/gdi32/dibdrv/opengl.c b/dlls/gdi32/dibdrv/opengl.c
index a25da208..a0934d1 100644
--- a/dlls/gdi32/dibdrv/opengl.c
+++ b/dlls/gdi32/dibdrv/opengl.c
@@ -149,7 +149,8 @@ static int dibdrv_wglDescribePixelFormat( HDC hdc, int fmt, UINT size, PIXELFORM
 {
     int ret = sizeof(pixel_formats) / sizeof(pixel_formats[0]);
 
-    if (fmt <= 0 || fmt > ret) return ret;
+    if (!descr) return ret;
+    if (fmt <= 0 || fmt > ret) return ret; /* FIXME: should this be 0? */
     if (size < sizeof(*descr)) return 0;
 
     memset( descr, 0, sizeof(*descr) );
diff --git a/dlls/gdi32/driver.c b/dlls/gdi32/driver.c
index ab39e41..d33c9af 100644
--- a/dlls/gdi32/driver.c
+++ b/dlls/gdi32/driver.c
@@ -110,6 +110,32 @@ static const struct gdi_dc_funcs *get_display_driver(void)
 
 
 /**********************************************************************
+ *	     is_display_device
+ */
+static BOOL is_display_device( LPCWSTR name )
+{
+    static const WCHAR display_deviceW[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    const WCHAR *p = name;
+
+    if (strncmpiW( name, display_deviceW, sizeof(display_deviceW) / sizeof(WCHAR) ))
+        return FALSE;
+
+    p += sizeof(display_deviceW) / sizeof(WCHAR);
+
+    if (!isdigitW( *p++ ))
+        return FALSE;
+
+    for (; *p; p++)
+    {
+        if (!isdigitW( *p ))
+            return FALSE;
+    }
+
+    return TRUE;
+}
+
+
+/**********************************************************************
  *	     DRIVER_load_driver
  */
 const struct gdi_dc_funcs *DRIVER_load_driver( LPCWSTR name )
@@ -117,10 +143,9 @@ const struct gdi_dc_funcs *DRIVER_load_driver( LPCWSTR name )
     HMODULE module;
     struct graphics_driver *driver, *new_driver;
     static const WCHAR displayW[] = { 'd','i','s','p','l','a','y',0 };
-    static const WCHAR display1W[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','1',0};
 
     /* display driver is a special case */
-    if (!strcmpiW( name, displayW ) || !strcmpiW( name, display1W )) return get_display_driver();
+    if (!strcmpiW( name, displayW ) || is_display_device( name )) return get_display_driver();
 
     if ((module = GetModuleHandleW( name )))
     {
@@ -775,13 +800,12 @@ BOOL DRIVER_GetDriverName( LPCWSTR device, LPWSTR driver, DWORD size )
 {
     static const WCHAR displayW[] = { 'd','i','s','p','l','a','y',0 };
     static const WCHAR devicesW[] = { 'd','e','v','i','c','e','s',0 };
-    static const WCHAR display1W[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','1',0};
     static const WCHAR empty_strW[] = { 0 };
     WCHAR *p;
 
     /* display is a special case */
     if (!strcmpiW( device, displayW ) ||
-        !strcmpiW( device, display1W ))
+        is_display_device( device ))
     {
         lstrcpynW( driver, displayW, size );
         return TRUE;
diff --git a/dlls/gdiplus/gdiplus.spec b/dlls/gdiplus/gdiplus.spec
index cee3ea6..bbe6c4c 100644
--- a/dlls/gdiplus/gdiplus.spec
+++ b/dlls/gdiplus/gdiplus.spec
@@ -610,7 +610,7 @@
 610 stdcall GdipFindFirstImageItem(ptr ptr)
 611 stub GdipFindNextImageItem
 612 stdcall GdipGetImageItemData(ptr ptr)
-613 stub GdipCreateEffect
+613 stdcall GdipCreateEffect(ptr ptr)
 614 stdcall GdipDeleteEffect(ptr)
 615 stub GdipGetEffectParameterSize
 616 stub GdipGetEffectParameters
diff --git a/dlls/gdiplus/image.c b/dlls/gdiplus/image.c
index 86802a5..8b9042c 100644
--- a/dlls/gdiplus/image.c
+++ b/dlls/gdiplus/image.c
@@ -152,6 +152,13 @@ static INT ipicture_pixel_width(IPicture *pic)
     return x;
 }
 
+GpStatus WINGDIPAPI GdipCreateEffect(const GUID guid, CGpEffect **effect)
+{
+    FIXME("(%s, %p): stub\n", debugstr_guid(&guid), effect);
+    *effect = NULL;
+    return NotImplemented;
+}
+
 GpStatus WINGDIPAPI GdipBitmapApplyEffect(GpBitmap* bitmap, CGpEffect* effect,
     RECT* roi, BOOL useAuxData, VOID** auxData, INT* auxDataSize)
 {
diff --git a/dlls/gdiplus/region.c b/dlls/gdiplus/region.c
index 4ba86eb..450105f 100644
--- a/dlls/gdiplus/region.c
+++ b/dlls/gdiplus/region.c
@@ -1,5 +1,6 @@
 /*
  * Copyright (C) 2008 Google (Lei Zhang)
+ * Copyright (C) 2013 Dmitry Timoshkov
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -76,6 +77,28 @@ WINE_DEFAULT_DEBUG_CHANNEL(gdiplus);
 #define FLAGS_NOFLAGS   0x0
 #define FLAGS_INTPATH   0x4000
 
+struct memory_buffer
+{
+    const BYTE *buffer;
+    INT size, pos;
+};
+
+struct region_header
+{
+    DWORD size;
+    DWORD checksum;
+    DWORD magic;
+    DWORD num_children;
+};
+
+struct path_header
+{
+    DWORD size;
+    DWORD magic;
+    DWORD count;
+    DWORD flags;
+};
+
 /* Header size as far as header->size is concerned. This doesn't include
  * header->size or header->checksum
  */
@@ -522,12 +545,221 @@ GpStatus WINGDIPAPI GdipCreateRegionRectI(GDIPCONST GpRect *rect,
     return GdipCreateRegionRect(&rectf, region);
 }
 
+static inline void init_memory_buffer(struct memory_buffer *mbuf, const BYTE *buffer, INT size)
+{
+    mbuf->buffer = buffer;
+    mbuf->size = size;
+    mbuf->pos = 0;
+}
+
+static inline const void *buffer_read(struct memory_buffer *mbuf, INT size)
+{
+    if (mbuf->size - mbuf->pos >= size)
+    {
+        const void *data = mbuf->buffer + mbuf->pos;
+        mbuf->pos += size;
+        return data;
+    }
+    return NULL;
+}
+
+static GpStatus read_element(struct memory_buffer *mbuf, GpRegion *region, region_element *node, INT *count)
+{
+    GpStatus status;
+    const DWORD *type;
+
+    type = buffer_read(mbuf, sizeof(DWORD));
+    if (!type) return Ok;
+
+    TRACE("type %#x\n", *type);
+
+    node->type = *type;
+
+    switch (node->type)
+    {
+    case CombineModeReplace:
+    case CombineModeIntersect:
+    case CombineModeUnion:
+    case CombineModeXor:
+    case CombineModeExclude:
+    case CombineModeComplement:
+    {
+        region_element *left, *right;
+
+        left = GdipAlloc(sizeof(region_element));
+        if (!left) return OutOfMemory;
+        right = GdipAlloc(sizeof(region_element));
+        if (!right)
+        {
+            GdipFree(left);
+            return OutOfMemory;
+        }
+
+        status = read_element(mbuf, region, left, count);
+        if (status == Ok)
+        {
+            status = read_element(mbuf, region, right, count);
+            if (status == Ok)
+            {
+                node->elementdata.combine.left = left;
+                node->elementdata.combine.right = right;
+                region->num_children += 2;
+                return Ok;
+            }
+        }
+
+        GdipFree(left);
+        GdipFree(right);
+        return status;
+    }
+
+    case RegionDataRect:
+    {
+        const GpRectF *rc;
+
+        rc = buffer_read(mbuf, sizeof(GpRectF));
+        if (!rc)
+        {
+            ERR("failed to read rect data\n");
+            return InvalidParameter;
+        }
+
+        node->elementdata.rect = *rc;
+        *count += 1;
+        return Ok;
+    }
+
+    case RegionDataPath:
+    {
+        GpPath *path;
+        const struct path_header *path_header;
+        const BYTE *types;
+
+        path_header = buffer_read(mbuf, sizeof(struct path_header));
+        if (!path_header)
+        {
+            ERR("failed to read path header\n");
+            return InvalidParameter;
+        }
+        if (path_header->magic != VERSION_MAGIC)
+        {
+            ERR("invalid path header magic %#x\n", path_header->magic);
+            return InvalidParameter;
+        }
+
+        /* Windows always fails to create an empty path in a region */
+        if (!path_header->count)
+        {
+            TRACE("refusing to create an empty path in a region\n");
+            return GenericError;
+        }
+
+        status = GdipCreatePath(FillModeAlternate, &path);
+        if (status) return status;
+
+        node->elementdata.path = path;
+
+        if (!lengthen_path(path, path_header->count))
+            return OutOfMemory;
+
+        path->pathdata.Count = path_header->count;
+
+        if (path_header->flags & ~FLAGS_INTPATH)
+            FIXME("unhandled path flags %#x\n", path_header->flags);
+
+        if (path_header->flags & FLAGS_INTPATH)
+        {
+            const packed_point *pt;
+            DWORD i;
+
+            pt = buffer_read(mbuf, sizeof(packed_point) * path_header->count);
+            if (!pt)
+            {
+                ERR("failed to read packed %u path points\n", path_header->count);
+                return InvalidParameter;
+            }
+
+            for (i = 0; i < path_header->count; i++)
+            {
+                path->pathdata.Points[i].X = (REAL)pt[i].X;
+                path->pathdata.Points[i].Y = (REAL)pt[i].Y;
+            }
+        }
+        else
+        {
+            const GpPointF *ptf;
+
+            ptf = buffer_read(mbuf, sizeof(GpPointF) * path_header->count);
+            if (!ptf)
+            {
+                ERR("failed to read %u path points\n", path_header->count);
+                return InvalidParameter;
+            }
+            memcpy(path->pathdata.Points, ptf, sizeof(GpPointF) * path_header->count);
+        }
+
+        types = buffer_read(mbuf, path_header->count);
+        if (!types)
+        {
+            ERR("failed to read %u path types\n", path_header->count);
+            return InvalidParameter;
+        }
+        memcpy(path->pathdata.Types, types, path_header->count);
+        if (path_header->count & 3)
+        {
+            if (!buffer_read(mbuf, 4 - (path_header->count & 3)))
+            {
+                ERR("failed to read rounding %u bytes\n", 4 - (path_header->count & 3));
+                return InvalidParameter;
+            }
+        }
+
+        *count += 1;
+        return Ok;
+    }
+
+    case RegionDataEmptyRect:
+    case RegionDataInfiniteRect:
+        *count += 1;
+        return Ok;
+
+    default:
+        FIXME("element type %#x is not supported\n", *type);
+        break;
+    }
+
+    return InvalidParameter;
+}
+
 GpStatus WINGDIPAPI GdipCreateRegionRgnData(GDIPCONST BYTE *data, INT size, GpRegion **region)
 {
-    FIXME("(%p, %d, %p): stub\n", data, size, region);
+    GpStatus status;
+    struct memory_buffer mbuf;
+    const struct region_header *region_header;
+    INT count;
 
-    *region = NULL;
-    return NotImplemented;
+    if (!data || !size) return InvalidParameter;
+
+    TRACE("%p, %d, %p\n", data, size, region);
+
+    init_memory_buffer(&mbuf, data, size);
+
+    region_header = buffer_read(&mbuf, sizeof(struct region_header));
+    if (!region_header || region_header->magic != VERSION_MAGIC)
+        return InvalidParameter;
+
+    status = GdipCreateRegion(region);
+    if (status != Ok) return status;
+
+    count = 0;
+    status = read_element(&mbuf, *region, &(*region)->node, &count);
+    if (status == Ok && !count)
+        status = InvalidParameter;
+
+    if (status != Ok)
+        GdipDeleteRegion(*region);
+
+    return status;
 }
 
 
@@ -738,15 +970,9 @@ static void write_element(const region_element* element, DWORD *buffer,
         {
             INT i;
             const GpPath* path = element->elementdata.path;
-            struct _pathheader
-            {
-                DWORD size;
-                DWORD magic;
-                DWORD count;
-                DWORD flags;
-            } *pathheader;
+            struct path_header *pathheader;
 
-            pathheader = (struct _pathheader *)(buffer + *filled);
+            pathheader = (struct path_header *)(buffer + *filled);
 
             pathheader->flags = is_integer_path(path) ? FLAGS_INTPATH : FLAGS_NOFLAGS;
             /* 3 for headers, once again size doesn't count itself */
@@ -823,13 +1049,7 @@ static void write_element(const region_element* element, DWORD *buffer,
 GpStatus WINGDIPAPI GdipGetRegionData(GpRegion *region, BYTE *buffer, UINT size,
         UINT *needed)
 {
-    struct _region_header
-    {
-        DWORD size;
-        DWORD checksum;
-        DWORD magic;
-        DWORD num_children;
-    } *region_header;
+    struct region_header *region_header;
     INT filled = 0;
     UINT required;
     GpStatus status;
@@ -847,7 +1067,7 @@ GpStatus WINGDIPAPI GdipGetRegionData(GpRegion *region, BYTE *buffer, UINT size,
         return InsufficientBuffer;
     }
 
-    region_header = (struct _region_header *)buffer;
+    region_header = (struct region_header *)buffer;
     region_header->size = sizeheader_size + get_element_size(&region->node);
     region_header->checksum = 0;
     region_header->magic = VERSION_MAGIC;
diff --git a/dlls/gdiplus/tests/region.c b/dlls/gdiplus/tests/region.c
index 5632e4d..a718a5c 100644
--- a/dlls/gdiplus/tests/region.c
+++ b/dlls/gdiplus/tests/region.c
@@ -102,6 +102,56 @@ static void verify_region(HRGN hrgn, const RECT *rc)
        rgn.data.rdh.rcBound.left, rgn.data.rdh.rcBound.top, rgn.data.rdh.rcBound.right, rgn.data.rdh.rcBound.bottom);
 }
 
+static void test_region_data(DWORD *data, UINT size, INT line)
+{
+    GpStatus status;
+    GpRegion *region;
+    DWORD buf[256];
+    UINT needed, i;
+
+    status = GdipCreateRegionRgnData((BYTE *)data, size, &region);
+    /* Windows always fails to create an empty path in a region */
+    if (data[4] == RGNDATA_PATH)
+    {
+        struct _path_header
+        {
+            DWORD size;
+            DWORD magic;
+            DWORD count;
+            DWORD flags;
+        } *path_header = (struct _path_header *)(data + 5);
+        if (!path_header->count)
+        {
+            ok_(__FILE__, line)(status == GenericError, "expected GenericError, got %d\n", status);
+            return;
+        }
+    }
+
+    ok_(__FILE__, line)(status == Ok, "GdipCreateRegionRgnData error %d\n", status);
+    if (status != Ok) return;
+
+    needed = 0;
+    status = GdipGetRegionDataSize(region, &needed);
+    ok_(__FILE__, line)(status == Ok, "status %d\n", status);
+    ok_(__FILE__, line)(needed == size, "data size mismatch: %u != %u\n", needed, size);
+
+    memset(buf, 0xee, sizeof(buf));
+    needed = 0;
+    status = GdipGetRegionData(region, (BYTE *)buf, sizeof(buf), &needed);
+    ok_(__FILE__, line)(status == Ok, "status %08x\n", status);
+    ok_(__FILE__, line)(needed == size, "data size mismatch: %u != %u\n", needed, size);
+
+    size /= sizeof(DWORD);
+    for (i = 0; i < size - 1; i++)
+    {
+        if (i == 1) continue; /* data[1] never matches */
+        ok_(__FILE__, line)(data[i] == buf[i], "off %u: %#x != %#x\n", i, data[i], buf[i]);
+    }
+    /* some Windows versions fail to properly clear the aligned DWORD */
+    ok_(__FILE__, line)(data[size - 1] == buf[size - 1] || broken(data[size - 1] != buf[size - 1]),
+        "off %u: %#x != %#x\n", size - 1, data[size - 1], buf[size - 1]);
+}
+
 static void test_getregiondata(void)
 {
     GpStatus status;
@@ -143,6 +193,7 @@ static void test_getregiondata(void)
     expect_dword(buf + 3, 0);
     expect_dword(buf + 4, RGNDATA_INFINITE_RECT);
     expect_dword(buf + 6, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipSetEmpty(region);
     ok(status == Ok, "status %08x\n", status);
@@ -160,6 +211,7 @@ static void test_getregiondata(void)
     expect_dword(buf + 3, 0);
     expect_dword(buf + 4, RGNDATA_EMPTY_RECT);
     expect_dword(buf + 6, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipSetInfinite(region);
     ok(status == Ok, "status %08x\n", status);
@@ -177,6 +229,7 @@ static void test_getregiondata(void)
     expect_dword(buf + 3, 0);
     expect_dword(buf + 4, RGNDATA_INFINITE_RECT);
     expect_dword(buf + 6, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeleteRegion(region);
     ok(status == Ok, "status %08x\n", status);
@@ -205,6 +258,7 @@ static void test_getregiondata(void)
     expect_float(buf + 7, 100.0);
     expect_float(buf + 8, 200.0);
     expect_dword(buf + 10, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     rect.X = 50;
     rect.Y = 30;
@@ -290,6 +344,7 @@ static void test_getregiondata(void)
     expect_float(buf + 37, 22.0);
     expect_float(buf + 38, 55.0);
     expect_dword(buf + 39, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeleteRegion(region2);
     ok(status == Ok, "status %08x\n", status);
@@ -331,6 +386,7 @@ static void test_getregiondata(void)
     expect_float(buf + 16, 28.0);
     expect_dword(buf + 17, 0x81010100);
     expect_dword(buf + 18, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     rect.X = 50;
     rect.Y = 30;
@@ -371,6 +427,7 @@ static void test_getregiondata(void)
     expect_float(buf + 22, 10.0);
     expect_float(buf + 23, 20.0);
     expect_dword(buf + 24, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeleteRegion(region);
     ok(status == Ok, "status %08x\n", status);
@@ -403,6 +460,7 @@ static void test_getregiondata(void)
     ok(*(buf + 8) == 0x4000 /* before win7 */ || *(buf + 8) == 0,
        "expected 0x4000 or 0, got %08x\n", *(buf + 8));
     expect_dword(buf + 10, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     /* Transform an empty region */
     status = GdipCreateMatrix(&matrix);
@@ -453,6 +511,7 @@ static void test_getregiondata(void)
     expect(6, point[3].Y);
     expect_dword(buf + 13, 0x81010100); /* 0x01010100 if we don't close the path */
     expect_dword(buf + 14, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipTranslateRegion(region, 0.6, 0.8);
     expect(Ok, status);
@@ -480,6 +539,7 @@ static void test_getregiondata(void)
     expect_float(buf + 16, 6.8);
     expect_dword(buf + 17, 0x81010100); /* 0x01010100 if we don't close the path */
     expect_dword(buf + 18, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeletePath(path);
     expect(Ok, status);
@@ -522,6 +582,7 @@ static void test_getregiondata(void)
     expect_float(buf + 16, 6.2);
     expect_dword(buf + 17, 0x01010100);
     expect_dword(buf + 18, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeletePath(path);
     expect(Ok, status);
@@ -584,6 +645,7 @@ static void test_getregiondata(void)
     ok(*(buf + 28) == 0x00000101 || *(buf + 28) == 0x43050101 /* Win 7 */,
        "expected 00000101 or 43050101 got %08x\n", *(buf + 28));
     expect_dword(buf + 29, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeletePath(path);
     expect(Ok, status);
@@ -627,6 +689,7 @@ static void test_getregiondata(void)
     expect(23, point[3].Y);
     expect_dword(buf + 13, 0x81010100); /* 0x01010100 if we don't close the path */
     expect_dword(buf + 14, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeletePath(path);
     expect(Ok, status);
@@ -669,6 +732,7 @@ static void test_getregiondata(void)
     expect_float(buf + 16, 2300.0);
     expect_dword(buf + 17, 0x81010100); /* 0x01010100 if we don't close the path */
     expect_dword(buf + 18, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeletePath(path);
     expect(Ok, status);
@@ -732,6 +796,7 @@ static void test_getregiondata(void)
        *(buf + 33) == 0x43030303 /* 32-bit win7 */ || *(buf + 33) == 0x4c030303 /* 64-bit win7 */,
        "expected 0x00030303 or 0x43030303 or 0x4c030303 got %08x\n", *(buf + 33));
     expect_dword(buf + 34, 0xeeeeeeee);
+    test_region_data(buf, needed, __LINE__);
 
     status = GdipDeletePath(path);
     expect(Ok, status);
diff --git a/dlls/ieframe/client.c b/dlls/ieframe/client.c
index dadbe13..40a4c2f 100644
--- a/dlls/ieframe/client.c
+++ b/dlls/ieframe/client.c
@@ -297,6 +297,9 @@ static HRESULT WINAPI InPlaceSite_OnInPlaceActivateEx(IOleInPlaceSiteEx *iface,
     TRACE("(%p)->(%p, %x)\n", This, pfNoRedraw, dwFlags);
 
     /* FIXME: Avoid redraw, when possible */
+    if (!pfNoRedraw) {
+      return S_OK;
+    }
     *pfNoRedraw = FALSE;
 
     if (dwFlags) {
diff --git a/dlls/imagehlp/modify.c b/dlls/imagehlp/modify.c
index debccc0..4ac3248 100644
--- a/dlls/imagehlp/modify.c
+++ b/dlls/imagehlp/modify.c
@@ -31,9 +31,11 @@ WINE_DEFAULT_DEBUG_CHANNEL(imagehlp);
 
 static WORD CalcCheckSum(DWORD StartValue, LPVOID BaseAddress, DWORD WordCount);
 
-
 /***********************************************************************
  *		BindImage (IMAGEHLP.@)
+ *
+ * NOTES
+ *   See BindImageEx
  */
 BOOL WINAPI BindImage(
   PCSTR ImageName, PCSTR DllPath, PCSTR SymbolPath)
@@ -43,16 +45,113 @@ BOOL WINAPI BindImage(
 
 /***********************************************************************
  *		BindImageEx (IMAGEHLP.@)
+ *
+ * Compute the virtual address of each function imported by a PE image
+ *
+ * PARAMS
+ *
+ *   Flags         [in] Bind options
+ *   ImageName     [in] File name of the image to be bound
+ *   DllPath       [in] Root of the fallback search path in case the ImageName file cannot be opened
+ *   SymbolPath    [in] Symbol file root search path
+ *   StatusRoutine [in] Pointer to a status routine which will be called during the binding process
+ *
+ * RETURNS
+ *   Success: TRUE
+ *   Failure: FALSE
+ *
+ * NOTES
+ *  Binding is not implemented yet, so far this function only enumerates
+ *  all imported dlls/functions and returns TRUE.
  */
 BOOL WINAPI BindImageEx(
   DWORD Flags, PCSTR ImageName, PCSTR DllPath, PCSTR SymbolPath,
   PIMAGEHLP_STATUS_ROUTINE StatusRoutine)
 {
-  FIXME("(%d, %s, %s, %s, %p): stub\n",
-    Flags, debugstr_a(ImageName), debugstr_a(DllPath),
-    debugstr_a(SymbolPath), StatusRoutine
-  );
-  return TRUE;
+    LOADED_IMAGE loaded_image;
+    const IMAGE_IMPORT_DESCRIPTOR *import_desc;
+    ULONG size;
+
+    FIXME("(%d, %s, %s, %s, %p): semi-stub\n",
+        Flags, debugstr_a(ImageName), debugstr_a(DllPath),
+        debugstr_a(SymbolPath), StatusRoutine
+    );
+
+    if (!(MapAndLoad(ImageName, DllPath, &loaded_image, TRUE, TRUE))) return FALSE;
+
+    if (!(import_desc = RtlImageDirectoryEntryToData((HMODULE)loaded_image.MappedAddress, FALSE,
+                                                     IMAGE_DIRECTORY_ENTRY_IMPORT, &size)))
+    {
+        UnMapAndLoad(&loaded_image);
+        return TRUE; /* No imported modules means nothing to bind, so we're done. */
+    }
+
+    /* FIXME: Does native imagehlp support both 32-bit and 64-bit PE executables? */
+#ifdef _WIN64
+    if (loaded_image.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+#else
+    if (loaded_image.FileHeader->OptionalHeader.Magic != IMAGE_NT_OPTIONAL_HDR32_MAGIC)
+#endif
+    {
+        FIXME("Wrong architecture in PE header, unable to enumerate imports\n");
+        UnMapAndLoad(&loaded_image);
+        return TRUE;
+    }
+
+    for (; import_desc->Name && import_desc->FirstThunk; ++import_desc)
+    {
+        IMAGE_THUNK_DATA *thunk;
+        char dll_fullname[MAX_PATH];
+        const char *dll_name;
+
+        if (!(dll_name = ImageRvaToVa(loaded_image.FileHeader, loaded_image.MappedAddress,
+                                      import_desc->Name, 0)))
+        {
+            UnMapAndLoad(&loaded_image);
+            SetLastError(ERROR_INVALID_ACCESS); /* FIXME */
+            return FALSE;
+        }
+
+        if (StatusRoutine)
+            StatusRoutine(BindImportModule, ImageName, dll_name, 0, 0);
+
+        if (!SearchPathA(DllPath, dll_name, 0, sizeof(dll_fullname), dll_fullname, 0))
+        {
+            UnMapAndLoad(&loaded_image);
+            SetLastError(ERROR_FILE_NOT_FOUND);
+            return FALSE;
+        }
+
+        if (!(thunk = ImageRvaToVa(loaded_image.FileHeader, loaded_image.MappedAddress,
+                                   import_desc->OriginalFirstThunk ? import_desc->OriginalFirstThunk :
+                                   import_desc->FirstThunk, 0)))
+        {
+            ERR("Can't grab thunk data of %s, going to next imported DLL\n", dll_name);
+            continue;
+        }
+
+        for (; thunk->u1.Ordinal; ++thunk)
+        {
+            /* Ignoring ordinal imports for now */
+            if(!IMAGE_SNAP_BY_ORDINAL(thunk->u1.Ordinal))
+            {
+                IMAGE_IMPORT_BY_NAME *iibn;
+
+                if (!(iibn = ImageRvaToVa(loaded_image.FileHeader, loaded_image.MappedAddress,
+                                          thunk->u1.AddressOfData, 0)))
+                {
+                    ERR("Can't grab import by name info, skipping to next ordinal\n");
+                    continue;
+                }
+
+                if (StatusRoutine)
+                    StatusRoutine(BindImportProcedure, ImageName, dll_fullname, 0, (ULONG_PTR)iibn->Name);
+            }
+        }
+    }
+
+    UnMapAndLoad(&loaded_image);
+    return TRUE;
 }
 
 
diff --git a/dlls/imagehlp/tests/image.c b/dlls/imagehlp/tests/image.c
index 48443f5..4a19c16 100644
--- a/dlls/imagehlp/tests/image.c
+++ b/dlls/imagehlp/tests/image.c
@@ -390,10 +390,10 @@ static void test_bind_image_ex(void)
     SetLastError(0xdeadbeef);
     ret = pBindImageEx(BIND_NO_BOUND_IMPORTS | BIND_NO_UPDATE | BIND_ALL_IMAGES, "nonexistent.dll", 0, 0,
                        testing_status_routine);
-    todo_wine ok(!ret && ((GetLastError() == ERROR_FILE_NOT_FOUND) ||
-                 (GetLastError() == ERROR_INVALID_PARAMETER)),
-                 "expected ERROR_FILE_NOT_FOUND or ERROR_INVALID_PARAMETER, got %d\n",
-                 GetLastError());
+    ok(!ret && ((GetLastError() == ERROR_FILE_NOT_FOUND) ||
+       (GetLastError() == ERROR_INVALID_PARAMETER)),
+       "expected ERROR_FILE_NOT_FOUND or ERROR_INVALID_PARAMETER, got %d\n",
+       GetLastError());
 
     file = create_temp_file(temp_file);
     if (file == INVALID_HANDLE_VALUE)
@@ -415,14 +415,14 @@ static void test_bind_image_ex(void)
                        testing_status_routine);
     ok(ret, "BindImageEx failed: %d\n", GetLastError());
 
-    todo_wine ok(status_routine_called[BindImportModule] == 1,
-                 "StatusRoutine was called %d times\n", status_routine_called[BindImportModule]);
+    ok(status_routine_called[BindImportModule] == 1,
+       "StatusRoutine was called %d times\n", status_routine_called[BindImportModule]);
 
-    todo_wine ok((status_routine_called[BindImportProcedure] == 1)
+    ok((status_routine_called[BindImportProcedure] == 1)
 #if defined(_WIN64)
-                 || broken(status_routine_called[BindImportProcedure] == 0) /* < Win8 */
+       || broken(status_routine_called[BindImportProcedure] == 0) /* < Win8 */
 #endif
-                 , "StatusRoutine was called %d times\n", status_routine_called[BindImportProcedure]);
+       , "StatusRoutine was called %d times\n", status_routine_called[BindImportProcedure]);
 
     DeleteFileA(temp_file);
 }
diff --git a/dlls/iphlpapi/iphlpapi.spec b/dlls/iphlpapi/iphlpapi.spec
index 228f64f..1fdfbe9 100644
--- a/dlls/iphlpapi/iphlpapi.spec
+++ b/dlls/iphlpapi/iphlpapi.spec
@@ -5,6 +5,7 @@
 @ stdcall AllocateAndGetIpAddrTableFromStack( ptr long long long )
 @ stdcall AllocateAndGetIpForwardTableFromStack( ptr long long long )
 @ stdcall AllocateAndGetIpNetTableFromStack( ptr long long long )
+@ stdcall AllocateAndGetTcpExTableFromStack( ptr long long long long )
 @ stdcall AllocateAndGetTcpTableFromStack( ptr long long long )
 @ stdcall AllocateAndGetUdpTableFromStack( ptr long long long )
 @ stdcall CancelIPChangeNotify( ptr )
diff --git a/dlls/iphlpapi/ipstats.c b/dlls/iphlpapi/ipstats.c
index 3ff30f3..460f688 100644
--- a/dlls/iphlpapi/ipstats.c
+++ b/dlls/iphlpapi/ipstats.c
@@ -2327,6 +2327,41 @@ DWORD WINAPI AllocateAndGetTcpTableFromStack( PMIB_TCPTABLE *ppTcpTable, BOOL bO
     return build_tcp_table( TCP_TABLE_BASIC_ALL, (void **)ppTcpTable, bOrder, heap, flags, NULL );
 }
 
+/******************************************************************
+ *    AllocateAndGetTcpExTableFromStack (IPHLPAPI.@)
+ *
+ * Get the TCP connection table.
+ * Like GetTcpTable(), but allocate the returned table from heap.
+ *
+ * PARAMS
+ *  ppTcpTable [Out] pointer into which the MIB_TCPTABLE_EX is
+ *                   allocated and returned.
+ *  bOrder     [In]  whether to sort the table
+ *  heap       [In]  heap from which the table is allocated
+ *  flags      [In]  flags to HeapAlloc
+ *  family     [In]  address family [AF_INET|AF_INET6]
+ *
+ * RETURNS
+ *  ERROR_INVALID_PARAMETER if ppTcpTable is NULL, whatever GetTcpTable()
+ *  returns otherwise.
+ */
+DWORD WINAPI AllocateAndGetTcpExTableFromStack( VOID **ppTcpTable, BOOL bOrder,
+                                                HANDLE heap, DWORD flags, DWORD family )
+{
+    TRACE("table %p, bOrder %d, heap %p, flags 0x%08x, family %u\n",
+          ppTcpTable, bOrder, heap, flags, family);
+
+    if (!ppTcpTable) return ERROR_INVALID_PARAMETER;
+
+    if (family != AF_INET)
+    {
+        FIXME( "family = %u not supported\n", family );
+        return ERROR_NOT_SUPPORTED;
+    }
+
+    return build_tcp_table( TCP_TABLE_OWNER_PID_ALL, ppTcpTable, bOrder, heap, flags, NULL );
+}
+
 static DWORD get_udp_table_sizes( UDP_TABLE_CLASS class, DWORD row_count, DWORD *row_size )
 {
     DWORD table_size;
diff --git a/dlls/iphlpapi/ipstats.h b/dlls/iphlpapi/ipstats.h
index bf5bb92..d8835aa 100644
--- a/dlls/iphlpapi/ipstats.h
+++ b/dlls/iphlpapi/ipstats.h
@@ -34,6 +34,7 @@ DWORD getInterfaceStatsByName(const char *name, PMIB_IFROW entry) DECLSPEC_HIDDE
 
 DWORD WINAPI AllocateAndGetUdpTableFromStack(PMIB_UDPTABLE *ppUdpTable, BOOL bOrder, HANDLE heap, DWORD flags) DECLSPEC_HIDDEN;
 DWORD WINAPI AllocateAndGetTcpTableFromStack(PMIB_TCPTABLE *ppTcpTable, BOOL bOrder, HANDLE heap, DWORD flags) DECLSPEC_HIDDEN;
+DWORD WINAPI AllocateAndGetTcpExTableFromStack(VOID **ppTcpTable, BOOL bOrder, HANDLE heap, DWORD flags, DWORD family) DECLSPEC_HIDDEN;
 DWORD WINAPI AllocateAndGetIpNetTableFromStack(PMIB_IPNETTABLE *ppIpNetTable, BOOL bOrder, HANDLE heap, DWORD flags) DECLSPEC_HIDDEN;
 DWORD WINAPI AllocateAndGetIpForwardTableFromStack(PMIB_IPFORWARDTABLE *ppIpForwardTable, BOOL bOrder, HANDLE heap, DWORD flags) DECLSPEC_HIDDEN;
 
diff --git a/dlls/kernel32/console.c b/dlls/kernel32/console.c
index 303b638..14f1189 100644
--- a/dlls/kernel32/console.c
+++ b/dlls/kernel32/console.c
@@ -3119,24 +3119,25 @@ BOOL CONSOLE_Init(RTL_USER_PROCESS_PARAMETERS *params)
     }
 
     /* convert value from server:
-     * + 0 => INVALID_HANDLE_VALUE
+     * + INVALID_HANDLE_VALUE => TEB: 0, STARTUPINFO: INVALID_HANDLE_VALUE
+     * + 0                    => TEB: 0, STARTUPINFO: INVALID_HANDLE_VALUE
      * + console handle needs to be mapped
      */
-    if (!params->hStdInput)
-        params->hStdInput = INVALID_HANDLE_VALUE;
+    if (!params->hStdInput || params->hStdInput == INVALID_HANDLE_VALUE)
+        params->hStdInput = 0;
     else if (VerifyConsoleIoHandle(console_handle_map(params->hStdInput)))
     {
         params->hStdInput = console_handle_map(params->hStdInput);
         save_console_mode(params->hStdInput);
     }
 
-    if (!params->hStdOutput)
-        params->hStdOutput = INVALID_HANDLE_VALUE;
+    if (!params->hStdOutput || params->hStdOutput == INVALID_HANDLE_VALUE)
+        params->hStdOutput = 0;
     else if (VerifyConsoleIoHandle(console_handle_map(params->hStdOutput)))
         params->hStdOutput = console_handle_map(params->hStdOutput);
 
-    if (!params->hStdError)
-        params->hStdError = INVALID_HANDLE_VALUE;
+    if (!params->hStdError || params->hStdError == INVALID_HANDLE_VALUE)
+        params->hStdError = 0;
     else if (VerifyConsoleIoHandle(console_handle_map(params->hStdError)))
         params->hStdError = console_handle_map(params->hStdError);
 
diff --git a/dlls/kernel32/cpu.c b/dlls/kernel32/cpu.c
index f48fcf0..886e415 100644
--- a/dlls/kernel32/cpu.c
+++ b/dlls/kernel32/cpu.c
@@ -291,3 +291,31 @@ err:
     }
     return TRUE;
 }
+
+/***********************************************************************
+ *           GetNumaProcessorNode (KERNEL32.@)
+ */
+BOOL WINAPI GetNumaProcessorNode(UCHAR processor, PUCHAR node)
+{
+    SYSTEM_INFO si;
+
+    TRACE( "(%d, %p)\n", processor, node );
+
+    if (!node)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    GetSystemInfo(&si);
+
+    if (processor < si.dwNumberOfProcessors)
+    {
+        *node = 0;
+        return TRUE;
+    }
+
+    *node = 0xFF;
+    SetLastError(ERROR_INVALID_PARAMETER);
+    return FALSE;
+}
diff --git a/dlls/kernel32/debugger.c b/dlls/kernel32/debugger.c
index d4d66b2..981661b 100644
--- a/dlls/kernel32/debugger.c
+++ b/dlls/kernel32/debugger.c
@@ -277,6 +277,23 @@ void WINAPI OutputDebugStringA( LPCSTR str )
     __ENDTRY
     if (caught_by_dbg) return;
 
+    /* for some unknown reason Windows sends the exception a second time, if a
+     * debugger is attached, and the event wasn't handled in the first attempt */
+    if (NtCurrentTeb()->Peb->BeingDebugged)
+    {
+        __TRY
+        {
+            ULONG_PTR args[2];
+            args[0] = strlen(str) + 1;
+            args[1] = (ULONG_PTR)str;
+            RaiseException( DBG_PRINTEXCEPTION_C, 0, 2, args );
+        }
+        __EXCEPT(debug_exception_handler)
+        {
+        }
+        __ENDTRY
+    }
+
     /* send string to a system-wide monitor */
     if (!mutex_inited)
     {
diff --git a/dlls/kernel32/environ.c b/dlls/kernel32/environ.c
index 57b6a1f..99bf706 100644
--- a/dlls/kernel32/environ.c
+++ b/dlls/kernel32/environ.c
@@ -464,9 +464,9 @@ void ENV_CopyStartupInformation(void)
     startup_infoW.wShowWindow          = rupp->wShowWindow;
     startup_infoW.cbReserved2          = rupp->RuntimeInfo.MaximumLength;
     startup_infoW.lpReserved2          = rupp->RuntimeInfo.MaximumLength ? (void*)rupp->RuntimeInfo.Buffer : NULL;
-    startup_infoW.hStdInput            = rupp->hStdInput;
-    startup_infoW.hStdOutput           = rupp->hStdOutput;
-    startup_infoW.hStdError            = rupp->hStdError;
+    startup_infoW.hStdInput            = rupp->hStdInput ? rupp->hStdInput : INVALID_HANDLE_VALUE;
+    startup_infoW.hStdOutput           = rupp->hStdOutput ? rupp->hStdOutput : INVALID_HANDLE_VALUE;
+    startup_infoW.hStdError            = rupp->hStdError ? rupp->hStdError : INVALID_HANDLE_VALUE;
 
     startup_infoA.cb                   = sizeof(startup_infoA);
     startup_infoA.lpReserved           = NULL;
@@ -485,9 +485,9 @@ void ENV_CopyStartupInformation(void)
     startup_infoA.wShowWindow          = rupp->wShowWindow;
     startup_infoA.cbReserved2          = rupp->RuntimeInfo.MaximumLength;
     startup_infoA.lpReserved2          = rupp->RuntimeInfo.MaximumLength ? (void*)rupp->RuntimeInfo.Buffer : NULL;
-    startup_infoA.hStdInput            = rupp->hStdInput;
-    startup_infoA.hStdOutput           = rupp->hStdOutput;
-    startup_infoA.hStdError            = rupp->hStdError;
+    startup_infoA.hStdInput            = rupp->hStdInput ? rupp->hStdInput : INVALID_HANDLE_VALUE;
+    startup_infoA.hStdOutput           = rupp->hStdOutput ? rupp->hStdOutput : INVALID_HANDLE_VALUE;
+    startup_infoA.hStdError            = rupp->hStdError ? rupp->hStdError : INVALID_HANDLE_VALUE;
 
     RtlReleasePebLock();
 }
diff --git a/dlls/kernel32/file.c b/dlls/kernel32/file.c
index 006db1c..f60c70c 100644
--- a/dlls/kernel32/file.c
+++ b/dlls/kernel32/file.c
@@ -48,6 +48,22 @@
 #include "wine/unicode.h"
 #include "wine/debug.h"
 
+C_ASSERT(sizeof(FILE_BASIC_INFO) == sizeof(FILE_BASIC_INFORMATION));
+C_ASSERT(sizeof(FILE_STANDARD_INFO) == sizeof(FILE_STANDARD_INFORMATION));
+C_ASSERT(sizeof(FILE_NAME_INFO) == sizeof(FILE_NAME_INFORMATION));
+C_ASSERT(FIELD_OFFSET(FILE_RENAME_INFO, RootDirectory) == FIELD_OFFSET(FILE_RENAME_INFORMATION, RootDir));
+C_ASSERT(sizeof(FILE_RENAME_INFO) == sizeof(FILE_RENAME_INFORMATION));
+C_ASSERT(sizeof(FILE_DISPOSITION_INFO) == sizeof(FILE_DISPOSITION_INFORMATION));
+C_ASSERT(sizeof(FILE_ALLOCATION_INFO) == sizeof(FILE_ALLOCATION_INFORMATION));
+C_ASSERT(sizeof(FILE_END_OF_FILE_INFO) == sizeof(FILE_END_OF_FILE_INFORMATION));
+C_ASSERT(sizeof(FILE_STREAM_INFO) == sizeof(FILE_STREAM_INFORMATION));
+/* C_ASSERT(sizeof(FILE_COMPRESSION_INFO) == sizeof(FILE_COMPRESSION_INFORMATION)); */
+C_ASSERT(sizeof(FILE_ATTRIBUTE_TAG_INFO) == sizeof(FILE_ATTRIBUTE_TAG_INFORMATION));
+/* C_ASSERT(sizeof(FILE_ID_BOTH_DIR_INFO) == sizeof(FILE_ID_BOTH_DIR_INFORMATION)); */
+/* C_ASSERT(sizeof(FILE_IO_PRIORITY_HINT_INFO) == sizeof(FILE_IO_PRIORITY_HINT_INFORMATION)); */
+C_ASSERT(sizeof(FILE_FULL_DIR_INFO) == sizeof(FILE_FULL_DIR_INFORMATION));
+/* C_ASSERT(sizeof(FILE_ALIGNMENT_INFO) == sizeof(FILE_ALIGNMENT_INFORMATION)); */
+
 WINE_DEFAULT_DEBUG_CHANNEL(file);
 
 /* info structure for FindFirstFile handle */
@@ -325,8 +341,9 @@ BOOL WINAPI AreFileApisANSI(void)
 static void WINAPI FILE_ReadWriteApc(void* apc_user, PIO_STATUS_BLOCK io_status, ULONG reserved)
 {
     LPOVERLAPPED_COMPLETION_ROUTINE  cr = apc_user;
-
-    cr(RtlNtStatusToDosError(io_status->u.Status), io_status->Information, (LPOVERLAPPED)io_status);
+    NTSTATUS status = io_status->u.Status;
+    if (status == STATUS_BUFFER_OVERFLOW) status = STATUS_SUCCESS;
+    cr(RtlNtStatusToDosError(status), io_status->Information, (LPOVERLAPPED)io_status);
 }
 
 
@@ -358,7 +375,7 @@ BOOL WINAPI ReadFileEx(HANDLE hFile, LPVOID buffer, DWORD bytesToRead,
     status = NtReadFile(hFile, NULL, FILE_ReadWriteApc, lpCompletionRoutine,
                         io_status, buffer, bytesToRead, &offset, NULL);
 
-    if (status && status != STATUS_PENDING)
+    if (status && status != STATUS_PENDING && status != STATUS_BUFFER_OVERFLOW)
     {
         SetLastError( RtlNtStatusToDosError(status) );
         return FALSE;
@@ -1039,7 +1056,91 @@ BOOL WINAPI SetEndOfFile( HANDLE hFile )
 
 BOOL WINAPI SetFileInformationByHandle( HANDLE file, FILE_INFO_BY_HANDLE_CLASS class, VOID *info, DWORD size )
 {
-    FIXME("%p %u %p %u - stub\n", file, class, info, size);
+    IO_STATUS_BLOCK io;
+    FILE_INFORMATION_CLASS ntclass;
+    NTSTATUS status;
+
+    TRACE("%p %u %p %u\n", file, class, info, size);
+
+    switch (class)
+    {
+        /* make sure that the kernel32 and NT structures are identical */
+        case FileBasicInfo:
+            /* FILE_BASIC_INFO matches FILE_BASIC_INFORMATION */
+            ntclass = FileBasicInformation;
+            break;
+        case FileStandardInfo:
+            /* FILE_STANDARD_INFO matches FILE_STANDARD_INFORMATION */
+            ntclass = FileStandardInformation;
+            break;
+        case FileNameInfo:
+            /* FILE_NAME_INFO matches FILE_NAME_INFORMATION */
+            ntclass = FileNameInformation;
+            break;
+        case FileRenameInfo:
+            /* FILE_RENAME_INFO matches FILE_RENAME_INFORMATION,
+             * except BOOL <-> BOOLEAN. */
+            ntclass = FileRenameInformation;
+            break;
+        case FileDispositionInfo:
+            /* FILE_DISPOSITION_INFO matches FILE_DISPOSITION_INFORMATION,
+             * except BOOL <-> BOOLEAN. */
+            ntclass = FileDispositionInformation;
+            break;
+        case FileAllocationInfo:
+            /* FILE_ALLOCATION_INFO matches FILE_ALLOCATION_INFORMATION */
+            ntclass = FileAllocationInformation;
+            break;
+        case FileEndOfFileInfo:
+            /* FILE_END_OF_FILE_INFO matches FILE_END_OF_FILE_INFORMATION */
+            ntclass = FileEndOfFileInformation;
+            break;
+        case FileStreamInfo:
+            /* FILE_STREAM_INFO matches FILE_STREAM_INFORMATION */
+            ntclass = FileStreamInformation;
+            break;
+        case FileCompressionInfo:
+            /* FILE_COMPRESSION_INFO matches FILE_COMPRESSION_INFORMATION */
+            ntclass = FileCompressionInformation;
+            break;
+        case FileAttributeTagInfo:
+            /* FILE_ATTRIBUTE_TAG_INFO matches FILE_ATTRIBUTE_TAG_INFORMATION */
+            ntclass = FileAttributeTagInformation;
+            break;
+        case FileIdBothDirectoryInfo:
+            /* FILE_ID_BOTH_DIR_INFO matches FILE_ID_BOTH_DIR_INFORMATION */
+            ntclass = FileIdBothDirectoryInformation;
+            break;
+        case FileIoPriorityHintInfo:
+            /* FILE_IO_PRIORITY_HINT_INFO  matches FILE_IO_PRIORITY_HINT_INFORMATION */
+            ntclass = FileIoPriorityHintInformation;
+            break;
+        case FileFullDirectoryInfo:
+            /* FILE_FULL_DIR_INFO matches FILE_FULL_DIR_INFORMATION */
+            ntclass = FileFullDirectoryInformation;
+            break;
+        case FileAlignmentInfo:
+            /* FILE_ALIGNMENT_INFO matches FILE_ALIGNMENT_INFORMATION */
+            ntclass = FileAlignmentInformation;
+            break;
+
+        /* do not have a NT equivalent with same structure */
+        case FileFullDirectoryRestartInfo:
+        case FileIdBothDirectoryRestartInfo:
+        case FileIdExtdDirectoryInfo:
+        case FileIdInfo:
+        case FileRemoteProtocolInfo:
+        case FileStorageInfo:
+        default:
+            FIXME("unsupported class: %u\n", class);
+            SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
+            return FALSE;
+    }
+
+    status = NtSetInformationFile( file, &io, info, size, ntclass );
+
+    if (status == STATUS_SUCCESS) return TRUE;
+    SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
 }
 
@@ -1602,8 +1703,7 @@ BOOL WINAPI DeleteFileW( LPCWSTR path )
     attr.SecurityDescriptor = NULL;
     attr.SecurityQualityOfService = NULL;
 
-    status = NtCreateFile(&hFile, GENERIC_READ | GENERIC_WRITE | DELETE,
-			  &attr, &io, NULL, 0,
+    status = NtCreateFile(&hFile, DELETE, &attr, &io, NULL, 0,
 			  FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
 			  FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE, NULL, 0);
     if (status == STATUS_SUCCESS) status = NtClose(hFile);
@@ -2829,3 +2929,185 @@ DWORD WINAPI K32GetDeviceDriverFileNameW(void *image_base, LPWSTR file_name, DWO
 
     return 0;
 }
+
+/***********************************************************************
+ *           GetFinalPathNameByHandleW (KERNEL32.@)
+ */
+DWORD WINAPI GetFinalPathNameByHandleW(HANDLE file, LPWSTR path, DWORD charcount, DWORD flags)
+{
+    WCHAR buffer[sizeof(OBJECT_NAME_INFORMATION) + MAX_PATH + 1];
+    OBJECT_NAME_INFORMATION *info = (OBJECT_NAME_INFORMATION*)&buffer;
+    WCHAR drive_part[MAX_PATH];
+    DWORD drive_part_len;
+    NTSTATUS status;
+    DWORD result = 0;
+    ULONG dummy;
+    WCHAR *ptr;
+
+    TRACE( "(%p,%p,%d,%x)\n", file, path, charcount, flags );
+
+    /* check for invalid arguments */
+    if (!path)
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return 0;
+    }
+    else if (file == INVALID_HANDLE_VALUE)
+    {
+        SetLastError( ERROR_INVALID_HANDLE );
+        return 0;
+    }
+    else if (flags & ~(FILE_NAME_OPENED | VOLUME_NAME_GUID | VOLUME_NAME_NONE | VOLUME_NAME_NT))
+    {
+        WARN("Invalid or unsupported flags: %x\n", flags);
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return 0;
+    }
+
+    /* get object name */
+    status = NtQueryObject( file, ObjectNameInformation, &buffer, sizeof(buffer) - sizeof(WCHAR), &dummy );
+    if (status != STATUS_SUCCESS)
+    {
+        SetLastError( RtlNtStatusToDosError( status ) );
+        return 0;
+    }
+    else if (info->Name.Length < 4 * sizeof(WCHAR) || info->Name.Buffer[0] != '\\' ||
+             info->Name.Buffer[1] != '?' || info->Name.Buffer[2] != '?' || info->Name.Buffer[3] != '\\' )
+    {
+        FIXME("Unexpected object name: %s\n", debugstr_wn(info->Name.Buffer, info->Name.Length / sizeof(WCHAR)));
+        SetLastError( ERROR_GEN_FAILURE );
+        return 0;
+    }
+
+    /* add terminating null character, remove "\\??\\" */
+    info->Name.Buffer[info->Name.Length / sizeof(WCHAR)] = 0;
+    info->Name.Length -= 4 * sizeof(WCHAR);
+    info->Name.Buffer += 4;
+
+    /* FILE_NAME_OPENED is not supported yet, and would require Wineserver changes */
+    if (flags & FILE_NAME_OPENED)
+    {
+        FIXME("FILE_NAME_OPENED not supported\n");
+        flags &= ~FILE_NAME_OPENED;
+    }
+
+    /* Get information required for VOLUME_NAME_NONE, VOLUME_NAME_GUID and VOLUME_NAME_NT */
+    if (flags == VOLUME_NAME_NONE || flags == VOLUME_NAME_GUID || flags == VOLUME_NAME_NT)
+    {
+        if (!GetVolumePathNameW( info->Name.Buffer, drive_part, MAX_PATH ))
+            return 0;
+
+        drive_part_len = strlenW(drive_part);
+        if (!drive_part_len || drive_part_len > strlenW(info->Name.Buffer) ||
+                drive_part[drive_part_len-1] != '\\' ||
+                strncmpiW( info->Name.Buffer, drive_part, drive_part_len ))
+        {
+            FIXME("Path %s returned by GetVolumePathNameW does not match file path %s\n",
+                debugstr_w(drive_part), debugstr_w(info->Name.Buffer));
+            SetLastError( ERROR_GEN_FAILURE );
+            return 0;
+        }
+    }
+
+    if (flags == VOLUME_NAME_NONE)
+    {
+        ptr    = info->Name.Buffer + drive_part_len - 1;
+        result = strlenW(ptr);
+        if (result < charcount)
+            memcpy(path, ptr, (result + 1) * sizeof(WCHAR));
+        else result++;
+    }
+    else if (flags == VOLUME_NAME_GUID)
+    {
+        WCHAR volume_prefix[51];
+
+        /* GetVolumeNameForVolumeMountPointW sets error code on failure */
+        if (!GetVolumeNameForVolumeMountPointW( drive_part, volume_prefix, 50 ))
+            return 0;
+
+        ptr    = info->Name.Buffer + drive_part_len;
+        result = strlenW(volume_prefix) + strlenW(ptr);
+        if (result < charcount)
+        {
+            path[0] = 0;
+            strcatW(path, volume_prefix);
+            strcatW(path, ptr);
+        }
+        else result++;
+    }
+    else if (flags == VOLUME_NAME_NT)
+    {
+        WCHAR nt_prefix[MAX_PATH];
+
+        /* QueryDosDeviceW sets error code on failure */
+        drive_part[drive_part_len - 1] = 0;
+        if (!QueryDosDeviceW( drive_part, nt_prefix, MAX_PATH ))
+            return 0;
+
+        ptr    = info->Name.Buffer + drive_part_len - 1;
+        result = strlenW(nt_prefix) + strlenW(ptr);
+        if (result < charcount)
+        {
+            path[0] = 0;
+            strcatW(path, nt_prefix);
+            strcatW(path, ptr);
+        }
+        else result++;
+    }
+    else if (flags == VOLUME_NAME_DOS)
+    {
+        static const WCHAR dos_prefix[] = {'\\','\\','?','\\', '\0'};
+
+        result = strlenW(dos_prefix) + strlenW(info->Name.Buffer);
+        if (result < charcount)
+        {
+            path[0] = 0;
+            strcatW(path, dos_prefix);
+            strcatW(path, info->Name.Buffer);
+        }
+        else result++;
+    }
+    else
+    {
+        /* Windows crashes here, but we prefer returning ERROR_INVALID_PARAMETER */
+        WARN("Invalid combination of flags: %x\n", flags);
+        SetLastError( ERROR_INVALID_PARAMETER );
+    }
+
+    return result;
+}
+
+/***********************************************************************
+ *           GetFinalPathNameByHandleA (KERNEL32.@)
+ */
+DWORD WINAPI GetFinalPathNameByHandleA(HANDLE file, LPSTR path, DWORD charcount, DWORD flags)
+{
+    WCHAR *str;
+    DWORD result;
+
+    TRACE( "(%p,%p,%d,%x)\n", file, path, charcount, flags );
+
+    if (!path || !charcount)
+        return GetFinalPathNameByHandleW(file, (LPWSTR)path, charcount, flags);
+
+    str = HeapAlloc( GetProcessHeap(), 0, charcount * sizeof(WCHAR) );
+    if (!str)
+    {
+        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
+        return 0;
+    }
+
+    result = GetFinalPathNameByHandleW(file, (LPWSTR)str, charcount, flags);
+    if (result)
+    {
+        if (result < charcount)
+        {
+            result = FILE_name_WtoA( str, result, path, charcount - 1 );
+            path[result] = 0;
+        }
+        else result--; /* Why does Windows do this? */
+    }
+
+    HeapFree( GetProcessHeap(), 0, str );
+    return result;
+}
\ No newline at end of file
diff --git a/dlls/kernel32/kernel32.spec b/dlls/kernel32/kernel32.spec
index bb72041..dea45c3 100644
--- a/dlls/kernel32/kernel32.spec
+++ b/dlls/kernel32/kernel32.spec
@@ -204,7 +204,7 @@
 @ stdcall BuildCommDCBAndTimeoutsA(str ptr ptr)
 @ stdcall BuildCommDCBAndTimeoutsW(wstr ptr ptr)
 @ stdcall BuildCommDCBW(wstr ptr)
-# @ stub CallbackMayRunLong
+@ stdcall CallbackMayRunLong(ptr) ntdll.TpCallbackMayRunLong
 @ stdcall CallNamedPipeA(str ptr long ptr long ptr long)
 @ stdcall CallNamedPipeW(wstr ptr long ptr long ptr long)
 @ stub CancelDeviceWakeupRequest
@@ -228,13 +228,13 @@
 # @ stub ClosePrivateNamespace
 @ stdcall CloseProfileUserMapping()
 @ stub CloseSystemHandle
-# @ stub CloseThreadpool
-# @ stub CloseThreadpoolCleanupGroup
-# @ stub CloseThreadpoolCleanupGroupMembers
+@ stdcall CloseThreadpool(ptr) ntdll.TpReleasePool
+@ stdcall CloseThreadpoolCleanupGroup(ptr) ntdll.TpReleaseCleanupGroup
+@ stdcall CloseThreadpoolCleanupGroupMembers(ptr long ptr) ntdll.TpReleaseCleanupGroupMembers
 # @ stub CloseThreadpoolIo
-# @ stub CloseThreadpoolTimer
-# @ stub CloseThreadpoolWait
-# @ stub CloseThreadpoolWork
+@ stdcall CloseThreadpoolTimer(ptr) ntdll.TpReleaseTimer
+@ stdcall CloseThreadpoolWait(ptr) ntdll.TpReleaseWait
+@ stdcall CloseThreadpoolWork(ptr) ntdll.TpReleaseWork
 @ stdcall CmdBatNotification(long)
 @ stdcall CommConfigDialogA(str long ptr)
 @ stdcall CommConfigDialogW(wstr long ptr)
@@ -331,12 +331,12 @@
 @ stdcall CreateSymbolicLinkW(wstr wstr long)
 @ stdcall CreateTapePartition(long long long long)
 @ stdcall CreateThread(ptr long ptr long long ptr)
-# @ stub CreateThreadpool
-# @ stub CreateThreadpoolCleanupGroup
+@ stdcall CreateThreadpool(ptr)
+@ stdcall CreateThreadpoolCleanupGroup()
 # @ stub CreateThreadpoolIo
-# @ stub CreateThreadpoolTimer
-# @ stub CreateThreadpoolWait
-# @ stub CreateThreadpoolWork
+@ stdcall CreateThreadpoolTimer(ptr ptr ptr)
+@ stdcall CreateThreadpoolWait(ptr ptr ptr)
+@ stdcall CreateThreadpoolWork(ptr ptr ptr)
 @ stdcall CreateTimerQueue ()
 @ stdcall CreateTimerQueueTimer(ptr long ptr ptr long long long)
 @ stdcall CreateToolhelp32Snapshot(long long)
@@ -369,7 +369,7 @@
 @ stdcall DeleteFileW(wstr)
 # @ stub DeleteProcThreadAttributeList
 # @ stub DisableThreadProfiling
-# @ stub DisassociateCurrentThreadFromCallback
+@ stdcall DisassociateCurrentThreadFromCallback(ptr) ntdll.TpDisassociateCallback
 @ stdcall DeleteTimerQueue(long)
 @ stdcall DeleteTimerQueueEx (long long)
 @ stdcall DeleteTimerQueueTimer(long long long)
@@ -495,7 +495,6 @@
 @ stdcall FindFirstVolumeMountPointA(str ptr long)
 @ stdcall FindFirstVolumeMountPointW(wstr ptr long)
 @ stdcall FindFirstVolumeW(ptr long)
-# @ stub FreeLibraryWhenCallbackReturns
 @ stdcall FindNextChangeNotification(long)
 @ stdcall FindNextFileA(long ptr)
 # @ stub FindNextFileNameW
@@ -533,6 +532,7 @@
 @ stub -i386 FreeLSCallback
 @ stdcall FreeLibrary(long)
 @ stdcall FreeLibraryAndExitThread(long long)
+@ stdcall FreeLibraryWhenCallbackReturns(ptr ptr) ntdll.TpCallbackUnloadDllOnCompletion
 @ stdcall FreeResource(long)
 @ stdcall -i386 -private FreeSLCallback(long) krnl386.exe16.FreeSLCallback
 @ stub FreeUserPhysicalPages
@@ -682,8 +682,8 @@
 @ stdcall GetFileSizeEx(long ptr)
 @ stdcall GetFileTime(long ptr ptr ptr)
 @ stdcall GetFileType(long)
-# @ stub GetFinalPathNameByHandleA
-# @ stub GetFinalPathNameByHandleW
+@ stdcall GetFinalPathNameByHandleA(long ptr long long)
+@ stdcall GetFinalPathNameByHandleW(long ptr long long)
 @ stdcall GetFirmwareEnvironmentVariableA(str str ptr long)
 @ stdcall GetFirmwareEnvironmentVariableW(wstr wstr ptr long)
 @ stdcall GetFullPathNameA(str long ptr ptr)
@@ -746,7 +746,7 @@
 @ stdcall GetNumaNodeProcessorMask(long ptr)
 # @ stub GetNumaNodeProcessorMaskEx
 # @ stub GetNumaProcessorMap
-# @ stub GetNumaProcessorNode
+@ stdcall GetNumaProcessorNode(long ptr)
 # @ stub GetNumaProcessorNodeEx
 # @ stub GetNumaProximityNode
 # @ stub GetNumaProximityNodeEx
@@ -980,7 +980,7 @@
 @ stub -i386 IsSLCallback
 @ stdcall IsSystemResumeAutomatic()
 @ stdcall IsThreadAFiber()
-# @ stub IsThreadpoolTimerSet
+@ stdcall IsThreadpoolTimerSet(ptr) ntdll.TpIsTimerSet
 # @ stub IsTimeZoneRedirectionEnabled
 # @ stub IsValidCalDateTime
 @ stdcall IsValidCodePage(long)
@@ -1034,7 +1034,7 @@
 @ stdcall LZSeek(long long long)
 @ stdcall LZStart()
 @ stdcall LeaveCriticalSection(ptr) ntdll.RtlLeaveCriticalSection
-# @ stub LeaveCriticalSectionWhenCallbackReturns
+@ stdcall LeaveCriticalSectionWhenCallbackReturns(ptr ptr) ntdll.TpCallbackLeaveCriticalSectionOnCompletion
 # @ stub LoadAppInitDlls
 @ stdcall LoadLibraryA(str)
 @ stdcall LoadLibraryExA( str long long)
@@ -1251,9 +1251,9 @@
 @ stdcall ReinitializeCriticalSection(ptr)
 @ stdcall ReleaseActCtx(ptr)
 @ stdcall ReleaseMutex(long)
-# @ stub ReleaseMutexWhenCallbackReturns
+@ stdcall ReleaseMutexWhenCallbackReturns(ptr long) ntdll.TpCallbackReleaseMutexOnCompletion
 @ stdcall ReleaseSemaphore(long long ptr)
-# @ stub ReleaseSemaphoreWhenCallbackReturns
+@ stdcall ReleaseSemaphoreWhenCallbackReturns(ptr long long) ntdll.TpCallbackReleaseSemaphoreOnCompletion
 @ stdcall ReleaseSRWLockExclusive(ptr) ntdll.RtlReleaseSRWLockExclusive
 @ stdcall ReleaseSRWLockShared(ptr) ntdll.RtlReleaseSRWLockShared
 @ stdcall RemoveDirectoryA(str)
@@ -1384,7 +1384,7 @@
 @ stdcall SetEnvironmentVariableW(wstr wstr)
 @ stdcall SetErrorMode(long)
 @ stdcall SetEvent(long)
-# @ stub SetEventWhenCallbackReturns
+@ stdcall SetEventWhenCallbackReturns(ptr long) ntdll.TpCallbackSetEventOnCompletion
 @ stdcall SetFileApisToANSI()
 @ stdcall SetFileApisToOEM()
 @ stdcall SetFileAttributesA(str long)
@@ -1453,10 +1453,10 @@
 # @ stub SetThreadToken
 @ stdcall SetThreadUILanguage(long)
 # @ stub SetThreadpoolStackInformation
-# @ stub SetThreadpoolThreadMaximum
-# @ stub SetThreadpoolThreadMinimum
-# @ stub SetThreadpoolTimer
-# @ stub SetThreadpoolWait
+@ stdcall SetThreadpoolThreadMaximum(ptr long) ntdll.TpSetPoolMaxThreads
+@ stdcall SetThreadpoolThreadMinimum(ptr long) ntdll.TpSetPoolMinThreads
+@ stdcall SetThreadpoolTimer(ptr ptr long long)
+@ stdcall SetThreadpoolWait(ptr long ptr)
 @ stdcall SetTimeZoneInformation(ptr)
 @ stub SetTimerQueueTimer
 # @ stub -arch=x86_64 SetUmsThreadInformation
@@ -1481,7 +1481,7 @@
 # @ stub SortCloseHandle
 # @ stub SortGetHandle
 # @ stub StartThreadpoolIo
-# @ stub SubmitThreadpoolWork
+@ stdcall SubmitThreadpoolWork(ptr) ntdll.TpPostWork
 @ stdcall SuspendThread(long)
 @ stdcall SwitchToFiber(ptr)
 @ stdcall SwitchToThread()
@@ -1508,7 +1508,7 @@
 @ stdcall TryAcquireSRWLockExclusive(ptr) ntdll.RtlTryAcquireSRWLockExclusive
 @ stdcall TryAcquireSRWLockShared(ptr) ntdll.RtlTryAcquireSRWLockShared
 @ stdcall TryEnterCriticalSection(ptr) ntdll.RtlTryEnterCriticalSection
-# @ stub TrySubmitThreadpoolCallback
+@ stdcall TrySubmitThreadpoolCallback(ptr ptr ptr) ntdll.TpSimpleTryPost
 @ stdcall TzSpecificLocalTimeToSystemTime(ptr ptr ptr)
 # @ stub TzSpecificLocalTimeToSystemTimeEx
 # @ stub -arch=x86_64 uaw_lstrcmpW
@@ -1570,9 +1570,9 @@
 @ stdcall WaitForSingleObject(long long)
 @ stdcall WaitForSingleObjectEx(long long long)
 # @ stub WaitForThreadpoolIoCallbacks
-# @ stub WaitForThreadpoolTimerCallbacks
-# @ stub WaitForThreadpoolWaitCallbacks
-# @ stub WaitForThreadpoolWorkCallbacks
+@ stdcall WaitForThreadpoolTimerCallbacks(ptr long) ntdll.TpWaitForTimer
+@ stdcall WaitForThreadpoolWaitCallbacks(ptr long) ntdll.TpWaitForWait
+@ stdcall WaitForThreadpoolWorkCallbacks(ptr long) ntdll.TpWaitForWork
 @ stdcall WaitNamedPipeA (str long)
 @ stdcall WaitNamedPipeW (wstr long)
 @ stdcall WakeAllConditionVariable(ptr) ntdll.RtlWakeAllConditionVariable
diff --git a/dlls/kernel32/locale.c b/dlls/kernel32/locale.c
index 9896872..7b1cb1e 100644
--- a/dlls/kernel32/locale.c
+++ b/dlls/kernel32/locale.c
@@ -2732,6 +2732,11 @@ BOOL WINAPI GetStringTypeW( DWORD type, LPCWSTR src, INT count, LPWORD chartype
         C2_OTHERNEUTRAL        /* LRE, LRO, RLE, RLO, PDF */
     };
 
+    if (!src) /* Abort and return FALSE when src is null */
+    {
+        SetLastError( ERROR_INVALID_PARAMETER );
+        return FALSE;
+    }
     if (count == -1) count = strlenW(src) + 1;
     switch(type)
     {
@@ -3243,9 +3248,10 @@ INT WINAPI CompareStringW(LCID lcid, DWORD flags,
 INT WINAPI CompareStringEx(LPCWSTR locale, DWORD flags, LPCWSTR str1, INT len1,
                            LPCWSTR str2, INT len2, LPNLSVERSIONINFO version, LPVOID reserved, LPARAM lParam)
 {
-    DWORD supported_flags = NORM_IGNORECASE|NORM_IGNORENONSPACE|NORM_IGNORESYMBOLS|SORT_STRINGSORT
-                           |NORM_IGNOREKANATYPE|NORM_IGNOREWIDTH|LOCALE_USE_CP_ACP;
-    DWORD semistub_flags = NORM_LINGUISTIC_CASING|LINGUISTIC_IGNORECASE|0x10000000;
+    static const DWORD supported_flags = NORM_IGNORECASE|NORM_IGNORENONSPACE|NORM_IGNORESYMBOLS|SORT_STRINGSORT
+                                        |NORM_IGNOREKANATYPE|NORM_IGNOREWIDTH|LOCALE_USE_CP_ACP
+                                        |NORM_LINGUISTIC_CASING|LINGUISTIC_IGNORECASE|0x10000000;
+    static DWORD semistub_flags = NORM_LINGUISTIC_CASING|LINGUISTIC_IGNORECASE|0x10000000;
     /* 0x10000000 is related to diacritics in Arabic, Japanese, and Hebrew */
     INT ret;
 
@@ -3259,14 +3265,17 @@ INT WINAPI CompareStringEx(LPCWSTR locale, DWORD flags, LPCWSTR str1, INT len1,
         return 0;
     }
 
-    if (flags & ~(supported_flags|semistub_flags))
+    if (flags & ~supported_flags)
     {
         SetLastError(ERROR_INVALID_FLAGS);
         return 0;
     }
 
     if (flags & semistub_flags)
-        FIXME("semi-stub behavor for flag(s) 0x%x\n", flags & semistub_flags);
+    {
+        FIXME("semi-stub behavior for flag(s) 0x%x\n", flags & semistub_flags);
+        semistub_flags &= ~flags;
+    }
 
     if (len1 < 0) len1 = strlenW(str1);
     if (len2 < 0) len2 = strlenW(str2);
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index c2833b1..3888a1a 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -1094,6 +1094,9 @@ BOOL WINAPI CopyFileExW(LPCWSTR source, LPCWSTR dest,
     DWORD count;
     BOOL ret = FALSE;
     char *buffer;
+    LARGE_INTEGER size;
+    LARGE_INTEGER transferred;
+    DWORD cbret;
 
     if (!source || !dest)
     {
@@ -1108,7 +1111,13 @@ BOOL WINAPI CopyFileExW(LPCWSTR source, LPCWSTR dest,
 
     TRACE("%s -> %s, %x\n", debugstr_w(source), debugstr_w(dest), flags);
 
-    if ((h1 = CreateFileW(source, GENERIC_READ,
+    if (flags & COPY_FILE_RESTARTABLE)
+        FIXME("COPY_FILE_RESTARTABLE is not supported\n");
+    if (flags & COPY_FILE_COPY_SYMLINK)
+        FIXME("COPY_FILE_COPY_SYMLINK is not supported\n");
+
+    if ((h1 = CreateFileW(source, (flags & COPY_FILE_OPEN_SOURCE_FOR_WRITE) ?
+                     GENERIC_WRITE | GENERIC_READ : GENERIC_READ,
                      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                      NULL, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE)
     {
@@ -1144,7 +1153,7 @@ BOOL WINAPI CopyFileExW(LPCWSTR source, LPCWSTR dest,
         }
     }
 
-    if ((h2 = CreateFileW( dest, GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
+    if ((h2 = CreateFileW( dest, GENERIC_WRITE | DELETE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,
                              (flags & COPY_FILE_FAIL_IF_EXISTS) ? CREATE_NEW : CREATE_ALWAYS,
                              info.dwFileAttributes, h1 )) == INVALID_HANDLE_VALUE)
     {
@@ -1154,6 +1163,31 @@ BOOL WINAPI CopyFileExW(LPCWSTR source, LPCWSTR dest,
         return FALSE;
     }
 
+    size.u.LowPart = info.nFileSizeLow;
+    size.u.HighPart = info.nFileSizeHigh;
+    transferred.QuadPart = 0;
+
+    if (progress)
+    {
+        cbret = progress( size, transferred, size, transferred, 1,
+                          CALLBACK_STREAM_SWITCH, h1, h2, param );
+        if (cbret == PROGRESS_QUIET)
+            progress = NULL;
+        else if (cbret == PROGRESS_STOP)
+        {
+            SetLastError( ERROR_REQUEST_ABORTED );
+            goto done;
+        }
+        else if (cbret == PROGRESS_CANCEL)
+        {
+            FILE_DISPOSITION_INFO disp;
+            disp.DoDeleteFile = TRUE;
+            SetFileInformationByHandle( h2, FileDispositionInfo, &disp, sizeof(disp) );
+            SetLastError( ERROR_REQUEST_ABORTED );
+            goto done;
+        }
+    }
+
     while (ReadFile( h1, buffer, buffer_size, &count, NULL ) && count)
     {
         char *p = buffer;
@@ -1163,6 +1197,28 @@ BOOL WINAPI CopyFileExW(LPCWSTR source, LPCWSTR dest,
             if (!WriteFile( h2, p, count, &res, NULL ) || !res) goto done;
             p += res;
             count -= res;
+
+            if (progress)
+            {
+                transferred.QuadPart += res;
+                cbret = progress( size, transferred, size, transferred, 1,
+                                  CALLBACK_CHUNK_FINISHED, h1, h2, param );
+                if (cbret == PROGRESS_QUIET)
+                    progress = NULL;
+                else if (cbret == PROGRESS_STOP)
+                {
+                    SetLastError( ERROR_REQUEST_ABORTED );
+                    goto done;
+                }
+                else if (cbret == PROGRESS_CANCEL)
+                {
+                    FILE_DISPOSITION_INFO disp;
+                    disp.DoDeleteFile = TRUE;
+                    SetFileInformationByHandle( h2, FileDispositionInfo, &disp, sizeof(disp) );
+                    SetLastError( ERROR_REQUEST_ABORTED );
+                    goto done;
+                }
+            }
         }
     }
     ret =  TRUE;
@@ -1585,6 +1641,7 @@ BOOL WINAPI CreateDirectoryExW( LPCWSTR template, LPCWSTR path, LPSECURITY_ATTRI
  */
 BOOL WINAPI RemoveDirectoryW( LPCWSTR path )
 {
+    FILE_BASIC_INFORMATION info;
     OBJECT_ATTRIBUTES attr;
     UNICODE_STRING nt_name;
     ANSI_STRING unix_name;
@@ -1610,18 +1667,29 @@ BOOL WINAPI RemoveDirectoryW( LPCWSTR path )
     status = NtOpenFile( &handle, DELETE, &attr, &io,
                          FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
                          FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT );
-    if (status == STATUS_SUCCESS)
-        status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN, FALSE );
-    RtlFreeUnicodeString( &nt_name );
-
     if (status != STATUS_SUCCESS)
     {
         SetLastError( RtlNtStatusToDosError(status) );
+        RtlFreeUnicodeString( &nt_name );
         return FALSE;
     }
 
-    if (!(ret = (rmdir( unix_name.Buffer ) != -1))) FILE_SetDosError();
-    RtlFreeAnsiString( &unix_name );
+    status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN, FALSE );
+    if (status == STATUS_SUCCESS)
+    {
+        status = NtQueryAttributesFile( &attr, &info );
+        if (status == STATUS_SUCCESS && (info.FileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) &&
+                                        (info.FileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+            ret = (unlink( unix_name.Buffer ) != -1);
+        else
+            ret = (rmdir( unix_name.Buffer ) != -1);
+        if (!ret) FILE_SetDosError();
+        RtlFreeAnsiString( &unix_name );
+    }
+    else
+        SetLastError( RtlNtStatusToDosError(status) );
+    RtlFreeUnicodeString( &nt_name );
+
     NtClose( handle );
     return ret;
 }
@@ -1874,8 +1942,7 @@ BOOL WINAPI NeedCurrentDirectoryForExePathW( LPCWSTR name )
                                      'I','n','E','x','e','P','a','t','h',0};
     WCHAR env_val;
 
-    /* MSDN mentions some 'registry location'. We do not use registry. */
-    FIXME("(%s): partial stub\n", debugstr_w(name));
+    TRACE("(%s)\n", debugstr_w(name));
 
     if (strchrW(name, '\\'))
         return TRUE;
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 2c8074b..f0fbf8b 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -65,6 +65,7 @@
 WINE_DEFAULT_DEBUG_CHANNEL(process);
 WINE_DECLARE_DEBUG_CHANNEL(file);
 WINE_DECLARE_DEBUG_CHANNEL(relay);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 #ifdef __APPLE__
 extern char **__wine_get_main_environment(void);
@@ -259,9 +260,17 @@ static HANDLE open_exe_file( const WCHAR *name, struct binary_info *binary_info
 static BOOL find_exe_file( const WCHAR *name, WCHAR *buffer, int buflen,
                            HANDLE *handle, struct binary_info *binary_info )
 {
+    WCHAR cur_dir[MAX_PATH];
+
     TRACE("looking for %s\n", debugstr_w(name) );
 
-    if (!SearchPathW( NULL, name, exeW, buflen, buffer, NULL ) &&
+    /* The working directory takes precedence over other locations for CreateProcess unless the
+     * 'NoDefaultCurrentDirectoryInExePath' environment variable is set (and the executable name
+     * does not contain a backslash). */
+    if ((NeedCurrentDirectoryForExePathW( name ) && GetCurrentDirectoryW( MAX_PATH, cur_dir) &&
+         !SearchPathW( cur_dir, name, exeW, buflen, buffer, NULL )) &&
+        /* not found in the working directory, try the system search path */
+        !SearchPathW( NULL, name, exeW, buflen, buffer, NULL ) &&
         /* no builtin found, try native without extension in case it is a Unix app */
         !SearchPathW( NULL, name, NULL, buflen, buffer, NULL )) return FALSE;
 
@@ -1079,16 +1088,11 @@ static inline DWORD call_process_entry( PEB *peb, LPTHREAD_START_ROUTINE entry )
  *
  * Startup routine of a new process. Runs on the new process stack.
  */
-static DWORD WINAPI start_process( PEB *peb )
+static DWORD WINAPI start_process( LPTHREAD_START_ROUTINE entry )
 {
-    IMAGE_NT_HEADERS *nt;
-    LPTHREAD_START_ROUTINE entry;
-
-    nt = RtlImageNtHeader( peb->ImageBaseAddress );
-    entry = (LPTHREAD_START_ROUTINE)((char *)peb->ImageBaseAddress +
-                                     nt->OptionalHeader.AddressOfEntryPoint);
+    PEB *peb = NtCurrentTeb()->Peb;
 
-    if (!nt->OptionalHeader.AddressOfEntryPoint)
+    if (!entry)
     {
         ERR( "%s doesn't have an entry point, it cannot be executed\n",
              debugstr_w(peb->ProcessParameters->ImagePathName.Buffer) );
@@ -1099,6 +1103,15 @@ static DWORD WINAPI start_process( PEB *peb )
         DPRINTF( "%04x:Starting process %s (entryproc=%p)\n", GetCurrentThreadId(),
                  debugstr_w(peb->ProcessParameters->ImagePathName.Buffer), entry );
 
+    /* Wine developers don't like it, when bug are reported with Wine versions containing our patches. */
+    if (CreateEventA(0, 0, 0, "__winestaging_warn_event") && GetLastError() != ERROR_ALREADY_EXISTS)
+    {
+        FIXME_(winediag)("Wine Staging is a testing version containing experimental patches.\n");
+        FIXME_(winediag)("Please report bugs at http://bugs.wine-staging.com (instead of winehq.org).\n");
+    }
+    else
+        WARN_(winediag)("Wine Staging is a testing version containing experimental patches.\n");
+
     SetLastError( 0 );  /* clear error code */
     if (peb->BeingDebugged) DbgBreakPoint();
     return call_process_entry( peb, entry );
@@ -1923,6 +1936,70 @@ static pid_t exec_loader( LPCWSTR cmd_line, unsigned int flags, int socketfd,
     return pid;
 }
 
+/* creates a struct security_descriptor and contained information in one contiguous piece of memory */
+static NTSTATUS create_struct_sd(PSECURITY_DESCRIPTOR nt_sd, struct security_descriptor **server_sd,
+                                 data_size_t *server_sd_len)
+{
+    unsigned int len;
+    PSID owner, group;
+    ACL *dacl, *sacl;
+    BOOLEAN owner_present, group_present, dacl_present, sacl_present;
+    BOOLEAN defaulted;
+    NTSTATUS status;
+    unsigned char *ptr;
+
+    if (!nt_sd)
+    {
+        *server_sd = NULL;
+        *server_sd_len = 0;
+        return STATUS_SUCCESS;
+    }
+
+    len = sizeof(struct security_descriptor);
+
+    status = RtlGetOwnerSecurityDescriptor(nt_sd, &owner, &owner_present);
+    if (status != STATUS_SUCCESS) return status;
+    status = RtlGetGroupSecurityDescriptor(nt_sd, &group, &group_present);
+    if (status != STATUS_SUCCESS) return status;
+    status = RtlGetSaclSecurityDescriptor(nt_sd, &sacl_present, &sacl, &defaulted);
+    if (status != STATUS_SUCCESS) return status;
+    status = RtlGetDaclSecurityDescriptor(nt_sd, &dacl_present, &dacl, &defaulted);
+    if (status != STATUS_SUCCESS) return status;
+
+    if (owner_present)
+        len += RtlLengthSid(owner);
+    if (group_present)
+        len += RtlLengthSid(group);
+    if (sacl_present && sacl)
+        len += sacl->AclSize;
+    if (dacl_present && dacl)
+        len += dacl->AclSize;
+
+    /* fix alignment for the Unicode name that follows the structure */
+    len = (len + sizeof(WCHAR) - 1) & ~(sizeof(WCHAR) - 1);
+    *server_sd = RtlAllocateHeap(GetProcessHeap(), 0, len);
+    if (!*server_sd) return STATUS_NO_MEMORY;
+
+    (*server_sd)->control = ((SECURITY_DESCRIPTOR *)nt_sd)->Control & ~SE_SELF_RELATIVE;
+    (*server_sd)->owner_len = owner_present ? RtlLengthSid(owner) : 0;
+    (*server_sd)->group_len = group_present ? RtlLengthSid(group) : 0;
+    (*server_sd)->sacl_len = (sacl_present && sacl) ? sacl->AclSize : 0;
+    (*server_sd)->dacl_len = (dacl_present && dacl) ? dacl->AclSize : 0;
+
+    ptr = (unsigned char *)(*server_sd + 1);
+    memcpy(ptr, owner, (*server_sd)->owner_len);
+    ptr += (*server_sd)->owner_len;
+    memcpy(ptr, group, (*server_sd)->group_len);
+    ptr += (*server_sd)->group_len;
+    memcpy(ptr, sacl, (*server_sd)->sacl_len);
+    ptr += (*server_sd)->sacl_len;
+    memcpy(ptr, dacl, (*server_sd)->dacl_len);
+
+    *server_sd_len = len;
+
+    return STATUS_SUCCESS;
+}
+
 /***********************************************************************
  *           create_process
  *
@@ -1946,6 +2023,8 @@ static BOOL create_process( HANDLE hFile, LPCWSTR filename, LPWSTR cmd_line, LPW
     int socketfd[2], stdin_fd = -1, stdout_fd = -1;
     pid_t pid;
     int err, cpu;
+    struct security_descriptor *process_sd = NULL, *thread_sd = NULL;
+    data_size_t process_sd_size = 0, thread_sd_size = 0;
 
     if ((cpu = get_process_cpu( filename, binary_info )) == -1)
     {
@@ -2000,12 +2079,41 @@ static BOOL create_process( HANDLE hFile, LPCWSTR filename, LPWSTR cmd_line, LPW
         return FALSE;
     }
 
+    if (psa && (psa->nLength >= sizeof(*psa)))
+    {
+        status = create_struct_sd( psa->lpSecurityDescriptor, &process_sd, &process_sd_size );
+        if (status != STATUS_SUCCESS)
+        {
+            close( socketfd[0] );
+            close( socketfd[1] );
+            WARN( "Invalid process security descriptor: Status %x\n", status );
+            SetLastError( RtlNtStatusToDosError(status) );
+            return FALSE;
+        }
+    }
+
+    if (tsa && (tsa->nLength >= sizeof(*tsa)))
+    {
+        status = create_struct_sd( tsa->lpSecurityDescriptor, &thread_sd, &thread_sd_size );
+        if (status != STATUS_SUCCESS)
+        {
+            RtlFreeHeap( GetProcessHeap(), 0, process_sd );
+            close( socketfd[0] );
+            close( socketfd[1] );
+            WARN( "Invalid thread security descriptor: Status %x\n", status );
+            SetLastError( RtlNtStatusToDosError(status) );
+            return FALSE;
+        }
+    }
+
     RtlAcquirePebLock();
 
     if (!(startup_info = create_startup_info( filename, cmd_line, cur_dir, env, flags, startup,
                                               &startup_info_size )))
     {
         RtlReleasePebLock();
+        RtlFreeHeap( GetProcessHeap(), 0, process_sd );
+        RtlFreeHeap( GetProcessHeap(), 0, thread_sd );
         close( socketfd[0] );
         close( socketfd[1] );
         return FALSE;
@@ -2042,9 +2150,13 @@ static BOOL create_process( HANDLE hFile, LPCWSTR filename, LPWSTR cmd_line, LPW
         req->thread_attr    = (tsa && (tsa->nLength >= sizeof(*tsa)) && tsa->bInheritHandle) ? OBJ_INHERIT : 0;
         req->cpu            = cpu;
         req->info_size      = startup_info_size;
+        req->env_size       = (env_end - env) * sizeof(WCHAR);
+        req->process_sd_size = process_sd_size;
 
         wine_server_add_data( req, startup_info, startup_info_size );
         wine_server_add_data( req, env, (env_end - env) * sizeof(WCHAR) );
+        wine_server_add_data( req, process_sd, process_sd_size );
+        wine_server_add_data( req, thread_sd, thread_sd_size );
         if (!(status = wine_server_call( req )))
         {
             info->dwProcessId = (DWORD)reply->pid;
@@ -2057,6 +2169,9 @@ static BOOL create_process( HANDLE hFile, LPCWSTR filename, LPWSTR cmd_line, LPW
     SERVER_END_REQ;
 
     RtlReleasePebLock();
+    RtlFreeHeap( GetProcessHeap(), 0, process_sd );
+    RtlFreeHeap( GetProcessHeap(), 0, thread_sd );
+
     if (status)
     {
         switch (status)
@@ -3836,8 +3951,18 @@ BOOL WINAPI GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION
 BOOL WINAPI GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP relationship, PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX buffer, PDWORD pBufLen)
 {
     FIXME("(%u,%p,%p): stub\n", relationship, buffer, pBufLen);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return FALSE;
+
+    if (!pBufLen)
+    {
+        SetLastError(ERROR_INVALID_PARAMETER);
+        return FALSE;
+    }
+
+    /* MSDN says '[...] at least one SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
+     * structure is written to the output buffer.' - don't be surprised if this
+     * stub doesn't work always. */
+    *pBufLen = 0;
+    return TRUE;
 }
 
 /***********************************************************************
diff --git a/dlls/kernel32/profile.c b/dlls/kernel32/profile.c
index a9a11b1..fb35c90 100644
--- a/dlls/kernel32/profile.c
+++ b/dlls/kernel32/profile.c
@@ -500,7 +500,7 @@ static BOOL PROFILE_DeleteSection( PROFILESECTION **section, LPCWSTR name )
 {
     while (*section)
     {
-        if ((*section)->name[0] && !strcmpiW( (*section)->name, name ))
+        if (!strcmpiW( (*section)->name, name ))
         {
             PROFILESECTION *to_del = *section;
             *section = to_del->next;
@@ -524,7 +524,7 @@ static BOOL PROFILE_DeleteKey( PROFILESECTION **section,
 {
     while (*section)
     {
-        if ((*section)->name[0] && !strcmpiW( (*section)->name, section_name ))
+        if (!strcmpiW( (*section)->name, section_name ))
         {
             PROFILEKEY **key = &(*section)->key;
             while (*key)
@@ -556,7 +556,7 @@ static void PROFILE_DeleteAllKeys( LPCWSTR section_name)
     PROFILESECTION **section= &CurProfile->section;
     while (*section)
     {
-        if ((*section)->name[0] && !strcmpiW( (*section)->name, section_name ))
+        if (!strcmpiW( (*section)->name, section_name ))
         {
             PROFILEKEY **key = &(*section)->key;
             while (*key)
@@ -582,31 +582,28 @@ static PROFILEKEY *PROFILE_Find( PROFILESECTION **section, LPCWSTR section_name,
                                  LPCWSTR key_name, BOOL create, BOOL create_always )
 {
     LPCWSTR p;
-    int seclen, keylen;
+    int seclen = 0, keylen = 0;
 
     while (PROFILE_isspaceW(*section_name)) section_name++;
     if (*section_name)
+    {
         p = section_name + strlenW(section_name) - 1;
-    else
-        p = section_name;
-
-    while ((p > section_name) && PROFILE_isspaceW(*p)) p--;
-    seclen = p - section_name + 1;
+        while ((p > section_name) && PROFILE_isspaceW(*p)) p--;
+        seclen = p - section_name + 1;
+    }
 
     while (PROFILE_isspaceW(*key_name)) key_name++;
     if (*key_name)
+    {
         p = key_name + strlenW(key_name) - 1;
-    else
-        p = key_name;
-
-    while ((p > key_name) && PROFILE_isspaceW(*p)) p--;
-    keylen = p - key_name + 1;
+        while ((p > key_name) && PROFILE_isspaceW(*p)) p--;
+        keylen = p - key_name + 1;
+    }
 
     while (*section)
     {
-        if ( ((*section)->name[0])
-             && (!(strncmpiW( (*section)->name, section_name, seclen )))
-             && (((*section)->name)[seclen] == '\0') )
+        if (!strncmpiW((*section)->name, section_name, seclen) &&
+            ((*section)->name)[seclen] == '\0')
         {
             PROFILEKEY **key = &(*section)->key;
 
@@ -873,7 +870,7 @@ static INT PROFILE_GetSection( PROFILESECTION *section, LPCWSTR section_name,
 
     while (section)
     {
-        if (section->name[0] && !strcmpiW( section->name, section_name ))
+        if (!strcmpiW( section->name, section_name ))
         {
             UINT oldlen = len;
             for (key = section->key; key; key = key->next)
@@ -988,11 +985,6 @@ static INT PROFILE_GetString( LPCWSTR section, LPCWSTR key_name,
     if (!def_val) def_val = empty_strW;
     if (key_name)
     {
-	if (!key_name[0])
-        {
-            PROFILE_CopyEntry(buffer, def_val, len, TRUE);
-            return strlenW(buffer);
-        }
         key = PROFILE_Find( &CurProfile->section, section, key_name, FALSE, FALSE);
         PROFILE_CopyEntry( buffer, (key && key->value) ? key->value : def_val,
                            len, TRUE );
@@ -1002,7 +994,7 @@ static INT PROFILE_GetString( LPCWSTR section, LPCWSTR key_name,
         return strlenW( buffer );
     }
     /* no "else" here ! */
-    if (section && section[0])
+    if (section)
     {
         INT ret = PROFILE_GetSection(CurProfile->section, section, buffer, len, FALSE);
         if (!buffer[0]) /* no luck -> def_val */
diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index a07ce97..8157140 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -1470,7 +1470,7 @@ BOOL WINAPI PeekNamedPipe( HANDLE hPipe, LPVOID lpvBuffer, DWORD cbBuffer,
         ULONG read_size = io.Information - FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
         if (lpcbAvail) *lpcbAvail = buffer->ReadDataAvailable;
         if (lpcbRead) *lpcbRead = read_size;
-        if (lpcbMessage) *lpcbMessage = 0;  /* FIXME */
+        if (lpcbMessage) *lpcbMessage = buffer->MessageLength;
         if (lpvBuffer) memcpy( lpvBuffer, buffer->Data, read_size );
     }
     else SetLastError( RtlNtStatusToDosError(status) );
@@ -1616,6 +1616,7 @@ BOOL WINAPI ConnectNamedPipe(HANDLE hPipe, LPOVERLAPPED overlapped)
                              overlapped ? (IO_STATUS_BLOCK *)overlapped : &status_block,
                              FSCTL_PIPE_LISTEN, NULL, 0, NULL, 0);
 
+    if (overlapped && status == STATUS_SUCCESS) status = STATUS_PIPE_CONNECTED;
     if (status == STATUS_SUCCESS) return TRUE;
     SetLastError( RtlNtStatusToDosError(status) );
     return FALSE;
diff --git a/dlls/kernel32/tests/Makefile.in b/dlls/kernel32/tests/Makefile.in
index 2f2ac5f..50b0d8d 100644
--- a/dlls/kernel32/tests/Makefile.in
+++ b/dlls/kernel32/tests/Makefile.in
@@ -8,6 +8,7 @@ C_SRCS = \
 	codepage.c \
 	comm.c \
 	console.c \
+	cpu.c \
 	debugger.c \
 	directory.c \
 	drive.c \
diff --git a/dlls/kernel32/tests/actctx.c b/dlls/kernel32/tests/actctx.c
index 7512aed..6d5f2da 100644
--- a/dlls/kernel32/tests/actctx.c
+++ b/dlls/kernel32/tests/actctx.c
@@ -2067,7 +2067,7 @@ static HANDLE create_manifest(const char *filename, const char *data, int line)
     return handle;
 }
 
-static void kernel32_find(ULONG section, const char *string_to_find, BOOL should_find, BOOL todo, int line)
+static void kernel32_find(ULONG section, const char *string_to_find, BOOL should_find, int line)
 {
     UNICODE_STRING string_to_findW;
     ACTCTX_SECTION_KEYED_DATA data;
@@ -2084,13 +2084,8 @@ static void kernel32_find(ULONG section, const char *string_to_find, BOOL should
     err = GetLastError();
     ok_(__FILE__, line)(ret == should_find,
         "FindActCtxSectionStringA: expected ret = %u, got %u\n", should_find, ret);
-    if (todo)
-        todo_wine
-        ok_(__FILE__, line)(err == (should_find ? ERROR_SUCCESS : ERROR_SXS_KEY_NOT_FOUND),
-            "FindActCtxSectionStringA: unexpected error %u\n", err);
-    else
-        ok_(__FILE__, line)(err == (should_find ? ERROR_SUCCESS : ERROR_SXS_KEY_NOT_FOUND),
-            "FindActCtxSectionStringA: unexpected error %u\n", err);
+    ok_(__FILE__, line)(err == (should_find ? ERROR_SUCCESS : ERROR_SXS_KEY_NOT_FOUND),
+        "FindActCtxSectionStringA: unexpected error %u\n", err);
 
     memset(&data, 0xfe, sizeof(data));
     data.cbSize = sizeof(data);
@@ -2100,13 +2095,8 @@ static void kernel32_find(ULONG section, const char *string_to_find, BOOL should
     err = GetLastError();
     ok_(__FILE__, line)(ret == should_find,
         "FindActCtxSectionStringW: expected ret = %u, got %u\n", should_find, ret);
-    if (todo)
-        todo_wine
-        ok_(__FILE__, line)(err == (should_find ? ERROR_SUCCESS : ERROR_SXS_KEY_NOT_FOUND),
-            "FindActCtxSectionStringW: unexpected error %u\n", err);
-    else
-        ok_(__FILE__, line)(err == (should_find ? ERROR_SUCCESS : ERROR_SXS_KEY_NOT_FOUND),
-            "FindActCtxSectionStringW: unexpected error %u\n", err);
+    ok_(__FILE__, line)(err == (should_find ? ERROR_SUCCESS : ERROR_SXS_KEY_NOT_FOUND),
+        "FindActCtxSectionStringW: unexpected error %u\n", err);
 
     SetLastError(0);
     ret = pFindActCtxSectionStringA(0, NULL, section, string_to_find, NULL);
@@ -2127,7 +2117,7 @@ static void kernel32_find(ULONG section, const char *string_to_find, BOOL should
     pRtlFreeUnicodeString(&string_to_findW);
 }
 
-static void ntdll_find(ULONG section, const char *string_to_find, BOOL should_find, BOOL todo, int line)
+static void ntdll_find(ULONG section, const char *string_to_find, BOOL should_find, int line)
 {
     UNICODE_STRING string_to_findW;
     ACTCTX_SECTION_KEYED_DATA data;
@@ -2139,22 +2129,12 @@ static void ntdll_find(ULONG section, const char *string_to_find, BOOL should_fi
     data.cbSize = sizeof(data);
 
     ret = pRtlFindActivationContextSectionString(0, NULL, section, &string_to_findW, &data);
-    if (todo)
-        todo_wine
-        ok_(__FILE__, line)(ret == (should_find ? STATUS_SUCCESS : STATUS_SXS_KEY_NOT_FOUND),
-            "RtlFindActivationContextSectionString: unexpected status 0x%x\n", ret);
-    else
-        ok_(__FILE__, line)(ret == (should_find ? STATUS_SUCCESS : STATUS_SXS_KEY_NOT_FOUND),
-            "RtlFindActivationContextSectionString: unexpected status 0x%x\n", ret);
+    ok_(__FILE__, line)(ret == (should_find ? STATUS_SUCCESS : STATUS_SXS_KEY_NOT_FOUND),
+        "RtlFindActivationContextSectionString: unexpected status 0x%x\n", ret);
 
     ret = pRtlFindActivationContextSectionString(0, NULL, section, &string_to_findW, NULL);
-    if (todo)
-        todo_wine
-        ok_(__FILE__, line)(ret == (should_find ? STATUS_SUCCESS : STATUS_SXS_KEY_NOT_FOUND),
-            "RtlFindActivationContextSectionString: unexpected status 0x%x\n", ret);
-    else
-        ok_(__FILE__, line)(ret == (should_find ? STATUS_SUCCESS : STATUS_SXS_KEY_NOT_FOUND),
-            "RtlFindActivationContextSectionString: unexpected status 0x%x\n", ret);
+    ok_(__FILE__, line)(ret == (should_find ? STATUS_SUCCESS : STATUS_SXS_KEY_NOT_FOUND),
+        "RtlFindActivationContextSectionString: unexpected status 0x%x\n", ret);
 
     pRtlFreeUnicodeString(&string_to_findW);
 }
@@ -2170,22 +2150,22 @@ static void test_findsectionstring(void)
     ok(ret, "ActivateActCtx failed: %u\n", GetLastError());
 
     /* first we show the parameter validation from kernel32 */
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "testdep", FALSE, TRUE, __LINE__);
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib.dll", TRUE, FALSE, __LINE__);
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib2.dll", TRUE, FALSE, __LINE__);
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib3.dll", FALSE, FALSE, __LINE__);
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass", TRUE, FALSE, __LINE__);
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass2", TRUE, FALSE, __LINE__);
-    kernel32_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass3", FALSE, FALSE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "testdep", FALSE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib.dll", TRUE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib2.dll", TRUE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib3.dll", FALSE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass", TRUE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass2", TRUE, __LINE__);
+    kernel32_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass3", FALSE, __LINE__);
 
     /* then we show that ntdll plays by different rules */
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "testdep", FALSE, TRUE, __LINE__);
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib.dll", TRUE, FALSE, __LINE__);
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib2.dll", TRUE, FALSE, __LINE__);
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib3.dll", FALSE, FALSE, __LINE__);
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass", TRUE, FALSE, __LINE__);
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass2", TRUE, FALSE, __LINE__);
-    ntdll_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass3", FALSE, FALSE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION, "testdep", FALSE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib.dll", TRUE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib2.dll", TRUE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION, "testlib3.dll", FALSE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass", TRUE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass2", TRUE, __LINE__);
+    ntdll_find(ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, "wndClass3", FALSE, __LINE__);
 
     ret = pDeactivateActCtx(0, cookie);
     ok(ret, "DeactivateActCtx failed: %u\n", GetLastError());
diff --git a/dlls/kernel32/tests/file.c b/dlls/kernel32/tests/file.c
index 99fffab..0f5ac52 100644
--- a/dlls/kernel32/tests/file.c
+++ b/dlls/kernel32/tests/file.c
@@ -28,10 +28,13 @@
 #include <time.h>
 #include <stdio.h>
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "wine/test.h"
 #include "windef.h"
 #include "winbase.h"
 #include "winerror.h"
+#include "winternl.h"
 #include "winnls.h"
 #include "fileapi.h"
 
@@ -48,6 +51,10 @@ static HRESULT (WINAPI *pCopyFile2)(PCWSTR,PCWSTR,COPYFILE2_EXTENDED_PARAMETERS*
 static HANDLE (WINAPI *pCreateFile2)(LPCWSTR, DWORD, DWORD, DWORD, CREATEFILE2_EXTENDED_PARAMETERS*);
 static DWORD (WINAPI *pGetFinalPathNameByHandleA)(HANDLE, LPSTR, DWORD, DWORD);
 static DWORD (WINAPI *pGetFinalPathNameByHandleW)(HANDLE, LPWSTR, DWORD, DWORD);
+static NTSTATUS (WINAPI *pNtCreateFile)(PHANDLE, ACCESS_MASK, POBJECT_ATTRIBUTES, PIO_STATUS_BLOCK,
+                                        PLARGE_INTEGER, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
+static BOOL (WINAPI *pRtlDosPathNameToNtPathName_U)(LPCWSTR, PUNICODE_STRING, PWSTR*, CURDIR*);
+static NTSTATUS (WINAPI *pRtlAnsiStringToUnicodeString)(PUNICODE_STRING, PCANSI_STRING, BOOLEAN);
 
 static const char filename[] = "testfile.xxx";
 static const char sillytext[] =
@@ -72,8 +79,13 @@ struct test_list {
 
 static void InitFunctionPointers(void)
 {
+    HMODULE hntdll = GetModuleHandleA("ntdll");
     HMODULE hkernel32 = GetModuleHandleA("kernel32");
 
+    pNtCreateFile = (void *)GetProcAddress(hntdll, "NtCreateFile");
+    pRtlDosPathNameToNtPathName_U = (void *)GetProcAddress(hntdll, "RtlDosPathNameToNtPathName_U");
+    pRtlAnsiStringToUnicodeString = (void *)GetProcAddress(hntdll, "RtlAnsiStringToUnicodeString");
+
     pFindFirstFileExA=(void*)GetProcAddress(hkernel32, "FindFirstFileExA");
     pReplaceFileA=(void*)GetProcAddress(hkernel32, "ReplaceFileA");
     pReplaceFileW=(void*)GetProcAddress(hkernel32, "ReplaceFileW");
@@ -243,15 +255,36 @@ static void test__lclose( void )
     ok( ret != 0, "DeleteFile failed (%d)\n", GetLastError(  ) );
 }
 
+/* helper function for test__lcreat */
+static void get_nt_pathW(const char *name, UNICODE_STRING *nameW)
+{
+    UNICODE_STRING strW;
+    ANSI_STRING str;
+    NTSTATUS status;
+    BOOLEAN ret;
+    RtlInitAnsiString(&str, name);
+
+    status = pRtlAnsiStringToUnicodeString(&strW, &str, TRUE);
+    ok(!status, "RtlAnsiStringToUnicodeString failed with %08x\n", status);
+
+    ret = pRtlDosPathNameToNtPathName_U(strW.Buffer, nameW, NULL, NULL);
+    ok(ret, "RtlDosPathNameToNtPathName_U failed\n");
+
+    RtlFreeUnicodeString(&strW);
+}
 
 static void test__lcreat( void )
 {
+    UNICODE_STRING filenameW;
+    OBJECT_ATTRIBUTES attr;
+    IO_STATUS_BLOCK io;
     HFILE filehandle;
     char buffer[10000];
     WIN32_FIND_DATAA search_results;
     char slashname[] = "testfi/";
     int err;
-    HANDLE find;
+    HANDLE find, file;
+    NTSTATUS status;
     BOOL ret;
 
     filehandle = _lcreat( filename, 0 );
@@ -287,12 +320,47 @@ static void test__lcreat( void )
     ok( INVALID_HANDLE_VALUE != find, "should be able to find file\n" );
     FindClose( find );
 
+    SetLastError( 0xdeadbeef );
     ok( 0 == DeleteFileA( filename ), "shouldn't be able to delete a readonly file\n" );
+    ok( GetLastError() == ERROR_ACCESS_DENIED, "expected ERROR_ACCESS_DENIED, got %d\n", GetLastError() );
 
     ok( SetFileAttributesA(filename, FILE_ATTRIBUTE_NORMAL ) != 0, "couldn't change attributes on file\n" );
 
     ok( DeleteFileA( filename ) != 0, "now it should be possible to delete the file!\n" );
 
+    filehandle = _lcreat( filename, 1 ); /* readonly */
+    ok( HFILE_ERROR != filehandle, "couldn't create file \"%s\" (err=%d)\n", filename, GetLastError() );
+    ok( HFILE_ERROR != _hwrite( filehandle, sillytext, strlen(sillytext) ),
+        "_hwrite shouldn't be able to write never the less\n" );
+    ok( HFILE_ERROR != _lclose(filehandle), "_lclose complains\n" );
+
+    find = FindFirstFileA( filename, &search_results );
+    ok( INVALID_HANDLE_VALUE != find, "should be able to find file\n" );
+    FindClose( find );
+
+    get_nt_pathW(filename, &filenameW);
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = 0;
+    attr.Attributes = OBJ_CASE_INSENSITIVE;
+    attr.ObjectName = &filenameW;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+
+    status = NtCreateFile( &file, GENERIC_READ | GENERIC_WRITE | DELETE, &attr, &io, NULL, 0,
+                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+                           FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE, NULL, 0 );
+    ok( status == STATUS_ACCESS_DENIED, "expected STATUS_ACCESS_DENIED, got %08x\n", status );
+    ok( GetFileAttributesA( filename ) != INVALID_FILE_ATTRIBUTES, "file was deleted\n" );
+
+    status = NtCreateFile( &file, DELETE, &attr, &io, NULL, 0,
+                           FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
+                           FILE_OPEN, FILE_DELETE_ON_CLOSE | FILE_NON_DIRECTORY_FILE, NULL, 0 );
+    ok( status == STATUS_CANNOT_DELETE, "expected STATUS_CANNOT_DELETE, got %08x\n", status );
+    if (!status) CloseHandle( file );
+    ok( GetFileAttributesA( filename ) != INVALID_FILE_ATTRIBUTES, "file was deleted\n" );
+    ok( SetFileAttributesA(filename, FILE_ATTRIBUTE_NORMAL ) != 0, "couldn't change attributes on file\n" );
+    ok( DeleteFileA( filename ) != 0, "now it should be possible to delete the file!\n" );
+
     filehandle = _lcreat( filename, 2 );
     ok( HFILE_ERROR != filehandle, "couldn't create file \"%s\" (err=%d)\n", filename, GetLastError(  ) );
 
@@ -1646,14 +1714,12 @@ static void test_DeleteFileA( void )
 
     SetLastError(0xdeadbeef);
     ret = DeleteFileA(temp_file);
-todo_wine
     ok(ret, "DeleteFile error %d\n", GetLastError());
 
     SetLastError(0xdeadbeef);
     ret = CloseHandle(hfile);
     ok(ret, "CloseHandle error %d\n", GetLastError());
     ret = DeleteFileA(temp_file);
-todo_wine
     ok(!ret, "DeleteFile should fail\n");
 
     SetLastError(0xdeadbeef);
diff --git a/dlls/kernel32/tests/locale.c b/dlls/kernel32/tests/locale.c
index 95e0ac6..868bff7 100644
--- a/dlls/kernel32/tests/locale.c
+++ b/dlls/kernel32/tests/locale.c
@@ -1759,13 +1759,13 @@ static void test_CompareStringA(void)
     todo_wine ok(ret != CSTR_EQUAL, "\\2 vs \\1 expected unequal\n");
 
     ret = CompareStringA(lcid, NORM_IGNORECASE | LOCALE_USE_CP_ACP, "#", -1, ".", -1);
-    todo_wine ok(ret == CSTR_LESS_THAN, "\"#\" vs \".\" expected CSTR_LESS_THAN, got %d\n", ret);
+    ok(ret == CSTR_LESS_THAN, "\"#\" vs \".\" expected CSTR_LESS_THAN, got %d\n", ret);
 
     ret = CompareStringA(lcid, NORM_IGNORECASE, "_", -1, ".", -1);
-    todo_wine ok(ret == CSTR_GREATER_THAN, "\"_\" vs \".\" expected CSTR_GREATER_THAN, got %d\n", ret);
+    ok(ret == CSTR_GREATER_THAN, "\"_\" vs \".\" expected CSTR_GREATER_THAN, got %d\n", ret);
 
     ret = lstrcmpiA("#", ".");
-    todo_wine ok(ret == -1, "\"#\" vs \".\" expected -1, got %d\n", ret);
+    ok(ret == -1, "\"#\" vs \".\" expected -1, got %d\n", ret);
 
     lcid = MAKELCID(MAKELANGID(LANG_POLISH, SUBLANG_DEFAULT), SORT_DEFAULT);
 
@@ -3579,6 +3579,7 @@ static void test_GetStringTypeW(void)
 
     WORD types[20];
     WCHAR ch;
+    BOOL res;
     int i;
 
     memset(types,0,sizeof(types));
@@ -3636,6 +3637,15 @@ static void test_GetStringTypeW(void)
     for (i = 0; i < 3; i++)
         ok(types[i] & C1_SPACE || broken(types[i] == C1_CNTRL) || broken(types[i] == 0), "incorrect types returned for %x -> (%x does not have %x)\n",space_special[i], types[i], C1_SPACE );
 
+    for (i = -1; i < 3; i++)
+    {
+        SetLastError(0xdeadbeef);
+        memset(types, 0, sizeof(types));
+        res = GetStringTypeW(CT_CTYPE1, NULL, i, types);
+        ok(!res, "GetStringTypeW unexpectedly succeeded\n");
+        ok(GetLastError() == ERROR_INVALID_PARAMETER, "wrong error, got %u\n", GetLastError());
+    }
+
     /* surrogate pairs */
     ch = 0xd800;
     memset(types, 0, sizeof(types));
diff --git a/dlls/kernel32/tests/path.c b/dlls/kernel32/tests/path.c
index cdb565a..7dfc2bd 100644
--- a/dlls/kernel32/tests/path.c
+++ b/dlls/kernel32/tests/path.c
@@ -1082,8 +1082,10 @@ static void test_GetTempPath(void)
 {
     char save_TMP[MAX_PATH];
     char windir[MAX_PATH];
+    char origdir[MAX_PATH];
     char buf[MAX_PATH];
 
+    GetCurrentDirectoryA(sizeof(origdir), origdir);
     if (!GetEnvironmentVariableA("TMP", save_TMP, sizeof(save_TMP))) save_TMP[0] = 0;
 
     /* test default configuration */
@@ -1128,6 +1130,7 @@ static void test_GetTempPath(void)
     test_GetTempPathW(windir);
 
     SetEnvironmentVariableA("TMP", save_TMP);
+    SetCurrentDirectoryA(origdir);
 }
 
 static void test_GetLongPathNameA(void)
@@ -1724,10 +1727,11 @@ static void test_SearchPathA(void)
     static const CHAR testdeprelA[] = "./testdep.dll";
     static const CHAR kernel32A[] = "kernel32.dll";
     static const CHAR fileA[] = "";
-    CHAR pathA[MAX_PATH], buffA[MAX_PATH], path2A[MAX_PATH];
-    CHAR *ptrA = NULL;
+    CHAR pathA[MAX_PATH], buffA[MAX_PATH], path2A[MAX_PATH], path3A[MAX_PATH], curdirA[MAX_PATH];
+    CHAR tmpdirA[MAX_PATH], *ptrA = NULL;
     ULONG_PTR cookie;
     HANDLE handle;
+    BOOL bret;
     DWORD ret;
 
     if (!pSearchPathA)
@@ -1801,6 +1805,28 @@ static void test_SearchPathA(void)
     ret = pDeactivateActCtx(0, cookie);
     ok(ret, "failed to deactivate context, %u\n", GetLastError());
     pReleaseActCtx(handle);
+
+    /* test the search path priority of the working directory */
+    GetTempPathA(sizeof(tmpdirA), tmpdirA);
+    ret = GetCurrentDirectoryA(MAX_PATH, curdirA);
+    ok(ret, "failed to obtain working directory.\n");
+    sprintf(pathA, "%s\\%s", tmpdirA, kernel32A);
+    ret = pSearchPathA(NULL, kernel32A, NULL, sizeof(path2A)/sizeof(CHAR), path2A, NULL);
+    ok(ret && ret == strlen(path2A), "got %d\n", ret);
+    bret = CopyFileA(path2A, pathA, FALSE);
+    ok(bret != 0, "failed to copy test executable to temp directory, %u\n", GetLastError());
+    sprintf(path3A, "%s%s%s", curdirA, curdirA[strlen(curdirA)-1] != '\\' ? "\\" : "", kernel32A);
+    bret = CopyFileA(path2A, path3A, FALSE);
+    ok(bret != 0, "failed to copy test executable to launch directory, %u\n", GetLastError());
+    bret = SetCurrentDirectoryA(tmpdirA);
+    ok(bret, "failed to change working directory\n");
+    ret = pSearchPathA(NULL, kernel32A, ".exe", sizeof(buffA), buffA, NULL);
+    ok(ret && ret == strlen(buffA), "got %d\n", ret);
+    ok(strcmp(buffA, path3A) == 0, "expected %s, got %s\n", path3A, buffA);
+    bret = SetCurrentDirectoryA(curdirA);
+    ok(bret, "failed to reset working directory\n");
+    DeleteFileA(path3A);
+    DeleteFileA(pathA);
 }
 
 static void test_SearchPathW(void)
diff --git a/dlls/kernel32/tests/pipe.c b/dlls/kernel32/tests/pipe.c
index b115ed8..703188c 100644
--- a/dlls/kernel32/tests/pipe.c
+++ b/dlls/kernel32/tests/pipe.c
@@ -29,6 +29,7 @@
 #include "wine/test.h"
 
 #define PIPENAME "\\\\.\\PiPe\\tests_pipe.c"
+#define PIPENAME_SPECIAL "\\\\.\\PiPe\\tests->pipe.c"
 
 #define NB_SERVER_LOOPS 8
 
@@ -46,7 +47,9 @@ static void CALLBACK user_apc(ULONG_PTR param)
 
 enum rpcThreadOp
 {
-    RPC_READFILE
+    RPC_READFILE,
+    RPC_WRITEFILE,
+    RPC_PEEKNAMEDPIPE
 };
 
 struct rpcThreadArgs
@@ -54,7 +57,7 @@ struct rpcThreadArgs
     ULONG_PTR returnValue;
     DWORD lastError;
     enum rpcThreadOp op;
-    ULONG_PTR args[5];
+    ULONG_PTR args[6];
 };
 
 static DWORD CALLBACK rpcThreadMain(LPVOID arg)
@@ -73,6 +76,23 @@ static DWORD CALLBACK rpcThreadMain(LPVOID arg)
                                                         (LPOVERLAPPED)rpcargs->args[4] ); /* overlapped */
             break;
 
+        case RPC_WRITEFILE:
+            rpcargs->returnValue = (ULONG_PTR)WriteFile( (HANDLE)rpcargs->args[0],        /* hFile */
+                                                         (LPCVOID)rpcargs->args[1],       /* buffer */
+                                                         (DWORD)rpcargs->args[2],         /* bytesToWrite */
+                                                         (LPDWORD)rpcargs->args[3],       /* bytesWritten */
+                                                         (LPOVERLAPPED)rpcargs->args[4] ); /* overlapped */
+            break;
+
+        case RPC_PEEKNAMEDPIPE:
+            rpcargs->returnValue = (ULONG_PTR)PeekNamedPipe( (HANDLE)rpcargs->args[0],    /* hPipe */
+                                                             (LPVOID)rpcargs->args[1],    /* lpvBuffer */
+                                                             (DWORD)rpcargs->args[2],     /* cbBuffer */
+                                                             (LPDWORD)rpcargs->args[3],   /* lpcbRead */
+                                                             (LPDWORD)rpcargs->args[4],   /* lpcbAvail */
+                                                             (LPDWORD)rpcargs->args[5] ); /* lpcbMessage */
+            break;
+
         default:
             SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
             rpcargs->returnValue = 0;
@@ -110,6 +130,33 @@ static BOOL RpcReadFile(HANDLE hFile, LPVOID buffer, DWORD bytesToRead, LPDWORD
     return (BOOL)rpcargs.returnValue;
 }
 
+/* Runs PeekNamedPipe(...) from a different thread */
+static BOOL RpcPeekNamedPipe(HANDLE hPipe, LPVOID lpvBuffer, DWORD cbBuffer,
+                             LPDWORD lpcbRead, LPDWORD lpcbAvail, LPDWORD lpcbMessage)
+{
+    struct rpcThreadArgs rpcargs;
+    HANDLE thread;
+    DWORD threadId;
+
+    rpcargs.returnValue = 0;
+    rpcargs.lastError = GetLastError();
+    rpcargs.op = RPC_PEEKNAMEDPIPE;
+    rpcargs.args[0] = (ULONG_PTR)hPipe;
+    rpcargs.args[1] = (ULONG_PTR)lpvBuffer;
+    rpcargs.args[2] = (ULONG_PTR)cbBuffer;
+    rpcargs.args[3] = (ULONG_PTR)lpcbRead;
+    rpcargs.args[4] = (ULONG_PTR)lpcbAvail;
+    rpcargs.args[5] = (ULONG_PTR)lpcbMessage;
+
+    thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+    ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+    ok(WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0,"WaitForSingleObject failed with %d.\n", GetLastError());
+    CloseHandle(thread);
+
+    SetLastError(rpcargs.lastError);
+    return (BOOL)rpcargs.returnValue;
+}
+
 static void test_CreateNamedPipe(int pipemode)
 {
     HANDLE hnp;
@@ -119,6 +166,7 @@ static void test_CreateNamedPipe(int pipemode)
     char ibuf[32], *pbuf;
     DWORD written;
     DWORD readden;
+    DWORD leftmsg;
     DWORD avail;
     DWORD lpmode;
     BOOL ret;
@@ -233,9 +281,20 @@ static void test_CreateNamedPipe(int pipemode)
         ok(written == sizeof(obuf2), "write file len\n");
         ok(ReadFile(hFile, ibuf, 4, &readden, NULL), "ReadFile\n");
         ok(readden == 4, "read got %d bytes\n", readden);
+        readden = leftmsg = -1;
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe\n");
+        ok(readden == sizeof(obuf2) - 4, "peek got %d bytes total\n", readden);
+        if (pipemode == PIPE_TYPE_BYTE)
+            ok(leftmsg == 0, "peek got %d bytes left in message\n", leftmsg);
+        else
+            ok(leftmsg == sizeof(obuf2) - 4, "peek got %d bytes left in message\n", leftmsg);
         ok(ReadFile(hFile, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile\n");
         ok(readden == sizeof(obuf2) - 4, "read got %d bytes\n", readden);
         ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
+        readden = leftmsg = -1;
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe\n");
+        ok(readden == 0, "peek got %d bytes total\n", readden);
+        ok(leftmsg == 0, "peek got %d bytes left in message\n", leftmsg);
 
         memset(ibuf, 0, sizeof(ibuf));
         ok(WriteFile(hFile, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
@@ -247,9 +306,7 @@ static void test_CreateNamedPipe(int pipemode)
         else
         {
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
         }
         ok(readden == 4, "read got %d bytes\n", readden);
@@ -270,15 +327,11 @@ static void test_CreateNamedPipe(int pipemode)
         else
         {
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
             ok(readden == 4, "read got %d bytes\n", readden);
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf + 4, 4, &readden, NULL), "ReadFile\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
         }
         ok(readden == 4, "read got %d bytes\n", readden);
@@ -286,6 +339,146 @@ static void test_CreateNamedPipe(int pipemode)
         ok(readden == sizeof(obuf2) - 8, "read got %d bytes\n", readden);
         ok(memcmp(obuf2, ibuf, written) == 0, "content check\n");
 
+        /* Tests for sending empty messages */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        /* similar to above, but with an additional call to PeekNamedPipe inbetween */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == 0, "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            struct rpcThreadArgs rpcargs;
+            HANDLE thread;
+            DWORD threadId;
+
+            rpcargs.returnValue = 0;
+            rpcargs.lastError = GetLastError();
+            rpcargs.op = RPC_READFILE;
+            rpcargs.args[0] = (ULONG_PTR)hFile;
+            rpcargs.args[1] = (ULONG_PTR)ibuf;
+            rpcargs.args[2] = (ULONG_PTR)sizeof(ibuf);
+            rpcargs.args[3] = (ULONG_PTR)&readden;
+            rpcargs.args[4] = (ULONG_PTR)NULL;
+
+            thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+            ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+            ret = WaitForSingleObject(thread, 200);
+            todo_wine
+            ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+            if (ret == WAIT_TIMEOUT)
+            {
+                ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+                ok(written == 0, "write file len\n");
+                ret = WaitForSingleObject(thread, 200);
+                ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+            }
+            CloseHandle(thread);
+            ok((BOOL)rpcargs.returnValue, "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == 0, "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            struct rpcThreadArgs rpcargs;
+            HANDLE thread;
+            DWORD threadId;
+
+            rpcargs.returnValue = 0;
+            rpcargs.lastError = GetLastError();
+            rpcargs.op = RPC_READFILE;
+            rpcargs.args[0] = (ULONG_PTR)hnp;
+            rpcargs.args[1] = (ULONG_PTR)ibuf;
+            rpcargs.args[2] = (ULONG_PTR)sizeof(ibuf);
+            rpcargs.args[3] = (ULONG_PTR)&readden;
+            rpcargs.args[4] = (ULONG_PTR)NULL;
+
+            thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+            ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+            ret = WaitForSingleObject(thread, 200);
+            todo_wine
+            ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+            if (ret == WAIT_TIMEOUT)
+            {
+                ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+                ok(written == 0, "write file len\n");
+                ret = WaitForSingleObject(thread, 200);
+                ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+            }
+            CloseHandle(thread);
+            ok((BOOL)rpcargs.returnValue, "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+        }
+
+        /* similar to above, but now with PeekNamedPipe and multiple messages */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len\n");
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+        ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        else
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        ok(readden == sizeof(obuf), "read got %d bytes\n", readden);
+        ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check\n");
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf2, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+        ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf2), "write file len\n");
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+        ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+        ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+        if (pipemode != PIPE_TYPE_BYTE)
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        else
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            todo_wine
+            ok(readden == 0, "read got %d bytes\n", readden);
+            if (readden == 0)
+                ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+        }
+        ok(readden == sizeof(obuf2), "read got %d bytes\n", readden);
+        ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check\n");
+
         /* Test reading of multiple writes */
         memset(ibuf, 0, sizeof(ibuf));
         ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile3a\n");
@@ -340,9 +533,7 @@ static void test_CreateNamedPipe(int pipemode)
             ok(readden == sizeof(obuf) + sizeof(obuf2), "read 4 got %d bytes\n", readden);
         }
         else {
-            todo_wine {
-                ok(readden == sizeof(obuf), "read 4 got %d bytes\n", readden);
-            }
+            ok(readden == sizeof(obuf), "read 4 got %d bytes\n", readden);
         }
         pbuf = ibuf;
         ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 4a check\n");
@@ -372,9 +563,7 @@ static void test_CreateNamedPipe(int pipemode)
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 5a check\n");
             ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
-            todo_wine {
-                ok(readden == sizeof(obuf), "read 5 got %d bytes\n", readden);
-            }
+            ok(readden == sizeof(obuf), "read 5 got %d bytes\n", readden);
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 5a check\n");
             if (readden <= sizeof(obuf))
@@ -383,10 +572,8 @@ static void test_CreateNamedPipe(int pipemode)
             /* Multiple writes in the reverse direction */
             /* the write of obuf2 from write4 should still be in the buffer */
             ok(PeekNamedPipe(hnp, ibuf, sizeof(ibuf), &readden, &avail, NULL), "Peek6a\n");
-            todo_wine {
-                ok(readden == sizeof(obuf2), "peek6a got %d bytes\n", readden);
-                ok(avail == sizeof(obuf2), "peek6a got %d bytes available\n", avail);
-            }
+            ok(readden == sizeof(obuf2), "peek6a got %d bytes\n", readden);
+            ok(avail == sizeof(obuf2), "peek6a got %d bytes available\n", avail);
             if (avail > 0) {
                 ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
                 ok(readden == sizeof(obuf2), "read 6a got %d bytes\n", readden);
@@ -404,22 +591,145 @@ static void test_CreateNamedPipe(int pipemode)
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 6a check\n");
             ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
-            todo_wine {
-                ok(readden == sizeof(obuf), "read 6b got %d bytes\n", readden);
-            }
+            ok(readden == sizeof(obuf), "read 6b got %d bytes\n", readden);
             pbuf = ibuf;
             ok(memcmp(obuf, pbuf, sizeof(obuf)) == 0, "content 6a check\n");
             if (readden <= sizeof(obuf))
                 ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
 
+            /* Tests for sending empty messages */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == 0, "read got %d bytes\n", readden);
+
+            /* similar to above, but with an additional call to PeekNamedPipe inbetween */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
+            ok(readden == 0, "peek got %d bytes\n", readden);
+            {
+                struct rpcThreadArgs rpcargs;
+                HANDLE thread;
+                DWORD threadId;
+
+                rpcargs.returnValue = 0;
+                rpcargs.lastError = GetLastError();
+                rpcargs.op = RPC_READFILE;
+                rpcargs.args[0] = (ULONG_PTR)hFile;
+                rpcargs.args[1] = (ULONG_PTR)ibuf;
+                rpcargs.args[2] = (ULONG_PTR)sizeof(ibuf);
+                rpcargs.args[3] = (ULONG_PTR)&readden;
+                rpcargs.args[4] = (ULONG_PTR)NULL;
+
+                thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+                ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+                ret = WaitForSingleObject(thread, 200);
+                todo_wine
+                ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+                if (ret == WAIT_TIMEOUT)
+                {
+                    ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+                    ok(written == 0, "write file len\n");
+                    ret = WaitForSingleObject(thread, 200);
+                    ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+                }
+                CloseHandle(thread);
+                ok((BOOL)rpcargs.returnValue, "ReadFile\n");
+                ok(readden == 0, "read got %d bytes\n", readden);
+            }
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL), "Peek\n");
+            ok(readden == 0, "peek got %d bytes\n", readden);
+            {
+                struct rpcThreadArgs rpcargs;
+                HANDLE thread;
+                DWORD threadId;
+
+                rpcargs.returnValue = 0;
+                rpcargs.lastError = GetLastError();
+                rpcargs.op = RPC_READFILE;
+                rpcargs.args[0] = (ULONG_PTR)hnp;
+                rpcargs.args[1] = (ULONG_PTR)ibuf;
+                rpcargs.args[2] = (ULONG_PTR)sizeof(ibuf);
+                rpcargs.args[3] = (ULONG_PTR)&readden;
+                rpcargs.args[4] = (ULONG_PTR)NULL;
+
+                thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+                ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+                ret = WaitForSingleObject(thread, 200);
+                todo_wine
+                ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+                if (ret == WAIT_TIMEOUT)
+                {
+                    ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+                    ok(written == 0, "write file len\n");
+                    ret = WaitForSingleObject(thread, 200);
+                    ok(ret == WAIT_OBJECT_0, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_OBJECT_0);
+                }
+                CloseHandle(thread);
+                ok((BOOL)rpcargs.returnValue, "ReadFile\n");
+                ok(readden == 0, "read got %d bytes\n", readden);
+            }
+
+            /* similar to above, but now with PeekNamedPipe and multiple messages */
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+            ok(written == sizeof(obuf), "write file len\n");
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf), "peek got %d bytes\n", readden);
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(readden == 0, "read got %d bytes\n", readden);
+            if (readden == 0)
+                ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == sizeof(obuf), "read got %d bytes\n", readden);
+            ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check\n");
+
+            memset(ibuf, 0, sizeof(ibuf));
+            ok(WriteFile(hFile, obuf2, 0, &written, NULL), "WriteFile\n");
+            ok(written == 0, "write file len\n");
+            ok(WriteFile(hFile, obuf2, sizeof(obuf2), &written, NULL), "WriteFile\n");
+            ok(written == sizeof(obuf2), "write file len\n");
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "Peek\n");
+            ok(readden == sizeof(obuf2), "peek got %d bytes\n", readden);
+            todo_wine
+            ok(leftmsg == 0, "peek got %d bytes left in msg\n", leftmsg);
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(readden == 0, "read got %d bytes\n", readden);
+            if (readden == 0)
+                ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile\n");
+            ok(readden == sizeof(obuf2), "read got %d bytes\n", readden);
+            ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check\n");
+
             /* Test how ReadFile behaves when the buffer is not big enough for the whole message */
             memset(ibuf, 0, sizeof(ibuf));
             ok(WriteFile(hnp, obuf2, sizeof(obuf2), &written, NULL), "WriteFile 7\n");
             ok(written == sizeof(obuf2), "write file len 7\n");
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hFile, ibuf, 4, &readden, NULL), "ReadFile 7\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 7\n");
             ok(readden == 4, "read got %d bytes 7\n", readden);
             ok(ReadFile(hFile, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile 7\n");
@@ -430,9 +740,7 @@ static void test_CreateNamedPipe(int pipemode)
             ok(WriteFile(hFile, obuf, sizeof(obuf), &written, NULL), "WriteFile 8\n");
             ok(written == sizeof(obuf), "write file len 8\n");
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile 8\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 8\n");
             ok(readden == 4, "read got %d bytes 8\n", readden);
             ok(ReadFile(hnp, ibuf + 4, sizeof(ibuf) - 4, &readden, NULL), "ReadFile 8\n");
@@ -448,44 +756,76 @@ static void test_CreateNamedPipe(int pipemode)
             ok(written == sizeof(obuf), "write file len 9\n");
             ok(WriteFile(hnp, obuf2, sizeof(obuf2), &written, NULL), "WriteFile 9\n");
             ok(written == sizeof(obuf2), "write file len 9\n");
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
+            ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
+            ok(leftmsg == sizeof(obuf), "peek got %d bytes left in message 9\n", leftmsg);
+            readden = leftmsg = -1;
+            ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
+            ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
+            ok(leftmsg == sizeof(obuf), "peek got %d bytes left in message 9\n", leftmsg);
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hFile, ibuf, 4, &readden, NULL), "ReadFile 9\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 9\n");
             ok(readden == 4, "read got %d bytes 9\n", readden);
             SetLastError(0xdeadbeef);
             ret = RpcReadFile(hFile, ibuf + 4, 4, &readden, NULL);
-            todo_wine
             ok(!ret, "RpcReadFile 9\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 9\n");
             ok(readden == 4, "read got %d bytes 9\n", readden);
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
+            ok(readden == sizeof(obuf) - 8 + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
+            ok(leftmsg == sizeof(obuf) - 8, "peek got %d bytes left in message 9\n", leftmsg);
+            readden = leftmsg = -1;
+            ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
+            ok(readden == sizeof(obuf) - 8 + sizeof(obuf2), "peek got %d bytes total 9\n", readden);
+            ok(leftmsg == sizeof(obuf) - 8, "peek got %d bytes left in message 9\n", leftmsg);
             ret = RpcReadFile(hFile, ibuf + 8, sizeof(ibuf), &readden, NULL);
             ok(ret, "RpcReadFile 9\n");
-            todo_wine
             ok(readden == sizeof(obuf) - 8, "read got %d bytes 9\n", readden);
             ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check 9\n");
             if (readden <= sizeof(obuf) - 8) /* blocks forever if second part was already received */
             {
                 memset(ibuf, 0, sizeof(ibuf));
+                readden = leftmsg = -1;
+                ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
+                ok(readden == sizeof(obuf2), "peek got %d bytes total 9\n", readden);
+                ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 9\n", leftmsg);
+                readden = leftmsg = -1;
+                ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
+                ok(readden == sizeof(obuf2), "peek got %d bytes total 9\n", readden);
+                ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 9\n", leftmsg);
                 SetLastError(0xdeadbeef);
                 ret = RpcReadFile(hFile, ibuf, 4, &readden, NULL);
                 ok(!ret, "RpcReadFile 9\n");
-                todo_wine
                 ok(GetLastError() == ERROR_MORE_DATA, "wrong error 9\n");
                 ok(readden == 4, "read got %d bytes 9\n", readden);
                 SetLastError(0xdeadbeef);
-                todo_wine
                 ok(!ReadFile(hFile, ibuf + 4, 4, &readden, NULL), "ReadFile 9\n");
-                todo_wine
                 ok(GetLastError() == ERROR_MORE_DATA, "wrong error 9\n");
                 ok(readden == 4, "read got %d bytes 9\n", readden);
+                readden = leftmsg = -1;
+                ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
+                ok(readden == sizeof(obuf2) - 8, "peek got %d bytes total 9\n", readden);
+                ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 9\n", leftmsg);
+                readden = leftmsg = -1;
+                ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
+                ok(readden == sizeof(obuf2) - 8, "peek got %d bytes total 9\n", readden);
+                ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 9\n", leftmsg);
                 ret = RpcReadFile(hFile, ibuf + 8, sizeof(ibuf), &readden, NULL);
                 ok(ret, "RpcReadFile 9\n");
                 ok(readden == sizeof(obuf2) - 8, "read got %d bytes 9\n", readden);
                 ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check 9\n");
             }
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 9\n");
+            ok(readden == 0, "peek got %d bytes total 9\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message 9\n", leftmsg);
+            readden = leftmsg = -1;
+            ok(RpcPeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 9\n");
+            ok(readden == 0, "peek got %d bytes total 9\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message 9\n", leftmsg);
 
             /* Now the reverse direction */
             memset(ibuf, 0, sizeof(ibuf));
@@ -493,45 +833,188 @@ static void test_CreateNamedPipe(int pipemode)
             ok(written == sizeof(obuf2), "write file len 10\n");
             ok(WriteFile(hFile, obuf, sizeof(obuf), &written, NULL), "WriteFile 10\n");
             ok(written == sizeof(obuf), "write file len 10\n");
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
+            ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 10\n", readden);
+            ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 10\n", leftmsg);
+            readden = leftmsg = -1;
+            ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
+            ok(readden == sizeof(obuf) + sizeof(obuf2), "peek got %d bytes total 10\n", readden);
+            ok(leftmsg == sizeof(obuf2), "peek got %d bytes left in message 10\n", leftmsg);
             SetLastError(0xdeadbeef);
-            todo_wine
             ok(!ReadFile(hnp, ibuf, 4, &readden, NULL), "ReadFile 10\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
             ok(readden == 4, "read got %d bytes 10\n", readden);
             SetLastError(0xdeadbeef);
             ret = RpcReadFile(hnp, ibuf + 4, 4, &readden, NULL);
-            todo_wine
             ok(!ret, "RpcReadFile 10\n");
-            todo_wine
             ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
             ok(readden == 4, "read got %d bytes 10\n", readden);
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
+            ok(readden == sizeof(obuf2) - 8 + sizeof(obuf), "peek got %d bytes total 10\n", readden);
+            ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 10\n", leftmsg);
+            readden = leftmsg = -1;
+            ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
+            ok(readden == sizeof(obuf2) - 8 + sizeof(obuf), "peek got %d bytes total 10\n", readden);
+            ok(leftmsg == sizeof(obuf2) - 8, "peek got %d bytes left in message 10\n", leftmsg);
             ret = RpcReadFile(hnp, ibuf + 8, sizeof(ibuf), &readden, NULL);
             ok(ret, "RpcReadFile 10\n");
-            todo_wine
             ok(readden == sizeof(obuf2) - 8, "read got %d bytes 10\n", readden);
             ok(memcmp(obuf2, ibuf, sizeof(obuf2)) == 0, "content check 10\n");
             if (readden <= sizeof(obuf2) - 8) /* blocks forever if second part was already received */
             {
                 memset(ibuf, 0, sizeof(ibuf));
+                readden = leftmsg = -1;
+                ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
+                ok(readden == sizeof(obuf), "peek got %d bytes total 10\n", readden);
+                ok(leftmsg == sizeof(obuf), "peek got %d bytes left in message 10\n", leftmsg);
+                readden = leftmsg = -1;
+                ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
+                ok(readden == sizeof(obuf), "peek got %d bytes total 10\n", readden);
+                ok(leftmsg == sizeof(obuf), "peek got %d bytes left in message 10\n", leftmsg);
                 SetLastError(0xdeadbeef);
                 ret = RpcReadFile(hnp, ibuf, 4, &readden, NULL);
                 ok(!ret, "RpcReadFile 10\n");
-                todo_wine
                 ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
                 ok(readden == 4, "read got %d bytes 10\n", readden);
                 SetLastError(0xdeadbeef);
-                todo_wine
                 ok(!ReadFile(hnp, ibuf + 4, 4, &readden, NULL), "ReadFile 10\n");
-                todo_wine
                 ok(GetLastError() == ERROR_MORE_DATA, "wrong error 10\n");
                 ok(readden == 4, "read got %d bytes 10\n", readden);
+                readden = leftmsg = -1;
+                ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
+                ok(readden == sizeof(obuf) - 8, "peek got %d bytes total 10\n", readden);
+                ok(leftmsg == sizeof(obuf) - 8, "peek got %d bytes left in message 10\n", leftmsg);
+                readden = leftmsg = -1;
+                ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
+                ok(readden == sizeof(obuf) - 8, "peek got %d bytes total 10\n", readden);
+                ok(leftmsg == sizeof(obuf) - 8, "peek got %d bytes left in message 10\n", leftmsg);
                 ret = RpcReadFile(hnp, ibuf + 8, sizeof(ibuf), &readden, NULL);
                 ok(ret, "RpcReadFile 10\n");
                 ok(readden == sizeof(obuf) - 8, "read got %d bytes 10\n", readden);
                 ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check 10\n");
             }
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe 10\n");
+            ok(readden == 0, "peek got %d bytes total 10\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message 10\n", leftmsg);
+            readden = leftmsg = -1;
+            ok(RpcPeekNamedPipe(hnp, NULL, 0, NULL, &readden, &leftmsg), "RpcPeekNamedPipe 10\n");
+            ok(readden == 0, "peek got %d bytes total 10\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message 10\n", leftmsg);
+
+        }
 
+        /* Test behaviour for very huge messages (which don't fit completely in the buffer) */
+        {
+            static char big_obuf[512 * 1024];
+            static char big_ibuf[512 * 1024];
+            struct rpcThreadArgs rpcargs;
+            HANDLE thread;
+            DWORD threadId;
+            memset(big_obuf, 0xAA, sizeof(big_obuf));
+
+            /* Ensure that both pipes are empty before we continue with the next test */
+            while (PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL) && readden > 0)
+                ok(ReadFile(hFile, big_ibuf, sizeof(big_ibuf), &readden, NULL) ||
+                   GetLastError() == ERROR_MORE_DATA, "ReadFile\n");
+
+            while (PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL) && readden > 0)
+                ok(ReadFile(hnp, big_ibuf, sizeof(big_ibuf), &readden, NULL) ||
+                   GetLastError() == ERROR_MORE_DATA, "ReadFile\n");
+
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe\n");
+            ok(readden == 0, "peek got %d bytes total\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message\n", leftmsg);
+
+            /* transmit big message, receive with buffer of equal size */
+            memset(big_ibuf, 0, sizeof(big_ibuf));
+            rpcargs.returnValue = 0;
+            rpcargs.lastError = GetLastError();
+            rpcargs.op = RPC_WRITEFILE;
+            rpcargs.args[0] = (ULONG_PTR)hnp;
+            rpcargs.args[1] = (ULONG_PTR)big_obuf;
+            rpcargs.args[2] = (ULONG_PTR)sizeof(big_obuf);
+            rpcargs.args[3] = (ULONG_PTR)&written;
+            rpcargs.args[4] = (ULONG_PTR)NULL;
+
+            thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+            ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+            ret = WaitForSingleObject(thread, 200);
+            ok(ret == WAIT_TIMEOUT, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_TIMEOUT);
+            ok(ReadFile(hFile, big_ibuf, sizeof(big_ibuf), &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(readden == sizeof(big_obuf), "read got %d bytes\n", readden);
+            todo_wine
+            ok(memcmp(big_ibuf, big_obuf, sizeof(big_obuf)) == 0, "content check\n");
+            do
+            {
+                ret = WaitForSingleObject(thread, 1);
+                while (PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL) && readden > 0)
+                    ok(ReadFile(hFile, big_ibuf, sizeof(big_ibuf), &readden, NULL) ||
+                       GetLastError() == ERROR_MORE_DATA, "ReadFile\n");
+            }
+            while (ret == WAIT_TIMEOUT);
+            ok(WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0, "WaitForSingleObject failed with %d.\n", GetLastError());
+            ok((BOOL)rpcargs.returnValue, "WriteFile\n");
+            ok(written == sizeof(big_obuf), "write file len\n");
+            CloseHandle(thread);
+
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe\n");
+            ok(readden == 0, "peek got %d bytes total\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message\n", leftmsg);
+
+            /* same as above, but receive as multiple parts */
+            memset(big_ibuf, 0, sizeof(big_ibuf));
+            rpcargs.returnValue = 0;
+            rpcargs.lastError = GetLastError();
+
+            thread = CreateThread(NULL, 0, rpcThreadMain, (void *)&rpcargs, 0, &threadId);
+            ok(thread != NULL, "CreateThread failed. %d\n", GetLastError());
+            ret = WaitForSingleObject(thread, 200);
+            ok(ret == WAIT_TIMEOUT, "WaitForSingleObject returned %d instead of %d.\n", ret, WAIT_TIMEOUT);
+            if (pipemode == PIPE_TYPE_BYTE)
+            {
+                ok(ReadFile(hFile, big_ibuf, 32, &readden, NULL), "ReadFile\n");
+                ok(readden == 32, "read got %d bytes\n", readden);
+                ok(ReadFile(hFile, big_ibuf + 32, 32, &readden, NULL), "ReadFile\n");
+            }
+            else
+            {
+                SetLastError(0xdeadbeef);
+                ok(!ReadFile(hFile, big_ibuf, 32, &readden, NULL), "ReadFile\n");
+                ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+                ok(readden == 32, "read got %d bytes\n", readden);
+                SetLastError(0xdeadbeef);
+                ok(!ReadFile(hFile, big_ibuf + 32, 32, &readden, NULL), "ReadFile\n");
+                ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+            }
+            ok(readden == 32, "read got %d bytes\n", readden);
+            ok(ReadFile(hFile, big_ibuf + 64, sizeof(big_ibuf) - 64, &readden, NULL), "ReadFile\n");
+            todo_wine
+            ok(readden == sizeof(big_obuf) - 64, "read got %d bytes\n", readden);
+            todo_wine
+            ok(memcmp(big_ibuf, big_obuf, sizeof(big_obuf)) == 0, "content check\n");
+            do
+            {
+                ret = WaitForSingleObject(thread, 1);
+                while (PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL) && readden > 0)
+                    ok(ReadFile(hFile, big_ibuf, sizeof(big_ibuf), &readden, NULL) ||
+                       GetLastError() == ERROR_MORE_DATA, "ReadFile\n");
+            }
+            while (ret == WAIT_TIMEOUT);
+            ok(WaitForSingleObject(thread, INFINITE) == WAIT_OBJECT_0, "WaitForSingleObject failed with %d.\n", GetLastError());
+            ok((BOOL)rpcargs.returnValue, "WriteFile\n");
+            ok(written == sizeof(big_obuf), "write file len\n");
+            CloseHandle(thread);
+
+            readden = leftmsg = -1;
+            ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, &leftmsg), "PeekNamedPipe\n");
+            ok(readden == 0, "peek got %d bytes total\n", readden);
+            ok(leftmsg == 0, "peek got %d bytes left in message\n", leftmsg);
         }
 
         /* Picky conformance tests */
@@ -574,6 +1057,15 @@ static void test_CreateNamedPipe(int pipemode)
 
     ok(CloseHandle(hnp), "CloseHandle\n");
 
+    hnp = CreateNamedPipeA(PIPENAME_SPECIAL, PIPE_ACCESS_DUPLEX, pipemode | PIPE_WAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 1024,
+        /* nInBufSize */ 1024,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe with special characters failed\n");
+    ok(CloseHandle(hnp), "CloseHandle\n");
+
     trace("test_CreateNamedPipe returning\n");
 }
 
@@ -662,6 +1154,167 @@ static void test_CreateNamedPipe_instances_must_match(void)
     ok(CloseHandle(hnp2), "CloseHandle\n");
 }
 
+static void test_CloseNamedPipe(void)
+{
+    HANDLE hnp;
+    HANDLE hFile;
+    static const char obuf[] = "Bit Bucket";
+    char ibuf[32];
+    DWORD written;
+    DWORD readden;
+
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
+    /* don't try to do i/o if one side couldn't be opened, as it hangs */
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        /* Make sure we can read and write a few bytes in both directions */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len 1\n");
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+
+        /* close server end without disconnecting */
+        ok(CloseHandle(hnp), "CloseHandle() failed: %08x\n", GetLastError());
+
+        ok(ReadFile(hFile, ibuf, 0, &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == 0, "got %d bytes\n", readden);
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+        /* pipe is empty now */
+
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hFile, ibuf, 0, &readden, NULL), "ReadFile() succeeded\n");
+        ok(GetLastError() == ERROR_BROKEN_PIPE, "GetLastError() returned %08x, expected ERROR_BROKEN_PIPE\n", GetLastError());
+        SetLastError(0);
+
+        CloseHandle(hFile);
+    }
+
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
+    /* don't try to do i/o if one side couldn't be opened, as it hangs */
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len 1\n");
+
+        /* close server end without disconnecting */
+        ok(CloseHandle(hnp), "CloseHandle() failed: %08x\n", GetLastError());
+
+        todo_wine
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == 0, "got %d bytes\n", readden);
+        /* pipe is empty now */
+
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        todo_wine
+        ok(GetLastError() == ERROR_BROKEN_PIPE, "GetLastError() returned %08x, expected ERROR_BROKEN_PIPE\n", GetLastError());
+        SetLastError(0);
+
+        CloseHandle(hFile);
+    }
+
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        /* Make sure we can read and write a few bytes in both directions */
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(WriteFile(hFile, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len 1\n");
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+
+        /* close client end without disconnecting */
+        ok(CloseHandle(hFile), "CloseHandle() failed: %08x\n", GetLastError());
+
+        /* you'd think ERROR_MORE_DATA, but no */
+        ok(ReadFile(hnp, ibuf, 0, &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == 0, "got %d bytes\n", readden);
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+        /* pipe is empty now */
+
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hnp, ibuf, 0, &readden, NULL), "ReadFile() succeeded\n");
+        ok(GetLastError() == ERROR_BROKEN_PIPE, "GetLastError() returned %08x, expected ERROR_BROKEN_PIPE\n", GetLastError());
+        SetLastError(0);
+
+        CloseHandle(hnp);
+    }
+
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
+    /* don't try to do i/o if one side couldn't be opened, as it hangs */
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len 1\n");
+
+        /* close server end without disconnecting */
+        ok(CloseHandle(hFile), "CloseHandle() failed: %08x\n", GetLastError());
+
+        todo_wine
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == 0, "got %d bytes\n", readden);
+        /* pipe is empty now */
+
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        ok(GetLastError() == ERROR_BROKEN_PIPE, "GetLastError() returned %08x, expected ERROR_BROKEN_PIPE\n", GetLastError());
+        SetLastError(0);
+
+        CloseHandle(hnp);
+    }
+}
+
 /** implementation of alarm() */
 static DWORD CALLBACK alarmThreadMain(LPVOID arg)
 {
@@ -1885,27 +2538,142 @@ static void test_overlapped(void)
     CloseHandle(thread);
 }
 
-static void test_NamedPipeHandleState(void)
+static void test_nowait(int pipemode)
 {
-    HANDLE server, client;
-    BOOL ret;
-    DWORD state, instances, maxCollectionCount, collectDataTimeout;
-    char userName[MAX_PATH];
+    HANDLE hnp;
+    HANDLE hFile;
+    static const char obuf[] = "Bit Bucket";
+    char ibuf[32];
+    DWORD written;
+    DWORD readden;
+    DWORD lpmode;
 
-    server = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
-        /* dwOpenMode */ PIPE_TYPE_BYTE | PIPE_WAIT,
-        /* nMaxInstances */ 1,
-        /* nOutBufSize */ 1024,
-        /* nInBufSize */ 1024,
-        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
-        /* lpSecurityAttrib */ NULL);
-    ok(server != INVALID_HANDLE_VALUE, "cf failed\n");
-    ret = GetNamedPipeHandleStateA(server, NULL, NULL, NULL, NULL, NULL, 0);
-    ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
-    ret = GetNamedPipeHandleStateA(server, &state, &instances, NULL, NULL, NULL,
-        0);
-    ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
-    if (ret)
+    hnp = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+                           pipemode | PIPE_NOWAIT,
+                           /* nMaxInstances */ 1,
+                           /* nOutBufSize */ 1024,
+                           /* nInBufSize */ 1024,
+                           /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+                           /* lpSecurityAttrib */ NULL);
+    ok(hnp != INVALID_HANDLE_VALUE, "CreateNamedPipe failed\n");
+
+    hFile = CreateFileA(PIPENAME, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0);
+    ok(hFile != INVALID_HANDLE_VALUE, "CreateFile failed (%d)\n", GetLastError());
+
+    /* don't try to do i/o if one side couldn't be opened, as it hangs */
+    if (hFile != INVALID_HANDLE_VALUE)
+    {
+        /* send message from client to server */
+        ok(WriteFile(hFile, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len\n");
+        ok(PeekNamedPipe(hnp, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+        ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check\n");
+
+        readden = 0xdeadbeef;
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        ok(readden == 0, "got %d bytes\n", readden);
+        ok(GetLastError() == ERROR_NO_DATA, "GetLastError() returned %08x, expected ERROR_NO_DATA\n", GetLastError());
+
+        lpmode = (pipemode & PIPE_READMODE_MESSAGE) | PIPE_NOWAIT;
+        ok(SetNamedPipeHandleState(hFile, &lpmode, NULL, NULL), "Change mode\n");
+
+        /* send message from server to client */
+        ok(WriteFile(hnp, obuf, sizeof(obuf), &written, NULL), "WriteFile\n");
+        ok(written == sizeof(obuf), "write file len\n");
+        ok(PeekNamedPipe(hFile, NULL, 0, NULL, &readden, NULL), "Peek\n");
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+
+        memset(ibuf, 0, sizeof(ibuf));
+        ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+        ok(readden == sizeof(obuf), "got %d bytes\n", readden);
+        ok(memcmp(obuf, ibuf, sizeof(obuf)) == 0, "content check\n");
+
+        readden = 0xdeadbeef;
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        ok(readden == 0, "got %d bytes\n", readden);
+        ok(GetLastError() == ERROR_NO_DATA, "GetLastError() returned %08x, expected ERROR_NO_DATA\n", GetLastError());
+
+        /* now again the bad zero byte message test */
+        ok(WriteFile(hFile, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+            ok(readden == 0, "got %d bytes\n", readden);
+        }
+        else
+        {
+            SetLastError(0xdeadbeef);
+            ok(!ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+            ok(readden == 0, "got %d bytes\n", readden);
+            ok(GetLastError() == ERROR_NO_DATA, "GetLastError() returned %08x, expected ERROR_NO_DATA\n", GetLastError());
+        }
+
+        readden = 0xdeadbeef;
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hnp, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        ok(readden == 0, "got %d bytes\n", readden);
+        ok(GetLastError() == ERROR_NO_DATA, "GetLastError() returned %08x, expected ERROR_NO_DATA\n", GetLastError());
+
+        /* and the same for the reverse direction */
+        ok(WriteFile(hnp, obuf, 0, &written, NULL), "WriteFile\n");
+        ok(written == 0, "write file len\n");
+
+        if (pipemode != PIPE_TYPE_BYTE)
+        {
+            ok(ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() failed: %08x\n", GetLastError());
+            ok(readden == 0, "got %d bytes\n", readden);
+        }
+        else
+        {
+            SetLastError(0xdeadbeef);
+            ok(!ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+            ok(readden == 0, "got %d bytes\n", readden);
+            ok(GetLastError() == ERROR_NO_DATA, "GetLastError() returned %08x, expected ERROR_NO_DATA\n", GetLastError());
+        }
+
+        readden = 0xdeadbeef;
+        SetLastError(0xdeadbeef);
+        ok(!ReadFile(hFile, ibuf, sizeof(ibuf), &readden, NULL), "ReadFile() succeeded\n");
+        ok(readden == 0, "got %d bytes\n", readden);
+        ok(GetLastError() == ERROR_NO_DATA, "GetLastError() returned %08x, expected ERROR_NO_DATA\n", GetLastError());
+
+        ok(CloseHandle(hFile), "CloseHandle\n");
+    }
+
+    ok(CloseHandle(hnp), "CloseHandle\n");
+
+}
+
+static void test_NamedPipeHandleState(void)
+{
+    HANDLE server, client;
+    BOOL ret;
+    DWORD state, instances, maxCollectionCount, collectDataTimeout;
+    char userName[MAX_PATH];
+
+    server = CreateNamedPipeA(PIPENAME, PIPE_ACCESS_DUPLEX,
+        /* dwOpenMode */ PIPE_TYPE_BYTE | PIPE_WAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 1024,
+        /* nInBufSize */ 1024,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(server != INVALID_HANDLE_VALUE, "cf failed\n");
+    ret = GetNamedPipeHandleStateA(server, NULL, NULL, NULL, NULL, NULL, 0);
+    ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
+    ret = GetNamedPipeHandleStateA(server, &state, &instances, NULL, NULL, NULL,
+        0);
+    ok(ret, "GetNamedPipeHandleState failed: %d\n", GetLastError());
+    if (ret)
     {
         ok(state == 0, "unexpected state %08x\n", state);
         ok(instances == 1, "expected 1 instances, got %d\n", instances);
@@ -1990,10 +2758,11 @@ static void test_readfileex_pending(void)
 {
     HANDLE server, client, event;
     BOOL ret;
-    DWORD err, wait, num_bytes;
+    DWORD err, wait, num_bytes, lpmode;
     OVERLAPPED overlapped;
     char read_buf[1024];
     char write_buf[1024];
+    const char long_test_string[] = "12test3456ab";
     const char test_string[] = "test";
     int i;
 
@@ -2033,6 +2802,9 @@ static void test_readfileex_pending(void)
     ret = ReadFileEx(server, read_buf, sizeof(read_buf), &overlapped, completion_routine);
     ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
     ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 0, "completion routine called before WriteFile started\n");
 
     ret = WriteFile(client, test_string, strlen(test_string), &num_bytes, NULL);
     ok(ret == TRUE, "WriteFile failed\n");
@@ -2112,7 +2884,6 @@ static void test_readfileex_pending(void)
     SetLastError(0xdeadbeef);
     ret = ReadFile(server, read_buf, 0, &num_bytes, &overlapped);
     ok(!ret, "ReadFile should fail\n");
-todo_wine
     ok(GetLastError() == ERROR_IO_PENDING, "expected ERROR_IO_PENDING, got %d\n", GetLastError());
     ok(num_bytes == 0, "bytes %u\n", num_bytes);
     ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
@@ -2128,11 +2899,9 @@ todo_wine
     ok(num_bytes == 1, "bytes %u\n", num_bytes);
 
     wait = WaitForSingleObject(event, 100);
-todo_wine
     ok(wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
 
     ok(num_bytes == 1, "bytes %u\n", num_bytes);
-todo_wine
     ok((NTSTATUS)overlapped.Internal == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %#lx\n", overlapped.Internal);
     ok(overlapped.InternalHigh == 0, "expected 0, got %lu\n", overlapped.InternalHigh);
 
@@ -2144,6 +2913,438 @@ todo_wine
 
     CloseHandle(client);
     CloseHandle(server);
+
+    /* On Windows versions > 2000 it is not possible to add PIPE_NOWAIT to a byte-mode
+     * PIPE after creating. Create a new pipe for the following tests. */
+    server = CreateNamedPipeA(PIPENAME, FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
+        /* dwOpenMode */ PIPE_TYPE_BYTE | PIPE_NOWAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 1024,
+        /* nInBufSize */ 1024,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(server != INVALID_HANDLE_VALUE, "cf failed\n");
+
+    client = CreateFileA(PIPENAME, GENERIC_READ|GENERIC_WRITE, 0, NULL,
+        OPEN_EXISTING, 0, NULL);
+    ok(client != INVALID_HANDLE_VALUE, "cf failed\n");
+
+    memset(&overlapped, 0, sizeof(overlapped));
+    overlapped.hEvent = event;
+
+    /* Initial check with empty pipe */
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, 4, &overlapped, completion_routine);
+    ok(ret == FALSE, "ReadFileEx succeded\n");
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    ok(GetLastError() == ERROR_NO_DATA, "expected ERROR_NO_DATA, got %d\n", GetLastError());
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 0, "completion routine called before writing to file\n");
+
+    /* Call ReadFileEx after writing content to the pipe */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, 4, &overlapped, completion_routine);
+    ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 1, "completion not called after writing pipe\n");
+    ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
+    ok(completion_num_bytes == 4, "ReadFileEx returned only %d bytes\n", completion_num_bytes);
+    ok(completion_lpoverlapped == &overlapped, "completion called with wrong overlapped pointer\n");
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile succeeded\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Same again, but read as a single part */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, sizeof(read_buf), &overlapped, completion_routine);
+    ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 1, "completion not called after writing pipe\n");
+    ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
+    ok(completion_num_bytes == strlen(long_test_string), "ReadFileEx returned only %d bytes\n", completion_num_bytes);
+    ok(completion_lpoverlapped == &overlapped, "completion called with wrong overlapped pointer\n");
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Check content of overlapped structure */
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, 4, &num_bytes, &overlapped);
+    ok(ret == FALSE, "ReadFile succeeded\n");
+    ok(GetLastError() == ERROR_NO_DATA, "expected ERROR_NO_DATA, got %d\n", GetLastError());
+    ok(num_bytes == 0, "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
+    todo_wine
+    ok(overlapped.InternalHigh == -1, "expected -1, got %lu\n", overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObjectEx returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
+    todo_wine
+    ok(overlapped.InternalHigh == -1, "expected -1, got %lu\n", overlapped.InternalHigh);
+
+    /* Call ReadFile after writing to the pipe */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, 4, &num_bytes, &overlapped);
+    ok(ret == TRUE, "ReadFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == 4, "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == 4, "expected 4, got %lu\n", overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == STATUS_SUCCESS, "expected STATUS_SUCCESS, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == 4, "expected 4, got %lu\n", overlapped.InternalHigh);
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile failed\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Same again, but read as a single part */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, sizeof(read_buf), &num_bytes, &overlapped);
+    ok(ret == TRUE, "ReadFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == 0, "expected 0, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == strlen(long_test_string), "expected %u, got %lu\n", (DWORD)strlen(long_test_string), overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == 0, "expected 0, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == strlen(long_test_string), "expected %u, got %lu\n", (DWORD)strlen(long_test_string), overlapped.InternalHigh);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    CloseHandle(client);
+    CloseHandle(server);
+
+    server = CreateNamedPipeA(PIPENAME, FILE_FLAG_OVERLAPPED | PIPE_ACCESS_DUPLEX,
+        /* dwOpenMode */ PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
+        /* nMaxInstances */ 1,
+        /* nOutBufSize */ 1024,
+        /* nInBufSize */ 1024,
+        /* nDefaultWait */ NMPWAIT_USE_DEFAULT_WAIT,
+        /* lpSecurityAttrib */ NULL);
+    ok(server != INVALID_HANDLE_VALUE, "cf failed\n");
+
+    client = CreateFileA(PIPENAME, GENERIC_READ|GENERIC_WRITE, 0, NULL,
+        OPEN_EXISTING, 0, NULL);
+    ok(client != INVALID_HANDLE_VALUE, "cf failed\n");
+
+    memset(&overlapped, 0, sizeof(overlapped));
+    overlapped.hEvent = event;
+
+    /* Start a call to ReadFileEx which cannot complete immediately */
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, 4, &overlapped, completion_routine);
+    ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObject returned %x\n", wait);
+    ok(completion_called == 0, "completion routine called before WriteFile started\n");
+
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret == TRUE, "WriteFile failed\n");
+    ok(num_bytes == strlen(long_test_string), "only %i bytes written\n", num_bytes);
+    ok(completion_called == 0, "completion routine called during WriteFile\n");
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+
+    ok(completion_called == 1, "completion not called after writing pipe\n");
+    ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
+    ok(completion_num_bytes == 4, "ReadFileEx returned only %d bytes\n", completion_num_bytes);
+    ok(completion_lpoverlapped == &overlapped, "completion called with wrong overlapped pointer\n");
+    ok(!memcmp(long_test_string, read_buf, 4), "ReadFileEx read wrong bytes\n");
+
+    ret = ReadFile(server, read_buf + 4, 4, &num_bytes, NULL);
+    ok(ret == FALSE, "ReadFile succeeded\n");
+    ok(num_bytes == 4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(GetLastError() == ERROR_MORE_DATA, "wrong error\n");
+    ret = ReadFile(server, read_buf + 8, sizeof(read_buf) - 8, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile failed\n");
+    ok(num_bytes == strlen(long_test_string)-8, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Call ReadFileEx when there is already some content in the pipe */
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret == TRUE, "WriteFile failed\n");
+    ok(num_bytes == strlen(long_test_string), "only %i bytes written\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, 4, &overlapped, completion_routine);
+    ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 1, "completion not called after writing pipe\n");
+    ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
+    ok(completion_num_bytes == 4, "ReadFileEx returned only %d bytes\n", completion_num_bytes);
+    ok(completion_lpoverlapped == &overlapped, "completion called with wrong overlapped pointer\n");
+    ok(!memcmp(long_test_string, read_buf, 4), "ReadFileEx read wrong bytes\n");
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile failed\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Check content of overlapped structure */
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, 4, &num_bytes, &overlapped);
+    ok(GetLastError() == ERROR_IO_PENDING, "expected ERROR_IO_PENDING, got %d\n", GetLastError());
+    ok(num_bytes == 0, "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
+    todo_wine
+    ok(overlapped.InternalHigh == -1, "expected -1, got %lu\n", overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObject returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
+
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed\n");
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_BUFFER_OVERFLOW, "expected STATUS_BUFFER_OVERFLOW, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == 4, "expected 4, got %lu\n", overlapped.InternalHigh);
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile failed\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Call ReadFile when there is already some content in the pipe */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed\n");
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, 4, &num_bytes, &overlapped);
+    ok(ret == FALSE, "ReadFile succeeded\n");
+    ok(GetLastError() == ERROR_MORE_DATA, "expected ERROR_MORE_DATA, got %d\n", GetLastError());
+    todo_wine
+    ok(num_bytes == 0, "ReadFile returned %d bytes\n", num_bytes);
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+    todo_wine
+    ok(num_bytes == 0, "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_BUFFER_OVERFLOW, "expected STATUS_BUFFER_OVERFLOW, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == 4, "expected 4, got %lu\n", overlapped.InternalHigh);
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile failed\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Tests for PIPE_NOWAIT in message mode */
+    lpmode = PIPE_READMODE_MESSAGE | PIPE_NOWAIT;
+    ok(SetNamedPipeHandleState(server, &lpmode, NULL, NULL), "Change mode\n");
+
+    /* Initial check with empty pipe */
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, 4, &overlapped, completion_routine);
+    ok(ret == FALSE, "ReadFileEx succeded\n");
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    ok(GetLastError() == ERROR_NO_DATA, "expected ERROR_NO_DATA, got %d\n", GetLastError());
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 0, "completion routine called before writing to file\n");
+
+    /* Call ReadFileEx after writing content to the pipe */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, 4, &overlapped, completion_routine);
+    ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 1, "completion not called after writing pipe\n");
+    ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
+    ok(completion_num_bytes == 4, "ReadFileEx returned only %d bytes\n", completion_num_bytes);
+    ok(completion_lpoverlapped == &overlapped, "completion called with wrong overlapped pointer\n");
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile succeeded\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Same again, but read as a single part */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    completion_called = 0;
+    ResetEvent(event);
+    ret = ReadFileEx(server, read_buf, sizeof(read_buf), &overlapped, completion_routine);
+    ok(ret == TRUE, "ReadFileEx failed, err=%i\n", GetLastError());
+    ok(completion_called == 0, "completion routine called before ReadFileEx returned\n");
+    wait = WaitForSingleObjectEx(event, 0, TRUE);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObjectEx returned %x\n", wait);
+    ok(completion_called == 1, "completion not called after writing pipe\n");
+    ok(completion_errorcode == 0, "completion called with error %x\n", completion_errorcode);
+    ok(completion_num_bytes == strlen(long_test_string), "ReadFileEx returned only %d bytes\n", completion_num_bytes);
+    ok(completion_lpoverlapped == &overlapped, "completion called with wrong overlapped pointer\n");
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Check content of overlapped structure */
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, 4, &num_bytes, &overlapped);
+    ok(ret == FALSE, "ReadFile succeeded\n");
+    ok(GetLastError() == ERROR_NO_DATA, "expected ERROR_NO_DATA, got %d\n", GetLastError());
+    ok(num_bytes == 0, "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
+    todo_wine
+    ok(overlapped.InternalHigh == -1, "expected -1, got %lu\n", overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_TIMEOUT, "WaitForSingleObjectEx returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == STATUS_PENDING, "expected STATUS_PENDING, got %#lx\n", overlapped.Internal);
+    todo_wine
+    ok(overlapped.InternalHigh == -1, "expected -1, got %lu\n", overlapped.InternalHigh);
+
+    /* Call ReadFile after writing to the pipe */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, 4, &num_bytes, &overlapped);
+    ok(ret == FALSE, "ReadFile succeeded\n");
+    ok(GetLastError() == ERROR_MORE_DATA, "expected ERROR_MORE_DATA, got %d\n", GetLastError());
+    todo_wine
+    ok(num_bytes == 0, "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == STATUS_BUFFER_OVERFLOW, "expected STATUS_BUFFER_OVERFLOW, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == 4, "expected 4, got %lu\n", overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == STATUS_BUFFER_OVERFLOW, "expected STATUS_BUFFER_OVERFLOW, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == 4, "expected 4, got %lu\n", overlapped.InternalHigh);
+
+    ret = ReadFile(server, read_buf + 4, sizeof(read_buf) - 4, &num_bytes, NULL);
+    ok(ret == TRUE, "ReadFile failed\n");
+    ok(num_bytes == strlen(long_test_string)-4, "ReadFile returned only %d bytes\n", num_bytes);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    /* Same again, but read as a single part */
+    num_bytes = 0xdeadbeef;
+    ret = WriteFile(client, long_test_string, strlen(long_test_string), &num_bytes, NULL);
+    ok(ret, "WriteFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+
+    memset(read_buf, 0, sizeof(read_buf));
+    S(U(overlapped)).Offset = 0;
+    S(U(overlapped)).OffsetHigh = 0;
+    overlapped.Internal = -1;
+    overlapped.InternalHigh = -1;
+    overlapped.hEvent = event;
+    num_bytes = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = ReadFile(server, read_buf, sizeof(read_buf), &num_bytes, &overlapped);
+    ok(ret == TRUE, "ReadFile failed, err=%i\n", GetLastError());
+    ok(num_bytes == strlen(long_test_string), "bytes %u\n", num_bytes);
+    ok((NTSTATUS)overlapped.Internal == 0, "expected 0, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == strlen(long_test_string), "expected %u, got %lu\n", (DWORD)strlen(long_test_string), overlapped.InternalHigh);
+    wait = WaitForSingleObject(event, 100);
+    ok(wait == WAIT_IO_COMPLETION || wait == WAIT_OBJECT_0, "WaitForSingleObject returned %x\n", wait);
+    ok((NTSTATUS)overlapped.Internal == 0, "expected 0, got %#lx\n", overlapped.Internal);
+    ok(overlapped.InternalHigh == strlen(long_test_string), "expected %u, got %lu\n", (DWORD)strlen(long_test_string), overlapped.InternalHigh);
+    ok(!memcmp(long_test_string, read_buf, strlen(long_test_string)), "ReadFile read wrong bytes\n");
+
+    CloseHandle(client);
+    CloseHandle(server);
     CloseHandle(event);
 }
 
@@ -2162,9 +3363,12 @@ START_TEST(pipe)
     test_NamedPipe_2();
     test_CreateNamedPipe(PIPE_TYPE_BYTE);
     test_CreateNamedPipe(PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE);
+    test_CloseNamedPipe();
     test_CreatePipe();
     test_impersonation();
     test_overlapped();
+    test_nowait(PIPE_TYPE_BYTE);
+    test_nowait(PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE);
     test_NamedPipeHandleState();
     test_readfileex_pending();
 }
diff --git a/dlls/kernel32/tests/process.c b/dlls/kernel32/tests/process.c
index c63d6b1..c325d32 100644
--- a/dlls/kernel32/tests/process.c
+++ b/dlls/kernel32/tests/process.c
@@ -57,7 +57,7 @@
           wine_dbgstr_w(expected), wine_dbgstr_w(value)); \
     } while (0)
 
-static HINSTANCE hkernel32;
+static HINSTANCE hkernel32, hntdll;
 static void   (WINAPI *pGetNativeSystemInfo)(LPSYSTEM_INFO);
 static BOOL   (WINAPI *pGetSystemRegistryQuota)(PDWORD, PDWORD);
 static BOOL   (WINAPI *pIsWow64Process)(HANDLE,PBOOL);
@@ -66,6 +66,7 @@ static BOOL   (WINAPI *pVirtualFreeEx)(HANDLE, LPVOID, SIZE_T, DWORD);
 static BOOL   (WINAPI *pQueryFullProcessImageNameA)(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize);
 static BOOL   (WINAPI *pQueryFullProcessImageNameW)(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize);
 static DWORD  (WINAPI *pK32GetProcessImageFileNameA)(HANDLE,LPSTR,DWORD);
+static struct _TEB * (WINAPI *pNtCurrentTeb)(void);
 static HANDLE (WINAPI *pCreateJobObjectW)(LPSECURITY_ATTRIBUTES sa, LPCWSTR name);
 static BOOL   (WINAPI *pAssignProcessToJobObject)(HANDLE job, HANDLE process);
 static BOOL   (WINAPI *pIsProcessInJob)(HANDLE process, HANDLE job, PBOOL result);
@@ -208,6 +209,8 @@ static BOOL init(void)
     if ((p = strrchr(exename, '/')) != NULL) exename = p + 1;
 
     hkernel32 = GetModuleHandleA("kernel32");
+    hntdll    = GetModuleHandleA("ntdll.dll");
+
     pGetNativeSystemInfo = (void *) GetProcAddress(hkernel32, "GetNativeSystemInfo");
     pGetSystemRegistryQuota = (void *) GetProcAddress(hkernel32, "GetSystemRegistryQuota");
     pIsWow64Process = (void *) GetProcAddress(hkernel32, "IsWow64Process");
@@ -216,6 +219,7 @@ static BOOL init(void)
     pQueryFullProcessImageNameA = (void *) GetProcAddress(hkernel32, "QueryFullProcessImageNameA");
     pQueryFullProcessImageNameW = (void *) GetProcAddress(hkernel32, "QueryFullProcessImageNameW");
     pK32GetProcessImageFileNameA = (void *) GetProcAddress(hkernel32, "K32GetProcessImageFileNameA");
+    pNtCurrentTeb = (void *)GetProcAddress(hntdll, "NtCurrentTeb");
     pCreateJobObjectW = (void *)GetProcAddress(hkernel32, "CreateJobObjectW");
     pAssignProcessToJobObject = (void *)GetProcAddress(hkernel32, "AssignProcessToJobObject");
     pIsProcessInJob = (void *)GetProcAddress(hkernel32, "IsProcessInJob");
@@ -291,6 +295,16 @@ static void     doChild(const char* file, const char* option)
                 siA.dwFlags, siA.wShowWindow,
                 (DWORD_PTR)siA.hStdInput, (DWORD_PTR)siA.hStdOutput, (DWORD_PTR)siA.hStdError);
 
+    if (pNtCurrentTeb)
+    {
+        RTL_USER_PROCESS_PARAMETERS *params = pNtCurrentTeb()->Peb->ProcessParameters;
+
+        /* check the console handles in the TEB */
+        childPrintf(hFile, "[TEB]\nhStdInput=%lu\nhStdOutput=%lu\nhStdError=%lu\n\n",
+                    (DWORD_PTR)params->hStdInput, (DWORD_PTR)params->hStdOutput,
+                    (DWORD_PTR)params->hStdError);
+    }
+
     /* since GetStartupInfoW is only implemented in win2k,
      * zero out before calling so we can notice the difference
      */
@@ -2435,7 +2449,6 @@ static void test_KillOnJobClose(void)
     CloseHandle(job);
 
     dwret = WaitForSingleObject(pi.hProcess, 1000);
-    todo_wine
     ok(dwret == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", dwret);
     if (dwret == WAIT_TIMEOUT) TerminateProcess(pi.hProcess, 0);
 
@@ -2642,6 +2655,43 @@ static void test_BreakawayOk(HANDLE job)
     ok(ret, "SetInformationJobObject error %u\n", GetLastError());
 }
 
+void test_StartupNoConsole(void)
+{
+#ifndef _WIN64
+    char                buffer[MAX_PATH];
+    STARTUPINFOA        startup;
+    PROCESS_INFORMATION info;
+    DWORD               code;
+
+    if (!pNtCurrentTeb)
+    {
+        win_skip( "NtCurrentTeb not supported\n" );
+        return;
+    }
+
+    memset(&startup, 0, sizeof(startup));
+    startup.cb = sizeof(startup);
+    startup.dwFlags = STARTF_USESHOWWINDOW;
+    startup.wShowWindow = SW_SHOWNORMAL;
+    get_file_name(resfile);
+    sprintf(buffer, "\"%s\" tests/process.c dump \"%s\"", selfname, resfile);
+    ok(CreateProcessA(NULL, buffer, NULL, NULL, TRUE, DETACHED_PROCESS, NULL, NULL, &startup,
+                      &info), "CreateProcess\n");
+    ok(WaitForSingleObject(info.hProcess, 30000) == WAIT_OBJECT_0, "Child process termination\n");
+    ok(GetExitCodeProcess(info.hProcess, &code), "Getting exit code\n");
+    WritePrivateProfileStringA(NULL, NULL, NULL, resfile);
+    okChildInt("StartupInfoA", "hStdInput", (UINT)INVALID_HANDLE_VALUE);
+    okChildInt("StartupInfoA", "hStdOutput", (UINT)INVALID_HANDLE_VALUE);
+    okChildInt("StartupInfoA", "hStdError", (UINT)INVALID_HANDLE_VALUE);
+    okChildInt("TEB", "hStdInput", 0);
+    okChildInt("TEB", "hStdOutput", 0);
+    okChildInt("TEB", "hStdError", 0);
+    release_memory();
+    assert(DeleteFileA(resfile) != 0);
+#endif
+
+}
+
 START_TEST(process)
 {
     HANDLE job;
@@ -2690,6 +2740,7 @@ START_TEST(process)
     test_SystemInfo();
     test_RegistryQuota();
     test_DuplicateHandle();
+    test_StartupNoConsole();
     /* things that can be tested:
      *  lookup:         check the way program to be executed is searched
      *  handles:        check the handle inheritance stuff (+sec options)
diff --git a/dlls/kernel32/tests/profile.c b/dlls/kernel32/tests/profile.c
index 2eb90a8..990aa14 100644
--- a/dlls/kernel32/tests/profile.c
+++ b/dlls/kernel32/tests/profile.c
@@ -154,9 +154,7 @@ static void test_profile_string(void)
     /* works only in unicode, ascii crashes */
     ret=GetPrivateProfileStringW(sW, emptyW, emptyW, bufW,
                                  sizeof(bufW)/sizeof(bufW[0]), TESTFILE2W);
-    todo_wine
     ok(ret == 10, "expected 10, got %u\n", ret);
-    todo_wine
     ok(!lstrcmpW(valnokeyW,bufW), "expected %s, got %s\n",
         wine_dbgstr_w(valnokeyW), wine_dbgstr_w(bufW) );
 
diff --git a/dlls/kernel32/tests/sync.c b/dlls/kernel32/tests/sync.c
index cbe0acb..668b92d 100644
--- a/dlls/kernel32/tests/sync.c
+++ b/dlls/kernel32/tests/sync.c
@@ -64,6 +64,7 @@ static void test_signalandwait(void)
     HMODULE kernel32;
     DWORD r;
     HANDLE event[2], semaphore[2], file;
+    int i;
 
     kernel32 = GetModuleHandleA("kernel32.dll");
     pSignalObjectAndWait = (void*) GetProcAddress(kernel32, "SignalObjectAndWait");
@@ -96,9 +97,13 @@ static void test_signalandwait(void)
     r = pSignalObjectAndWait(event[0], event[1], 0, FALSE);
     ok( r == WAIT_OBJECT_0, "should succeed\n");
 
-    /* event[0] is now signalled */
-    r = pSignalObjectAndWait(event[0], event[0], 0, FALSE);
-    ok( r == WAIT_OBJECT_0, "should succeed\n");
+    /* event[0] is now signalled - we repeat this test multiple times
+     * to ensure that the wineserver handles this situation properly. */
+    for (i = 0; i < 10000; i++)
+    {
+        r = pSignalObjectAndWait(event[0], event[0], 0, FALSE);
+        ok( r == WAIT_OBJECT_0, "should succeed\n");
+    }
 
     /* event[0] is not signalled */
     r = WaitForSingleObject(event[0], 0);
diff --git a/dlls/kernel32/tests/thread.c b/dlls/kernel32/tests/thread.c
index d3ecd2a..25801b2 100644
--- a/dlls/kernel32/tests/thread.c
+++ b/dlls/kernel32/tests/thread.c
@@ -1627,8 +1627,8 @@ static void test_threadpool(void)
     int workcalled = 0;
 
     if (!pCreateThreadpool) {
-        todo_wine win_skip("thread pool apis not supported.\n");
-	return;
+        win_skip("thread pool apis not supported.\n");
+        return;
     }
 
     work = pCreateThreadpoolWork(threadpool_workcallback, &workcalled, NULL);
@@ -1640,7 +1640,7 @@ static void test_threadpool(void)
     ok (workcalled == 1, "expected work to be called once, got %d\n", workcalled);
 
     pool = pCreateThreadpool(NULL);
-    todo_wine ok (pool != NULL, "CreateThreadpool failed\n");
+    ok (pool != NULL, "CreateThreadpool failed\n");
 }
 
 static void test_reserved_tls(void)
diff --git a/dlls/kernel32/tests/time.c b/dlls/kernel32/tests/time.c
index 55d4be9..63ab35a 100644
--- a/dlls/kernel32/tests/time.c
+++ b/dlls/kernel32/tests/time.c
@@ -22,9 +22,11 @@
 #include "wine/test.h"
 #include "winbase.h"
 #include "winnls.h"
+#include "winternl.h"
 
 static BOOL (WINAPI *pTzSpecificLocalTimeToSystemTime)(LPTIME_ZONE_INFORMATION, LPSYSTEMTIME, LPSYSTEMTIME);
 static BOOL (WINAPI *pSystemTimeToTzSpecificLocalTime)(LPTIME_ZONE_INFORMATION, LPSYSTEMTIME, LPSYSTEMTIME);
+static BOOL (WINAPI *pGetSystemTimes)(LPFILETIME, LPFILETIME, LPFILETIME);
 static int (WINAPI *pGetCalendarInfoA)(LCID,CALID,CALTYPE,LPSTR,int,LPDWORD);
 static int (WINAPI *pGetCalendarInfoW)(LCID,CALID,CALTYPE,LPWSTR,int,LPDWORD);
 
@@ -732,12 +734,85 @@ static void test_GetCalendarInfo(void)
     ok( ret == ret2, "got %d, expected %d\n", ret, ret2 );
 
 }
+static void test_GetSystemTimes(void)
+{
+
+    FILETIME idletime, kerneltime, usertime;
+    int i;
+    ULARGE_INTEGER ul1, ul2, ul3;
+    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi;
+    SYSTEM_BASIC_INFORMATION sbi;
+    ULONG ReturnLength;
+    double total_usertime = 0.0, total_kerneltime = 0.0, total_idletime = 0.0;
+
+    if (!pGetSystemTimes)
+    {
+        win_skip("GetSystemTimes not available\n");
+        return;
+    }
+
+    ok( pGetSystemTimes(NULL, NULL, NULL), "GetSystemTimes failed unexpectedly\n" );
+
+    memset( &idletime, 0x11, sizeof(idletime) );
+    memset( &kerneltime, 0x11, sizeof(kerneltime) );
+    memset( &usertime, 0x11, sizeof(usertime) );
+    ok( pGetSystemTimes(&idletime, &kerneltime , &usertime),
+        "GetSystemTimes failed unexpectedly\n" );
+
+    ul1.LowPart = idletime.dwLowDateTime;
+    ul1.HighPart = idletime.dwHighDateTime;
+
+    trace( "IdleTime:   %f seconds\n", (double)ul1.QuadPart/10000000.0 );
+
+    ul2.LowPart = kerneltime.dwLowDateTime;
+    ul2.HighPart = kerneltime.dwHighDateTime;
+
+    trace( "KernelTime: %f seconds\n", (double)ul2.QuadPart/10000000.0 );
+
+    ul3.LowPart = usertime.dwLowDateTime;
+    ul3.HighPart = usertime.dwHighDateTime;
+
+    trace( "UserTime:   %f seconds\n", (double)ul3.QuadPart/10000000.0 );
+
+    ok( !NtQuerySystemInformation(SystemBasicInformation, &sbi, sizeof(sbi), &ReturnLength),
+                                  "NtQuerySystemInformation failed\n" );
+    ok( sizeof(sbi) == ReturnLength, "Inconsistent length %d\n", ReturnLength );
+
+    /* Check if we have some return values */
+    trace( "Number of Processors : %d\n", sbi.NumberOfProcessors );
+    ok( sbi.NumberOfProcessors > 0, "Expected more than 0 processors, got %d\n",
+        sbi.NumberOfProcessors );
+
+    sppi = HeapAlloc( GetProcessHeap(), 0,
+                      sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * sbi.NumberOfProcessors);
+
+    ok( !NtQuerySystemInformation( SystemProcessorPerformanceInformation, sppi,
+                                   sizeof(*sppi), &ReturnLength),
+                                   "NtQuerySystemInformation failed\n" );
+
+    for (i = 0; i < sbi.NumberOfProcessors; i++)
+    {
+        total_usertime += (double)(sppi[i].UserTime.QuadPart)/10000000.0;
+        total_kerneltime += (double)(sppi[i].KernelTime.QuadPart)/10000000.0;
+        total_idletime += (double)(sppi[i].IdleTime.QuadPart)/10000000.0;
+    }
+
+    trace( "total_idletime %f total_kerneltime %f total_usertime %f \n", total_idletime,
+          total_kerneltime, total_usertime );
+
+    ok( (total_idletime - (double)ul1.QuadPart/10000000.0) < 1.0, "test idletime failed\n" );
+    ok( (total_kerneltime - (double)ul2.QuadPart/10000000.0) < 1.0, "test kerneltime failed\n" );
+    ok( (total_usertime - (double)ul3.QuadPart/10000000.0) < 1.0, "test usertime failed\n" );
+
+    HeapFree(GetProcessHeap(), 0, sppi);
+}
 
 START_TEST(time)
 {
     HMODULE hKernel = GetModuleHandleA("kernel32");
     pTzSpecificLocalTimeToSystemTime = (void *)GetProcAddress(hKernel, "TzSpecificLocalTimeToSystemTime");
     pSystemTimeToTzSpecificLocalTime = (void *)GetProcAddress( hKernel, "SystemTimeToTzSpecificLocalTime");
+    pGetSystemTimes = (void *)GetProcAddress( hKernel, "GetSystemTimes");
     pGetCalendarInfoA = (void *)GetProcAddress(hKernel, "GetCalendarInfoA");
     pGetCalendarInfoW = (void *)GetProcAddress(hKernel, "GetCalendarInfoW");
 
@@ -747,6 +822,7 @@ START_TEST(time)
     test_FileTimeToSystemTime();
     test_FileTimeToLocalFileTime();
     test_TzSpecificLocalTimeToSystemTime();
+    test_GetSystemTimes();
     test_FileTimeToDosDateTime();
     test_GetCalendarInfo();
 }
diff --git a/dlls/kernel32/tests/version.c b/dlls/kernel32/tests/version.c
index a47e52c..4d07176 100644
--- a/dlls/kernel32/tests/version.c
+++ b/dlls/kernel32/tests/version.c
@@ -353,6 +353,337 @@ static void test_VerifyVersionInfo(void)
         pVerSetConditionMask(0, VER_MINORVERSION, VER_GREATER_EQUAL));
     ok(ret || broken(!ret) /* some win2k */, "VerifyVersionInfoA failed with error %d\n", GetLastError());
 
+    /* systematically test behaviour of condition mask (tests sorted by condition mask value) */
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.dwMinorVersion++;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_MINORVERSION, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.dwMinorVersion++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_MINORVERSION, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_MINORVERSION, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_MINORVERSION, VER_AND));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.dwMinorVersion++;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_LESS_EQUAL), VER_MINORVERSION, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.dwMinorVersion++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_AND), VER_MINORVERSION, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.dwMinorVersion++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_OR), VER_MINORVERSION, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_EQUAL));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    if (servicepack)
+    {
+        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+        GetVersionExA((OSVERSIONINFOA *)&info);
+        info.dwMajorVersion++;
+        info.wServicePackMajor--;
+        ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+            pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_LESS), VER_SERVICEPACKMAJOR, VER_EQUAL));
+        ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+    }
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    ret = pVerifyVersionInfoA(&info, VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_SERVICEPACKMAJOR, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_SERVICEPACKMAJOR, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    ret = pVerifyVersionInfoA(&info, VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MINORVERSION, VER_EQUAL),
+        VER_SERVICEPACKMAJOR, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MINORVERSION, VER_EQUAL),
+        VER_SERVICEPACKMAJOR, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL),
+        VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMinor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL),
+        VER_MINORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_EQUAL), VER_SERVICEPACKMINOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    if (servicepack)
+    {
+        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+        GetVersionExA((OSVERSIONINFOA *)&info);
+        info.wServicePackMajor--;
+        SetLastError(0xdeadbeef);
+        ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+            pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_GREATER));
+        error = GetLastError();
+        ok(!ret, "VerifyVersionInfoA succeeded\n");
+        ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+           "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+        GetVersionExA((OSVERSIONINFOA *)&info);
+        info.wServicePackMajor--;
+        ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+            pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL),
+            VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_GREATER));
+        ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+        GetVersionExA((OSVERSIONINFOA *)&info);
+        info.wServicePackMajor--;
+        ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+            pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL),
+            VER_MINORVERSION, VER_LESS_EQUAL), VER_SERVICEPACKMAJOR, VER_GREATER));
+        ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+        GetVersionExA((OSVERSIONINFOA *)&info);
+        info.wServicePackMajor--;
+        ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+            pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL),
+            VER_MINORVERSION, VER_AND), VER_SERVICEPACKMAJOR, VER_GREATER));
+        ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+    }
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_LESS_EQUAL), VER_SERVICEPACKMAJOR, VER_GREATER));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    if (servicepack)
+    {
+        info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+        GetVersionExA((OSVERSIONINFOA *)&info);
+        info.wServicePackMajor--;
+        SetLastError(0xdeadbeef);
+        ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+            pVerSetConditionMask(pVerSetConditionMask(0, VER_SERVICEPACKMAJOR, VER_GREATER), VER_SERVICEPACKMINOR, VER_EQUAL));
+        error = GetLastError();
+        ok(!ret, "VerifyVersionInfoA succeeded\n");
+        ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+           "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+    }
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    ret = pVerifyVersionInfoA(&info, VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_EQUAL),
+        VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.dwMajorVersion--;
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL),
+        VER_MINORVERSION, VER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    info.wServicePackMajor++;
+    SetLastError(0xdeadbeef);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL),
+        VER_MINORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_LESS_EQUAL));
+    error = GetLastError();
+    ok(!ret, "VerifyVersionInfoA succeeded\n");
+    ok(error == ERROR_OLD_WIN_VERSION || broken(error == ERROR_BAD_ARGUMENTS) /* some win2k */,
+       "VerifyVersionInfoA should have failed with ERROR_OLD_WIN_VERSION instead of %d\n", error);
+
+    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
+    GetVersionExA((OSVERSIONINFOA *)&info);
+    ret = pVerifyVersionInfoA(&info, VER_MAJORVERSION | VER_MINORVERSION | VER_SERVICEPACKMAJOR | VER_SERVICEPACKMINOR,
+        pVerSetConditionMask(pVerSetConditionMask(0, VER_MAJORVERSION, VER_GREATER_EQUAL), VER_SERVICEPACKMAJOR, VER_AND));
+    ok(ret, "VerifyVersionInfoA failed with error %d\n", GetLastError());
+
     /* test bad dwOSVersionInfoSize */
     info.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
     GetVersionExA((OSVERSIONINFOA *)&info);
diff --git a/dlls/kernel32/tests/virtual.c b/dlls/kernel32/tests/virtual.c
index 75e91d5..9ecf753 100644
--- a/dlls/kernel32/tests/virtual.c
+++ b/dlls/kernel32/tests/virtual.c
@@ -47,9 +47,27 @@ static struct _TEB * (WINAPI *pNtCurrentTeb)(void);
 static PVOID  (WINAPI *pRtlAddVectoredExceptionHandler)(ULONG, PVECTORED_EXCEPTION_HANDLER);
 static ULONG  (WINAPI *pRtlRemoveVectoredExceptionHandler)(PVOID);
 static BOOL   (WINAPI *pGetProcessDEPPolicy)(HANDLE, LPDWORD, PBOOL);
+static NTSTATUS (WINAPI *pNtQuerySection)(HANDLE, int, PVOID, ULONG, PULONG);
 
 /* ############################### */
 
+static UINT_PTR page_mask = 0xfff;
+#define ROUND_SIZE(addr,size) \
+   (((SIZE_T)(size) + ((UINT_PTR)(addr) & page_mask) + page_mask) & ~page_mask)
+
+static PIMAGE_NT_HEADERS image_nt_header(HMODULE module)
+{
+    IMAGE_NT_HEADERS *ret = NULL;
+    IMAGE_DOS_HEADER *dos = (IMAGE_DOS_HEADER *)module;
+
+    if (dos->e_magic == IMAGE_DOS_SIGNATURE)
+    {
+        ret = (IMAGE_NT_HEADERS *)((char *)dos + dos->e_lfanew);
+        if (ret->Signature != IMAGE_NT_SIGNATURE) ret = NULL;
+    }
+    return ret;
+}
+
 static HANDLE create_target_process(const char *arg)
 {
     char **argv;
@@ -2929,11 +2947,7 @@ todo_wine
                 SetLastError(0xdeadbeef);
                 ret = VirtualQuery(base, &info, sizeof(info));
                 ok(ret, "VirtualQuery failed %d\n", GetLastError());
-                /* FIXME: remove the condition below once Wine is fixed */
-                if (td[i].prot == PAGE_WRITECOPY || td[i].prot == PAGE_EXECUTE_WRITECOPY)
-                    todo_wine ok(info.Protect == td[i].prot_after_write, "%d: got %#x != expected %#x\n", i, info.Protect, td[i].prot_after_write);
-                else
-                    ok(info.Protect == td[i].prot_after_write, "%d: got %#x != expected %#x\n", i, info.Protect, td[i].prot_after_write);
+                ok(info.Protect == td[i].prot_after_write, "%d: got %#x != expected %#x\n", i, info.Protect, td[i].prot_after_write);
             }
         }
         else
@@ -2947,11 +2961,7 @@ todo_wine
         SetLastError(0xdeadbeef);
         ret = VirtualProtect(base, si.dwPageSize, PAGE_NOACCESS, &old_prot);
         ok(ret, "%d: VirtualProtect error %d\n", i, GetLastError());
-        /* FIXME: remove the condition below once Wine is fixed */
-        if (td[i].prot == PAGE_WRITECOPY || td[i].prot == PAGE_EXECUTE_WRITECOPY)
-            todo_wine ok(old_prot == td[i].prot_after_write, "%d: got %#x != expected %#x\n", i, old_prot, td[i].prot_after_write);
-        else
-            ok(old_prot == td[i].prot_after_write, "%d: got %#x != expected %#x\n", i, old_prot, td[i].prot_after_write);
+        ok(old_prot == td[i].prot_after_write, "%d: got %#x != expected %#x\n", i, old_prot, td[i].prot_after_write);
     }
 
     UnmapViewOfFile(base);
@@ -3425,6 +3435,244 @@ static void test_shared_memory_ro(BOOL is_child, DWORD child_access)
     CloseHandle(mapping);
 }
 
+static void test_NtQuerySection(void)
+{
+    char path[MAX_PATH];
+    HANDLE file, mapping;
+    void *p;
+    NTSTATUS status;
+    union
+    {
+        SECTION_BASIC_INFORMATION basic;
+        SECTION_IMAGE_INFORMATION image;
+        char buf[1024];
+    } info;
+    IMAGE_NT_HEADERS *nt;
+    ULONG ret;
+    SIZE_T fsize, image_size;
+    SYSTEM_INFO si;
+
+    if (!pNtQuerySection)
+    {
+        win_skip("NtQuerySection is not available\n");
+        return;
+    }
+
+    GetSystemInfo(&si);
+    page_mask = si.dwPageSize - 1;
+
+    GetSystemDirectoryA(path, sizeof(path));
+    strcat(path, "\\kernel32.dll");
+
+    SetLastError(0xdeadbef);
+    file = CreateFileA(path, GENERIC_READ|GENERIC_EXECUTE, FILE_SHARE_READ|FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, 0);
+    ok(file != INVALID_HANDLE_VALUE, "CreateFile error %u\n", GetLastError());
+
+    fsize = GetFileSize(file, NULL);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_EXECUTE_READ, 0, 0, NULL);
+    /* NT4 and win2k don't support EXEC on file mappings */
+    if (!mapping)
+        mapping = CreateFileMappingA(file, NULL, PAGE_READONLY, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %u\n", GetLastError());
+
+    status = pNtQuerySection(mapping, SectionBasicInformation, NULL, sizeof(info), &ret);
+    ok(status == STATUS_ACCESS_VIOLATION, "expected STATUS_ACCESS_VIOLATION, got %#x\n", status);
+
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, 0, NULL);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status);
+
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, 0, &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+todo_wine
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#x\n", info.basic.Attributes);
+todo_wine
+    ok(info.basic.Size.QuadPart == fsize, "expected %#lx, got %#x/%08x\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info.basic), &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SECTION_NOT_IMAGE, "expected STATUS_SECTION_NOT_IMAGE, got %#x\n", status);
+
+    SetLastError(0xdeadbef);
+    p = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
+    ok(p != NULL, "MapViewOfFile error %u\n", GetLastError());
+
+    nt = image_nt_header(p);
+    image_size = ROUND_SIZE(p, nt->OptionalHeader.SizeOfImage);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+todo_wine
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#x\n", info.basic.Attributes);
+todo_wine
+    ok(info.basic.Size.QuadPart == fsize, "expected %#lx, got %#x/%08x\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    UnmapViewOfFile(p);
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_EXECUTE_READ|SEC_IMAGE, 0, 0, NULL);
+    /* NT4 and win2k don't support EXEC on file mappings */
+    if (!mapping)
+        mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_IMAGE, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %u\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+todo_wine
+    ok(info.basic.Attributes == (SEC_FILE|SEC_IMAGE), "expected SEC_FILE|SEC_IMAGE, got %#x\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == image_size, "expected %#lx, got %#x/%08x\n", image_size, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, NULL, sizeof(info), &ret);
+    ok(status == STATUS_ACCESS_VIOLATION, "expected STATUS_ACCESS_VIOLATION, got %#x\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, 0, NULL);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, 0, &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status);
+
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info.basic), &ret);
+    ok(status == STATUS_INFO_LENGTH_MISMATCH, "expected STATUS_INFO_LENGTH_MISMATCH, got %#x\n", status);
+
+    SetLastError(0xdeadbef);
+    p = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
+    ok(p != NULL, "MapViewOfFile error %u\n", GetLastError());
+
+    nt = image_nt_header(p);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionImageInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.image), "wrong returned size %u\n", ret);
+    ok((ULONG_PTR)info.image.TransferAddress == nt->OptionalHeader.ImageBase + nt->OptionalHeader.AddressOfEntryPoint,
+       "expected %#lx, got %p\n", (SIZE_T)(nt->OptionalHeader.ImageBase + nt->OptionalHeader.AddressOfEntryPoint), info.image.TransferAddress);
+    ok(info.image.ZeroBits == 0, "expected 0, got %#x\n", info.image.ZeroBits);
+todo_wine
+    ok(info.image.MaximumStackSize == nt->OptionalHeader.SizeOfStackReserve, "expected %#lx, got %#lx\n", (SIZE_T)nt->OptionalHeader.SizeOfStackReserve, info.image.MaximumStackSize);
+todo_wine
+    ok(info.image.CommittedStackSize == nt->OptionalHeader.SizeOfStackCommit, "expected %#lx, got %#lx\n", (SIZE_T)nt->OptionalHeader.SizeOfStackCommit, info.image.CommittedStackSize);
+    ok(info.image.SubSystemType == nt->OptionalHeader.Subsystem, "expected %#x, got %#x\n", nt->OptionalHeader.Subsystem, info.image.SubSystemType);
+    ok(info.image.SubsystemVersionLow == nt->OptionalHeader.MinorSubsystemVersion, "expected %#x, got %#x\n", nt->OptionalHeader.MinorSubsystemVersion, info.image.SubsystemVersionLow);
+    ok(info.image.SubsystemVersionHigh == nt->OptionalHeader.MajorSubsystemVersion, "expected %#x, got %#x\n", nt->OptionalHeader.MajorSubsystemVersion, info.image.SubsystemVersionHigh);
+    ok(info.image.ImageCharacteristics == nt->FileHeader.Characteristics, "expected %#x, got %#x\n", nt->FileHeader.Characteristics, info.image.ImageCharacteristics);
+    ok(info.image.DllCharacteristics == nt->OptionalHeader.DllCharacteristics, "expected %#x, got %#x\n", nt->OptionalHeader.DllCharacteristics, info.image.DllCharacteristics);
+    ok(info.image.Machine == nt->FileHeader.Machine, "expected %#x, got %#x\n", nt->FileHeader.Machine, info.image.Machine);
+    ok(info.image.ImageContainsCode == TRUE, "expected 1, got %#x\n", info.image.ImageContainsCode);
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+todo_wine
+    ok(info.basic.Attributes == (SEC_FILE|SEC_IMAGE), "expected SEC_FILE|SEC_IMAGE, got %#x\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == image_size, "expected %#lx, got %#x/%08x\n", image_size, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    UnmapViewOfFile(p);
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_COMMIT|SEC_NOCACHE, 0, 0, NULL);
+    ok(mapping != 0, "CreateFileMapping error %u\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+todo_wine
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#x\n", info.basic.Attributes);
+todo_wine
+    ok(info.basic.Size.QuadPart == fsize, "expected %#lx, got %#x/%08x\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(file, NULL, PAGE_READONLY|SEC_RESERVE, 0, 0, NULL);
+todo_wine
+    ok(mapping != 0, "CreateFileMapping error %u\n", GetLastError());
+    if (!mapping) goto skip1;
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_FILE, "expected SEC_FILE, got %#x\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == fsize, "expected %#lx, got %#x/%08x\n", fsize, info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    CloseHandle(mapping);
+skip1:
+    CloseHandle(file);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE|SEC_COMMIT, 0, 4096, NULL);
+    ok(mapping != 0, "CreateFileMapping error %u\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_COMMIT, "expected SEC_COMMIT, got %#x\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == 4096, "expected 4096, got %#x/%08x\n", info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    SetLastError(0xdeadbef);
+    p = MapViewOfFile(mapping, FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, 0);
+    ok(p != NULL, "MapViewOfFile error %u\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_COMMIT, "expected SEC_COMMIT, got %#x\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == 4096, "expected 4096, got %#x/%08x\n", info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    UnmapViewOfFile(p);
+    CloseHandle(mapping);
+
+    SetLastError(0xdeadbef);
+    mapping = CreateFileMappingA(INVALID_HANDLE_VALUE, NULL, PAGE_READONLY|SEC_RESERVE, 0, 4096, NULL);
+    ok(mapping != 0, "CreateFileMapping error %u\n", GetLastError());
+
+    memset(&info, 0x55, sizeof(info));
+    ret = 0xdeadbeef;
+    status = pNtQuerySection(mapping, SectionBasicInformation, &info, sizeof(info), &ret);
+    ok(status == STATUS_SUCCESS, "NtQuerySection error %#x\n", status);
+    ok(ret == sizeof(info.basic), "wrong returned size %u\n", ret);
+    ok(info.basic.BaseAddress == NULL, "expected NULL, got %p\n", info.basic.BaseAddress);
+    ok(info.basic.Attributes == SEC_RESERVE, "expected SEC_RESERVE, got %#x\n", info.basic.Attributes);
+    ok(info.basic.Size.QuadPart == 4096, "expected 4096, got %#x/%08x\n", info.basic.Size.HighPart, info.basic.Size.LowPart);
+
+    CloseHandle(mapping);
+}
+
 START_TEST(virtual)
 {
     int argc;
@@ -3477,12 +3725,14 @@ START_TEST(virtual)
     pNtCurrentTeb = (void *)GetProcAddress( hntdll, "NtCurrentTeb" );
     pRtlAddVectoredExceptionHandler = (void *)GetProcAddress( hntdll, "RtlAddVectoredExceptionHandler" );
     pRtlRemoveVectoredExceptionHandler = (void *)GetProcAddress( hntdll, "RtlRemoveVectoredExceptionHandler" );
+    pNtQuerySection = (void *)GetProcAddress( hntdll, "NtQuerySection" );
 
     test_shared_memory(FALSE);
     test_shared_memory_ro(FALSE, FILE_MAP_READ|FILE_MAP_WRITE);
     test_shared_memory_ro(FALSE, FILE_MAP_COPY);
     test_shared_memory_ro(FALSE, FILE_MAP_COPY|FILE_MAP_WRITE);
     test_mapping();
+    test_NtQuerySection();
     test_CreateFileMapping_protection();
     test_VirtualAlloc_protection();
     test_VirtualProtect();
diff --git a/dlls/kernel32/tests/volume.c b/dlls/kernel32/tests/volume.c
index e934dee..38a2430 100644
--- a/dlls/kernel32/tests/volume.c
+++ b/dlls/kernel32/tests/volume.c
@@ -54,6 +54,7 @@ static UINT (WINAPI *pGetLogicalDriveStringsA)(UINT,LPSTR);
 static UINT (WINAPI *pGetLogicalDriveStringsW)(UINT,LPWSTR);
 static BOOL (WINAPI *pGetVolumeInformationA)(LPCSTR, LPSTR, DWORD, LPDWORD, LPDWORD, LPDWORD, LPSTR, DWORD);
 static BOOL (WINAPI *pGetVolumePathNameA)(LPCSTR, LPSTR, DWORD);
+static BOOL (WINAPI *pGetVolumePathNameW)(LPWSTR, LPWSTR, DWORD);
 static BOOL (WINAPI *pGetVolumePathNamesForVolumeNameA)(LPCSTR, LPSTR, DWORD, LPDWORD);
 static BOOL (WINAPI *pGetVolumePathNamesForVolumeNameW)(LPCWSTR, LPWSTR, DWORD, LPDWORD);
 
@@ -591,82 +592,266 @@ static void test_disk_extents(void)
 
 static void test_GetVolumePathNameA(void)
 {
-    BOOL ret;
-    char volume[MAX_PATH];
-    char expected[] = "C:\\", pathC1[] = "C:\\", pathC2[] = "C::";
+    char volume_path[MAX_PATH];
+    struct {
+        const char *file_name;
+        const char *path_name;
+        DWORD       path_len;
+        DWORD       error;
+        DWORD       broken_error;
+    } test_paths[] = {
+        { /* test 0: NULL parameters, 0 output length */
+            NULL, NULL, 0,
+            ERROR_INVALID_PARAMETER, 0xdeadbeef /* XP */
+        },
+        { /* test 1: empty input, NULL output, 0 output length */
+            "", NULL, 0,
+            ERROR_INVALID_PARAMETER, 0xdeadbeef /* XP */
+        },
+        { /* test 2: valid input, NULL output, 0 output length */
+            "C:\\", NULL, 0,
+            ERROR_INVALID_PARAMETER, ERROR_FILENAME_EXCED_RANGE /* XP */
+        },
+        { /* test 3: valid input, valid output, 0 output length */
+            "C:\\", "C:\\", 0,
+            ERROR_INVALID_PARAMETER, ERROR_FILENAME_EXCED_RANGE /* XP */
+        },
+        { /* test 4: valid input, valid output, 1 output length */
+            "C:\\", "C:\\", 1,
+            ERROR_FILENAME_EXCED_RANGE, NO_ERROR
+        },
+        { /* test 5: valid input, valid output, valid output length */
+            "C:\\", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 6: lowercase input, uppercase output, valid output length */
+            "c:\\", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 7: poor quality input, valid output, valid output length */
+            "C::", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 8: really bogus input, valid output, 1 output length */
+            "\\\\$$$", "C:\\", 1,
+            ERROR_INVALID_NAME, ERROR_FILENAME_EXCED_RANGE
+        },
+        { /* test 9: a reasonable DOS path that is guaranteed to exist */
+            "C:\\windows\\system32", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 10: a reasonable DOS path that shouldn't exist */
+            "C:\\windows\\system32\\AnInvalidFolder", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 11: an unreasonable DOS path */
+            "InvalidDrive:\\AnInvalidFolder", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR /* FIXME: depends on system dir */
+        },
+        { /* test 12: a reasonable NT-converted DOS path that shouldn't exist */
+            "\\\\?\\C:\\AnInvalidFolder", "\\\\?\\C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 13: an unreasonable NT-converted DOS path */
+            "\\\\?\\InvalidDrive:\\AnInvalidFolder", "", sizeof(volume_path),
+            ERROR_INVALID_NAME, NO_ERROR
+        },
+        { /* test 14: an unreasonable NT volume path */
+            "\\\\?\\Volume{00000000-00-0000-0000-000000000000}\\AnInvalidFolder", "", sizeof(volume_path),
+            ERROR_INVALID_NAME, NO_ERROR
+        },
+        { /* test 15: an unreasonable NT-ish path */
+            "\\\\ReallyBogus\\InvalidDrive:\\AnInvalidFolder", "", sizeof(volume_path),
+            ERROR_INVALID_NAME, NO_ERROR
+        },
+        { /* test 16 */
+            "C:", "C:", 2,
+            ERROR_FILENAME_EXCED_RANGE, NO_ERROR
+        },
+        { /* test 17 */
+            "C:", "C:", 3,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 18 */
+            "C:\\", "C:", 2,
+            ERROR_FILENAME_EXCED_RANGE, NO_ERROR
+        },
+        { /* test 19 */
+            "C:\\", "C:", 3,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 20 */
+            "C::", "C:", 2,
+            ERROR_FILENAME_EXCED_RANGE, NO_ERROR
+        },
+        { /* test 21 */
+            "C::", "C:", 3,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 22 */
+            "C::", "C:\\", 4,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 23 */
+            "C:\\windows\\system32\\AnInvalidFolder", "C:", 3,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 24 */
+            "\\\\?\\C:\\AnInvalidFolder", "\\\\?\\C:", 3,
+            ERROR_FILENAME_EXCED_RANGE, NO_ERROR
+        },
+        { /* test 25 */
+            "\\\\?\\C:\\AnInvalidFolder", "\\\\?\\C:", 6,
+            ERROR_FILENAME_EXCED_RANGE, NO_ERROR
+        },
+        { /* test 26 */
+            "\\\\?\\C:\\AnInvalidFolder", "\\\\?\\C:", 7,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 27 */
+            "\\\\?\\c:\\AnInvalidFolder", "\\\\?\\c:", 7,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 28 */
+            "C:/", "C:\\", 4,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 29 */
+            "E:/", "", 4,
+            ERROR_FILE_NOT_FOUND, NO_ERROR
+        },
+        { /* test 30 */
+            "M::", "C:\\", 4,
+            ERROR_FILE_NOT_FOUND, NO_ERROR
+        },
+        { /* test 31 */
+            "C:ABC:DEF:\\AnInvalidFolder", "C:\\", 4,
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 32 */
+            "?:ABC:DEF:\\AnInvalidFolder", "", sizeof(volume_path),
+            ERROR_FILE_NOT_FOUND, NO_ERROR
+        },
+        { /* test 33 */
+            "relative/path", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR /* FIXME: depends on system dir */
+        },
+        { /* test 34 */
+            "/unix-style/absolute/path", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR /* FIXME: depends on system dir */
+        },
+        { /* test 35 */
+            "\\??\\ReallyBogus", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR /* FIXME: depends on system dir */
+        },
+        { /* test 36 */
+            "\\??\\C:\\NonExistent", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR /* FIXME: depends on system dir */
+        },
+        { /* test 37 */
+            "\\??\\M:\\NonExistent", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR /* FIXME: depends on system dir */
+        },
+        { /* test 38 */
+            "somefile:def", "C:\\", sizeof(volume_path),
+            NO_ERROR, NO_ERROR
+        },
+        { /* test 39 */
+            "s:omefile", "", sizeof(volume_path),
+            ERROR_FILE_NOT_FOUND, NO_ERROR
+        },
+
+    };
+    BOOL ret, success;
     DWORD error;
+    UINT i;
 
+    /* GetVolumePathNameA is not present before w2k */
     if (!pGetVolumePathNameA)
     {
         win_skip("required functions not found\n");
         return;
     }
 
-    SetLastError( 0xdeadbeef );
-    ret = pGetVolumePathNameA(NULL, NULL, 0);
-    error = GetLastError();
-    ok(!ret, "expected failure\n");
-    ok(error == ERROR_INVALID_PARAMETER
-       || broken( error == 0xdeadbeef) /* <=XP */,
-       "expected ERROR_INVALID_PARAMETER got %u\n", error);
+    for(i=0; i<sizeof(test_paths)/sizeof(test_paths[0]); i++)
+    {
+        char *output = (test_paths[i].path_name != NULL ? volume_path : NULL);
+        BOOL expected_ret = test_paths[i].error == NO_ERROR ? TRUE : FALSE;
 
-    SetLastError( 0xdeadbeef );
-    ret = pGetVolumePathNameA("", NULL, 0);
-    error = GetLastError();
-    ok(!ret, "expected failure\n");
-    ok(error == ERROR_INVALID_PARAMETER
-       || broken( error == 0xdeadbeef) /* <=XP */,
-       "expected ERROR_INVALID_PARAMETER got %u\n", error);
+        volume_path[0] = 0;
+        if (test_paths[i].path_len < sizeof(volume_path))
+            volume_path[ test_paths[i].path_len ] = 0x11;
 
-    SetLastError( 0xdeadbeef );
-    ret = pGetVolumePathNameA(pathC1, NULL, 0);
-    error = GetLastError();
-    ok(!ret, "expected failure\n");
-    ok(error == ERROR_INVALID_PARAMETER
-       || broken(error == ERROR_FILENAME_EXCED_RANGE) /* <=XP */,
-       "expected ERROR_INVALID_PARAMETER got %u\n", error);
+        SetLastError( 0xdeadbeef );
+        ret = pGetVolumePathNameA( test_paths[i].file_name, output, test_paths[i].path_len );
+        error = GetLastError();
+        ok(ret == expected_ret, "GetVolumePathName test %d %s unexpectedly.\n",
+                                i, test_paths[i].error == NO_ERROR ? "failed" : "succeeded");
 
-    SetLastError( 0xdeadbeef );
-    ret = pGetVolumePathNameA(pathC1, volume, 0);
-    error = GetLastError();
-    ok(!ret, "expected failure\n");
-    ok(error == ERROR_INVALID_PARAMETER
-       || broken(error == ERROR_FILENAME_EXCED_RANGE ) /* <=XP */,
-       "expected ERROR_INVALID_PARAMETER got %u\n", error);
+        if (ret)
+        {
+            /* If we succeeded then make sure the path is correct */
+            success = (strcmp( volume_path, test_paths[i].path_name ) == 0)
+                      || broken(strcasecmp( volume_path, test_paths[i].path_name ) == 0) /* XP */;
+            ok(success, "GetVolumePathName test %d unexpectedly returned path %s (expected %s).\n",
+                        i, volume_path, test_paths[i].path_name);
+        }
+        else
+        {
+            /* On success Windows always returns ERROR_MORE_DATA, so only worry about failure */
+            success = (error == test_paths[i].error || broken(error == test_paths[i].broken_error));
+            ok(success, "GetVolumePathName test %d unexpectedly returned error 0x%x (expected 0x%x).\n",
+                        i, error, test_paths[i].error);
+        }
 
-    SetLastError( 0xdeadbeef );
-    ret = pGetVolumePathNameA(pathC1, volume, 1);
-    error = GetLastError();
-    ok(!ret, "expected failure\n");
-    ok(error == ERROR_FILENAME_EXCED_RANGE, "expected ERROR_FILENAME_EXCED_RANGE got %u\n", error);
-
-    volume[0] = '\0';
-    ret = pGetVolumePathNameA(pathC1, volume, sizeof(volume));
-    ok(ret, "expected success\n");
-    ok(!strcmp(expected, volume), "expected name '%s', returned '%s'\n", pathC1, volume);
-
-    pathC1[0] = tolower(pathC1[0]);
-    volume[0] = '\0';
-    ret = pGetVolumePathNameA(pathC1, volume, sizeof(volume));
-    ok(ret, "expected success\n");
-todo_wine
-    ok(!strcmp(expected, volume) || broken(!strcasecmp(expected, volume)) /* <=XP */,
-       "expected name '%s', returned '%s'\n", expected, volume);
-
-    volume[0] = '\0';
-    ret = pGetVolumePathNameA(pathC2, volume, sizeof(volume));
-todo_wine
-    ok(ret, "expected success\n");
-todo_wine
-    ok(!strcmp(expected, volume), "expected name '%s', returned '%s'\n", expected, volume);
-
-    /* test an invalid path */
-    SetLastError( 0xdeadbeef );
-    ret = pGetVolumePathNameA("\\\\$$$", volume, 1);
-    error = GetLastError();
-    ok(!ret, "expected failure\n");
-    ok(error == ERROR_INVALID_NAME || broken(ERROR_FILENAME_EXCED_RANGE) /* <=2000 */,
-       "expected ERROR_INVALID_NAME got %u\n", error);
+        if (test_paths[i].path_len < sizeof(volume_path))
+            ok(volume_path[ test_paths[i].path_len ] == 0x11,
+               "GetVolumePathName test %d corrupted byte after end of buffer.\n", i);
+    }
+}
+
+static void test_GetVolumePathNameW(void)
+{
+    static WCHAR drive_c1[] = {'C',':',0};
+    static WCHAR drive_c2[] = {'C',':','\\',0};
+    WCHAR volume_path[MAX_PATH];
+    BOOL ret;
+
+    if (!pGetVolumePathNameW)
+    {
+        win_skip("required functions not found\n");
+        return;
+    }
+
+    volume_path[0] = 0;
+    volume_path[1] = 0x11;
+    ret = pGetVolumePathNameW( drive_c1, volume_path, 1 );
+    ok(!ret, "GetVolumePathNameW test succeeded unexpectedly.\n");
+    ok(GetLastError() == ERROR_FILENAME_EXCED_RANGE, "GetVolumePathNameW unexpectedly returned error 0x%x (expected 0x%x).\n",
+        GetLastError(), ERROR_FILENAME_EXCED_RANGE);
+    ok(volume_path[1] == 0x11, "GetVolumePathW corrupted byte after end of buffer.\n");
+
+    volume_path[0] = 0;
+    volume_path[2] = 0x11;
+    ret = pGetVolumePathNameW( drive_c1, volume_path, 2 );
+    ok(!ret, "GetVolumePathNameW test succeeded unexpectedly.\n");
+    ok(GetLastError() == ERROR_FILENAME_EXCED_RANGE, "GetVolumePathNameW unexpectedly returned error 0x%x (expected 0x%x).\n",
+        GetLastError(), ERROR_FILENAME_EXCED_RANGE);
+    ok(volume_path[2] == 0x11, "GetVolumePathW corrupted byte after end of buffer.\n");
+
+    volume_path[0] = 0;
+    volume_path[3] = 0x11;
+    ret = pGetVolumePathNameW( drive_c1, volume_path, 3 );
+    ok(ret, "GetVolumePathNameW test failed unexpectedly.\n");
+    ok(memcmp(volume_path, drive_c1, sizeof(drive_c1)) == 0, "GetVolumePathNameW unexpectedly returned wrong path.\n");
+    ok(volume_path[3] == 0x11, "GetVolumePathW corrupted byte after end of buffer.\n");
+
+    volume_path[0] = 0;
+    volume_path[4] = 0x11;
+    ret = pGetVolumePathNameW( drive_c1, volume_path, 4 );
+    ok(ret, "GetVolumePathNameW test failed unexpectedly.\n");
+    ok(memcmp(volume_path, drive_c2, sizeof(drive_c2)) == 0, "GetVolumePathNameW unexpectedly returned wrong path.\n");
+    ok(volume_path[4] == 0x11, "GetVolumePathW corrupted byte after end of buffer.\n");
 }
 
 static void test_GetVolumePathNamesForVolumeNameA(void)
@@ -1008,6 +1193,7 @@ START_TEST(volume)
     pGetLogicalDriveStringsW = (void *) GetProcAddress(hdll, "GetLogicalDriveStringsW");
     pGetVolumeInformationA = (void *) GetProcAddress(hdll, "GetVolumeInformationA");
     pGetVolumePathNameA = (void *) GetProcAddress(hdll, "GetVolumePathNameA");
+    pGetVolumePathNameW = (void *) GetProcAddress(hdll, "GetVolumePathNameW");
     pGetVolumePathNamesForVolumeNameA = (void *) GetProcAddress(hdll, "GetVolumePathNamesForVolumeNameA");
     pGetVolumePathNamesForVolumeNameW = (void *) GetProcAddress(hdll, "GetVolumePathNamesForVolumeNameW");
 
@@ -1015,6 +1201,7 @@ START_TEST(volume)
     test_define_dos_deviceA();
     test_FindFirstVolume();
     test_GetVolumePathNameA();
+    test_GetVolumePathNameW();
     test_GetVolumeNameForVolumeMountPointA();
     test_GetVolumeNameForVolumeMountPointW();
     test_GetLogicalDriveStringsA();
diff --git a/dlls/kernel32/thread.c b/dlls/kernel32/thread.c
index 3dabf94..89b0b60 100644
--- a/dlls/kernel32/thread.c
+++ b/dlls/kernel32/thread.c
@@ -860,3 +860,147 @@ BOOL WINAPI GetThreadPreferredUILanguages( DWORD flags, PULONG count, PCZZWSTR b
     *buffersize = 0;
     return TRUE;
 }
+
+/***********************************************************************
+ *              CreateThreadpool (KERNEL32.@)
+ */
+PTP_POOL WINAPI CreateThreadpool( PVOID reserved )
+{
+    TP_POOL *pool;
+    NTSTATUS status;
+
+    TRACE( "%p\n", reserved );
+
+    status = TpAllocPool( &pool, reserved );
+    if (status)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        return NULL;
+    }
+
+    return pool;
+}
+
+/***********************************************************************
+ *              CreateThreadpoolCleanupGroup (KERNEL32.@)
+ */
+PTP_CLEANUP_GROUP WINAPI CreateThreadpoolCleanupGroup( void )
+{
+    TP_CLEANUP_GROUP *group;
+    NTSTATUS status;
+
+    TRACE( "\n" );
+
+    status = TpAllocCleanupGroup( &group );
+    if (status)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        return NULL;
+    }
+
+    return group;
+}
+
+/***********************************************************************
+ *              CreateThreadpoolTimer (KERNEL32.@)
+ */
+PTP_TIMER WINAPI CreateThreadpoolTimer( PTP_TIMER_CALLBACK callback, PVOID userdata,
+                                        TP_CALLBACK_ENVIRON *environment )
+{
+    TP_TIMER *timer;
+    NTSTATUS status;
+
+    TRACE( "%p, %p, %p\n", callback, userdata, environment );
+
+    status = TpAllocTimer( &timer, callback, userdata, environment );
+    if (status)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        return NULL;
+    }
+
+    return timer;
+}
+
+/***********************************************************************
+ *              CreateThreadpoolWait (KERNEL32.@)
+ */
+PTP_WAIT WINAPI CreateThreadpoolWait( PTP_WAIT_CALLBACK callback, PVOID userdata,
+                                      TP_CALLBACK_ENVIRON *environment )
+{
+    TP_WAIT *wait;
+    NTSTATUS status;
+
+    TRACE( "%p, %p, %p\n", callback, userdata, environment );
+
+    status = TpAllocWait( &wait, callback, userdata, environment );
+    if (status)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        return NULL;
+    }
+
+    return wait;
+}
+
+/***********************************************************************
+ *              CreateThreadpoolWork (KERNEL32.@)
+ */
+PTP_WORK WINAPI CreateThreadpoolWork( PTP_WORK_CALLBACK callback, PVOID userdata,
+                                      TP_CALLBACK_ENVIRON *environment )
+{
+    TP_WORK *work;
+    NTSTATUS status;
+
+    TRACE( "%p, %p, %p\n", callback, userdata, environment );
+
+    status = TpAllocWork( &work, callback, userdata, environment );
+    if (status)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        return NULL;
+    }
+
+    return work;
+}
+
+/***********************************************************************
+ *              SetThreadpoolTimer (KERNEL32.@)
+ */
+VOID WINAPI SetThreadpoolTimer( TP_TIMER *timer, FILETIME *due_time,
+                                DWORD period, DWORD window_length )
+{
+    LARGE_INTEGER timeout;
+
+    TRACE( "%p, %p, %u, %u\n", timer, due_time, period, window_length );
+
+    if (due_time)
+    {
+        timeout.u.LowPart = due_time->dwLowDateTime;
+        timeout.u.HighPart = due_time->dwHighDateTime;
+    }
+
+    TpSetTimer( timer, due_time ? &timeout : NULL, period, window_length );
+}
+
+/***********************************************************************
+ *              SetThreadpoolWait (KERNEL32.@)
+ */
+VOID WINAPI SetThreadpoolWait( TP_WAIT *wait, HANDLE handle, FILETIME *due_time )
+{
+    LARGE_INTEGER timeout;
+
+    TRACE( "%p, %p, %p\n", wait, handle, due_time );
+
+    if (!handle)
+    {
+        due_time = NULL;
+    }
+    else if (due_time)
+    {
+        timeout.u.LowPart = due_time->dwLowDateTime;
+        timeout.u.HighPart = due_time->dwHighDateTime;
+    }
+
+    TpSetWait( wait, handle, due_time ? &timeout : NULL );
+}
diff --git a/dlls/kernel32/time.c b/dlls/kernel32/time.c
index 8214686..ef998f83 100644
--- a/dlls/kernel32/time.c
+++ b/dlls/kernel32/time.c
@@ -1089,9 +1089,67 @@ BOOL WINAPI FileTimeToDosDateTime( const FILETIME *ft, LPWORD fatdate,
  */
 BOOL WINAPI GetSystemTimes(LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime)
 {
-    FIXME("(%p,%p,%p): Stub!\n", lpIdleTime, lpKernelTime, lpUserTime);
+    LARGE_INTEGER idle_time, kernel_time, user_time;
+    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION *sppi;
+    SYSTEM_BASIC_INFORMATION sbi;
+    NTSTATUS status;
+    ULONG ret_size;
+    int i;
 
-    return FALSE;
+    TRACE("(%p,%p,%p)\n", lpIdleTime, lpKernelTime, lpUserTime);
+
+    status = NtQuerySystemInformation( SystemBasicInformation, &sbi, sizeof(sbi), &ret_size );
+    if (status != STATUS_SUCCESS)
+    {
+        SetLastError( RtlNtStatusToDosError(status) );
+        return FALSE;
+    }
+
+    sppi = HeapAlloc( GetProcessHeap(), 0,
+                      sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * sbi.NumberOfProcessors);
+    if (!sppi)
+    {
+        SetLastError( ERROR_OUTOFMEMORY );
+        return FALSE;
+    }
+
+    status = NtQuerySystemInformation( SystemProcessorPerformanceInformation, sppi, sizeof(*sppi) * sbi.NumberOfProcessors,
+                                       &ret_size );
+    if (status != STATUS_SUCCESS)
+    {
+        HeapFree( GetProcessHeap(), 0, sppi );
+        SetLastError( RtlNtStatusToDosError(status) );
+        return FALSE;
+    }
+
+    idle_time.QuadPart = 0;
+    kernel_time.QuadPart = 0;
+    user_time.QuadPart = 0;
+    for (i = 0; i < sbi.NumberOfProcessors; i++)
+    {
+        idle_time.QuadPart += sppi[i].IdleTime.QuadPart;
+        kernel_time.QuadPart += sppi[i].KernelTime.QuadPart;
+        user_time.QuadPart += sppi[i].UserTime.QuadPart;
+    }
+
+    if (lpIdleTime)
+    {
+        lpIdleTime->dwLowDateTime = idle_time.u.LowPart;
+        lpIdleTime->dwHighDateTime = idle_time.u.HighPart;
+    }
+    if (lpKernelTime)
+    {
+        lpKernelTime->dwLowDateTime = kernel_time.u.LowPart;
+        lpKernelTime->dwHighDateTime = kernel_time.u.HighPart;
+    }
+    if (lpUserTime)
+    {
+        lpUserTime->dwLowDateTime = user_time.u.LowPart;
+        lpUserTime->dwHighDateTime = user_time.u.HighPart;
+    }
+
+    HeapFree( GetProcessHeap(), 0, sppi );
+    return TRUE;
 }
 
 /***********************************************************************
diff --git a/dlls/kernel32/volume.c b/dlls/kernel32/volume.c
index 59eda44..2d30884 100644
--- a/dlls/kernel32/volume.c
+++ b/dlls/kernel32/volume.c
@@ -854,7 +854,8 @@ fill_fs_info:  /* now fill in the information that depends on the file system ty
     default:
         if (fsname) lstrcpynW( fsname, ntfsW, fsname_len );
         if (filename_len) *filename_len = 255;
-        if (flags) *flags = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS;
+        if (flags) *flags = FILE_CASE_PRESERVED_NAMES | FILE_PERSISTENT_ACLS
+                            | FILE_SUPPORTS_REPARSE_POINTS;
         break;
     }
     ret = TRUE;
@@ -1610,7 +1611,15 @@ UINT WINAPI GetDriveTypeW(LPCWSTR root) /* [in] String describing drive */
     HANDLE handle;
     UINT ret;
 
-    if (!open_device_root( root, &handle )) return DRIVE_NO_ROOT_DIR;
+    if (!open_device_root( root, &handle ))
+    {
+        /* CD ROM devices do not necessarily have a volume, but a drive type */
+        ret = get_mountmgr_drive_type( root );
+        if (ret == DRIVE_CDROM || ret == DRIVE_REMOVABLE)
+            return ret;
+
+        return DRIVE_NO_ROOT_DIR;
+    }
 
     status = NtQueryVolumeInformationFile( handle, &io, &info, sizeof(info), FileFsDeviceInformation );
     NtClose( handle );
@@ -1786,7 +1795,7 @@ BOOL WINAPI GetVolumePathNameA(LPCSTR filename, LPSTR volumepathname, DWORD bufl
     BOOL ret;
     WCHAR *filenameW = NULL, *volumeW = NULL;
 
-    FIXME("(%s, %p, %d), stub!\n", debugstr_a(filename), volumepathname, buflen);
+    TRACE("(%s, %p, %d)\n", debugstr_a(filename), volumepathname, buflen);
 
     if (filename && !(filenameW = FILE_name_AtoW( filename, FALSE )))
         return FALSE;
@@ -1802,12 +1811,27 @@ BOOL WINAPI GetVolumePathNameA(LPCSTR filename, LPSTR volumepathname, DWORD bufl
 
 /***********************************************************************
  *           GetVolumePathNameW   (KERNEL32.@)
+ *
+ * This routine is intended to find the most basic path on the same filesystem
+ * for any particular path name.  Since we can have very complicated drive/path
+ * relationships on Unix systems, due to symbolic links, the safest way to
+ * handle this is to start with the full path and work our way back folder by
+ * folder unil we find a folder on a different drive (or run out of folders).
  */
 BOOL WINAPI GetVolumePathNameW(LPCWSTR filename, LPWSTR volumepathname, DWORD buflen)
 {
-    const WCHAR *p = filename;
+    const WCHAR ntprefixW[] = { '\\','\\','?','\\',0 };
+    const WCHAR fallbackpathW[] = { 'C',':','\\',0 };
+    NTSTATUS status = STATUS_SUCCESS;
+    WCHAR *volumenameW = NULL, *c;
+    int pos, last_pos, stop_pos;
+    UNICODE_STRING nt_name;
+    ANSI_STRING unix_name;
+    BOOL first_run = TRUE;
+    dev_t search_dev = 0;
+    struct stat st;
 
-    FIXME("(%s, %p, %d), stub!\n", debugstr_w(filename), volumepathname, buflen);
+    TRACE("(%s, %p, %d)\n", debugstr_w(filename), volumepathname, buflen);
 
     if (!filename || !volumepathname || !buflen)
     {
@@ -1815,24 +1839,104 @@ BOOL WINAPI GetVolumePathNameW(LPCWSTR filename, LPWSTR volumepathname, DWORD bu
         return FALSE;
     }
 
-    if (p && tolowerW(p[0]) >= 'a' && tolowerW(p[0]) <= 'z' && p[1] ==':' && p[2] == '\\')
+    last_pos = pos = strlenW( filename );
+    /* allocate enough memory for searching the path (need room for a slash and a NULL terminator) */
+    if (!(volumenameW = HeapAlloc( GetProcessHeap(), 0, (pos + 2) * sizeof(WCHAR) )))
     {
-        if (buflen < 4)
+        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
+        return FALSE;
+    }
+    strcpyW( volumenameW, filename );
+    stop_pos = 0;
+    /* stop searching slashes early for NT-type and nearly NT-type paths */
+    if (strncmpW(ntprefixW, filename, strlenW(ntprefixW)) == 0)
+        stop_pos = strlenW(ntprefixW)-1;
+    else if (strncmpW(ntprefixW, filename, 2) == 0)
+        stop_pos = 2;
+
+    do
+    {
+        volumenameW[pos+0] = '\\';
+        volumenameW[pos+1] = '\0';
+        if (!RtlDosPathNameToNtPathName_U( volumenameW, &nt_name, NULL, NULL ))
+            goto cleanup;
+        volumenameW[pos] = '\0';
+        status = wine_nt_to_unix_file_name( &nt_name, &unix_name, FILE_OPEN, FALSE );
+        RtlFreeUnicodeString( &nt_name );
+        if (status == STATUS_SUCCESS)
         {
-            SetLastError(ERROR_FILENAME_EXCED_RANGE);
-            return FALSE;
+            if (stat( unix_name.Buffer, &st ) != 0)
+            {
+                RtlFreeAnsiString( &unix_name );
+                status = STATUS_OBJECT_NAME_INVALID;
+                goto cleanup;
+            }
+            if (first_run)
+            {
+                first_run = FALSE;
+                search_dev = st.st_dev;
+            }
+            else if (st.st_dev != search_dev)
+            {
+                /* folder is on a new filesystem, return the last folder */
+                RtlFreeAnsiString( &unix_name );
+                break;
+            }
+        }
+        RtlFreeAnsiString( &unix_name );
+        last_pos = pos;
+        c = strrchrW( volumenameW, '\\' );
+        if (c != NULL)
+            pos = c-volumenameW;
+    } while (c != NULL && pos > stop_pos);
+
+    if (status != STATUS_SUCCESS)
+    {
+        /* the path was completely invalid */
+        if (filename[0] != '\\')
+        {
+            /* DOS-style paths revert to C:\ (anything not beginning with a slash) */
+            last_pos = strlenW(fallbackpathW) - 1; /* points to \\ */
+            filename = fallbackpathW;
+            status = STATUS_SUCCESS;
+        }
+        else
+        {
+            /* NT-style paths fail */
+            status = STATUS_OBJECT_NAME_INVALID;
+            goto cleanup;
         }
-        volumepathname[0] = p[0];
-        volumepathname[1] = ':';
-        volumepathname[2] = '\\';
-        volumepathname[3] = 0;
-        return TRUE;
     }
 
-    SetLastError(ERROR_INVALID_NAME);
-    return FALSE;
+    if (last_pos + 1 <= buflen)
+    {
+        WCHAR *p;
+        memcpy(volumepathname, filename, last_pos * sizeof(WCHAR));
+        if (last_pos + 2 <= buflen) volumepathname[last_pos++] = '\\';
+        volumepathname[last_pos] = '\0';
+
+        /* Normalize path */
+        for (p = volumepathname; *p; p++) if (*p == '/') *p = '\\';
+
+        /* DOS-style paths always return upper-case drive letters */
+        if (volumepathname[1] == ':')
+            volumepathname[0] = toupper(volumepathname[0]);
+
+        TRACE("Successfully translated path %s to mount-point %s\n",
+              debugstr_w(filename), debugstr_w(volumepathname));
+    }
+    else
+        status = STATUS_NAME_TOO_LONG;
+
+cleanup:
+    HeapFree( GetProcessHeap(), 0, volumenameW );
+
+    if (status != STATUS_SUCCESS)
+        SetLastError( RtlNtStatusToDosError(status) );
+    return (status == STATUS_SUCCESS);
 }
 
+
 /***********************************************************************
  *           GetVolumePathNamesForVolumeNameA   (KERNEL32.@)
  */
diff --git a/dlls/krnl386.exe16/file.c b/dlls/krnl386.exe16/file.c
index 1584340..99bd5fe 100644
--- a/dlls/krnl386.exe16/file.c
+++ b/dlls/krnl386.exe16/file.c
@@ -53,21 +53,24 @@ static HANDLE dos_handles[DOS_TABLE_SIZE];
  */
 static void FILE_InitProcessDosHandles( void )
 {
+    HANDLE hStdInput, hStdOutput, hStdError;
     static BOOL init_done /* = FALSE */;
     HANDLE cp = GetCurrentProcess();
 
     if (init_done) return;
     init_done = TRUE;
-    DuplicateHandle(cp, GetStdHandle(STD_INPUT_HANDLE), cp, &dos_handles[0],
-                    0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, GetStdHandle(STD_OUTPUT_HANDLE), cp, &dos_handles[1],
-                    0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, GetStdHandle(STD_ERROR_HANDLE), cp, &dos_handles[2],
-                    0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, GetStdHandle(STD_ERROR_HANDLE), cp, &dos_handles[3],
-                    0, TRUE, DUPLICATE_SAME_ACCESS);
-    DuplicateHandle(cp, GetStdHandle(STD_ERROR_HANDLE), cp, &dos_handles[4],
-                    0, TRUE, DUPLICATE_SAME_ACCESS);
+    hStdInput = GetStdHandle(STD_INPUT_HANDLE);
+    hStdOutput = GetStdHandle(STD_OUTPUT_HANDLE);
+    hStdError = GetStdHandle(STD_ERROR_HANDLE);
+    /* Invalid console handles need to translate to real handles in a new process */
+    if (!hStdInput) hStdInput = INVALID_HANDLE_VALUE;
+    if (!hStdOutput) hStdOutput = INVALID_HANDLE_VALUE;
+    if (!hStdError) hStdError = INVALID_HANDLE_VALUE;
+    DuplicateHandle(cp, hStdInput, cp, &dos_handles[0], 0, TRUE, DUPLICATE_SAME_ACCESS);
+    DuplicateHandle(cp, hStdOutput, cp, &dos_handles[1], 0, TRUE, DUPLICATE_SAME_ACCESS);
+    DuplicateHandle(cp, hStdError, cp, &dos_handles[2], 0, TRUE, DUPLICATE_SAME_ACCESS);
+    DuplicateHandle(cp, hStdError, cp, &dos_handles[3], 0, TRUE, DUPLICATE_SAME_ACCESS);
+    DuplicateHandle(cp, hStdError, cp, &dos_handles[4], 0, TRUE, DUPLICATE_SAME_ACCESS);
 }
 
 /***********************************************************************
diff --git a/dlls/krnl386.exe16/int2f.c b/dlls/krnl386.exe16/int2f.c
index f5b5aaa..383c094 100644
--- a/dlls/krnl386.exe16/int2f.c
+++ b/dlls/krnl386.exe16/int2f.c
@@ -1027,8 +1027,8 @@ static void MSCDEX_Handler(CONTEXT* context)
                ERR("ES:BX==0 ! SEGFAULT ?\n");
                ERR("-->BX=0x%04x, ES=0x%04x, DS=0x%04x, CX=0x%04x\n",
                    BX_reg(context), context->SegEs, context->SegDs, CX_reg(context));
-               driver_request[4] |= 0x80;
-               driver_request[3] = 5;  /* bad request length */
+   //            driver_request[4] |= 0x80;
+   //            driver_request[3] = 5;  /* bad request length */
                return;
            }
 
diff --git a/dlls/mfplat/Makefile.in b/dlls/mfplat/Makefile.in
index 2b5bd24..9679f53 100644
--- a/dlls/mfplat/Makefile.in
+++ b/dlls/mfplat/Makefile.in
@@ -1,4 +1,5 @@
 MODULE    = mfplat.dll
+IMPORTS   = user32 advapi32
 
 C_SRCS = \
 	main.c
diff --git a/dlls/mfplat/main.c b/dlls/mfplat/main.c
index 3376a2c..34f17ee 100644
--- a/dlls/mfplat/main.c
+++ b/dlls/mfplat/main.c
@@ -22,13 +22,42 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "winuser.h"
+#include "winreg.h"
 #include "mfapi.h"
 #include "mferror.h"
 
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+static WCHAR transform_keyW[] = {'S','o','f','t','w','a','r','e','\\','C','l','a','s','s','e','s',
+                                 '\\','M','e','d','i','a','F','o','u','n','d','a','t','i','o','n','\\',
+                                 'T','r','a','n','s','f','o','r','m','s',0};
+static WCHAR categories_keyW[] = {'S','o','f','t','w','a','r','e','\\','C','l','a','s','s','e','s',
+                                 '\\','M','e','d','i','a','F','o','u','n','d','a','t','i','o','n','\\',
+                                 'T','r','a','n','s','f','o','r','m','s','\\',
+                                 'C','a','t','e','g','o','r','i','e','s',0};
+static WCHAR inputtypesW[]  = {'I','n','p','u','t','T','y','p','e','s',0};
+static WCHAR outputtypesW[] = {'O','u','t','p','u','t','T','y','p','e','s',0};
+static const WCHAR szGUIDFmt[] =
+{
+    '%','0','8','x','-','%','0','4','x','-','%','0','4','x','-','%','0',
+    '2','x','%','0','2','x','-','%','0','2','x','%','0','2','x','%','0','2',
+    'x','%','0','2','x','%','0','2','x','%','0','2','x',0
+};
+
+static LPWSTR GUIDToString(LPWSTR lpwstr, REFGUID lpcguid)
+{
+    wsprintfW(lpwstr, szGUIDFmt, lpcguid->Data1, lpcguid->Data2,
+        lpcguid->Data3, lpcguid->Data4[0], lpcguid->Data4[1],
+        lpcguid->Data4[2], lpcguid->Data4[3], lpcguid->Data4[4],
+        lpcguid->Data4[5], lpcguid->Data4[6], lpcguid->Data4[7]);
+
+    return lpwstr;
+}
+
 BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID reserved)
 {
     switch (reason)
@@ -43,6 +72,121 @@ BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID reserved)
     return TRUE;
 }
 
+static HRESULT register_transform(CLSID *clsid, WCHAR *name,
+                                  UINT32 cinput, MFT_REGISTER_TYPE_INFO *inputTypes,
+                                  UINT32 coutput, MFT_REGISTER_TYPE_INFO *outputTypes)
+{
+    HKEY htransform, hclsid = 0;
+    WCHAR buffer[64];
+    GUID *types;
+    DWORD size;
+    LONG ret;
+    UINT32 i;
+
+    if (RegOpenKeyW(HKEY_LOCAL_MACHINE, transform_keyW, &htransform))
+        return E_FAIL;
+
+    GUIDToString(buffer, clsid);
+    ret = RegCreateKeyW(htransform, buffer, &hclsid);
+    RegCloseKey(htransform);
+    if (ret) return E_FAIL;
+
+    size = (strlenW(name) + 1) * sizeof(WCHAR);
+    if (RegSetValueExW(hclsid, NULL, 0, REG_SZ, (BYTE *)name, size))
+        goto err;
+
+    if (cinput)
+    {
+        size = 2 * cinput * sizeof(GUID);
+        types = HeapAlloc(GetProcessHeap(), 0, size);
+        if (!types) goto err;
+
+        for (i = 0; i < cinput; i++)
+        {
+            memcpy(&types[2 * i],     &inputTypes[i].guidMajorType, sizeof(GUID));
+            memcpy(&types[2 * i + 1], &inputTypes[i].guidSubtype,   sizeof(GUID));
+        }
+
+        ret = RegSetValueExW(hclsid, inputtypesW, 0, REG_BINARY, (BYTE *)types, size);
+        HeapFree(GetProcessHeap(), 0, types);
+        if (ret) goto err;
+    }
+
+    if (coutput)
+    {
+        size = 2 * coutput * sizeof(GUID);
+        types = HeapAlloc(GetProcessHeap(), 0, size);
+        if (!types) goto err;
+
+        for (i = 0; i < coutput; i++)
+        {
+            memcpy(&types[2 * i],     &outputTypes[i].guidMajorType, sizeof(GUID));
+            memcpy(&types[2 * i + 1], &outputTypes[i].guidSubtype,   sizeof(GUID));
+        }
+
+        ret = RegSetValueExW(hclsid, outputtypesW, 0, REG_BINARY, (BYTE *)types, size);
+        HeapFree(GetProcessHeap(), 0, types);
+        if (ret) goto err;
+    }
+
+    RegCloseKey(hclsid);
+    return S_OK;
+
+err:
+    RegCloseKey(hclsid);
+    return E_FAIL;
+}
+
+static HRESULT register_category(CLSID *clsid, GUID *category)
+{
+    HKEY hcategory, htmp1, htmp2;
+    WCHAR buffer[64];
+    DWORD ret;
+
+    if (RegOpenKeyW(HKEY_LOCAL_MACHINE, categories_keyW, &hcategory))
+        return E_FAIL;
+
+    GUIDToString(buffer, category);
+    ret = RegCreateKeyW(hcategory, buffer, &htmp1);
+    RegCloseKey(hcategory);
+    if (ret) return E_FAIL;
+
+    GUIDToString(buffer, clsid);
+    ret = RegCreateKeyW(htmp1, buffer, &htmp2);
+    RegCloseKey(htmp1);
+    if (ret) return E_FAIL;
+
+    RegCloseKey(htmp2);
+    return S_OK;
+}
+
+/***********************************************************************
+ *      MFTRegister (mfplat.@)
+ */
+HRESULT WINAPI MFTRegister(CLSID clsid, GUID category, LPWSTR name, UINT32 flags, UINT32 cinput,
+                           MFT_REGISTER_TYPE_INFO *inputTypes, UINT32 coutput,
+                           MFT_REGISTER_TYPE_INFO *outputTypes, void *attributes)
+{
+    HRESULT hr;
+
+    FIXME("(%s, %s, %s, %x, %u, %p, %u, %p, %p)\n", debugstr_guid(&clsid), debugstr_guid(&category),
+                                                    debugstr_w(name), flags, cinput, inputTypes,
+                                                    coutput, outputTypes, attributes);
+
+    if (attributes)
+        FIXME("attributes not yet supported.\n");
+
+    if (flags)
+        FIXME("flags not yet supported.\n");
+
+    hr = register_transform(&clsid, name, cinput, inputTypes, coutput, outputTypes);
+
+    if (SUCCEEDED(hr))
+        hr = register_category(&clsid, &category);
+
+    return hr;
+}
+
 /***********************************************************************
  *      MFStartup (mfplat.@)
  */
diff --git a/dlls/mfplat/mfplat.spec b/dlls/mfplat/mfplat.spec
index 7100dfd..5b24aa9 100644
--- a/dlls/mfplat/mfplat.spec
+++ b/dlls/mfplat/mfplat.spec
@@ -137,7 +137,8 @@
 @ stub MFTEnum
 @ stub MFTEnumEx
 @ stub MFTGetInfo
-@ stub MFTRegister
+# Structures are directly pushed on the stack
+@ stdcall -norelay MFTRegister()
 @ stub MFTRegisterLocal
 @ stub MFTRegisterLocalByCLSID
 @ stub MFTUnregister
diff --git a/dlls/mmdevapi/audiovolume.c b/dlls/mmdevapi/audiovolume.c
index 194cfa3..d21385e 100644
--- a/dlls/mmdevapi/audiovolume.c
+++ b/dlls/mmdevapi/audiovolume.c
@@ -45,6 +45,8 @@ static const IAudioEndpointVolumeExVtbl AEVImpl_Vtbl;
 typedef struct AEVImpl {
     IAudioEndpointVolumeEx IAudioEndpointVolumeEx_iface;
     LONG ref;
+    float level;
+    BOOL mute;
 } AEVImpl;
 
 static inline AEVImpl *impl_from_IAudioEndpointVolumeEx(IAudioEndpointVolumeEx *iface)
@@ -61,6 +63,8 @@ HRESULT AudioEndpointVolume_Create(MMDevice *parent, IAudioEndpointVolume **ppv)
         return E_OUTOFMEMORY;
     This->IAudioEndpointVolumeEx_iface.lpVtbl = &AEVImpl_Vtbl;
     This->ref = 1;
+    This->level = 1.0f;
+    This->mute = FALSE;
     return S_OK;
 }
 
@@ -134,9 +138,13 @@ static HRESULT WINAPI AEV_GetChannelCount(IAudioEndpointVolumeEx *iface, UINT *c
 
 static HRESULT WINAPI AEV_SetMasterVolumeLevel(IAudioEndpointVolumeEx *iface, float leveldb, const GUID *ctx)
 {
-    TRACE("(%p)->(%f,%s)\n", iface, leveldb, debugstr_guid(ctx));
-    FIXME("stub\n");
-    return E_NOTIMPL;
+    AEVImpl *This = impl_from_IAudioEndpointVolumeEx(iface);
+
+    FIXME("(%p)->(%f,%s): stub\n", iface, leveldb, debugstr_guid(ctx));
+
+    This->level = leveldb;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI AEV_SetMasterVolumeLevelScalar(IAudioEndpointVolumeEx *iface, float level, const GUID *ctx)
@@ -148,11 +156,16 @@ static HRESULT WINAPI AEV_SetMasterVolumeLevelScalar(IAudioEndpointVolumeEx *ifa
 
 static HRESULT WINAPI AEV_GetMasterVolumeLevel(IAudioEndpointVolumeEx *iface, float *leveldb)
 {
-    TRACE("(%p)->(%p)\n", iface, leveldb);
+    AEVImpl *This = impl_from_IAudioEndpointVolumeEx(iface);
+
+    FIXME("(%p)->(%p): stub\n", iface, leveldb);
+
     if (!leveldb)
         return E_POINTER;
-    FIXME("stub\n");
-    return E_NOTIMPL;
+
+    *leveldb = This->level;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI AEV_GetMasterVolumeLevelScalar(IAudioEndpointVolumeEx *iface, float *level)
@@ -198,18 +211,27 @@ static HRESULT WINAPI AEV_GetChannelVolumeLevelScalar(IAudioEndpointVolumeEx *if
 
 static HRESULT WINAPI AEV_SetMute(IAudioEndpointVolumeEx *iface, BOOL mute, const GUID *ctx)
 {
-    TRACE("(%p)->(%u,%s)\n", iface, mute, debugstr_guid(ctx));
-    FIXME("stub\n");
-    return E_NOTIMPL;
+    AEVImpl *This = impl_from_IAudioEndpointVolumeEx(iface);
+
+    FIXME("(%p)->(%u,%s): stub\n", iface, mute, debugstr_guid(ctx));
+
+    This->mute = mute;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI AEV_GetMute(IAudioEndpointVolumeEx *iface, BOOL *mute)
 {
-    TRACE("(%p)->(%p)\n", iface, mute);
+    AEVImpl *This = impl_from_IAudioEndpointVolumeEx(iface);
+
+    FIXME("(%p)->(%p): stub\n", iface, mute);
+
     if (!mute)
         return E_POINTER;
-    FIXME("stub\n");
-    return E_NOTIMPL;
+
+    *mute = This->mute;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI AEV_GetVolumeStepInfo(IAudioEndpointVolumeEx *iface, UINT *stepsize, UINT *stepcount)
@@ -246,11 +268,16 @@ static HRESULT WINAPI AEV_QueryHardwareSupport(IAudioEndpointVolumeEx *iface, DW
 
 static HRESULT WINAPI AEV_GetVolumeRange(IAudioEndpointVolumeEx *iface, float *mindb, float *maxdb, float *inc)
 {
-    TRACE("(%p)->(%p,%p,%p)\n", iface, mindb, maxdb, inc);
+    FIXME("(%p)->(%p,%p,%p): stub\n", iface, mindb, maxdb, inc);
+
     if (!mindb || !maxdb || !inc)
         return E_POINTER;
-    FIXME("stub\n");
-    return E_NOTIMPL;
+
+    *mindb = 0.0f;
+    *maxdb = 1.0f;
+    *inc = 0.1f;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI AEV_GetVolumeRangeChannel(IAudioEndpointVolumeEx *iface, UINT chan, float *mindb, float *maxdb, float *inc)
diff --git a/dlls/mmdevapi/main.c b/dlls/mmdevapi/main.c
index 52cf6f1..aa4baa5 100644
--- a/dlls/mmdevapi/main.c
+++ b/dlls/mmdevapi/main.c
@@ -113,7 +113,7 @@ static BOOL init_driver(void)
 {
     static const WCHAR drv_value[] = {'A','u','d','i','o',0};
 
-    static WCHAR default_list[] = {'a','l','s','a',',','o','s','s',',',
+    static WCHAR default_list[] = {'p','u','l','s','e',',','a','l','s','a',',','o','s','s',',',
         'c','o','r','e','a','u','d','i','o',0};
 
     DriverFuncs driver;
diff --git a/dlls/mmdevapi/tests/render.c b/dlls/mmdevapi/tests/render.c
index 3a48c8d..02f47b5 100644
--- a/dlls/mmdevapi/tests/render.c
+++ b/dlls/mmdevapi/tests/render.c
@@ -467,6 +467,169 @@ static void test_formats(AUDCLNT_SHAREMODE mode)
     }
 }
 
+static void test_formats2(void)
+{
+    IAudioClient *ac;
+    HRESULT hr;
+    WAVEFORMATEX *pwfx, *pwfx2;
+    WAVEFORMATEXTENSIBLE *pwfe, wfe, *pwfe2;
+
+    hr = IMMDevice_Activate(dev, &IID_IAudioClient, CLSCTX_INPROC_SERVER,
+                            NULL, (void**)&ac);
+
+    ok(hr == S_OK, "Activation failed with %08x\n", hr);
+    if (hr != S_OK)
+        return;
+
+    hr = IAudioClient_GetMixFormat(ac, &pwfx);
+    ok(hr == S_OK, "GetMixFormat failed: %08x\n", hr);
+    if (hr != S_OK)
+        return;
+
+    ok(pwfx->wFormatTag == WAVE_FORMAT_EXTENSIBLE, "Invalid wFormatTag\n");
+    if (pwfx->wFormatTag != WAVE_FORMAT_EXTENSIBLE) {
+        CoTaskMemFree(pwfx);
+        return;
+    }
+
+    pwfe = (WAVEFORMATEXTENSIBLE*)pwfx;
+    ok(pwfe->Samples.wValidBitsPerSample, "wValidBitsPerSample should be non-zero\n");
+
+    if (pwfx->nChannels > 2) {
+        trace("Limiting channels to 2\n");
+        pwfx->nChannels = 2;
+        pwfx->nBlockAlign = pwfx->wBitsPerSample / 8 * pwfx->nChannels;
+        pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
+        pwfe->dwChannelMask = SPEAKER_FRONT_LEFT | SPEAKER_FRONT_RIGHT;
+    }
+
+    wfe = *pwfe;
+    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign = 0;
+
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with nAvgBytesPerSec=0 and nBlockAlign=0 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok((hr == E_INVALIDARG || hr == AUDCLNT_E_UNSUPPORTED_FORMAT) && !pwfx2,
+       "Shared IsFormatSupported with nAvgBytesPerSec=0 and nBlockAlign=0 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    pwfx->wFormatTag = WAVE_FORMAT_PCM;
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok((hr == S_OK || hr == AUDCLNT_E_UNSUPPORTED_FORMAT) && !pwfx2,
+       "Shared IsFormatSupported with nAvgBytesPerSec=0 and nBlockAlign=0 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfe->dwChannelMask = 0;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=0 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK,
+       "Shared IsFormatSupported with dwChannelMask=0 returned %08x\n", hr);
+    CoTaskMemFree(pwfx2);
+
+
+    pwfe->dwChannelMask = 0x3ffff;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=0x3ffff returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with dwChannelMask=0x3ffff returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+
+    pwfe->dwChannelMask = 0x40000000;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=0x40000000 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with dwChannelMask=0x40000000 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    pwfe->dwChannelMask = SPEAKER_ALL | SPEAKER_RESERVED;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with dwChannelMask=SPEAKER_ALL | SPEAKER_RESERVED returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_OK && !pwfx2,
+       "Shared IsFormatSupported with dwChannelMask=SPEAKER_ALL | SPEAKER_RESERVED returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfe->Samples.wValidBitsPerSample = 0;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_EXCLUSIVE, pwfx, NULL);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT || hr == AUDCLNT_E_EXCLUSIVE_MODE_NOT_ALLOWED,
+       "Exclusive IsFormatSupported with wValidBitsPerSample=0 returned %08x\n", hr);
+
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok((hr == S_FALSE || hr == AUDCLNT_E_UNSUPPORTED_FORMAT) && pwfx2,
+       "Shared IsFormatSupported with wValidBitsPerSample=0 returned %08x %p\n", hr, pwfx2);
+    if (pwfx2) {
+        pwfe2 = (WAVEFORMATEXTENSIBLE*)pwfx2;
+        ok(pwfe2->Samples.wValidBitsPerSample == pwfx->wBitsPerSample,
+           "Shared IsFormatSupported had wValidBitsPerSample set to %u, not %u\n",
+           pwfe2->Samples.wValidBitsPerSample, pwfx->wBitsPerSample);
+        CoTaskMemFree(pwfx2);
+    }
+
+    pwfx2 = NULL;
+    pwfe->Samples.wValidBitsPerSample = pwfx->wBitsPerSample + 1;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok((hr == E_INVALIDARG || hr == AUDCLNT_E_UNSUPPORTED_FORMAT) && !pwfx2,
+       "Shared IsFormatSupported with wValidBitsPerSample += 1 returned %08x %p\n", hr, pwfx2);
+
+    *pwfe = wfe;
+    memset(&pwfe->SubFormat, 0xff, 16);
+    pwfx2 = NULL;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == AUDCLNT_E_UNSUPPORTED_FORMAT && !pwfx2,
+       "Shared IsFormatSupported with SubFormat=-1 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfx2 = NULL;
+    pwfe->Samples.wValidBitsPerSample = pwfx->wBitsPerSample = 256;
+    pwfx->nBlockAlign = pwfx->wBitsPerSample / 8 * pwfx->nChannels;
+    pwfx->nAvgBytesPerSec = pwfx->nBlockAlign * pwfx->nSamplesPerSec;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok((hr == E_INVALIDARG || hr == AUDCLNT_E_UNSUPPORTED_FORMAT) && !pwfx2,
+       "Shared IsFormatSupported with wBitsPerSample=256 returned %08x %p\n", hr, pwfx2);
+    CoTaskMemFree(pwfx2);
+
+    *pwfe = wfe;
+    pwfx2 = NULL;
+    pwfe->Samples.wValidBitsPerSample = pwfx->wBitsPerSample - 1;
+    hr = IAudioClient_IsFormatSupported(ac, AUDCLNT_SHAREMODE_SHARED, pwfx, &pwfx2);
+    ok(hr == S_FALSE && pwfx2,
+       "Shared IsFormatSupported with wValidBitsPerSample-=1 returned %08x %p\n", hr, pwfx2);
+    if (pwfx2) {
+        pwfe2 = (WAVEFORMATEXTENSIBLE*)pwfx2;
+        ok(pwfe2->Samples.wValidBitsPerSample == pwfx->wBitsPerSample,
+           "Shared IsFormatSupported had wValidBitsPerSample set to %u, not %u\n",
+           pwfe2->Samples.wValidBitsPerSample, pwfx->wBitsPerSample);
+        CoTaskMemFree(pwfx2);
+    }
+
+    CoTaskMemFree(pwfx);
+    IAudioClient_Release(ac);
+}
+
 static void test_references(void)
 {
     IAudioClient *ac;
@@ -2255,6 +2418,7 @@ START_TEST(render)
     test_audioclient();
     test_formats(AUDCLNT_SHAREMODE_EXCLUSIVE);
     test_formats(AUDCLNT_SHAREMODE_SHARED);
+    test_formats2();
     test_references();
     test_marshal();
     trace("Output to a MS-DOS console is particularly slow and disturbs timing.\n");
diff --git a/dlls/mountmgr.sys/device.c b/dlls/mountmgr.sys/device.c
index 5003d4d..2722663 100644
--- a/dlls/mountmgr.sys/device.c
+++ b/dlls/mountmgr.sys/device.c
@@ -511,8 +511,8 @@ static NTSTATUS set_volume_info( struct volume *volume, struct dos_drive *drive,
         id = disk_device->unix_mount;
         id_len = strlen( disk_device->unix_mount ) + 1;
     }
-    if (volume->mount) set_mount_point_id( volume->mount, id, id_len );
-    if (drive && drive->mount) set_mount_point_id( drive->mount, id, id_len );
+    if (volume->mount) set_mount_point_id( volume->mount, id, id_len, -1 );
+    if (drive && drive->mount) set_mount_point_id( drive->mount, id, id_len, drive->drive );
 
     return STATUS_SUCCESS;
 }
diff --git a/dlls/mountmgr.sys/mountmgr.c b/dlls/mountmgr.sys/mountmgr.c
index 10286dc..ba803f3 100644
--- a/dlls/mountmgr.sys/mountmgr.c
+++ b/dlls/mountmgr.sys/mountmgr.c
@@ -47,14 +47,21 @@ struct mount_point
 static struct list mount_points_list = LIST_INIT(mount_points_list);
 static HKEY mount_key;
 
-void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len )
+void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len, int drive )
 {
+    WCHAR logicalW[] = {'\\','\\','.','\\','a',':',0};
     RtlFreeHeap( GetProcessHeap(), 0, mount->id );
     mount->id_len = max( MIN_ID_LEN, id_len );
     if ((mount->id = RtlAllocateHeap( GetProcessHeap(), HEAP_ZERO_MEMORY, mount->id_len )))
     {
         memcpy( mount->id, id, id_len );
-        RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, mount->id, mount->id_len );
+        if (drive < 0)
+            RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, mount->id, mount->id_len );
+        else
+        {
+            logicalW[4] = 'a' + drive;
+            RegSetValueExW( mount_key, mount->link.Buffer, 0, REG_BINARY, (BYTE*)logicalW, sizeof(logicalW) );
+        }
     }
     else mount->id_len = 0;
 }
diff --git a/dlls/mountmgr.sys/mountmgr.h b/dlls/mountmgr.sys/mountmgr.h
index 2f0db62..dd6ddc5 100644
--- a/dlls/mountmgr.sys/mountmgr.h
+++ b/dlls/mountmgr.sys/mountmgr.h
@@ -67,4 +67,4 @@ extern struct mount_point *add_dosdev_mount_point( DEVICE_OBJECT *device, UNICOD
 extern struct mount_point *add_volume_mount_point( DEVICE_OBJECT *device, UNICODE_STRING *device_name,
                                                    const GUID *guid ) DECLSPEC_HIDDEN;
 extern void delete_mount_point( struct mount_point *mount ) DECLSPEC_HIDDEN;
-extern void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len ) DECLSPEC_HIDDEN;
+extern void set_mount_point_id( struct mount_point *mount, const void *id, unsigned int id_len, int drive ) DECLSPEC_HIDDEN;
diff --git a/dlls/mscoree/mscoree_main.c b/dlls/mscoree/mscoree_main.c
index 8b46fd5..3644a18 100644
--- a/dlls/mscoree/mscoree_main.c
+++ b/dlls/mscoree/mscoree_main.c
@@ -21,11 +21,14 @@
 
 #include <stdarg.h>
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #define COBJMACROS
 #include "wine/unicode.h"
 #include "wine/library.h"
 #include "windef.h"
 #include "winbase.h"
+#include "winternl.h"
 #include "winuser.h"
 #include "winnls.h"
 #include "winreg.h"
@@ -259,8 +262,75 @@ VOID WINAPI _CorImageUnloading(PVOID imageBase)
 
 HRESULT WINAPI _CorValidateImage(PVOID* imageBase, LPCWSTR imageName)
 {
-    TRACE("(%p, %s): stub\n", imageBase, debugstr_w(imageName));
-    return E_FAIL;
+    IMAGE_COR20_HEADER *cliheader;
+    IMAGE_NT_HEADERS *nt;
+    ULONG size;
+
+    TRACE("(%p, %s)\n", imageBase, debugstr_w(imageName));
+
+    if (!imageBase)
+        return E_INVALIDARG;
+
+    nt = RtlImageNtHeader(*imageBase);
+    if (!nt)
+        return STATUS_INVALID_IMAGE_FORMAT;
+
+    cliheader = RtlImageDirectoryEntryToData(*imageBase, TRUE, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, &size);
+    if (!cliheader || size < sizeof(*cliheader))
+        return STATUS_INVALID_IMAGE_FORMAT;
+
+#ifdef __x86_64__
+    if (cliheader->Flags & COMIMAGE_FLAGS_32BITREQUIRED)
+            return STATUS_INVALID_IMAGE_FORMAT;
+
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR64_MAGIC)
+    {
+        if (cliheader->Flags & COMIMAGE_FLAGS_ILONLY)
+        {
+            DWORD *entry = &nt->OptionalHeader.AddressOfEntryPoint;
+            DWORD old_protect;
+
+            if (!VirtualProtect(entry, sizeof(*entry), PAGE_READWRITE, &old_protect))
+                return E_UNEXPECTED;
+            *entry = 0;
+            if (!VirtualProtect(entry, sizeof(*entry), old_protect, &old_protect))
+                return E_UNEXPECTED;
+        }
+
+        return STATUS_SUCCESS;
+    }
+
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
+    {
+        if (!(cliheader->Flags & COMIMAGE_FLAGS_ILONLY))
+            return STATUS_INVALID_IMAGE_FORMAT;
+
+        FIXME("conversion of IMAGE_NT_HEADERS32 -> IMAGE_NT_HEADERS64 not implemented\n");
+        return STATUS_NOT_IMPLEMENTED;
+    }
+
+#else
+    if (nt->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC)
+    {
+        if (cliheader->Flags & COMIMAGE_FLAGS_ILONLY)
+        {
+            DWORD *entry = &nt->OptionalHeader.AddressOfEntryPoint;
+            DWORD old_protect;
+
+            if (!VirtualProtect(entry, sizeof(*entry), PAGE_READWRITE, &old_protect))
+                return E_UNEXPECTED;
+            *entry = (nt->FileHeader.Characteristics & IMAGE_FILE_DLL) ?
+                ((DWORD)&_CorDllMain - (DWORD)*imageBase) : ((DWORD)&_CorExeMain - (DWORD)*imageBase);
+            if (!VirtualProtect(entry, sizeof(*entry), old_protect, &old_protect))
+                return E_UNEXPECTED;
+        }
+
+        return STATUS_SUCCESS;
+    }
+
+#endif
+
+    return STATUS_INVALID_IMAGE_FORMAT;
 }
 
 HRESULT WINAPI GetCORSystemDirectory(LPWSTR pbuffer, DWORD cchBuffer, DWORD *dwLength)
diff --git a/dlls/mshtml/script.c b/dlls/mshtml/script.c
index 4590854..e38e5bf 100644
--- a/dlls/mshtml/script.c
+++ b/dlls/mshtml/script.c
@@ -1506,8 +1506,10 @@ void bind_event_scripts(HTMLDocumentNode *doc)
 
                 if(SUCCEEDED(hres))
                     bind_activex_event(doc, plugin_container, event, event_disp);
-                else
+                else if(target_node)
                     bind_node_event(doc, event_target, target_node, event, event_disp);
+                else
+                    FIXME("binding to window not supported.\n");
 
                 if(target_node) {
                     IHTMLDOMNode_Release(&target_node->IHTMLDOMNode_iface);
diff --git a/dlls/msvcp90/msvcp90.h b/dlls/msvcp90/msvcp90.h
index 62dddc9..263051b 100644
--- a/dlls/msvcp90/msvcp90.h
+++ b/dlls/msvcp90/msvcp90.h
@@ -123,7 +123,7 @@ typedef struct
 basic_string_wchar* __thiscall MSVCP_basic_string_wchar_ctor(basic_string_wchar*);
 basic_string_wchar* __thiscall MSVCP_basic_string_wchar_ctor_cstr(basic_string_wchar*, const wchar_t*);
 basic_string_wchar* __thiscall MSVCP_basic_string_wchar_ctor_cstr_len(basic_string_wchar*, const wchar_t*, MSVCP_size_t);
-void __thiscall MSVCP_basic_string_wchar_dtor(basic_string_wchar*);
+void* __thiscall MSVCP_basic_string_wchar_dtor(basic_string_wchar*);
 const wchar_t* __thiscall MSVCP_basic_string_wchar_c_str(const basic_string_wchar*);
 void __thiscall MSVCP_basic_string_wchar_clear(basic_string_wchar*);
 basic_string_wchar* __thiscall MSVCP_basic_string_wchar_append_ch(basic_string_wchar*, wchar_t);
diff --git a/dlls/msvcp90/string.c b/dlls/msvcp90/string.c
index 3afb375..747bd27 100644
--- a/dlls/msvcp90/string.c
+++ b/dlls/msvcp90/string.c
@@ -2712,10 +2712,11 @@ basic_string_wchar* __thiscall MSVCP_basic_string_wchar_ctor_ptr_ptr(basic_strin
 /* ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QAE@XZ */
 /* ??1?$basic_string@GU?$char_traits@G@std@@V?$allocator@G@2@@std@@QEAA@XZ */
 DEFINE_THISCALL_WRAPPER(MSVCP_basic_string_wchar_dtor, 4)
-void __thiscall MSVCP_basic_string_wchar_dtor(basic_string_wchar *this)
+void* __thiscall MSVCP_basic_string_wchar_dtor(basic_string_wchar *this)
 {
     TRACE("%p\n", this);
     basic_string_wchar_tidy(this, TRUE, 0);
+    return NULL;
 }
 
 /* ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QBEIXZ */
diff --git a/dlls/msvcp90/tests/string.c b/dlls/msvcp90/tests/string.c
index f1aa92a..a2cd46f 100644
--- a/dlls/msvcp90/tests/string.c
+++ b/dlls/msvcp90/tests/string.c
@@ -85,7 +85,7 @@ static size_t *p_basic_string_char_npos;
 static basic_string_wchar* (__thiscall *p_basic_string_wchar_ctor)(basic_string_wchar*);
 static basic_string_wchar* (__thiscall *p_basic_string_wchar_copy_ctor)(basic_string_wchar*, basic_string_wchar*);
 static basic_string_wchar* (__thiscall *p_basic_string_wchar_ctor_cstr)(basic_string_wchar*, const wchar_t*);
-static void (__thiscall *p_basic_string_wchar_dtor)(basic_string_wchar*);
+static void* (__thiscall *p_basic_string_wchar_dtor)(basic_string_wchar*);
 static basic_string_wchar* (__thiscall *p_basic_string_wchar_erase)(basic_string_wchar*, size_t, size_t);
 static basic_string_wchar* (__thiscall *p_basic_string_wchar_assign_cstr_len)(basic_string_wchar*, const wchar_t*, size_t);
 static const wchar_t* (__thiscall *p_basic_string_wchar_cstr)(basic_string_wchar*);
@@ -113,32 +113,35 @@ static void __cdecl test_invalid_parameter_handler(const wchar_t *expression,
 #include "pshpack1.h"
 struct thiscall_thunk
 {
-    BYTE pop_eax;    /* popl  %eax (ret addr) */
-    BYTE pop_edx;    /* popl  %edx (func) */
-    BYTE pop_ecx;    /* popl  %ecx (this) */
-    BYTE push_eax;   /* pushl %eax */
-    WORD jmp_edx;    /* jmp  *%edx */
+    BYTE pop_ecx;           /* popl  %ecx (ret addr) */
+    BYTE pop_edx;           /* popl  %edx (func) */
+    BYTE pop_eax;           /* popl  %eax (eax value) */
+    BYTE xchg_ecx_esp[3];   /* xchg %ecx, *%esp (this <-> ret addr) */
+    WORD jmp_edx;           /* jmp  *%edx */
 };
 #include "poppack.h"
 
-static void * (WINAPI *call_thiscall_func1)( void *func, void *this );
-static void * (WINAPI *call_thiscall_func2)( void *func, void *this, const void *a );
-static void * (WINAPI *call_thiscall_func3)( void *func, void *this, const void *a, const void *b );
-static void * (WINAPI *call_thiscall_func4)( void *func, void *this, const void *a, const void *b,
-                                             const void *c );
-static void * (WINAPI *call_thiscall_func5)( void *func, void *this, const void *a, const void *b,
-                                             const void *c, const void *d );
-static void * (WINAPI *call_thiscall_func6)( void *func, void *this, const void *a, const void *b,
-                                             const void *c, const void *d, const void *e );
+static void * (WINAPI *call_thiscall_func1)( void *func, unsigned int eax, void *this);
+static void * (WINAPI *call_thiscall_func2)( void *func, unsigned int eax, void *this, const void *a );
+static void * (WINAPI *call_thiscall_func3)( void *func, unsigned int eax, void *this, const void *a,
+                                             const void *b );
+static void * (WINAPI *call_thiscall_func4)( void *func, unsigned int eax, void *this, const void *a,
+                                             const void *b, const void *c );
+static void * (WINAPI *call_thiscall_func5)( void *func, unsigned int eax, void *this, const void *a,
+                                             const void *b, const void *c, const void *d );
+static void * (WINAPI *call_thiscall_func6)( void *func, unsigned int eax, void *this, const void *a,
+                                             const void *b, const void *c, const void *d, const void *e );
 
 static void init_thiscall_thunk(void)
 {
     struct thiscall_thunk *thunk = VirtualAlloc( NULL, sizeof(*thunk),
                                                  MEM_COMMIT, PAGE_EXECUTE_READWRITE );
-    thunk->pop_eax  = 0x58;   /* popl  %eax */
-    thunk->pop_edx  = 0x5a;   /* popl  %edx */
     thunk->pop_ecx  = 0x59;   /* popl  %ecx */
-    thunk->push_eax = 0x50;   /* pushl %eax */
+    thunk->pop_edx  = 0x5a;   /* popl  %edx */
+    thunk->pop_eax  = 0x58;   /* popl  %eax */
+    thunk->xchg_ecx_esp[0] = 0x87; /* xchg %ecx, *%esp */
+    thunk->xchg_ecx_esp[1] = 0x0c;
+    thunk->xchg_ecx_esp[2] = 0x24;
     thunk->jmp_edx  = 0xe2ff; /* jmp  *%edx */
     call_thiscall_func1 = (void *)thunk;
     call_thiscall_func2 = (void *)thunk;
@@ -148,15 +151,16 @@ static void init_thiscall_thunk(void)
     call_thiscall_func6 = (void *)thunk;
 }
 
-#define call_func1(func,_this) call_thiscall_func1(func,_this)
-#define call_func2(func,_this,a) call_thiscall_func2(func,_this,(const void*)a)
-#define call_func3(func,_this,a,b) call_thiscall_func3(func,_this,(const void*)a,(const void*)b)
-#define call_func4(func,_this,a,b,c) call_thiscall_func4(func,_this,(const void*)a,\
-        (const void*)b,(const void*)c)
-#define call_func5(func,_this,a,b,c,d) call_thiscall_func5(func,_this,(const void*)a,\
-        (const void*)b,(const void*)c,(const void*)d)
-#define call_func6(func,_this,a,b,c,d,e) call_thiscall_func6(func,_this,(const void*)a,\
-        (const void*)b,(const void*)c,(const void*)d,(const void*)e)
+#define call_func1(func,_this) call_thiscall_func1(func,0,_this)
+#define call_func2(func,_this,a) call_thiscall_func2(func,0,_this,(const void*)a)
+#define call_func3(func,_this,a,b) call_thiscall_func3(func,0,_this,(const void*)a,(const void*)b)
+#define call_func4(func,_this,a,b,c) call_thiscall_func4(func,0,_this,(const void*)a,\
+         (const void*)b,(const void*)c)
+#define call_func5(func,_this,a,b,c,d) call_thiscall_func5(func,0,_this,(const void*)a,\
+         (const void*)b,(const void*)c,(const void*)d)
+#define call_func6(func,_this,a,b,c,d,e) call_thiscall_func6(func,0,_this,(const void*)a,\
+         (const void*)b,(const void*)c,(const void*)d,(const void*)e)
+#define call_func1_eax(func,eax,_this) call_thiscall_func1(func,eax,_this)
 
 #else
 
@@ -767,6 +771,26 @@ static void test_basic_string_char_find_last_not_of(void) {
     }
 }
 
+static void test_basic_string_dtor_eax(void) {
+#ifdef __i386__
+    basic_string_wchar str1;
+    void *ret;
+    wchar_t wtmp1[32];
+
+    mbstowcs(wtmp1, "qwerty", 32);
+
+    /* eax = 0x1337 */
+    call_func2(p_basic_string_wchar_ctor_cstr, &str1, wtmp1);
+    ret = call_func1_eax(p_basic_string_wchar_dtor, 0x1337, &str1);
+    ok (ret == (void *)0x0, "Expected eax value 0x%x, got 0x%x\n", 0x0, (unsigned int)ret);
+
+    /* eax = 0xdeadbeef */
+    call_func2(p_basic_string_wchar_ctor_cstr, &str1, wtmp1);
+    ret = call_func1_eax(p_basic_string_wchar_dtor, 0xdeadbeef, &str1);
+    ok (ret == (void *)0x0, "Expected eax value 0x%x, got 0x%x\n", 0x0, (unsigned int)ret);
+#endif
+}
+
 START_TEST(string)
 {
     if(!init())
@@ -783,6 +807,7 @@ START_TEST(string)
     test_basic_string_wchar();
     test_basic_string_wchar_swap();
     test_basic_string_char_find_last_not_of();
+    test_basic_string_dtor_eax();
 
     ok(!invalid_parameter, "invalid_parameter_handler was invoked too many times\n");
 
diff --git a/dlls/msvcrt/math.c b/dlls/msvcrt/math.c
index 7c971d3..d48199e 100644
--- a/dlls/msvcrt/math.c
+++ b/dlls/msvcrt/math.c
@@ -51,6 +51,19 @@ WINE_DEFAULT_DEBUG_CHANNEL(msvcrt);
 #define signbit(x) ((x) < 0)
 #endif
 
+#ifndef HAVE_COSHL
+#define coshl(x) cosh(x)
+#endif
+#ifndef HAVE_SINHL
+#define sinhl(x) sinh(x)
+#endif
+#ifndef HAVE_EXPL
+#define expl(x) exp(x)
+#endif
+#ifndef HAVE_POWL
+#define powl(x,y) pow(x,y)
+#endif
+
 typedef int (CDECL *MSVCRT_matherr_func)(struct MSVCRT__exception *);
 typedef double LDOUBLE;  /* long double is just a double */
 
@@ -394,7 +407,7 @@ double CDECL MSVCRT_cos( double x )
 double CDECL MSVCRT_cosh( double x )
 {
   if (!isfinite(x)) *MSVCRT__errno() = MSVCRT_EDOM;
-  return cosh(x);
+  return coshl(x);
 }
 
 /*********************************************************************
@@ -403,7 +416,7 @@ double CDECL MSVCRT_cosh( double x )
 double CDECL MSVCRT_exp( double x )
 {
   if (isnan(x)) *MSVCRT__errno() = MSVCRT_EDOM;
-  return exp(x);
+  return expl(x);
 }
 
 /*********************************************************************
@@ -441,7 +454,7 @@ double CDECL MSVCRT_log10( double x )
 double CDECL MSVCRT_pow( double x, double y )
 {
   /* FIXME: If x < 0 and y is not integral, set EDOM */
-  double z = pow(x,y);
+  double z = powl(x,y);
   if (!isfinite(z)) *MSVCRT__errno() = MSVCRT_EDOM;
   return z;
 }
@@ -461,7 +474,7 @@ double CDECL MSVCRT_sin( double x )
 double CDECL MSVCRT_sinh( double x )
 {
   if (!isfinite(x)) *MSVCRT__errno() = MSVCRT_EDOM;
-  return sinh(x);
+  return sinhl(x);
 }
 
 /*********************************************************************
diff --git a/dlls/msvcrt/string.c b/dlls/msvcrt/string.c
index 6f9280f..d933643 100644
--- a/dlls/msvcrt/string.c
+++ b/dlls/msvcrt/string.c
@@ -434,6 +434,12 @@ static double strtod_helper(const char *str, char **end, MSVCRT__locale_t locale
  */
 double CDECL MSVCRT_strtod_l(const char *str, char **end, MSVCRT__locale_t locale)
 {
+    if (!str)
+    {
+        if (end) *end = NULL;
+        *MSVCRT__errno() = MSVCRT_EINVAL;
+        return 0.0;
+    }
     return strtod_helper(str, end, locale, NULL);
 }
 
diff --git a/dlls/msvcrt/tests/string.c b/dlls/msvcrt/tests/string.c
index cf609f7..0218de5 100644
--- a/dlls/msvcrt/tests/string.c
+++ b/dlls/msvcrt/tests/string.c
@@ -89,6 +89,8 @@ static int (__cdecl *p_tolower)(int);
 static size_t (__cdecl *p_mbrlen)(const char*, size_t, mbstate_t*);
 static size_t (__cdecl *p_mbrtowc)(wchar_t*, const char*, size_t, mbstate_t*);
 static int (__cdecl *p__atodbl_l)(_CRT_DOUBLE*,char*,_locale_t);
+static double (__cdecl *p__atof_l)(const char*,_locale_t);
+static double (__cdecl *p__strtod_l)(const char *,char**,_locale_t);
 static int (__cdecl *p__strnset_s)(char*,size_t,int,size_t);
 static int (__cdecl *p__wcsset_s)(wchar_t*,size_t,wchar_t);
 
@@ -1670,6 +1672,28 @@ static void test__strtod(void)
     ok(almost_equal(d, 0), "d = %lf\n", d);
     ok(end == white_chars, "incorrect end (%d)\n", (int)(end-white_chars));
 
+    if (!p__strtod_l)
+        win_skip("_strtod_l not found\n");
+    else
+    {
+        errno = EBADF;
+        d = strtod(NULL, NULL);
+        ok(almost_equal(d, 0.0), "d =  %lf\n", d);
+        ok(errno == EINVAL, "errno = %x\n", errno);
+
+        errno = EBADF;
+        end = (char *)0xdeadbeef;
+        d = strtod(NULL, &end);
+        ok(almost_equal(d, 0.0), "d = %lf\n", d);
+        ok(errno == EINVAL, "errno = %x\n", errno);
+        ok(!end, "incorrect end ptr %p\n", end);
+
+        errno = EBADF;
+        d = p__strtod_l(NULL, NULL, NULL);
+        ok(almost_equal(d, 0.0), "d = %lf\n", d);
+        ok(errno == EINVAL, "errno = %x\n", errno);
+    }
+
     /* Set locale with non '.' decimal point (',') */
     if(!setlocale(LC_ALL, "Polish")) {
         win_skip("system with limited locales\n");
@@ -2713,6 +2737,36 @@ static void test_atoi(void)
     ok(r == 0, "atoi(4294967296) = %d\n", r);
 }
 
+static void test_atof(void)
+{
+    double d;
+
+    d = atof("0.0");
+    ok(almost_equal(d, 0.0), "d = %lf\n", d);
+
+    d = atof("1.0");
+    ok(almost_equal(d, 1.0), "d = %lf\n", d);
+
+    d = atof("-1.0");
+    ok(almost_equal(d, -1.0), "d = %lf\n", d);
+
+    if (!p__atof_l)
+    {
+        win_skip("_atof_l not found\n");
+        return;
+    }
+
+    errno = EBADF;
+    d = atof(NULL);
+    ok(almost_equal(d, 0.0), "d = %lf\n", d);
+    ok(errno == EINVAL, "errno = %x\n", errno);
+
+    errno = EBADF;
+    d = p__atof_l(NULL, NULL);
+    ok(almost_equal(d, 0.0), "d = %lf\n", d);
+    ok(errno == EINVAL, "errno = %x\n", errno);
+}
+
 static void test_strncpy(void)
 {
 #define TEST_STRNCPY_LEN 10
@@ -2921,6 +2975,8 @@ START_TEST(string)
     p_mbrtowc = (void*)GetProcAddress(hMsvcrt, "mbrtowc");
     p_mbsrtowcs = (void*)GetProcAddress(hMsvcrt, "mbsrtowcs");
     p__atodbl_l = (void*)GetProcAddress(hMsvcrt, "_atodbl_l");
+    p__atof_l = (void*)GetProcAddress(hMsvcrt, "_atof_l");
+    p__strtod_l = (void*)GetProcAddress(hMsvcrt, "_strtod_l");
     p__strnset_s = (void*)GetProcAddress(hMsvcrt, "_strnset_s");
     p__wcsset_s = (void*)GetProcAddress(hMsvcrt, "_wcsset_s");
 
@@ -2977,6 +3033,7 @@ START_TEST(string)
     test__stricmp();
     test__wcstoi64();
     test_atoi();
+    test_atof();
     test_strncpy();
     test_strxfrm();
     test__strnset_s();
diff --git a/dlls/msvfw32/msvideo_main.c b/dlls/msvfw32/msvideo_main.c
index b6b7507..82b732b 100644
--- a/dlls/msvfw32/msvideo_main.c
+++ b/dlls/msvfw32/msvideo_main.c
@@ -1447,7 +1447,7 @@ BOOL VFWAPI ICSeqCompressFrameStart(PCOMPVARS pc, LPBITMAPINFO lpbiIn)
     }
     pc->cbState = sizeof(ICCOMPRESS);
 
-    pc->lpBitsOut = HeapAlloc(GetProcessHeap(), 0, pc->lpbiOut->bmiHeader.biSizeImage);
+    pc->lpBitsOut = HeapAlloc(GetProcessHeap(), 0, pc->lpbiIn->bmiHeader.biSizeImage);
     if (!pc->lpBitsOut)
     {
        HeapFree(GetProcessHeap(), 0, pc->lpbiIn);
diff --git a/dlls/msxml3/node.c b/dlls/msxml3/node.c
index 7119a43..1ddc9bf 100644
--- a/dlls/msxml3/node.c
+++ b/dlls/msxml3/node.c
@@ -2055,6 +2055,7 @@ IXMLDOMNode *create_node( xmlNodePtr node )
         new_node->ref = 1;
         init_xmlnode(&new_node->node, node, &new_node->IXMLDOMNode_iface, NULL);
         pUnk = (IUnknown*)&new_node->IXMLDOMNode_iface;
+        break;
     }
     default:
         ERR("Called for unsupported node type %d\n", node->type);
diff --git a/dlls/netapi32/netapi32.c b/dlls/netapi32/netapi32.c
index 33c0c17..4889554 100644
--- a/dlls/netapi32/netapi32.c
+++ b/dlls/netapi32/netapi32.c
@@ -779,7 +779,7 @@ static NET_API_STATUS share_info_to_samba( DWORD level, const BYTE *buf, unsigne
 static NET_API_STATUS share_add( LMSTR servername, DWORD level, LPBYTE buf, LPDWORD parm_err )
 {
     char *server = NULL;
-    unsigned char *info;
+    unsigned char *info = NULL;
     NET_API_STATUS status;
 
     if (servername && !(server = strdup_unixcp( servername ))) return ERROR_OUTOFMEMORY;
diff --git a/dlls/ntdll/actctx.c b/dlls/ntdll/actctx.c
index 715a760..558924d 100644
--- a/dlls/ntdll/actctx.c
+++ b/dlls/ntdll/actctx.c
@@ -4431,6 +4431,9 @@ static NTSTATUS find_string(ACTIVATION_CONTEXT* actctx, ULONG section_kind,
 
     switch (section_kind)
     {
+    case ACTIVATION_CONTEXT_SECTION_ASSEMBLY_INFORMATION:
+        FIXME("Unsupported yet section_kind %x\n", section_kind);
+        return STATUS_SXS_KEY_NOT_FOUND;
     case ACTIVATION_CONTEXT_SECTION_DLL_REDIRECTION:
         status = find_dll_redirection(actctx, section_name, data);
         break;
diff --git a/dlls/ntdll/cdrom.c b/dlls/ntdll/cdrom.c
index 34910e7..63a3c74 100644
--- a/dlls/ntdll/cdrom.c
+++ b/dlls/ntdll/cdrom.c
@@ -2491,6 +2491,28 @@ static NTSTATUS DVD_GetRegion(int fd, PDVD_REGION region)
 #endif
 }
 
+static DWORD DVD_ReadStructureSize(const DVD_READ_STRUCTURE *structure, DWORD size)
+{
+    if (!structure || size != sizeof(DVD_READ_STRUCTURE))
+        return 0;
+
+    switch (structure->Format)
+    {
+    case DvdPhysicalDescriptor:
+        return sizeof(DVD_LAYER_DESCRIPTOR);
+    case DvdCopyrightDescriptor:
+        return sizeof(DVD_COPYRIGHT_DESCRIPTOR);
+    case DvdDiskKeyDescriptor:
+        return sizeof(DVD_DISK_KEY_DESCRIPTOR);
+    case DvdBCADescriptor:
+        return sizeof(DVD_BCA_DESCRIPTOR);
+    case DvdManufacturerDescriptor:
+        return sizeof(DVD_MANUFACTURER_DESCRIPTOR);
+    default:
+        return 0;
+    }
+}
+
 /******************************************************************
  *		DVD_ReadStructure
  *
@@ -3094,7 +3116,7 @@ NTSTATUS CDROM_DeviceIoControl(HANDLE hDevice,
         status = DVD_GetRegion(fd, lpOutBuffer);
         break;
     case IOCTL_DVD_READ_STRUCTURE:
-        sz = sizeof(DVD_LAYER_DESCRIPTOR);
+        sz = DVD_ReadStructureSize(lpInBuffer, nInBufferSize);
         if (lpInBuffer == NULL || nInBufferSize != sizeof(DVD_READ_STRUCTURE)) status = STATUS_INVALID_PARAMETER;
         else if (nOutBufferSize < sz || !lpOutBuffer) status = STATUS_BUFFER_TOO_SMALL;
         else
diff --git a/dlls/ntdll/directory.c b/dlls/ntdll/directory.c
index cbfc022..1760b5b 100644
--- a/dlls/ntdll/directory.c
+++ b/dlls/ntdll/directory.c
@@ -1198,17 +1198,17 @@ static DWORD WINAPI init_options( RTL_RUN_ONCE *once, void *param, void **contex
  *
  * Check if the specified file should be hidden based on its name and the show dot files option.
  */
-BOOL DIR_is_hidden_file( const UNICODE_STRING *name )
+BOOL DIR_is_hidden_file( const char *name )
 {
-    WCHAR *p, *end;
+    char *p, *end;
 
     RtlRunOnceExecuteOnce( &init_once, init_options, NULL, NULL );
 
     if (show_dot_files) return FALSE;
 
-    end = p = name->Buffer + name->Length/sizeof(WCHAR);
-    while (p > name->Buffer && IS_SEPARATOR(p[-1])) p--;
-    while (p > name->Buffer && !IS_SEPARATOR(p[-1])) p--;
+    end = p = (char *)name + strlen(name);
+    while (p > name && IS_SEPARATOR(p[-1])) p--;
+    while (p > name && !IS_SEPARATOR(p[-1])) p--;
     if (p == end || *p != '.') return FALSE;
     /* make sure it isn't '.' or '..' */
     if (p + 1 == end) return FALSE;
@@ -1423,9 +1423,6 @@ static union file_directory_info *append_entry( void *info_ptr, IO_STATUS_BLOCK
         TRACE( "ignoring file %s\n", long_name );
         return NULL;
     }
-    if (!show_dot_files && long_name[0] == '.' && long_name[1] && (long_name[1] != '.' || long_name[2]))
-        attributes |= FILE_ATTRIBUTE_HIDDEN;
-
     total_len = dir_info_size( class, long_len );
     if (io->Information + total_len > max_length)
     {
@@ -3006,6 +3003,7 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
                                           UINT disposition, BOOLEAN check_case )
 {
     static const WCHAR unixW[] = {'u','n','i','x'};
+    static const WCHAR pipeW[] = {'p','i','p','e'};
     static const WCHAR invalid_charsW[] = { INVALID_NT_CHARS, 0 };
 
     NTSTATUS status = STATUS_SUCCESS;
@@ -3016,6 +3014,7 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
     int pos, ret, name_len, unix_len, prefix_len, used_default;
     WCHAR prefix[MAX_DIR_ENTRY_LEN];
     BOOLEAN is_unix = FALSE;
+    BOOLEAN is_pipe = FALSE;
 
     name     = nameW->Buffer;
     name_len = nameW->Length / sizeof(WCHAR);
@@ -3047,13 +3046,17 @@ NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRI
     name += prefix_len;
     name_len -= prefix_len;
 
-    /* check for invalid characters (all chars except 0 are valid for unix) */
-    is_unix = (prefix_len == 4 && !memcmp( prefix, unixW, sizeof(unixW) ));
-    if (is_unix)
+    /* check for invalid characters (all chars except 0 are valid for unix and pipes) */
+    if (prefix_len == 4)
+    {
+        is_unix = !memcmp( prefix, unixW, sizeof(unixW) );
+        is_pipe = !memcmp( prefix, pipeW, sizeof(pipeW) );
+    }
+    if (is_unix || is_pipe)
     {
         for (p = name; p < name + name_len; p++)
             if (!*p) return STATUS_OBJECT_NAME_INVALID;
-        check_case = TRUE;
+        check_case |= is_unix;
     }
     else
     {
diff --git a/dlls/ntdll/file.c b/dlls/ntdll/file.c
index 0dc5c13..54a1900 100644
--- a/dlls/ntdll/file.c
+++ b/dlls/ntdll/file.c
@@ -76,6 +76,10 @@
 # include <valgrind/memcheck.h>
 #endif
 
+#ifndef SO_PEEK_OFF
+#define SO_PEEK_OFF 42
+#endif
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #define NONAMELESSUNION
@@ -88,12 +92,14 @@
 #include "winioctl.h"
 #include "ddk/ntddk.h"
 #include "ddk/ntddser.h"
+#include "ntifs.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 mode_t FILE_umask = 0;
 
+#define WINE_TEMPLINK      P_tmpdir"/winelink.XXXXXX"
 #define SECSPERDAY         86400
 #define SECS_1601_TO_1970  ((369 * 365 + 89) * (ULONGLONG)SECSPERDAY)
 
@@ -102,6 +108,22 @@ mode_t FILE_umask = 0;
 
 static const WCHAR ntfsW[] = {'N','T','F','S'};
 
+/* Match the Samba conventions for storing DOS file attributes */
+#define SAMBA_XATTR_DOS_ATTRIB XATTR_USER_PREFIX "DOSATTRIB"
+/* We are only interested in some attributes, the others have corresponding Unix attributes */
+#define XATTR_ATTRIBS_MASK     (FILE_ATTRIBUTE_HIDDEN|FILE_ATTRIBUTE_SYSTEM)
+
+/* decode the xattr-stored DOS attributes */
+static inline int get_file_xattr( char *hexattr, int attrlen )
+{
+    if (attrlen > 2 && hexattr[0] == '0' && hexattr[1] == 'x')
+    {
+        hexattr[attrlen] = 0;
+        return strtol( hexattr+2, NULL, 16 ) & XATTR_ATTRIBS_MASK;
+    }
+    return 0;
+}
+
 /* fetch the attributes of a file */
 static inline ULONG get_file_attributes( const struct stat *st )
 {
@@ -119,19 +141,57 @@ static inline ULONG get_file_attributes( const struct stat *st )
 /* get the stat info and file attributes for a file (by file descriptor) */
 int fd_get_file_info( int fd, struct stat *st, ULONG *attr )
 {
-    int ret;
+    char hexattr[11];
+    int len, ret;
 
     *attr = 0;
     ret = fstat( fd, st );
     if (ret == -1) return ret;
     *attr |= get_file_attributes( st );
+    len = xattr_fget( fd, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
+    if (len == -1) return ret;
+    *attr |= get_file_xattr( hexattr, len );
     return ret;
 }
 
+/* set the stat info and file attributes for a file (by file descriptor) */
+NTSTATUS fd_set_file_info( int fd, ULONG attr )
+{
+    char hexattr[11];
+    struct stat st;
+
+    if (fstat( fd, &st ) == -1) return FILE_GetNtStatus();
+    if (attr & FILE_ATTRIBUTE_READONLY)
+    {
+        if (S_ISDIR( st.st_mode))
+            WARN("FILE_ATTRIBUTE_READONLY ignored for directory.\n");
+        else
+            st.st_mode &= ~0222; /* clear write permission bits */
+    }
+    else
+    {
+        /* add write permission only where we already have read permission */
+        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~FILE_umask);
+    }
+    if (fchmod( fd, st.st_mode ) == -1) return FILE_GetNtStatus();
+    attr &= ~FILE_ATTRIBUTE_NORMAL; /* do not store everything, but keep everything Samba can use */
+    if (attr != 0)
+    {
+        int len;
+
+        len = sprintf( hexattr, "0x%x", attr );
+        xattr_fset( fd, SAMBA_XATTR_DOS_ATTRIB, hexattr, len );
+    }
+    else
+        xattr_fremove( fd, SAMBA_XATTR_DOS_ATTRIB );
+    return STATUS_SUCCESS;
+}
+
 /* get the stat info and file attributes for a file (by name) */
 int get_file_info( const char *path, struct stat *st, ULONG *attr )
 {
-    int ret;
+    char hexattr[11];
+    int len, ret;
 
     *attr = 0;
     ret = lstat( path, st );
@@ -144,9 +204,31 @@ int get_file_info( const char *path, struct stat *st, ULONG *attr )
         if (S_ISDIR( st->st_mode )) *attr |= FILE_ATTRIBUTE_REPARSE_POINT;
     }
     *attr |= get_file_attributes( st );
+    /* convert Unix-style hidden files to a DOS hidden file attribute */
+    if (DIR_is_hidden_file( path ))
+        *attr |= FILE_ATTRIBUTE_HIDDEN;
+    /* retrieve any stored DOS attributes */
+    len = xattr_get( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, sizeof(hexattr)-1 );
+    if (len == -1) return ret;
+    *attr |= get_file_xattr( hexattr, len );
     return ret;
 }
 
+NTSTATUS set_file_info( const char *path, ULONG attr )
+{
+    char hexattr[11];
+    int len;
+
+    /* Note: unix mode already set when called this way */
+    attr &= ~FILE_ATTRIBUTE_NORMAL; /* do not store everything, but keep everything Samba can use */
+    len = sprintf( hexattr, "0x%x", attr );
+    if (attr != 0)
+        xattr_set( path, SAMBA_XATTR_DOS_ATTRIB, hexattr, len );
+    else
+        xattr_remove( path, SAMBA_XATTR_DOS_ATTRIB );
+    return STATUS_SUCCESS;
+}
+
 /**************************************************************************
  *                 FILE_CreateFile                    (internal)
  * Open a file.
@@ -158,6 +240,8 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
                                  ULONG attributes, ULONG sharing, ULONG disposition,
                                  ULONG options, PVOID ea_buffer, ULONG ea_length )
 {
+    struct object_attributes objattr;
+    struct security_descriptor *sd;
     ANSI_STRING unix_name;
     BOOL created = FALSE;
 
@@ -201,39 +285,37 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
         io->u.Status = STATUS_SUCCESS;
     }
 
-    if (io->u.Status == STATUS_SUCCESS)
+    if (io->u.Status != STATUS_SUCCESS)
     {
-        struct security_descriptor *sd;
-        struct object_attributes objattr;
-
-        objattr.rootdir = wine_server_obj_handle( attr->RootDirectory );
-        objattr.name_len = 0;
-        io->u.Status = NTDLL_create_struct_sd( attr->SecurityDescriptor, &sd, &objattr.sd_len );
-        if (io->u.Status != STATUS_SUCCESS)
-        {
-            RtlFreeAnsiString( &unix_name );
-            return io->u.Status;
-        }
+        WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
+        return io->u.Status;
+    }
 
-        SERVER_START_REQ( create_file )
-        {
-            req->access     = access;
-            req->attributes = attr->Attributes;
-            req->sharing    = sharing;
-            req->create     = disposition;
-            req->options    = options;
-            req->attrs      = attributes;
-            wine_server_add_data( req, &objattr, sizeof(objattr) );
-            if (objattr.sd_len) wine_server_add_data( req, sd, objattr.sd_len );
-            wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
-            io->u.Status = wine_server_call( req );
-            *handle = wine_server_ptr_handle( reply->handle );
-        }
-        SERVER_END_REQ;
-        NTDLL_free_struct_sd( sd );
+    objattr.rootdir = wine_server_obj_handle( attr->RootDirectory );
+    objattr.name_len = 0;
+    io->u.Status = NTDLL_create_struct_sd( attr->SecurityDescriptor, &sd, &objattr.sd_len );
+    if (io->u.Status != STATUS_SUCCESS)
+    {
         RtlFreeAnsiString( &unix_name );
+        return io->u.Status;
     }
-    else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), io->u.Status );
+
+    SERVER_START_REQ( create_file )
+    {
+        req->access     = access;
+        req->attributes = attr->Attributes;
+        req->sharing    = sharing;
+        req->create     = disposition;
+        req->options    = options;
+        req->attrs      = attributes;
+        wine_server_add_data( req, &objattr, sizeof(objattr) );
+        if (objattr.sd_len) wine_server_add_data( req, sd, objattr.sd_len );
+        wine_server_add_data( req, unix_name.Buffer, unix_name.Length );
+        io->u.Status = wine_server_call( req );
+        *handle = wine_server_ptr_handle( reply->handle );
+    }
+    SERVER_END_REQ;
+    NTDLL_free_struct_sd( sd );
 
     if (io->u.Status == STATUS_SUCCESS)
     {
@@ -255,6 +337,11 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
             io->Information = FILE_OVERWRITTEN;
             break;
         }
+        if (io->Information == FILE_CREATED)
+        {
+            /* set any DOS extended attributes */
+            set_file_info( unix_name.Buffer, attributes );
+        }
     }
     else if (io->u.Status == STATUS_TOO_MANY_OPENED_FILES)
     {
@@ -262,6 +349,7 @@ static NTSTATUS FILE_CreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATT
         if (!once++) ERR_(winediag)( "Too many open files, ulimit -n probably needs to be increased\n" );
     }
 
+    RtlFreeAnsiString( &unix_name );
     return io->u.Status;
 }
 
@@ -331,6 +419,7 @@ NTSTATUS WINAPI NtCreateFile( PHANDLE handle, ACCESS_MASK access, POBJECT_ATTRIB
 struct async_fileio
 {
     struct async_fileio *next;
+    DWORD                size;
     HANDLE               handle;
     PIO_APC_ROUTINE      apc;
     void                *apc_arg;
@@ -369,17 +458,28 @@ static struct async_fileio *alloc_fileio( DWORD size, HANDLE handle, PIO_APC_ROU
 {
     /* first free remaining previous fileinfos */
 
-    struct async_fileio *io = interlocked_xchg_ptr( (void **)&fileio_freelist, NULL );
+    struct async_fileio *old_io = interlocked_xchg_ptr( (void **)&fileio_freelist, NULL );
+    struct async_fileio *io = NULL;
 
-    while (io)
+    while (old_io)
     {
-        struct async_fileio *next = io->next;
-        RtlFreeHeap( GetProcessHeap(), 0, io );
-        io = next;
+        if (!io && old_io->size >= size && old_io->size <= max(4096, 4 * size))
+        {
+            io     = old_io;
+            size   = old_io->size;
+            old_io = old_io->next;
+        }
+        else
+        {
+            struct async_fileio *next = old_io->next;
+            RtlFreeHeap( GetProcessHeap(), 0, old_io );
+            old_io = next;
+        }
     }
 
-    if ((io = RtlAllocateHeap( GetProcessHeap(), 0, size )))
+    if (io || (io = RtlAllocateHeap( GetProcessHeap(), 0, size )))
     {
+        io->size    = size;
         io->handle  = handle;
         io->apc     = apc;
         io->apc_arg = arg;
@@ -436,6 +536,140 @@ NTSTATUS FILE_GetNtStatus(void)
     }
 }
 
+/* helper function for FSCTL_PIPE_PEEK and read_unix_fd */
+static NTSTATUS unix_fd_avail(int fd, int *avail)
+{
+    struct pollfd pollfd;
+    int ret;
+    *avail = 0;
+
+#ifdef FIONREAD
+    if (ioctl( fd, FIONREAD, avail ) != 0)
+    {
+        TRACE("FIONREAD failed reason: %s\n", strerror(errno));
+        return FILE_GetNtStatus();
+    }
+    if (*avail)
+        return STATUS_SUCCESS;
+#endif
+
+    pollfd.fd = fd;
+    pollfd.events = POLLIN;
+    pollfd.revents = 0;
+    ret = poll( &pollfd, 1, 0 );
+    return (ret == -1 || (ret == 1 && (pollfd.revents & (POLLHUP|POLLERR)))) ?
+           STATUS_PIPE_BROKEN : STATUS_SUCCESS;
+}
+
+/* returns the pipe flags for a file descriptor */
+static inline int get_pipe_flags(int fd)
+{
+#ifdef __linux__
+    int flags = fcntl( fd, F_GETSIG );
+
+    /* NAMED_PIPE_MESSAGE_STREAM_READ only allowed in
+     * combination with NAMED_PIPE_MESSAGE_STREAM_WRITE. */
+    if (!(flags & NAMED_PIPE_MESSAGE_STREAM_WRITE))
+        flags &= ~NAMED_PIPE_MESSAGE_STREAM_READ;
+
+    return flags;
+#else
+    return 0;
+#endif
+}
+
+/* helper function for NtReadFile and FILE_AsyncReadService */
+static NTSTATUS read_unix_fd(int fd, char *buf, ULONG *total, ULONG length,
+                             enum server_fd_type type, BOOL avail_mode)
+{
+    struct msghdr msg;
+    struct iovec iov;
+    int pipe_flags = 0, result;
+
+    if (type == FD_TYPE_PIPE)
+        pipe_flags = get_pipe_flags( fd );
+
+    for(;;)
+    {
+        if (pipe_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE)
+        {
+            int recvmsg_flags = MSG_PEEK;
+            if (*total || (pipe_flags & NAMED_PIPE_NONBLOCKING_MODE))
+                recvmsg_flags |= MSG_DONTWAIT;
+
+            msg.msg_name        = NULL;
+            msg.msg_namelen     = 0;
+            msg.msg_iov         = &iov;
+            msg.msg_iovlen      = 1;
+            msg.msg_control     = NULL;
+            msg.msg_controllen  = 0;
+            msg.msg_flags       = 0;
+
+            iov.iov_base = buf    + *total;
+            iov.iov_len  = length - *total;
+
+            result = recvmsg( fd, &msg, recvmsg_flags );
+            if (result >= 0 && !(msg.msg_flags & MSG_TRUNC))
+            {
+                int ret;
+                while (!(ret = recv( fd, NULL, 0, MSG_TRUNC)) && result > 0);
+                if (ret < 0) ERR("dequeue message failed reason: %s\n", strerror(errno));
+            }
+        }
+        else if (pipe_flags & NAMED_PIPE_NONBLOCKING_MODE)
+            result = recv( fd, buf + *total, length - *total, MSG_DONTWAIT );
+        else
+            result = read( fd, buf + *total, length - *total );
+
+        if (result >= 0)
+        {
+            *total += result;
+            if (!result || *total >= length || (avail_mode && !(pipe_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE)) ||
+                ((pipe_flags & NAMED_PIPE_MESSAGE_STREAM_READ) && !(msg.msg_flags & MSG_TRUNC)))
+            {
+                if (*total)
+                    return ((pipe_flags & NAMED_PIPE_MESSAGE_STREAM_READ) && (msg.msg_flags & MSG_TRUNC)) ?
+                           STATUS_BUFFER_OVERFLOW : STATUS_SUCCESS;
+                switch (type)
+                {
+                case FD_TYPE_FILE:
+                case FD_TYPE_CHAR:
+                    return length ? STATUS_END_OF_FILE : STATUS_SUCCESS;
+                case FD_TYPE_SERIAL:
+                    return STATUS_PENDING;
+                case FD_TYPE_PIPE:
+                    {
+                        NTSTATUS status = unix_fd_avail( fd, &result );
+                        if (!status && !result && !length) status = STATUS_PENDING;
+                        return status;
+                    }
+                default:
+                    return STATUS_PIPE_BROKEN;
+                }
+            }
+            else if ((pipe_flags & (NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ)) ==
+                     NAMED_PIPE_MESSAGE_STREAM_WRITE)
+                continue;
+            else if (type != FD_TYPE_FILE) /* no async I/O on regular files */
+                return STATUS_PENDING;
+        }
+        else if (errno == EAGAIN)
+        {
+            if (avail_mode && *total)
+                return STATUS_SUCCESS;
+            else if (pipe_flags & NAMED_PIPE_NONBLOCKING_MODE)
+                return *total ? STATUS_SUCCESS : STATUS_PIPE_EMPTY;
+            else
+                return STATUS_PENDING;
+        }
+        else if (errno == EFAULT && wine_uninterrupted_write_memory( buf + *total, NULL, length - *total ) >= (length - *total))
+            continue;
+        else if (errno != EINTR)
+            return FILE_GetNtStatus();
+    }
+    return STATUS_UNSUCCESSFUL; /* never reached */
+}
+
 /***********************************************************************
  *             FILE_AsyncReadService      (INTERNAL)
  */
@@ -443,44 +677,19 @@ static NTSTATUS FILE_AsyncReadService( void *user, IO_STATUS_BLOCK *iosb,
                                        NTSTATUS status, void **apc, void **arg )
 {
     struct async_fileio_read *fileio = user;
-    int fd, needs_close, result;
+    int fd, needs_close;
+    enum server_fd_type type;
 
     switch (status)
     {
     case STATUS_ALERTED: /* got some new data */
         /* check to see if the data is ready (non-blocking) */
         if ((status = server_get_unix_fd( fileio->io.handle, FILE_READ_DATA, &fd,
-                                          &needs_close, NULL, NULL )))
+                                          &needs_close, &type, NULL )))
             break;
-
-        result = read(fd, &fileio->buffer[fileio->already], fileio->count - fileio->already);
+        status = read_unix_fd( fd, fileio->buffer, &fileio->already, fileio->count,
+                               type, fileio->avail_mode );
         if (needs_close) close( fd );
-
-        if (result < 0)
-        {
-            if (errno == EAGAIN || errno == EINTR)
-                status = STATUS_PENDING;
-            else /* check to see if the transfer is complete */
-                status = FILE_GetNtStatus();
-        }
-        else if (result == 0)
-        {
-            status = fileio->already ? STATUS_SUCCESS : STATUS_PIPE_BROKEN;
-        }
-        else
-        {
-            fileio->already += result;
-            if (fileio->already >= fileio->count || fileio->avail_mode)
-                status = STATUS_SUCCESS;
-            else
-            {
-                /* if we only have to read the available data, and none is available,
-                 * simply cancel the request. If data was available, it has been read
-                 * while in by previous call (NtDelayExecution)
-                 */
-                status = (fileio->avail_mode) ? STATUS_SUCCESS : STATUS_PENDING;
-            }
-        }
         break;
 
     case STATUS_TIMEOUT:
@@ -631,7 +840,6 @@ static NTSTATUS get_io_avail_mode( HANDLE handle, enum server_fd_type type, BOOL
     return status;
 }
 
-
 /******************************************************************************
  *  NtReadFile					[NTDLL.@]
  *  ZwReadFile					[NTDLL.@]
@@ -698,6 +906,9 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
             /* async I/O doesn't make sense on regular files */
             while ((result = pread( unix_handle, buffer, length, offset->QuadPart )) == -1)
             {
+                if (errno == EFAULT && virtual_check_buffer_for_write( buffer, length ))
+                    continue;
+
                 if (errno != EINTR)
                 {
                     status = FILE_GetNtStatus();
@@ -724,37 +935,9 @@ NTSTATUS WINAPI NtReadFile(HANDLE hFile, HANDLE hEvent,
 
     for (;;)
     {
-        if ((result = read( unix_handle, (char *)buffer + total, length - total )) >= 0)
-        {
-            total += result;
-            if (!result || total == length)
-            {
-                if (total)
-                {
-                    status = STATUS_SUCCESS;
-                    goto done;
-                }
-                switch (type)
-                {
-                case FD_TYPE_FILE:
-                case FD_TYPE_CHAR:
-                    status = length ? STATUS_END_OF_FILE : STATUS_SUCCESS;
-                    goto done;
-                case FD_TYPE_SERIAL:
-                    break;
-                default:
-                    status = STATUS_PIPE_BROKEN;
-                    goto done;
-                }
-            }
-            else if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
-        }
-        else if (errno != EAGAIN)
-        {
-            if (errno == EINTR) continue;
-            if (!total) status = FILE_GetNtStatus();
+        status = read_unix_fd( unix_handle, buffer, &total, length, type, FALSE );
+        if (status != STATUS_PENDING)
             goto done;
-        }
 
         if (async_read)
         {
@@ -836,14 +1019,14 @@ done:
 
 err:
     if (needs_close) close( unix_handle );
-    if (status == STATUS_SUCCESS || (status == STATUS_END_OF_FILE && !async_read))
+    if (status == STATUS_SUCCESS || status == STATUS_BUFFER_OVERFLOW || (status == STATUS_END_OF_FILE && !async_read))
     {
         io_status->u.Status = status;
         io_status->Information = total;
         TRACE("= SUCCESS (%u)\n", total);
         if (hEvent) NtSetEvent( hEvent, NULL );
-        if (apc && !status) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
-                                              (ULONG_PTR)apc_user, (ULONG_PTR)io_status, 0 );
+        if (apc && status != STATUS_END_OF_FILE) NtQueueApcThread( GetCurrentThread(), (PNTAPCFUNC)apc,
+                                                                   (ULONG_PTR)apc_user, (ULONG_PTR)io_status, 0 );
     }
     else
     {
@@ -943,6 +1126,49 @@ NTSTATUS WINAPI NtReadFileScatter( HANDLE file, HANDLE event, PIO_APC_ROUTINE ap
     return status;
 }
 
+/* helper function for NtWriteFile and FILE_AsyncWriteService */
+static NTSTATUS write_unix_fd(int fd, const char *buf, ULONG *total, ULONG length, enum server_fd_type type)
+{
+    ULONG msgsize = (ULONG)-1;
+    int result;
+    for(;;)
+    {
+        if (!length && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_PIPE || type == FD_TYPE_SOCKET))
+            result = send( fd, buf, 0, 0 );
+        else
+            result = write( fd, buf + *total, min(length - *total, msgsize) );
+        if (result >= 0)
+        {
+            *total += result;
+            if (*total >= length)
+                return STATUS_SUCCESS;
+            else if (type != FD_TYPE_FILE) /* no async I/O on regular files */
+                return STATUS_PENDING;
+        }
+        else if (errno == EMSGSIZE && type == FD_TYPE_PIPE && msgsize > 4096)
+        {
+            static ULONG warn_msgsize;
+            if (msgsize == (ULONG)-1) msgsize = (length + 32 + 4095) & ~4095;
+            if (msgsize > warn_msgsize)
+            {
+                FIXME("Message is too big, try to increase /proc/sys/net/core/wmem_default to at least %d\n", msgsize);
+                warn_msgsize = msgsize;
+            }
+            msgsize -= 4096; /* FIXME: use more intelligent algorithm to discover msgsize */
+        }
+        else if (errno != EINTR)
+        {
+            if (errno == EAGAIN)
+                break;
+            else if (*total)
+                return STATUS_SUCCESS;
+            else if (errno == EFAULT)
+                return STATUS_INVALID_USER_BUFFER;
+            return FILE_GetNtStatus();
+        }
+    }
+    return STATUS_PENDING;
+}
 
 /***********************************************************************
  *             FILE_AsyncWriteService      (INTERNAL)
@@ -951,7 +1177,7 @@ static NTSTATUS FILE_AsyncWriteService( void *user, IO_STATUS_BLOCK *iosb,
                                         NTSTATUS status, void **apc, void **arg )
 {
     struct async_fileio_write *fileio = user;
-    int result, fd, needs_close;
+    int fd, needs_close;
     enum server_fd_type type;
 
     switch (status)
@@ -961,24 +1187,8 @@ static NTSTATUS FILE_AsyncWriteService( void *user, IO_STATUS_BLOCK *iosb,
         if ((status = server_get_unix_fd( fileio->io.handle, FILE_WRITE_DATA, &fd,
                                           &needs_close, &type, NULL )))
             break;
-
-        if (!fileio->count && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_PIPE || type == FD_TYPE_SOCKET))
-            result = send( fd, fileio->buffer, 0, 0 );
-        else
-            result = write( fd, &fileio->buffer[fileio->already], fileio->count - fileio->already );
-
+        status = write_unix_fd( fd, fileio->buffer, &fileio->already, fileio->count, type );
         if (needs_close) close( fd );
-
-        if (result < 0)
-        {
-            if (errno == EAGAIN || errno == EINTR) status = STATUS_PENDING;
-            else status = FILE_GetNtStatus();
-        }
-        else
-        {
-            fileio->already += result;
-            status = (fileio->already < fileio->count) ? STATUS_PENDING : STATUS_SUCCESS;
-        }
         break;
 
     case STATUS_TIMEOUT:
@@ -1140,32 +1350,9 @@ NTSTATUS WINAPI NtWriteFile(HANDLE hFile, HANDLE hEvent,
 
     for (;;)
     {
-        /* zero-length writes on sockets may not work with plain write(2) */
-        if (!length && (type == FD_TYPE_MAILSLOT || type == FD_TYPE_PIPE || type == FD_TYPE_SOCKET))
-            result = send( unix_handle, buffer, 0, 0 );
-        else
-            result = write( unix_handle, (const char *)buffer + total, length - total );
-
-        if (result >= 0)
-        {
-            total += result;
-            if (total == length)
-            {
-                status = STATUS_SUCCESS;
-                goto done;
-            }
-            if (type == FD_TYPE_FILE) continue;  /* no async I/O on regular files */
-        }
-        else if (errno != EAGAIN)
-        {
-            if (errno == EINTR) continue;
-            if (!total)
-            {
-                if (errno == EFAULT) status = STATUS_INVALID_USER_BUFFER;
-                else status = FILE_GetNtStatus();
-            }
+        status = write_unix_fd( unix_handle, buffer, &total, length, type );
+        if (status != STATUS_PENDING)
             goto done;
-        }
 
         if (async_write)
         {
@@ -1531,6 +1718,165 @@ NTSTATUS WINAPI NtDeviceIoControlFile(HANDLE handle, HANDLE event,
 }
 
 
+/*
+ * Retrieve the unix name corresponding to a file handle, remove that directory, and then symlink the
+ * requested directory to the location of the old directory.
+ */
+NTSTATUS FILE_CreateSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+{
+    int dest_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
+    int offset = buffer->MountPointReparseBuffer.SubstituteNameOffset;
+    WCHAR *dest = &buffer->MountPointReparseBuffer.PathBuffer[offset];
+    char tmplink[] = WINE_TEMPLINK;
+    ANSI_STRING unix_src, unix_dest;
+    BOOL dest_allocated = FALSE;
+    int dest_fd, needs_close;
+    UNICODE_STRING nt_dest;
+    NTSTATUS status;
+
+    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
+        return status;
+
+    if ((status = server_get_unix_name( handle, &unix_src )))
+        goto cleanup;
+
+    nt_dest.Buffer = dest;
+    nt_dest.Length = dest_len;
+    if ((status = wine_nt_to_unix_file_name( &nt_dest, &unix_dest, FILE_OPEN, FALSE )))
+        goto cleanup;
+    dest_allocated = TRUE;
+
+    TRACE("Linking %s to %s\n", unix_src.Buffer, unix_dest.Buffer);
+
+    /* Produce the link in a temporary location */
+    while(1)
+    {
+        int fd;
+
+        memcpy( tmplink, WINE_TEMPLINK, sizeof(tmplink) );
+        fd = mkstemps( tmplink, 0 );
+        if (fd == -1) break;
+        if (!unlink( tmplink ))
+        {
+            if (!symlink( unix_dest.Buffer, tmplink ))
+                break;
+        }
+        close(fd);
+    }
+    /* Atomically move the link into position */
+    if (rename( tmplink, unix_src.Buffer ))
+    {
+        unlink( tmplink );
+        FIXME("Atomic replace of directory with symbolic link unsupported on this system, may result in race condition.\n");
+        if (rmdir( unix_src.Buffer ) < 0)
+        {
+            status = FILE_GetNtStatus();
+            goto cleanup;
+        }
+        if (symlink( unix_dest.Buffer, unix_src.Buffer ) < 0)
+        {
+            status = FILE_GetNtStatus();
+            goto cleanup;
+        }
+    }
+    status = STATUS_SUCCESS;
+
+cleanup:
+    if (dest_allocated) RtlFreeAnsiString( &unix_dest );
+    if (needs_close) close( dest_fd );
+    return status;
+}
+
+
+/*
+ * Retrieve the unix name corresponding to a file handle and use that to find the destination of the symlink
+ * corresponding to that file handle.
+ */
+NTSTATUS FILE_GetSymlink(HANDLE handle, REPARSE_DATA_BUFFER *buffer)
+{
+    ANSI_STRING unix_src, unix_dest;
+    BOOL dest_allocated = FALSE;
+    int dest_fd, needs_close;
+    UNICODE_STRING nt_dest;
+    NTSTATUS status;
+    VOID *dest_name;
+    ssize_t ret;
+
+    if ((status = server_get_unix_fd( handle, FILE_ANY_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
+        return status;
+
+    if ((status = server_get_unix_name( handle, &unix_src )))
+        goto cleanup;
+
+    unix_dest.Buffer = RtlAllocateHeap( GetProcessHeap(), 0, PATH_MAX );
+    unix_dest.MaximumLength = PATH_MAX;
+    dest_allocated = TRUE;
+    ret = readlink( unix_src.Buffer, unix_dest.Buffer, unix_dest.MaximumLength );
+    if (ret < 0)
+    {
+        status = FILE_GetNtStatus();
+        goto cleanup;
+    }
+    unix_dest.Length = ret;
+
+    if ((status = wine_unix_to_nt_file_name( &unix_dest, &nt_dest )))
+        goto cleanup;
+
+    if (nt_dest.Length > buffer->MountPointReparseBuffer.SubstituteNameLength)
+    {
+        status = STATUS_BUFFER_TOO_SMALL;
+        goto cleanup;
+    }
+
+    buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+    buffer->MountPointReparseBuffer.SubstituteNameLength = nt_dest.Length;
+    buffer->MountPointReparseBuffer.SubstituteNameOffset = 0;
+    dest_name = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset];
+    memcpy( dest_name, nt_dest.Buffer, nt_dest.Length );
+    status = STATUS_SUCCESS;
+
+cleanup:
+    if (dest_allocated) RtlFreeAnsiString( &unix_dest );
+    if (needs_close) close( dest_fd );
+    return status;
+}
+
+
+/*
+ * Retrieve the unix name corresponding to a file handle, remove that symlink, and then recreate
+ * a directory at the location of the old filename.
+ */
+NTSTATUS FILE_RemoveSymlink(HANDLE handle, REPARSE_GUID_DATA_BUFFER *buffer)
+{
+    int dest_fd, needs_close;
+    ANSI_STRING unix_name;
+    NTSTATUS status;
+
+    if ((status = server_get_unix_fd( handle, FILE_SPECIAL_ACCESS, &dest_fd, &needs_close, NULL, NULL )))
+        return status;
+
+    if ((status = server_get_unix_name( handle, &unix_name )))
+        goto cleanup;
+
+    TRACE("Deleting symlink %s\n", unix_name.Buffer);
+    if (unlink( unix_name.Buffer ) < 0)
+    {
+        status = FILE_GetNtStatus();
+        goto cleanup;
+    }
+    if (mkdir( unix_name.Buffer, 0775 ) < 0)
+    {
+        status = FILE_GetNtStatus();
+        goto cleanup;
+    }
+    status = STATUS_SUCCESS;
+
+cleanup:
+    if (needs_close) close( dest_fd );
+    return status;
+}
+
+
 /**************************************************************************
  *              NtFsControlFile                 [NTDLL.@]
  *              ZwFsControlFile                 [NTDLL.@]
@@ -1589,43 +1935,41 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
             if ((status = server_get_unix_fd( handle, FILE_READ_DATA, &fd, &needs_close, NULL, NULL )))
                 break;
 
-#ifdef FIONREAD
-            if (ioctl( fd, FIONREAD, &avail ) != 0)
-            {
-                TRACE("FIONREAD failed reason: %s\n",strerror(errno));
-                if (needs_close) close( fd );
-                status = FILE_GetNtStatus();
-                break;
-            }
-#endif
-            if (!avail)  /* check for closed pipe */
+            status = unix_fd_avail( fd, &avail );
+            if (!status)
             {
-                struct pollfd pollfd;
-                int ret;
+                ULONG data_size = out_size - FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
+                int pipe_flags = get_pipe_flags( fd );
 
-                pollfd.fd = fd;
-                pollfd.events = POLLIN;
-                pollfd.revents = 0;
-                ret = poll( &pollfd, 1, 0 );
-                if (ret == -1 || (ret == 1 && (pollfd.revents & (POLLHUP|POLLERR))))
+                buffer->NamedPipeState    = 0;  /* FIXME */
+                buffer->ReadDataAvailable = avail;
+                buffer->NumberOfMessages  = 0;
+                buffer->MessageLength     = 0;
+                io->Information = FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
+
+                if (pipe_flags & NAMED_PIPE_MESSAGE_STREAM_WRITE)
                 {
-                    if (needs_close) close( fd );
-                    status = STATUS_PIPE_BROKEN;
-                    break;
+                    int peek_offset;
+                    socklen_t sock_opt_len = sizeof(peek_offset);
+                    if (getsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &peek_offset, &sock_opt_len ))
+                        ERR("getsockopt(SO_PEEK_OFF) failed reason: %s\n", strerror(errno));
+                    else
+                    {
+                        char *data = data_size ? buffer->Data : NULL;
+                        int res = recv( fd, data, data_size, MSG_PEEK | MSG_TRUNC | MSG_DONTWAIT );
+                        if (res >= 0) io->Information += min(res, data_size);
+
+                        if (setsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &peek_offset, sizeof(peek_offset) ))
+                            ERR("setsockopt(SO_PEEK_OFF) failed reason: %s\n", strerror(errno));
+
+                        buffer->ReadDataAvailable = avail - peek_offset;
+                        buffer->NumberOfMessages  = avail > peek_offset; /* FIXME */
+                        buffer->MessageLength     = max(0, res);
+                    }
                 }
-            }
-            buffer->NamedPipeState    = 0;  /* FIXME */
-            buffer->ReadDataAvailable = avail;
-            buffer->NumberOfMessages  = 0;  /* FIXME */
-            buffer->MessageLength     = 0;  /* FIXME */
-            io->Information = FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
-            status = STATUS_SUCCESS;
-            if (avail)
-            {
-                ULONG data_size = out_size - FIELD_OFFSET( FILE_PIPE_PEEK_BUFFER, Data );
-                if (data_size)
+                else if (avail && data_size)
                 {
-                    int res = recv( fd, buffer->Data, data_size, MSG_PEEK );
+                    int res = recv( fd, buffer->Data, data_size, MSG_PEEK | MSG_DONTWAIT );
                     if (res >= 0) io->Information += res;
                 }
             }
@@ -1678,6 +2022,48 @@ NTSTATUS WINAPI NtFsControlFile(HANDLE handle, HANDLE event, PIO_APC_ROUTINE apc
         }
         break;
     }
+
+    case FSCTL_DELETE_REPARSE_POINT:
+    {
+        REPARSE_GUID_DATA_BUFFER *buffer = (REPARSE_GUID_DATA_BUFFER *)in_buffer;
+
+        switch(buffer->ReparseTag)
+        {
+        case IO_REPARSE_TAG_MOUNT_POINT:
+            status = FILE_RemoveSymlink( handle, buffer );
+            break;
+        default:
+            FIXME("stub: FSCTL_DELETE_REPARSE_POINT(%x)\n", buffer->ReparseTag);
+            status = STATUS_NOT_IMPLEMENTED;
+            break;
+        }
+        break;
+    }
+    case FSCTL_GET_REPARSE_POINT:
+    {
+        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)out_buffer;
+        DWORD max_length = out_size-FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[1]);
+
+        buffer->MountPointReparseBuffer.SubstituteNameLength = max_length;
+        status = FILE_GetSymlink( handle, buffer );
+        break;
+    }
+    case FSCTL_SET_REPARSE_POINT:
+    {
+        REPARSE_DATA_BUFFER *buffer = (REPARSE_DATA_BUFFER *)in_buffer;
+
+        switch(buffer->ReparseTag)
+        {
+        case IO_REPARSE_TAG_MOUNT_POINT:
+            status = FILE_CreateSymlink( handle, buffer );
+            break;
+        default:
+            FIXME("stub: FSCTL_SET_REPARSE_POINT(%x)\n", buffer->ReparseTag);
+            status = STATUS_NOT_IMPLEMENTED;
+            break;
+        }
+        break;
+    }
     case FSCTL_PIPE_LISTEN:
     case FSCTL_PIPE_WAIT:
     default:
@@ -2489,7 +2875,6 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
     case FileBasicInformation:
         if (len >= sizeof(FILE_BASIC_INFORMATION))
         {
-            struct stat st;
             const FILE_BASIC_INFORMATION *info = ptr;
 
             if ((io->u.Status = server_get_unix_fd( handle, 0, &fd, &needs_close, NULL, NULL )))
@@ -2499,25 +2884,7 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
                 io->u.Status = set_file_times( fd, &info->LastWriteTime, &info->LastAccessTime );
 
             if (io->u.Status == STATUS_SUCCESS && info->FileAttributes)
-            {
-                if (fstat( fd, &st ) == -1) io->u.Status = FILE_GetNtStatus();
-                else
-                {
-                    if (info->FileAttributes & FILE_ATTRIBUTE_READONLY)
-                    {
-                        if (S_ISDIR( st.st_mode))
-                            WARN("FILE_ATTRIBUTE_READONLY ignored for directory.\n");
-                        else
-                            st.st_mode &= ~0222; /* clear write permission bits */
-                    }
-                    else
-                    {
-                        /* add write permission only where we already have read permission */
-                        st.st_mode |= (0600 | ((st.st_mode & 044) >> 1)) & (~FILE_umask);
-                    }
-                    if (fchmod( fd, st.st_mode ) == -1) io->u.Status = FILE_GetNtStatus();
-                }
-            }
+                io->u.Status = fd_set_file_info( fd, info->FileAttributes );
 
             if (needs_close) close( fd );
         }
@@ -2658,6 +3025,22 @@ NTSTATUS WINAPI NtSetInformationFile(HANDLE handle, PIO_STATUS_BLOCK io,
         else io->u.Status = STATUS_INVALID_PARAMETER_3;
         break;
 
+    case FileDispositionInformation:
+        if (len >= sizeof(FILE_DISPOSITION_INFORMATION))
+        {
+            FILE_DISPOSITION_INFORMATION *info = ptr;
+
+            SERVER_START_REQ( set_file_info )
+            {
+                req->handle   = wine_server_obj_handle( handle );
+                req->unlink   = info->DoDeleteFile;
+                io->u.Status = wine_server_call( req );
+            }
+            SERVER_END_REQ;
+        } else
+            io->u.Status = STATUS_INVALID_PARAMETER_3;
+        break;
+
     default:
         FIXME("Unsupported class (%d)\n", class);
         io->u.Status = STATUS_NOT_IMPLEMENTED;
@@ -2701,8 +3084,6 @@ NTSTATUS WINAPI NtQueryFullAttributesFile( const OBJECT_ATTRIBUTES *attr,
             info->AllocationSize = std.AllocationSize;
             info->EndOfFile      = std.EndOfFile;
             info->FileAttributes = basic.FileAttributes;
-            if (DIR_is_hidden_file( attr->ObjectName ))
-                info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
         }
         RtlFreeAnsiString( &unix_name );
     }
@@ -2730,11 +3111,7 @@ NTSTATUS WINAPI NtQueryAttributesFile( const OBJECT_ATTRIBUTES *attr, FILE_BASIC
         else if (!S_ISREG(st.st_mode) && !S_ISDIR(st.st_mode))
             status = STATUS_INVALID_INFO_CLASS;
         else
-        {
             status = fill_file_info( &st, attributes, info, FileBasicInformation );
-            if (DIR_is_hidden_file( attr->ObjectName ))
-                info->FileAttributes |= FILE_ATTRIBUTE_HIDDEN;
-        }
         RtlFreeAnsiString( &unix_name );
     }
     else WARN("%s not found (%x)\n", debugstr_us(attr->ObjectName), status );
@@ -3281,6 +3658,7 @@ NTSTATUS WINAPI NtCreateNamedPipeFile( PHANDLE handle, ULONG access,
 {
     struct security_descriptor *sd = NULL;
     struct object_attributes objattr;
+    unsigned int flags;
     NTSTATUS status;
 
     TRACE("(%p %x %s %p %x %d %x %d %d %d %d %d %d %p)\n",
@@ -3299,16 +3677,17 @@ NTSTATUS WINAPI NtCreateNamedPipeFile( PHANDLE handle, ULONG access,
     status = NTDLL_create_struct_sd( attr->SecurityDescriptor, &sd, &objattr.sd_len );
     if (status != STATUS_SUCCESS) return status;
 
+    flags = (pipe_type ? NAMED_PIPE_MESSAGE_STREAM_WRITE   : 0) |
+            (read_mode ? NAMED_PIPE_MESSAGE_STREAM_READ    : 0) |
+            (completion_mode ? NAMED_PIPE_NONBLOCKING_MODE : 0);
+
     SERVER_START_REQ( create_named_pipe )
     {
         req->access  = access;
         req->attributes = attr->Attributes;
         req->options = options;
         req->sharing = sharing;
-        req->flags = 
-            (pipe_type ? NAMED_PIPE_MESSAGE_STREAM_WRITE   : 0) |
-            (read_mode ? NAMED_PIPE_MESSAGE_STREAM_READ    : 0) |
-            (completion_mode ? NAMED_PIPE_NONBLOCKING_MODE : 0);
+        req->flags   = flags;
         req->maxinstances = max_inst;
         req->outsize = outbound_quota;
         req->insize  = inbound_quota;
@@ -3318,9 +3697,13 @@ NTSTATUS WINAPI NtCreateNamedPipeFile( PHANDLE handle, ULONG access,
         wine_server_add_data( req, attr->ObjectName->Buffer, attr->ObjectName->Length );
         status = wine_server_call( req );
         if (!status) *handle = wine_server_ptr_handle( reply->handle );
+        flags &= ~reply->flags; /* contains now all unsupported flags */
     }
     SERVER_END_REQ;
 
+    if (!status && (flags & (NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ)))
+        FIXME("Message mode not supported, falling back to byte mode.\n");
+
     NTDLL_free_struct_sd( sd );
     return status;
 }
diff --git a/dlls/ntdll/heap.c b/dlls/ntdll/heap.c
index a908f19..95c3554 100644
--- a/dlls/ntdll/heap.c
+++ b/dlls/ntdll/heap.c
@@ -116,7 +116,9 @@ C_ASSERT( sizeof(ARENA_LARGE) % LARGE_ALIGNMENT == 0 );
 /* Max size of the blocks on the free lists */
 static const SIZE_T HEAP_freeListSizes[] =
 {
-    0x10, 0x20, 0x30, 0x40, 0x60, 0x80, 0x100, 0x200, 0x400, 0x1000, ~0UL
+    0x10, 0x18, 0x20, 0x28, 0x30, 0x38, 0x40, 0x48, 0x50, 0x58, 0x60, 0x68,
+    0x70, 0x78, 0x80, 0x88, 0x90, 0x98, 0xA0, 0xA8, 0xB0, 0xB8, 0xC0, 0xC8,
+    0xD0, 0xD8, 0xE0, 0xE8, 0xF0, 0xF8, 0x100, 0x200, 0x400, 0x1000, ~0UL
 };
 #define HEAP_NB_FREE_LISTS  (sizeof(HEAP_freeListSizes)/sizeof(HEAP_freeListSizes[0]))
 
diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 9810f07..a88b812 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -85,6 +85,7 @@ struct builtin_load_info
 {
     const WCHAR *load_path;
     const WCHAR *filename;
+    const WCHAR *fakemodule;
     NTSTATUS     status;
     WINE_MODREF *wm;
 };
@@ -97,6 +98,10 @@ static UINT tls_module_count;      /* number of modules with TLS directory */
 static const IMAGE_TLS_DIRECTORY **tls_dirs;  /* array of TLS directories */
 LIST_ENTRY tls_links = { &tls_links, &tls_links };
 
+static HRESULT (WINAPI *p_CorValidateImage)(PVOID* ImageBase, LPCWSTR FileName);
+static __int32 (WINAPI *p_CorExeMain)(void);
+static BOOL    (WINAPI *p_CorDllMain)(HINSTANCE hInst, DWORD dwReason, LPVOID lpReserved);
+
 static RTL_CRITICAL_SECTION loader_section;
 static RTL_CRITICAL_SECTION_DEBUG critsect_debug =
 {
@@ -110,7 +115,8 @@ static WINE_MODREF *cached_modref;
 static WINE_MODREF *current_modref;
 static WINE_MODREF *last_failed_modref;
 
-static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, DWORD flags, WINE_MODREF** pwm );
+static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, LPCWSTR fakemodule,
+                          DWORD flags, WINE_MODREF** pwm );
 static NTSTATUS process_attach( WINE_MODREF *wm, LPVOID lpReserved );
 static FARPROC find_ordinal_export( HMODULE module, const IMAGE_EXPORT_DIRECTORY *exports,
                                     DWORD exp_size, DWORD ordinal, LPCWSTR load_path );
@@ -330,6 +336,78 @@ static inline ULONG_PTR allocate_stub( const char *dll, const char *name ) { ret
 
 
 /*************************************************************************
+ *      is_cli_only_image
+ *
+ * Checks if an image is a CLI/.NET image which does not contain any
+ * native code.
+ */
+static BOOL is_cli_only_image( HMODULE image )
+{
+    IMAGE_COR20_HEADER *cliheader;
+    ULONG size;
+
+    cliheader = RtlImageDirectoryEntryToData( image, TRUE, IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR, &size );
+    if (!cliheader || size < sizeof(*cliheader))
+        return FALSE;
+
+    return (cliheader->Flags & COMIMAGE_FLAGS_ILONLY) != 0;
+}
+
+
+/*************************************************************************
+ *      load_mscoree
+ *
+ * Load _CorValidateImage and the _Cor{Exe,Dll}Main functions from mscoree.
+ * The loader_section must be locked while calling this function.
+ */
+static BOOL load_mscoree( void )
+{
+    static const WCHAR mscoree_dllW[] = {'m','s','c','o','r','e','e','.','d','l','l',0};
+    UNICODE_STRING unicode_str;
+    ANSI_STRING ansi_str;
+    HMODULE module;
+
+    if (p_CorValidateImage)
+        return TRUE;
+
+    RtlInitUnicodeString( &unicode_str, mscoree_dllW );
+    if (LdrLoadDll( NULL, LOAD_LIBRARY_SEARCH_SYSTEM32, &unicode_str, &module ))
+    {
+        ERR( "Failed to load mscoree.dll\n" );
+        return FALSE;
+    }
+
+    /* Load _CorValidateImage */
+    RtlInitAnsiString( &ansi_str, "_CorValidateImage" );
+    if (LdrGetProcedureAddress( module, &ansi_str, 0, (void **)&p_CorValidateImage) )
+    {
+        ERR( "Failed to get import for _CorValidateImage\n" );
+        LdrUnloadDll( module );
+        return FALSE;
+    }
+
+    /* Load _CorExeMain */
+    RtlInitAnsiString( &ansi_str, "_CorExeMain" );
+    if (LdrGetProcedureAddress( module, &ansi_str, 0, (void **)&p_CorExeMain) )
+    {
+        ERR( "Failed to get import for _CorExeMain\n" );
+        p_CorExeMain = NULL;
+    }
+
+    /* Load _CorDllMain */
+    RtlInitAnsiString( &ansi_str, "_CorDllMain" );
+    if (LdrGetProcedureAddress( module, &ansi_str, 0, (void **)&p_CorDllMain) )
+    {
+        ERR( "Failed to get import for _CorDllMain\n" );
+        p_CorDllMain = NULL;
+    }
+
+    /* FIXME: Unload mscoree again when no longer needed */
+    return TRUE;
+}
+
+
+/*************************************************************************
  *		get_modref
  *
  * Looks for the referenced HMODULE in the current process
@@ -436,7 +514,7 @@ static FARPROC find_forwarded_export( HMODULE module, const char *forward, LPCWS
     if (!(wm = find_basename_module( mod_name )))
     {
         TRACE( "delay loading %s for '%s'\n", debugstr_w(mod_name), forward );
-        if (load_dll( load_path, mod_name, 0, &wm ) == STATUS_SUCCESS &&
+        if (load_dll( load_path, mod_name, NULL, 0, &wm ) == STATUS_SUCCESS &&
             !(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS))
         {
             if (process_attach( wm, NULL ) != STATUS_SUCCESS)
@@ -585,7 +663,7 @@ static WINE_MODREF *import_dll( HMODULE module, const IMAGE_IMPORT_DESCRIPTOR *d
     {
         ascii_to_unicode( buffer, name, len );
         buffer[len] = 0;
-        status = load_dll( load_path, buffer, 0, &wmImp );
+        status = load_dll( load_path, buffer, NULL, 0, &wmImp );
     }
     else  /* need to allocate a larger buffer */
     {
@@ -593,7 +671,7 @@ static WINE_MODREF *import_dll( HMODULE module, const IMAGE_IMPORT_DESCRIPTOR *d
         if (!ptr) return NULL;
         ascii_to_unicode( ptr, name, len );
         ptr[len] = 0;
-        status = load_dll( load_path, ptr, 0, &wmImp );
+        status = load_dll( load_path, ptr, NULL, 0, &wmImp );
         RtlFreeHeap( GetProcessHeap(), 0, ptr );
     }
 
@@ -863,6 +941,10 @@ static NTSTATUS fixup_imports( WINE_MODREF *wm, LPCWSTR load_path )
     if (!(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS)) return STATUS_SUCCESS;  /* already done */
     wm->ldr.Flags &= ~LDR_DONT_RESOLVE_REFS;
 
+    /* For a CLI-only image there is nothing to do. Do not allocate a TLS slot
+     * and do not resolve any external dependencies. */
+    if (is_cli_only_image( wm->ldr.BaseAddress )) return STATUS_SUCCESS;
+
     wm->ldr.TlsIndex = alloc_tls_slot( &wm->ldr );
 
     if (!(imports = RtlImageDirectoryEntryToData( wm->ldr.BaseAddress, TRUE,
@@ -904,7 +986,7 @@ static NTSTATUS fixup_imports( WINE_MODREF *wm, LPCWSTR load_path )
  * Allocate a WINE_MODREF structure and add it to the process list
  * The loader_section must be locked while calling this function.
  */
-static WINE_MODREF *alloc_module( HMODULE hModule, LPCWSTR filename )
+static WINE_MODREF *alloc_module( HMODULE hModule, LPCWSTR filename, LPCWSTR fakemodule )
 {
     WINE_MODREF *wm;
     const WCHAR *p;
@@ -927,7 +1009,7 @@ static WINE_MODREF *alloc_module( HMODULE hModule, LPCWSTR filename )
     wm->ldr.TimeDateStamp = 0;
     wm->ldr.ActivationContext = 0;
 
-    RtlCreateUnicodeString( &wm->ldr.FullDllName, filename );
+    RtlCreateUnicodeString( &wm->ldr.FullDllName, fakemodule ? fakemodule : filename );
     if ((p = strrchrW( wm->ldr.FullDllName.Buffer, '\\' ))) p++;
     else p = wm->ldr.FullDllName.Buffer;
     RtlInitUnicodeString( &wm->ldr.BaseDllName, p );
@@ -1058,8 +1140,43 @@ static NTSTATUS MODULE_InitDLL( WINE_MODREF *wm, UINT reason, LPVOID lpReserved
     BOOL retv = FALSE;
 
     /* Skip calls for modules loaded with special load flags */
-
     if (wm->ldr.Flags & LDR_DONT_RESOLVE_REFS) return STATUS_SUCCESS;
+
+    /* Yes, Windows also has hardcoded exceptions for mscoree in ntdll */
+    if (is_cli_only_image( module ))
+    {
+    #ifndef __x86_64__
+        IMAGE_NT_HEADERS *nt = RtlImageNtHeader( module );
+    #endif
+
+        if (reason == DLL_WINE_PREATTACH)
+            return STATUS_SUCCESS;
+
+        if (reason == DLL_PROCESS_ATTACH)
+        {
+            HRESULT hr;
+
+            if (!load_mscoree())
+                return STATUS_DLL_INIT_FAILED;
+
+            hr = p_CorValidateImage( &module, wm->ldr.FullDllName.Buffer );
+            if (hr)
+            {
+                ERR( "failed to validate CLI image, error 0x%x\n", hr );
+                wm->ldr.EntryPoint = NULL;
+                return STATUS_DLL_INIT_FAILED;
+            }
+
+        #ifdef __x86_64__
+            wm->ldr.EntryPoint = (wm->ldr.Flags & LDR_IMAGE_IS_DLL) ?
+                                 (void *)p_CorDllMain : (void *)p_CorExeMain;
+        #else
+            wm->ldr.EntryPoint = (char *)module + nt->OptionalHeader.AddressOfEntryPoint;
+        #endif
+            entry = wm->ldr.EntryPoint;
+        }
+    }
+
     if (wm->ldr.TlsIndex != -1) call_tls_callbacks( wm->ldr.BaseAddress, reason );
     if (!entry || !(wm->ldr.Flags & LDR_IMAGE_IS_DLL)) return STATUS_SUCCESS;
 
@@ -1544,7 +1661,7 @@ static void load_builtin_callback( void *module, const char *filename )
         return;
     }
 
-    wm = alloc_module( module, fullname );
+    wm = alloc_module( module, fullname, builtin_load_info->fakemodule );
     RtlFreeHeap( GetProcessHeap(), 0, fullname );
     if (!wm)
     {
@@ -1600,8 +1717,8 @@ static void load_builtin_callback( void *module, const char *filename )
 /******************************************************************************
  *	load_native_dll  (internal)
  */
-static NTSTATUS load_native_dll( LPCWSTR load_path, LPCWSTR name, HANDLE file,
-                                 DWORD flags, WINE_MODREF** pwm )
+static NTSTATUS load_native_dll( LPCWSTR load_path, LPCWSTR name, LPCWSTR fakemodule,
+                                 HANDLE file, DWORD flags, WINE_MODREF** pwm )
 {
     void *module;
     HANDLE mapping;
@@ -1625,7 +1742,7 @@ static NTSTATUS load_native_dll( LPCWSTR load_path, LPCWSTR name, HANDLE file,
 
     /* create the MODREF */
 
-    if (!(wm = alloc_module( module, name )))
+    if (!(wm = alloc_module( module, name, fakemodule )))
     {
         status = STATUS_NO_MEMORY;
         goto done;
@@ -1687,8 +1804,8 @@ done:
 /***********************************************************************
  *           load_builtin_dll
  */
-static NTSTATUS load_builtin_dll( LPCWSTR load_path, LPCWSTR path, HANDLE file,
-                                  DWORD flags, WINE_MODREF** pwm )
+static NTSTATUS load_builtin_dll( LPCWSTR load_path, LPCWSTR path, LPCWSTR fakemodule,
+                                  HANDLE file, DWORD flags, WINE_MODREF** pwm )
 {
     char error[256], dllname[MAX_PATH];
     const WCHAR *name, *p;
@@ -1708,6 +1825,7 @@ static NTSTATUS load_builtin_dll( LPCWSTR load_path, LPCWSTR path, HANDLE file,
      */
     info.load_path = load_path;
     info.filename  = NULL;
+    info.fakemodule = fakemodule;
     info.status    = STATUS_SUCCESS;
     info.wm        = NULL;
 
@@ -2026,14 +2144,14 @@ overflow:
     return STATUS_BUFFER_TOO_SMALL;
 }
 
-
 /***********************************************************************
  *	load_dll  (internal)
  *
  * Load a PE style module according to the load order.
  * The loader_section must be locked while calling this function.
  */
-static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, DWORD flags, WINE_MODREF** pwm )
+static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, LPCWSTR fakemodule,
+                          DWORD flags, WINE_MODREF** pwm )
 {
     enum loadorder loadorder;
     WCHAR buffer[32];
@@ -2070,6 +2188,25 @@ static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, DWORD flags, WINE_
     }
 
     main_exe = get_modref( NtCurrentTeb()->Peb->ImageBaseAddress );
+
+    /* handle dll redirection */
+    if (!fakemodule)
+    {
+        BYTE buffer2[sizeof(KEY_VALUE_PARTIAL_INFORMATION) + MAX_PATH * sizeof(WCHAR)];
+        WCHAR *redirect = get_redirect( main_exe ? main_exe->ldr.BaseDllName.Buffer : NULL,
+                                        filename, buffer2, sizeof(buffer2) );
+        if (redirect)
+        {
+            FIXME("Loader redirect from %s to %s\n", debugstr_w(libname), debugstr_w(redirect));
+
+            nts = load_dll( load_path, redirect, filename, flags, pwm );
+
+            if (handle) NtClose( handle );
+            if (filename != buffer) RtlFreeHeap( GetProcessHeap(), 0, filename );
+            return nts;
+        }
+    }
+
     loadorder = get_load_order( main_exe ? main_exe->ldr.BaseDllName.Buffer : NULL, filename );
 
     if (handle && is_fake_dll( handle ))
@@ -2092,22 +2229,22 @@ static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, DWORD flags, WINE_
         if (!handle) nts = STATUS_DLL_NOT_FOUND;
         else
         {
-            nts = load_native_dll( load_path, filename, handle, flags, pwm );
+            nts = load_native_dll( load_path, filename, fakemodule, handle, flags, pwm );
             if (nts == STATUS_INVALID_IMAGE_NOT_MZ)
                 /* not in PE format, maybe it's a builtin */
-                nts = load_builtin_dll( load_path, filename, handle, flags, pwm );
+                nts = load_builtin_dll( load_path, filename, fakemodule, handle, flags, pwm );
         }
         if (nts == STATUS_DLL_NOT_FOUND && loadorder == LO_NATIVE_BUILTIN)
-            nts = load_builtin_dll( load_path, filename, 0, flags, pwm );
+            nts = load_builtin_dll( load_path, filename, fakemodule, 0, flags, pwm );
         break;
     case LO_BUILTIN:
     case LO_BUILTIN_NATIVE:
     case LO_DEFAULT:  /* default is builtin,native */
-        nts = load_builtin_dll( load_path, filename, handle, flags, pwm );
+        nts = load_builtin_dll( load_path, filename, fakemodule, handle, flags, pwm );
         if (!handle) break;  /* nothing else we can try */
         /* file is not a builtin library, try without using the specified file */
         if (nts != STATUS_SUCCESS)
-            nts = load_builtin_dll( load_path, filename, 0, flags, pwm );
+            nts = load_builtin_dll( load_path, filename, fakemodule, 0, flags, pwm );
         if (nts == STATUS_SUCCESS && loadorder == LO_DEFAULT &&
             (MODULE_InitDLL( *pwm, DLL_WINE_PREATTACH, NULL ) != STATUS_SUCCESS))
         {
@@ -2117,7 +2254,7 @@ static NTSTATUS load_dll( LPCWSTR load_path, LPCWSTR libname, DWORD flags, WINE_
             nts = STATUS_DLL_NOT_FOUND;
         }
         if (nts == STATUS_DLL_NOT_FOUND && loadorder != LO_BUILTIN)
-            nts = load_native_dll( load_path, filename, handle, flags, pwm );
+            nts = load_native_dll( load_path, filename, fakemodule, handle, flags, pwm );
         break;
     }
 
@@ -2150,7 +2287,7 @@ NTSTATUS WINAPI DECLSPEC_HOTPATCH LdrLoadDll(LPCWSTR path_name, DWORD flags,
     RtlEnterCriticalSection( &loader_section );
 
     if (!path_name) path_name = NtCurrentTeb()->Peb->ProcessParameters->DllPath.Buffer;
-    nts = load_dll( path_name, libname->Buffer, flags, &wm );
+    nts = load_dll( path_name, libname->Buffer, NULL, flags, &wm );
 
     if (nts == STATUS_SUCCESS && !(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS))
     {
@@ -2865,7 +3002,20 @@ static void load_global_options(void)
  */
 static void start_process( void *kernel_start )
 {
-    call_thread_entry_point( kernel_start, NtCurrentTeb()->Peb );
+    IMAGE_NT_HEADERS *nt;
+    LPTHREAD_START_ROUTINE entry;
+    PEB *peb = NtCurrentTeb()->Peb;
+
+    nt = RtlImageNtHeader( peb->ImageBaseAddress );
+    entry = (LPTHREAD_START_ROUTINE)((char *)peb->ImageBaseAddress +
+                                     nt->OptionalHeader.AddressOfEntryPoint);
+
+#ifdef __x86_64__
+    if (is_cli_only_image( peb->ImageBaseAddress ))
+        entry = (LPTHREAD_START_ROUTINE)p_CorExeMain;
+#endif
+
+    call_thread_entry_point( kernel_start, entry );
 }
 
 /******************************************************************
@@ -2876,6 +3026,7 @@ void WINAPI LdrInitializeThunk( void *kernel_start, ULONG_PTR unknown2,
                                 ULONG_PTR unknown3, ULONG_PTR unknown4 )
 {
     static const WCHAR globalflagW[] = {'G','l','o','b','a','l','F','l','a','g',0};
+    LARGE_INTEGER timeout;
     NTSTATUS status;
     WINE_MODREF *wm;
     LPCWSTR load_path;
@@ -2919,6 +3070,10 @@ void WINAPI LdrInitializeThunk( void *kernel_start, ULONG_PTR unknown2,
 
     virtual_release_address_space();
     virtual_clear_thread_stack();
+
+    timeout.QuadPart = 0;
+    NtDelayExecution( TRUE, &timeout );
+
     wine_switch_to_stack( start_process, kernel_start, NtCurrentTeb()->Tib.StackBase );
 
 error:
@@ -3113,7 +3268,7 @@ void __wine_process_init(void)
     /* setup the load callback and create ntdll modref */
     wine_dll_set_callback( load_builtin_callback );
 
-    if ((status = load_builtin_dll( NULL, kernel32W, 0, 0, &wm )) != STATUS_SUCCESS)
+    if ((status = load_builtin_dll( NULL, kernel32W, NULL, 0, 0, &wm )) != STATUS_SUCCESS)
     {
         MESSAGE( "wine: could not load kernel32.dll, status %x\n", status );
         exit(1);
diff --git a/dlls/ntdll/loadorder.c b/dlls/ntdll/loadorder.c
index 401d256..c7c4592 100644
--- a/dlls/ntdll/loadorder.c
+++ b/dlls/ntdll/loadorder.c
@@ -290,102 +290,165 @@ static inline enum loadorder get_env_load_order( const WCHAR *module )
 
 
 /***************************************************************************
- *	get_standard_key
+ *	open_user_reg_key
+ *
+ * Return a handle to a registry key under HKCU.
+ */
+static HANDLE open_user_reg_key(const WCHAR *key_name)
+{
+    HANDLE hkey, root;
+    OBJECT_ATTRIBUTES attr;
+    UNICODE_STRING nameW;
+
+    RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
+    attr.Length = sizeof(attr);
+    attr.RootDirectory = root;
+    attr.ObjectName = &nameW;
+    attr.Attributes = 0;
+    attr.SecurityDescriptor = NULL;
+    attr.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString( &nameW, key_name );
+
+    if (NtOpenKey( &hkey, KEY_ALL_ACCESS, &attr )) hkey = 0;
+    NtClose( root );
+
+    return hkey;
+}
+
+
+/***************************************************************************
+ *	open_app_reg_key
+ *
+ * Return a handle to an app-specific registry key.
+ */
+static HANDLE open_app_reg_key( const WCHAR *sub_key, const WCHAR *app_name )
+{
+    static const WCHAR AppDefaultsW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
+                                         'A','p','p','D','e','f','a','u','l','t','s','\\',0};
+    WCHAR *str;
+    HANDLE hkey;
+
+    str = RtlAllocateHeap( GetProcessHeap(), 0,
+                           sizeof(AppDefaultsW) +
+                           strlenW(sub_key) * sizeof(WCHAR) +
+                           strlenW(app_name) * sizeof(WCHAR) );
+    if (!str) return 0;
+    strcpyW( str, AppDefaultsW );
+    strcatW( str, app_name );
+    strcatW( str, sub_key );
+
+    hkey = open_user_reg_key( str );
+    RtlFreeHeap( GetProcessHeap(), 0, str );
+    return hkey;
+}
+
+
+/***************************************************************************
+ *	get_override_standard_key
  *
  * Return a handle to the standard DllOverrides registry section.
  */
-static HANDLE get_standard_key(void)
+static HANDLE get_override_standard_key(void)
 {
     static const WCHAR DllOverridesW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
                                           'D','l','l','O','v','e','r','r','i','d','e','s',0};
     static HANDLE std_key = (HANDLE)-1;
 
     if (std_key == (HANDLE)-1)
-    {
-        OBJECT_ATTRIBUTES attr;
-        UNICODE_STRING nameW;
-        HANDLE root;
-
-        RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
-        attr.Length = sizeof(attr);
-        attr.RootDirectory = root;
-        attr.ObjectName = &nameW;
-        attr.Attributes = 0;
-        attr.SecurityDescriptor = NULL;
-        attr.SecurityQualityOfService = NULL;
-        RtlInitUnicodeString( &nameW, DllOverridesW );
-
-        /* @@ Wine registry key: HKCU\Software\Wine\DllOverrides */
-        if (NtOpenKey( &std_key, KEY_ALL_ACCESS, &attr )) std_key = 0;
-        NtClose( root );
-    }
+        std_key = open_user_reg_key( DllOverridesW );
+
     return std_key;
 }
 
 
 /***************************************************************************
- *	get_app_key
+ *	get_override_app_key
  *
  * Get the registry key for the app-specific DllOverrides list.
  */
-static HANDLE get_app_key( const WCHAR *app_name )
+static HANDLE get_override_app_key( const WCHAR *app_name )
 {
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
-    HANDLE root;
-    WCHAR *str;
-    static const WCHAR AppDefaultsW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
-                                         'A','p','p','D','e','f','a','u','l','t','s','\\',0};
     static const WCHAR DllOverridesW[] = {'\\','D','l','l','O','v','e','r','r','i','d','e','s',0};
     static HANDLE app_key = (HANDLE)-1;
 
-    if (app_key != (HANDLE)-1) return app_key;
+    if (app_key == (HANDLE)-1)
+        app_key = open_app_reg_key( DllOverridesW, app_name );
 
-    str = RtlAllocateHeap( GetProcessHeap(), 0,
-                           sizeof(AppDefaultsW) + sizeof(DllOverridesW) +
-                           strlenW(app_name) * sizeof(WCHAR) );
-    if (!str) return 0;
-    strcpyW( str, AppDefaultsW );
-    strcatW( str, app_name );
-    strcatW( str, DllOverridesW );
+    return app_key;
+}
 
-    RtlOpenCurrentUser( KEY_ALL_ACCESS, &root );
-    attr.Length = sizeof(attr);
-    attr.RootDirectory = root;
-    attr.ObjectName = &nameW;
-    attr.Attributes = 0;
-    attr.SecurityDescriptor = NULL;
-    attr.SecurityQualityOfService = NULL;
-    RtlInitUnicodeString( &nameW, str );
 
-    /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\DllOverrides */
-    if (NtOpenKey( &app_key, KEY_ALL_ACCESS, &attr )) app_key = 0;
-    NtClose( root );
-    RtlFreeHeap( GetProcessHeap(), 0, str );
+/***************************************************************************
+ *	get_redirect_standard_key
+ *
+ * Return a handle to the standard DllRedirects registry section.
+ */
+static HANDLE get_redirect_standard_key(void)
+{
+    static const WCHAR DllRedirectsW[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
+                                          'D','l','l','R','e','d','i','r','e','c','t','s',0};
+    static HANDLE std_key = (HANDLE)-1;
+
+    if (std_key == (HANDLE)-1)
+        std_key = open_user_reg_key( DllRedirectsW );
+
+    return std_key;
+}
+
+
+/***************************************************************************
+ *	get_redirect_app_key
+ *
+ * Get the registry key for the app-specific DllRedirects list.
+ */
+static HANDLE get_redirect_app_key( const WCHAR *app_name )
+{
+    static const WCHAR DllRedirectsW[] = {'\\','D','l','l','R','e','d','i','r','e','c','t','s',0};
+    static HANDLE app_key = (HANDLE)-1;
+
+    if (app_key == (HANDLE)-1)
+        app_key = open_app_reg_key( DllRedirectsW, app_name );
+
     return app_key;
 }
 
 
 /***************************************************************************
- *	get_registry_value
+ *	get_registry_string
  *
- * Load the registry loadorder value for a given module.
+ * Load a registry string for a given module.
  */
-static enum loadorder get_registry_value( HANDLE hkey, const WCHAR *module )
+static WCHAR* get_registry_string( HANDLE hkey, const WCHAR *module, BYTE *buffer,
+                                   ULONG size )
 {
     UNICODE_STRING valueW;
-    char buffer[80];
     DWORD count;
+    WCHAR *ret = NULL;
 
     RtlInitUnicodeString( &valueW, module );
-
-    if (!NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation,
-                                 buffer, sizeof(buffer), &count ))
+    if (size >= sizeof(WCHAR) &&
+        !NtQueryValueKey( hkey, &valueW, KeyValuePartialInformation,
+                          buffer, size - sizeof(WCHAR), &count ))
     {
-        WCHAR *str = (WCHAR *)((KEY_VALUE_PARTIAL_INFORMATION *)buffer)->Data;
-        return parse_load_order( str );
+        KEY_VALUE_PARTIAL_INFORMATION *info = (void *)buffer;
+        ret = (WCHAR *)info->Data;
+        ret[info->DataLength / sizeof(WCHAR)] = 0;
     }
-    return LO_INVALID;
+
+    return ret;
+}
+
+
+/***************************************************************************
+ *	get_registry_load_order
+ *
+ * Load the registry loadorder value for a given module.
+ */
+static enum loadorder get_registry_load_order( HANDLE hkey, const WCHAR *module )
+{
+    BYTE buffer[81];
+    WCHAR *str = get_registry_string( hkey, module, buffer, sizeof(buffer) );
+    return str ? parse_load_order( str ) : LO_INVALID;
 }
 
 
@@ -407,13 +470,13 @@ static enum loadorder get_load_order_value( HANDLE std_key, HANDLE app_key, cons
         return ret;
     }
 
-    if (app_key && ((ret = get_registry_value( app_key, module )) != LO_INVALID))
+    if (app_key && ((ret = get_registry_load_order( app_key, module )) != LO_INVALID))
     {
         TRACE( "got app defaults %s for %s\n", debugstr_loadorder(ret), debugstr_w(module) );
         return ret;
     }
 
-    if (std_key && ((ret = get_registry_value( std_key, module )) != LO_INVALID))
+    if (std_key && ((ret = get_registry_load_order( std_key, module )) != LO_INVALID))
     {
         TRACE( "got standard key %s for %s\n", debugstr_loadorder(ret), debugstr_w(module) );
         return ret;
@@ -424,24 +487,44 @@ static enum loadorder get_load_order_value( HANDLE std_key, HANDLE app_key, cons
 
 
 /***************************************************************************
- *	get_load_order   (internal)
+ *	get_redirect_value
  *
- * Return the loadorder of a module.
- * The system directory and '.dll' extension is stripped from the path.
+ * Get the redirect value for the exact specified module string, looking in:
+ * 1. The per-application DllRedirects key
+ * 2. The standard DllRedirects key
  */
-enum loadorder get_load_order( const WCHAR *app_name, const WCHAR *path )
+static WCHAR* get_redirect_value( HANDLE std_key, HANDLE app_key, const WCHAR *module,
+                                  BYTE *buffer, ULONG size )
 {
-    enum loadorder ret = LO_INVALID;
-    HANDLE std_key, app_key = 0;
-    WCHAR *module, *basename;
-    UNICODE_STRING path_str;
-    int len;
+    WCHAR *ret = NULL;
 
-    if (!init_done) init_load_order();
-    std_key = get_standard_key();
-    if (app_name) app_key = get_app_key( app_name );
+    if (app_key && (ret = get_registry_string( app_key, module, buffer, size )))
+    {
+        TRACE( "got app defaults %s for %s\n", debugstr_w(ret), debugstr_w(module) );
+        return ret;
+    }
 
-    TRACE("looking for %s\n", debugstr_w(path));
+    if (std_key && (ret = get_registry_string( std_key, module, buffer, size )))
+    {
+        TRACE( "got standard key %s for %s\n", debugstr_w(ret), debugstr_w(module) );
+        return ret;
+    }
+
+    return ret;
+}
+
+
+/***************************************************************************
+ *	get_module_basename
+ *
+ * Determine the module basename. The caller is responsible for releasing
+ * the memory.
+ */
+static WCHAR* get_module_basename( const WCHAR *path, WCHAR **basename )
+{
+    UNICODE_STRING path_str;
+    WCHAR *module;
+    int len;
 
     /* Strip path information if the module resides in the system directory
      */
@@ -453,12 +536,36 @@ enum loadorder get_load_order( const WCHAR *app_name, const WCHAR *path )
         if (!strchrW( p, '\\' ) && !strchrW( p, '/' )) path = p;
     }
 
-    if (!(len = strlenW(path))) return ret;
-    if (!(module = RtlAllocateHeap( GetProcessHeap(), 0, (len + 2) * sizeof(WCHAR) ))) return ret;
+    if (!(len = strlenW(path))) return NULL;
+    if (!(module = RtlAllocateHeap( GetProcessHeap(), 0, (len + 2) * sizeof(WCHAR) ))) return NULL;
     strcpyW( module+1, path );  /* reserve module[0] for the wildcard char */
-    basename = (WCHAR *)get_basename( module+1 );
+    *basename = (WCHAR *)get_basename( module+1 );
 
     if (len >= 4) remove_dll_ext( module + 1 + len - 4 );
+    return module;
+}
+
+
+/***************************************************************************
+ *	get_load_order   (internal)
+ *
+ * Return the loadorder of a module.
+ * The system directory and '.dll' extension is stripped from the path.
+ */
+enum loadorder get_load_order( const WCHAR *app_name, const WCHAR *path )
+{
+    enum loadorder ret = LO_INVALID;
+    HANDLE std_key, app_key = 0;
+    WCHAR *module, *basename;
+
+    if (!init_done) init_load_order();
+    std_key = get_override_standard_key();
+    if (app_name) app_key = get_override_app_key( app_name );
+
+    TRACE("looking up loadorder for %s\n", debugstr_w(path));
+
+    if (!(module = get_module_basename(path, &basename)))
+        return ret;
 
     /* first explicit module name */
     if ((ret = get_load_order_value( std_key, app_key, module+1 )) != LO_INVALID)
@@ -489,3 +596,46 @@ enum loadorder get_load_order( const WCHAR *app_name, const WCHAR *path )
     RtlFreeHeap( GetProcessHeap(), 0, module );
     return ret;
 }
+
+
+/***************************************************************************
+ *  get_redirect   (internal)
+ *
+ * Return the redirect value of a module.
+ * The system directory and '.dll' extension is stripped from the path.
+ */
+WCHAR* get_redirect( const WCHAR *app_name, const WCHAR *path, BYTE *buffer, ULONG size )
+{
+    WCHAR *ret = NULL;
+    HANDLE std_key, app_key = 0;
+    WCHAR *module, *basename;
+
+    std_key = get_redirect_standard_key();
+    if (app_name) app_key = get_redirect_app_key( app_name );
+
+    TRACE("looking up redirection for %s\n", debugstr_w(path));
+
+    if (!(module = get_module_basename(path, &basename)))
+        return ret;
+
+    /* first explicit module name */
+    if ((ret = get_redirect_value( std_key, app_key, module+1, buffer, size )))
+        goto done;
+
+    /* then module basename preceded by '*' */
+    basename[-1] = '*';
+    if ((ret = get_redirect_value( std_key, app_key, basename-1, buffer, size )))
+        goto done;
+
+    /* then module basename without '*' (only if explicit path) */
+    if (basename != module+1 && (ret = get_redirect_value( std_key, app_key, basename, buffer, size )))
+        goto done;
+
+    /* and last the hard-coded default */
+    ret = NULL;
+    TRACE( "no redirection found for %s\n", debugstr_w(path) );
+
+ done:
+    RtlFreeHeap( GetProcessHeap(), 0, module );
+    return ret;
+}
diff --git a/dlls/ntdll/misc.c b/dlls/ntdll/misc.c
index ad1b43b..1f985e7 100644
--- a/dlls/ntdll/misc.c
+++ b/dlls/ntdll/misc.c
@@ -55,6 +55,14 @@ const char * CDECL NTDLL_wine_get_version(void)
 }
 
 /*********************************************************************
+ *                  wine_get_patches   (NTDLL.@)
+ */
+const void * CDECL NTDLL_wine_get_patches(void)
+{
+    return wine_get_patches();
+}
+
+/*********************************************************************
  *                  wine_get_build_id   (NTDLL.@)
  */
 const char * CDECL NTDLL_wine_get_build_id(void)
diff --git a/dlls/ntdll/nt.c b/dlls/ntdll/nt.c
index 3601c0f..db2212c 100644
--- a/dlls/ntdll/nt.c
+++ b/dlls/ntdll/nt.c
@@ -646,25 +646,6 @@ NTSTATUS WINAPI NtPrivilegeCheck(
 }
 
 /*
- *	Section
- */
-
-/******************************************************************************
- *  NtQuerySection	[NTDLL.@]
- */
-NTSTATUS WINAPI NtQuerySection(
-	IN HANDLE SectionHandle,
-	IN SECTION_INFORMATION_CLASS SectionInformationClass,
-	OUT PVOID SectionInformation,
-	IN ULONG Length,
-	OUT PULONG ResultLength)
-{
-	FIXME("(%p,%d,%p,0x%08x,%p) stub!\n",
-	SectionHandle,SectionInformationClass,SectionInformation,Length,ResultLength);
-	return 0;
-}
-
-/*
  *	ports
  */
 
@@ -2459,3 +2440,15 @@ NTSTATUS WINAPI NtSystemDebugControl(SYSDBG_COMMAND command, PVOID inbuffer, ULO
 
     return STATUS_NOT_IMPLEMENTED;
 }
+
+/******************************************************************************
+ *  NtSetLdtEntries   (NTDLL.@)
+ *  ZwSetLdtEntries   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtSetLdtEntries(ULONG selector1, ULONG entry1_low, ULONG entry1_high,
+                                ULONG selector2, ULONG entry2_low, ULONG entry2_high)
+{
+    FIXME("(%u, %u, %u, %u, %u, %u): stub\n", selector1, entry1_low, entry1_high, selector2, entry2_low, entry2_high);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
diff --git a/dlls/ntdll/ntdll.spec b/dlls/ntdll/ntdll.spec
index c3307b2..442fc1e 100644
--- a/dlls/ntdll/ntdll.spec
+++ b/dlls/ntdll/ntdll.spec
@@ -263,7 +263,7 @@
 @ stdcall NtQueryPerformanceCounter(ptr ptr)
 # @ stub NtQueryPortInformationProcess
 # @ stub NtQueryQuotaInformationFile
-@ stdcall NtQuerySection (long long long long long)
+@ stdcall NtQuerySection(long long ptr long ptr)
 @ stdcall NtQuerySecurityObject (long long long long long)
 @ stdcall NtQuerySemaphore (long long ptr long ptr)
 @ stdcall NtQuerySymbolicLinkObject(long ptr ptr)
@@ -333,7 +333,7 @@
 @ stdcall NtSetInformationToken(long long ptr long)
 @ stdcall NtSetIntervalProfile(long long)
 @ stdcall NtSetIoCompletion(ptr long ptr long long)
-@ stub NtSetLdtEntries
+@ stdcall NtSetLdtEntries(long long long long long long)
 @ stub NtSetLowEventPair
 @ stub NtSetLowWaitHighEventPair
 @ stub NtSetLowWaitHighThread
@@ -512,7 +512,7 @@
 @ stdcall RtlDecodePointer(ptr)
 # @ stub RtlDecodeSystemPointer
 @ stdcall RtlDecompressBuffer(long ptr long ptr long ptr)
-@ stub RtlDecompressFragment
+@ stdcall RtlDecompressFragment(long ptr long ptr long long ptr ptr)
 @ stub RtlDefaultNpAcl
 @ stub RtlDelete
 @ stdcall RtlDeleteAce(ptr long)
@@ -968,7 +968,72 @@
 @ stdcall RtlxOemStringToUnicodeSize(ptr) RtlOemStringToUnicodeSize
 @ stdcall RtlxUnicodeStringToAnsiSize(ptr) RtlUnicodeStringToAnsiSize
 @ stdcall RtlxUnicodeStringToOemSize(ptr) RtlUnicodeStringToOemSize
+# @ stub TpAllocAlpcCompletion
+# @ stub TpAllocAlpcCompletionEx
+@ stdcall TpAllocCleanupGroup(ptr)
+# @ stub TpAllocIoCompletion
+# @ stub TpAllocJobNotification
+@ stdcall TpAllocPool(ptr ptr)
+@ stdcall TpAllocTimer(ptr ptr ptr)
+@ stdcall TpAllocWait(ptr ptr ptr ptr)
+@ stdcall TpAllocWork(ptr ptr ptr ptr)
+# @ stub TpAlpcRegisterCompletionList
+# @ stub TpAlpcUnregisterCompletionList
+# @ stub TpCallbackDetectedUnrecoverableError
+# @ stub TpCallbackIndependent
+@ stdcall TpCallbackLeaveCriticalSectionOnCompletion(ptr ptr)
+@ stdcall TpCallbackMayRunLong(ptr)
+@ stdcall TpCallbackReleaseMutexOnCompletion(ptr long)
+@ stdcall TpCallbackReleaseSemaphoreOnCompletion(ptr long long)
+# @ stub TpCallbackSendAlpcMessageOnCompletion
+# @ stub TpCallbackSendPendingAlpcMessage
+@ stdcall TpCallbackSetEventOnCompletion(ptr long)
+@ stdcall TpCallbackUnloadDllOnCompletion(ptr long)
+# @ stub TpCancelAsyncIoOperation
+# @ stub TpCaptureCaller
+# @ stub TpCheckTerminateWorker
+# @ stub TpDbgDumpHeapUsage
+# @ stub TpDbgSetLogRoutine
+# @ stub TpDisablePoolCallbackChecks
+@ stdcall TpDisassociateCallback(ptr)
+@ stdcall TpIsTimerSet(ptr)
+@ stdcall TpPostWork(ptr)
+# @ stub TpQueryPoolStackInformation
+# @ stub TpReleaseAlpcCompletion
+@ stdcall TpReleaseCleanupGroup(ptr)
+@ stdcall TpReleaseCleanupGroupMembers(ptr long ptr)
+# @ stub TpReleaseIoCompletion
+# @ stub TpReleaseJobNotification
+@ stdcall TpReleasePool(ptr)
+@ stdcall TpReleaseTimer(ptr)
+@ stdcall TpReleaseWait(ptr)
+@ stdcall TpReleaseWork(ptr)
+# @ stub TpSetDefaultPoolMaxThreads
+# @ stub TpSetDefaultPoolStackInformation
+@ stdcall TpSetPoolMaxThreads(ptr long)
+# @ stub TpSetPoolMaxThreadsSoftLimit
+@ stdcall TpSetPoolMinThreads(ptr long)
+# @ stub TpSetPoolStackInformation
+# @ stub TpSetPoolThreadBasePriority
+# @ stub TpSetPoolWorkerThreadIdleTimeout
+@ stdcall TpSetTimer(ptr ptr long long)
+# @ stub TpSetTimerEx
+@ stdcall TpSetWait(ptr long ptr)
+# @ stub TpSetWaitEx
+@ stdcall TpSimpleTryPost(ptr ptr ptr)
+# @ stub TpStartAsyncIoOperation
+# @ stub TpTimerOutstandingCallbackCount
+# @ stub TpTrimPools
+# @ stub TpWaitForAlpcCompletion
+# @ stub TpWaitForIoCompletion
+# @ stub TpWaitForJobNotification
+@ stdcall TpWaitForTimer(ptr long)
+@ stdcall TpWaitForWait(ptr long)
+@ stdcall TpWaitForWork(ptr long)
 @ stdcall -ret64 VerSetConditionMask(int64 long long)
+@ stdcall WinSqmEndSession(ptr)
+@ stdcall WinSqmIsOptedIn()
+@ stdcall WinSqmStartSession(ptr long long)
 @ stdcall ZwAcceptConnectPort(ptr long ptr long long ptr) NtAcceptConnectPort
 @ stdcall ZwAccessCheck(ptr long long ptr ptr ptr ptr ptr) NtAccessCheck
 @ stdcall ZwAccessCheckAndAuditAlarm(ptr long ptr ptr ptr long ptr long ptr ptr ptr) NtAccessCheckAndAuditAlarm
@@ -1143,7 +1208,7 @@
 @ stdcall ZwQueryPerformanceCounter (long long) NtQueryPerformanceCounter
 # @ stub ZwQueryPortInformationProcess
 # @ stub ZwQueryQuotaInformationFile
-@ stdcall ZwQuerySection (long long long long long) NtQuerySection
+@ stdcall ZwQuerySection(long long ptr long ptr) NtQuerySection
 @ stdcall ZwQuerySecurityObject (long long long long long) NtQuerySecurityObject
 @ stdcall ZwQuerySemaphore (long long long long long) NtQuerySemaphore
 @ stdcall ZwQuerySymbolicLinkObject(long ptr ptr) NtQuerySymbolicLinkObject
@@ -1213,7 +1278,7 @@
 @ stdcall ZwSetInformationToken(long long ptr long) NtSetInformationToken
 @ stdcall ZwSetIntervalProfile(long long) NtSetIntervalProfile
 @ stdcall ZwSetIoCompletion(ptr long ptr long long) NtSetIoCompletion
-@ stub ZwSetLdtEntries
+@ stdcall ZwSetLdtEntries(long long long long long long) NtSetLdtEntries
 @ stub ZwSetLowEventPair
 @ stub ZwSetLowWaitHighEventPair
 @ stub ZwSetLowWaitHighThread
@@ -1416,6 +1481,7 @@
 # Server interface
 @ cdecl -norelay wine_server_call(ptr)
 @ cdecl wine_server_fd_to_handle(long long long ptr)
+@ cdecl wine_server_handle_exists(long)
 @ cdecl wine_server_handle_to_fd(long long ptr ptr)
 @ cdecl wine_server_release_fd(long long)
 @ cdecl wine_server_send_fd(long)
@@ -1423,6 +1489,7 @@
 
 # Version
 @ cdecl wine_get_version() NTDLL_wine_get_version
+@ cdecl wine_get_patches() NTDLL_wine_get_patches
 @ cdecl wine_get_build_id() NTDLL_wine_get_build_id
 @ cdecl wine_get_host_version(ptr ptr) NTDLL_wine_get_host_version
 
@@ -1432,7 +1499,14 @@
 # signal handling
 @ cdecl __wine_set_signal_handler(long ptr)
 
+# Virtual memory management
+@ cdecl wine_uninterrupted_read_memory(ptr ptr long)
+@ cdecl wine_uninterrupted_write_memory(ptr ptr long)
+
 # Filesystem
 @ cdecl wine_nt_to_unix_file_name(ptr ptr long long)
 @ cdecl wine_unix_to_nt_file_name(ptr ptr)
 @ cdecl __wine_init_windows_dir(wstr wstr)
+
+# User shared data
+@ cdecl __wine_user_shared_data()
diff --git a/dlls/ntdll/ntdll_misc.h b/dlls/ntdll/ntdll_misc.h
index 674fcbc..b60cc2e 100644
--- a/dlls/ntdll/ntdll_misc.h
+++ b/dlls/ntdll/ntdll_misc.h
@@ -68,6 +68,7 @@ extern NTSTATUS signal_alloc_thread( TEB **teb ) DECLSPEC_HIDDEN;
 extern void signal_free_thread( TEB *teb ) DECLSPEC_HIDDEN;
 extern void signal_init_thread( TEB *teb ) DECLSPEC_HIDDEN;
 extern void signal_init_process(void) DECLSPEC_HIDDEN;
+extern void signal_init_early(void) DECLSPEC_HIDDEN;
 extern void version_init( const WCHAR *appname ) DECLSPEC_HIDDEN;
 extern void debug_init(void) DECLSPEC_HIDDEN;
 extern HANDLE thread_init(void) DECLSPEC_HIDDEN;
@@ -97,6 +98,7 @@ extern int server_remove_fd_from_cache( HANDLE handle ) DECLSPEC_HIDDEN;
 extern int server_get_unix_fd( HANDLE handle, unsigned int access, int *unix_fd,
                                int *needs_close, enum server_fd_type *type, unsigned int *options ) DECLSPEC_HIDDEN;
 extern int server_pipe( int fd[2] ) DECLSPEC_HIDDEN;
+extern void *server_get_shared_memory( HANDLE thread ) DECLSPEC_HIDDEN;
 
 /* security descriptors */
 NTSTATUS NTDLL_create_struct_sd(PSECURITY_DESCRIPTOR nt_sd, struct security_descriptor **server_sd,
@@ -154,7 +156,7 @@ extern NTSTATUS fill_file_info( const struct stat *st, ULONG attr, void *ptr,
                                 FILE_INFORMATION_CLASS class ) DECLSPEC_HIDDEN;
 extern NTSTATUS server_get_unix_name( HANDLE handle, ANSI_STRING *unix_name ) DECLSPEC_HIDDEN;
 extern void DIR_init_windows_dir( const WCHAR *windir, const WCHAR *sysdir ) DECLSPEC_HIDDEN;
-extern BOOL DIR_is_hidden_file( const UNICODE_STRING *name ) DECLSPEC_HIDDEN;
+extern BOOL DIR_is_hidden_file( const char *name ) DECLSPEC_HIDDEN;
 extern NTSTATUS DIR_unmount_device( HANDLE handle ) DECLSPEC_HIDDEN;
 extern NTSTATUS DIR_get_unix_cwd( char **cwd ) DECLSPEC_HIDDEN;
 extern unsigned int DIR_get_drives_info( struct drive_info info[MAX_DOS_DRIVES] ) DECLSPEC_HIDDEN;
@@ -166,14 +168,13 @@ extern NTSTATUS nt_to_unix_file_name_attr( const OBJECT_ATTRIBUTES *attr, ANSI_S
 extern void virtual_get_system_info( SYSTEM_BASIC_INFORMATION *info ) DECLSPEC_HIDDEN;
 extern NTSTATUS virtual_create_builtin_view( void *base ) DECLSPEC_HIDDEN;
 extern NTSTATUS virtual_alloc_thread_stack( TEB *teb, SIZE_T reserve_size, SIZE_T commit_size ) DECLSPEC_HIDDEN;
+extern NTSTATUS virtual_map_shared_memory( int fd, PVOID *addr_ptr, ULONG zero_bits, SIZE_T *size_ptr, ULONG protect ) DECLSPEC_HIDDEN;
 extern void virtual_clear_thread_stack(void) DECLSPEC_HIDDEN;
 extern BOOL virtual_handle_stack_fault( void *addr ) DECLSPEC_HIDDEN;
 extern BOOL virtual_is_valid_code_address( const void *addr, SIZE_T size ) DECLSPEC_HIDDEN;
 extern NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack ) DECLSPEC_HIDDEN;
 extern BOOL virtual_check_buffer_for_read( const void *ptr, SIZE_T size ) DECLSPEC_HIDDEN;
 extern BOOL virtual_check_buffer_for_write( void *ptr, SIZE_T size ) DECLSPEC_HIDDEN;
-extern SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size ) DECLSPEC_HIDDEN;
-extern SIZE_T virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size ) DECLSPEC_HIDDEN;
 extern void VIRTUAL_SetForceExec( BOOL enable ) DECLSPEC_HIDDEN;
 extern void virtual_release_address_space(void) DECLSPEC_HIDDEN;
 extern void virtual_set_large_address_space(void) DECLSPEC_HIDDEN;
@@ -205,6 +206,7 @@ enum loadorder
 };
 
 extern enum loadorder get_load_order( const WCHAR *app_name, const WCHAR *path ) DECLSPEC_HIDDEN;
+extern WCHAR* get_redirect( const WCHAR *app_name, const WCHAR *path, BYTE *buffer, ULONG size ) DECLSPEC_HIDDEN;
 
 struct debug_info
 {
diff --git a/dlls/ntdll/om.c b/dlls/ntdll/om.c
index b337444..9fed37c 100644
--- a/dlls/ntdll/om.c
+++ b/dlls/ntdll/om.c
@@ -38,6 +38,7 @@
 #include "winternl.h"
 #include "ntdll_misc.h"
 #include "wine/server.h"
+#include "wine/exception.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(ntdll);
 
@@ -341,6 +342,13 @@ NTSTATUS WINAPI NtDuplicateObject( HANDLE source_process, HANDLE source,
     return ret;
 }
 
+
+static LONG WINAPI invalid_handle_exception_handler( EXCEPTION_POINTERS *eptr )
+{
+    EXCEPTION_RECORD *rec = eptr->ExceptionRecord;
+    return (rec->ExceptionCode == EXCEPTION_INVALID_HANDLE) ? EXCEPTION_EXECUTE_HANDLER : EXCEPTION_CONTINUE_SEARCH;
+}
+
 /* Everquest 2 / Pirates of the Burning Sea hooks NtClose, so we need a wrapper */
 NTSTATUS close_handle( HANDLE handle )
 {
@@ -354,6 +362,25 @@ NTSTATUS close_handle( HANDLE handle )
     }
     SERVER_END_REQ;
     if (fd != -1) close( fd );
+
+    if (ret == STATUS_INVALID_HANDLE && NtCurrentTeb()->Peb->BeingDebugged)
+    {
+        __TRY
+        {
+            EXCEPTION_RECORD record;
+            record.ExceptionCode    = EXCEPTION_INVALID_HANDLE;
+            record.ExceptionFlags   = 0;
+            record.ExceptionRecord  = NULL;
+            record.ExceptionAddress = NULL;
+            record.NumberParameters = 0;
+            RtlRaiseException( &record );
+        }
+        __EXCEPT(invalid_handle_exception_handler)
+        {
+        }
+        __ENDTRY
+    }
+
     return ret;
 }
 
diff --git a/dlls/ntdll/process.c b/dlls/ntdll/process.c
index 3ac8d52..d20e107 100644
--- a/dlls/ntdll/process.c
+++ b/dlls/ntdll/process.c
@@ -21,11 +21,16 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+
 #include <stdarg.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <time.h>
+#ifdef HAVE_UNISTD_H
+# include <unistd.h>
+#endif
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
@@ -60,7 +65,7 @@ NTSTATUS WINAPI NtTerminateProcess( HANDLE handle, LONG exit_code )
         self = !ret && reply->self;
     }
     SERVER_END_REQ;
-    if (self && handle) exit( exit_code );
+    if (self && handle) _exit( exit_code );
     return ret;
 }
 
diff --git a/dlls/ntdll/rtl.c b/dlls/ntdll/rtl.c
index 8f6f386..69e08dc 100644
--- a/dlls/ntdll/rtl.c
+++ b/dlls/ntdll/rtl.c
@@ -1215,42 +1215,317 @@ PSLIST_ENTRY WINAPI RtlInterlockedPushListSList(PSLIST_HEADER list, PSLIST_ENTRY
 /******************************************************************************
  *  RtlGetCompressionWorkSpaceSize		[NTDLL.@]
  */
-NTSTATUS WINAPI RtlGetCompressionWorkSpaceSize(USHORT CompressionFormatAndEngine,
-                                               PULONG CompressBufferWorkSpaceSize,
-                                               PULONG CompressFragmentWorkSpaceSize)
+NTSTATUS WINAPI RtlGetCompressionWorkSpaceSize(USHORT format, PULONG compress_workspace,
+                                               PULONG decompress_workspace)
 {
-    FIXME("0x%04x, %p, %p: stub!\n", CompressionFormatAndEngine, CompressBufferWorkSpaceSize,
-         CompressFragmentWorkSpaceSize);
+    FIXME("0x%04x, %p, %p: semi-stub\n", format, compress_workspace, decompress_workspace);
 
-    return STATUS_NOT_IMPLEMENTED;
+    switch (format & ~COMPRESSION_ENGINE_MAXIMUM)
+    {
+        case COMPRESSION_FORMAT_LZNT1:
+            if (compress_workspace)
+                *compress_workspace = 16; /* FIXME */
+            if (decompress_workspace)
+                *decompress_workspace = 0x1000;
+            return STATUS_SUCCESS;
+
+        case COMPRESSION_FORMAT_NONE:
+        case COMPRESSION_FORMAT_DEFAULT:
+            return STATUS_INVALID_PARAMETER;
+
+        default:
+            FIXME("format %d not implemented\n", format);
+            return STATUS_UNSUPPORTED_COMPRESSION;
+    }
+}
+
+/* compress data using LZNT1, currently only a stub */
+static NTSTATUS lznt1_compress(UCHAR *src, ULONG src_size, UCHAR *dst, ULONG dst_size,
+                               ULONG chunk_size, ULONG *final_size, UCHAR *workspace)
+{
+    UCHAR *src_cur, *src_end, *dst_cur, *dst_end;
+    ULONG block_size;
+
+    src_cur = src;
+    src_end = src + src_size;
+    dst_cur = dst;
+    dst_end = dst + dst_size;
+
+    while (src_cur < src_end)
+    {
+        /* determine size of current chunk */
+        block_size = min(0x1000, src_end - src_cur);
+        if (dst_cur + sizeof(WORD) + block_size > dst_end)
+            return STATUS_BUFFER_TOO_SMALL;
+
+        /* write (uncompressed) chunk header */
+        *(WORD *)dst_cur = 0x3000 | (block_size - 1);
+        dst_cur += sizeof(WORD);
+
+        /* write chunk content */
+        memcpy(dst_cur, src_cur, block_size);
+        dst_cur += block_size;
+        src_cur += block_size;
+    }
+
+    if (final_size)
+        *final_size = dst_cur - dst;
+
+    return STATUS_SUCCESS;
 }
 
 /******************************************************************************
  *  RtlCompressBuffer		[NTDLL.@]
  */
-NTSTATUS WINAPI RtlCompressBuffer(USHORT CompressionFormatAndEngine, PUCHAR UncompressedBuffer,
-                                  ULONG UncompressedBufferSize, PUCHAR CompressedBuffer,
-                                  ULONG CompressedBufferSize, ULONG UncompressedChunkSize,
-                                  PULONG FinalCompressedSize, PVOID WorkSpace)
+NTSTATUS WINAPI RtlCompressBuffer(USHORT format, PUCHAR uncompressed, ULONG uncompressed_size,
+                                  PUCHAR compressed, ULONG compressed_size, ULONG chunk_size,
+                                  PULONG final_size, PVOID workspace)
 {
-    FIXME("0x%04x, %p, %u, %p, %u, %u, %p, %p :stub\n", CompressionFormatAndEngine, UncompressedBuffer,
-         UncompressedBufferSize, CompressedBuffer, CompressedBufferSize, UncompressedChunkSize,
-         FinalCompressedSize, WorkSpace);
+    FIXME("0x%04x, %p, %u, %p, %u, %u, %p, %p :semi-stub\n", format, uncompressed,
+          uncompressed_size, compressed, compressed_size, chunk_size, final_size, workspace);
+
+    switch (format & ~COMPRESSION_ENGINE_MAXIMUM)
+    {
+        case COMPRESSION_FORMAT_LZNT1:
+            return lznt1_compress(uncompressed, uncompressed_size, compressed,
+                                  compressed_size, chunk_size, final_size, workspace);
+
+        case COMPRESSION_FORMAT_NONE:
+        case COMPRESSION_FORMAT_DEFAULT:
+            return STATUS_INVALID_PARAMETER;
+
+        default:
+            FIXME("format %d not implemented\n", format);
+            return STATUS_UNSUPPORTED_COMPRESSION;
+    }
+}
+
+/* decompress a single LZNT1 chunk */
+static PUCHAR lznt1_decompress_chunk(UCHAR *dst, ULONG dst_size, UCHAR *src, ULONG src_size)
+{
+    UCHAR *src_cur, *src_end, *dst_cur, *dst_end;
+    ULONG displacement_bits, length_bits;
+    ULONG code_displacement, code_length;
+    WORD flags, code;
+
+    src_cur = src;
+    src_end = src + src_size;
+    dst_cur = dst;
+    dst_end = dst + dst_size;
+
+    /* Partial decompression is no error on Windows. */
+    while (src_cur < src_end && dst_cur < dst_end)
+    {
+        /* read flags header */
+        flags = 0x8000 | *src_cur++;
+
+        /* parse following 8 entities, either uncompressed data or backwards reference */
+        while ((flags & 0xFF00) && src_cur < src_end)
+        {
+            if (flags & 1)
+            {
+                /* backwards reference */
+                if (src_cur + sizeof(WORD) > src_end)
+                    return NULL;
+                code = *(WORD *)src_cur;
+                src_cur += sizeof(WORD);
+
+                /* find length / displacement bits */
+                for (displacement_bits = 12; displacement_bits > 4; displacement_bits--)
+                    if ((1 << (displacement_bits - 1)) < dst_cur - dst) break;
+                length_bits       = 16 - displacement_bits;
+                code_length       = (code & ((1 << length_bits) - 1)) + 3;
+                code_displacement = (code >> length_bits) + 1;
+
+                /* ensure reference is valid */
+                if (dst_cur < dst + code_displacement)
+                    return NULL;
+
+                /* copy bytes of chunk - we can't use memcpy()
+                 * since source and dest can be overlapping */
+                while (code_length--)
+                {
+                    if (dst_cur >= dst_end) return dst_cur;
+                    *dst_cur = *(dst_cur - code_displacement);
+                    dst_cur++;
+                }
+            }
+            else
+            {
+                /* uncompressed data */
+                if (dst_cur >= dst_end) return dst_cur;
+                *dst_cur++ = *src_cur++;
+            }
+            flags >>= 1;
+        }
+
+    }
+
+    return dst_cur;
+}
+
+/* decompress data encoded with LZNT1 */
+static NTSTATUS lznt1_decompress(UCHAR *dst, ULONG dst_size, UCHAR *src, ULONG src_size,
+                                 ULONG offset, ULONG *final_size, UCHAR *workspace)
+{
+    UCHAR *src_cur, *src_end, *dst_cur, *dst_end, *ptr;
+    ULONG chunk_size, block_size;
+    WORD chunk_header;
+
+    src_cur = src;
+    src_end = src + src_size;
+    dst_cur = dst;
+    dst_end = dst + dst_size;
+
+    if (src_cur + sizeof(WCHAR) > src_end)
+        return STATUS_BAD_COMPRESSION_BUFFER;
+
+    /* skip over chunks which have a big distance (>= 0x1000) to the destination offset */
+    while (offset >= 0x1000 && src_cur + sizeof(WCHAR) <= src_end)
+    {
+        /* read chunk header and extract size */
+        chunk_header = *(WORD *)src_cur;
+        src_cur += sizeof(WCHAR);
+        if (!chunk_header) goto out;
+        chunk_size = (chunk_header & 0xFFF) + 1;
+
+        /* ensure we have enough buffer to process chunk */
+        if (src_cur + chunk_size > src_end)
+            return STATUS_BAD_COMPRESSION_BUFFER;
+
+        src_cur += chunk_size;
+        offset  -= 0x1000;
+    }
+
+    /* this chunk is can be included partially */
+    if (offset && src_cur + sizeof(WCHAR) <= src_end)
+    {
+        /* read chunk header and extract size */
+        chunk_header = *(WORD *)src_cur;
+        src_cur += sizeof(WCHAR);
+        if (!chunk_header) goto out;
+        chunk_size = (chunk_header & 0xFFF) + 1;
+
+        /* ensure we have enough buffer to process chunk */
+        if (src_cur + chunk_size > src_end)
+            return STATUS_BAD_COMPRESSION_BUFFER;
+
+        if (dst_cur >= dst_end)
+            goto out;
+
+        if (chunk_header & 0x8000)
+        {
+            /* compressed chunk */
+            if (!workspace) return STATUS_ACCESS_VIOLATION;
+            ptr = lznt1_decompress_chunk(workspace, 0x1000, src_cur, chunk_size);
+            if (!ptr) return STATUS_BAD_COMPRESSION_BUFFER;
+            if (ptr - workspace > offset)
+            {
+                block_size = min((ptr - workspace) - offset, dst_end - dst_cur);
+                memcpy(dst_cur, workspace + offset, block_size);
+                dst_cur += block_size;
+            }
+        }
+        else
+        {
+            /* uncompressed chunk */
+            if (chunk_size > offset)
+            {
+                block_size = min(chunk_size - offset, dst_end - dst_cur);
+                memcpy(dst_cur, src_cur + offset, block_size);
+                dst_cur += block_size;
+            }
+        }
+
+        src_cur += chunk_size;
+    }
+
+    while (src_cur + sizeof(WCHAR) <= src_end)
+    {
+        /* read chunk header and extract size */
+        chunk_header = *(WORD *)src_cur;
+        src_cur += sizeof(WCHAR);
+        if (!chunk_header) goto out;
+        chunk_size = (chunk_header & 0xFFF) + 1;
+
+        /* ensure we have enough buffer to process chunk */
+        if (src_cur + chunk_size > src_end)
+            return STATUS_BAD_COMPRESSION_BUFFER;
+
+        /* add padding if required */
+        block_size = ((dst_cur - dst) + offset) & 0xFFF;
+        if (block_size)
+        {
+            block_size = 0x1000 - block_size;
+            if (dst_cur + block_size >= dst_end)
+                goto out;
+            memset(dst_cur, 0, block_size);
+            dst_cur += block_size;
+        }
+        else if (dst_cur >= dst_end)
+            goto out;
+
+        if (chunk_header & 0x8000)
+        {
+            /* compressed chunk */
+            dst_cur = lznt1_decompress_chunk(dst_cur, dst_end - dst_cur, src_cur, chunk_size);
+            if (!dst_cur) return STATUS_BAD_COMPRESSION_BUFFER;
+        }
+        else
+        {
+            /* uncompressed chunk */
+            block_size = min(chunk_size, dst_end - dst_cur);
+            memcpy(dst_cur, src_cur, block_size);
+            dst_cur += block_size;
+        }
+
+        src_cur += chunk_size;
+    }
+
+out:
+    if (final_size)
+        *final_size = dst_cur - dst;
+
+    return STATUS_SUCCESS;
 
-    return STATUS_NOT_IMPLEMENTED;
 }
 
 /******************************************************************************
- *  RtlDecompressBuffer		[NTDLL.@]
+ *  RtlDecompressFragment      [NTDLL.@]
  */
-NTSTATUS WINAPI RtlDecompressBuffer(USHORT CompressionFormat, PUCHAR UncompressedBuffer,
-                                    ULONG UncompressedBufferSize, PUCHAR CompressedBuffer,
-                                    ULONG CompressedBufferSize, PULONG FinalUncompressedSize)
+NTSTATUS RtlDecompressFragment(USHORT format, PUCHAR uncompressed, ULONG uncompressed_size,
+                               PUCHAR compressed, ULONG compressed_size, ULONG offset,
+                               PULONG final_size, PVOID workspace)
 {
-    FIXME("0x%04x, %p, %u, %p, %u, %p :stub\n", CompressionFormat, UncompressedBuffer, UncompressedBufferSize,
-         CompressedBuffer, CompressedBufferSize, FinalUncompressedSize);
 
-    return STATUS_NOT_IMPLEMENTED;
+    TRACE("0x%04x, %p, %u, %p, %u, %u, %p, %p :stub\n", format, uncompressed,
+          uncompressed_size, compressed, compressed_size, offset, final_size, workspace);
+
+    switch (format & ~COMPRESSION_ENGINE_MAXIMUM)
+    {
+        case COMPRESSION_FORMAT_LZNT1:
+            return lznt1_decompress(uncompressed, uncompressed_size, compressed,
+                                    compressed_size, offset, final_size, workspace);
+
+        case COMPRESSION_FORMAT_NONE:
+        case COMPRESSION_FORMAT_DEFAULT:
+            return STATUS_INVALID_PARAMETER;
+
+        default:
+            FIXME("format %d not implemented\n", format);
+            return STATUS_UNSUPPORTED_COMPRESSION;
+    }
+}
+
+
+/******************************************************************************
+ *  RtlDecompressBuffer		[NTDLL.@]
+ */
+NTSTATUS WINAPI RtlDecompressBuffer(USHORT format, PUCHAR uncompressed, ULONG uncompressed_size,
+                                    PUCHAR compressed, ULONG compressed_size, PULONG final_size)
+{
+    return RtlDecompressFragment(format, uncompressed, uncompressed_size,
+                                 compressed, compressed_size, 0, final_size, NULL);
 }
 
 /***********************************************************************
@@ -1311,3 +1586,30 @@ BOOL WINAPI RtlSetCurrentTransaction(HANDLE new_transaction)
     FIXME("(%p) :stub\n", new_transaction);
     return FALSE;
 }
+
+/******************************************************************************
+ * WinSqmEndSession [NTDLL.@]
+ */
+NTSTATUS WINAPI WinSqmEndSession(PVOID unknown1)
+{
+    FIXME("(%p) stub!\n", unknown1);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/*********************************************************************
+ * WinSqmIsOptedIn [NTDLL.@]
+ */
+BOOL WINAPI WinSqmIsOptedIn(void)
+{
+    FIXME("() stub!\n");
+    return FALSE;
+}
+
+/******************************************************************************
+ * WinSqmStartSession [NTDLL.@]
+ */
+PVOID WINAPI WinSqmStartSession(PVOID unknown1, DWORD unknown2, DWORD unknown3)
+{
+    FIXME("(%p, 0x%x, 0x%x) stub!\n", unknown1, unknown2, unknown3);
+    return NULL;
+}
diff --git a/dlls/ntdll/server.c b/dlls/ntdll/server.c
index 69d01be..a123a95 100644
--- a/dlls/ntdll/server.c
+++ b/dlls/ntdll/server.c
@@ -75,12 +75,15 @@
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#include "windef.h"
+#include "winnt.h"
 #include "wine/library.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "ntdll_misc.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(server);
+WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
 /* Some versions of glibc don't define this */
 #ifndef SCM_RIGHTS
@@ -292,6 +295,14 @@ unsigned int wine_server_call( void *req_ptr )
     sigset_t old_set;
     unsigned int ret;
 
+    /* trigger write watches, otherwise read() might return EFAULT */
+    if (req->u.req.request_header.reply_size &&
+        !virtual_check_buffer_for_write( req->reply_data, req->u.req.request_header.reply_size ))
+    {
+        ret = STATUS_ACCESS_VIOLATION;
+        return ret;
+    }
+
     pthread_sigmask( SIG_BLOCK, &server_block_set, &old_set );
     ret = send_request( req );
     if (!ret) ret = wait_reply( req );
@@ -790,6 +801,7 @@ static int receive_fd( obj_handle_t *handle )
 /***********************************************************************/
 /* fd cache support */
 
+#include "pshpack1.h"
 struct fd_cache_entry
 {
     int fd;
@@ -797,6 +809,7 @@ struct fd_cache_entry
     unsigned int        access : 3;
     unsigned int        options : 24;
 };
+#include "poppack.h"
 
 #define FD_CACHE_BLOCK_SIZE  (65536 / sizeof(struct fd_cache_entry))
 #define FD_CACHE_ENTRIES     128
@@ -811,6 +824,36 @@ static inline unsigned int handle_to_index( HANDLE handle, unsigned int *entry )
     return idx % FD_CACHE_BLOCK_SIZE;
 }
 
+#if !defined(__powerpc__)
+
+static inline LONG64 interlocked_xchg64( LONG64 *dest, LONG64 val )
+{
+#ifdef _WIN64
+    return (LONG64)interlocked_xchg_ptr( (void **)dest, (void *)val );
+#else
+    LONG64 cmp = *dest;
+    while (interlocked_cmpxchg64( dest, val, cmp ) != cmp) cmp = *dest;
+    return cmp;
+#endif
+}
+
+C_ASSERT( sizeof(struct fd_cache_entry) == sizeof(LONG64) );
+
+/* atomically updates a fd cache entry and fetches the old value */
+static inline void interlocked_xchg_fd_cache( struct fd_cache_entry *cache,
+                                              struct fd_cache_entry *val )
+{
+    *(LONG64 *)val = interlocked_xchg64( (LONG64 *)cache, *(LONG64 *)val );
+}
+
+/* atomically reads a fd cache entry */
+static inline void interlocked_read_fd_cache( struct fd_cache_entry *cache,
+                                              struct fd_cache_entry *val )
+{
+    *(LONG64 *)val = interlocked_cmpxchg64( (LONG64 *)cache, 0, 0 );
+}
+
+#endif /* !defined(__powerpc__) */
 
 /***********************************************************************
  *           add_fd_to_cache
@@ -821,6 +864,9 @@ static BOOL add_fd_to_cache( HANDLE handle, int fd, enum server_fd_type type,
                             unsigned int access, unsigned int options )
 {
     unsigned int entry, idx = handle_to_index( handle, &entry );
+#if !defined(__powerpc__)
+    struct fd_cache_entry cache;
+#endif
 
     if (entry >= FD_CACHE_ENTRIES)
     {
@@ -839,12 +885,22 @@ static BOOL add_fd_to_cache( HANDLE handle, int fd, enum server_fd_type type,
             fd_cache[entry] = ptr;
         }
     }
+
     /* store fd+1 so that 0 can be used as the unset value */
+#if defined(__powerpc__)
     fd = interlocked_xchg( &fd_cache[entry][idx].fd, fd + 1 );
     fd_cache[entry][idx].type = type;
     fd_cache[entry][idx].access = access;
     fd_cache[entry][idx].options = options;
     assert( !fd );
+#else
+    cache.fd = fd + 1;
+    cache.type = type;
+    cache.access = access;
+    cache.options = options;
+    interlocked_xchg_fd_cache( &fd_cache[entry][idx], &cache );
+    assert( !cache.fd );
+#endif
     return TRUE;
 }
 
@@ -852,7 +908,7 @@ static BOOL add_fd_to_cache( HANDLE handle, int fd, enum server_fd_type type,
 /***********************************************************************
  *           get_cached_fd
  *
- * Caller must hold fd_cache_section.
+ * Caller must hold fd_cache_section on PowerPC processor architecture.
  */
 static inline int get_cached_fd( HANDLE handle, enum server_fd_type *type,
                                  unsigned int *access, unsigned int *options )
@@ -862,10 +918,19 @@ static inline int get_cached_fd( HANDLE handle, enum server_fd_type *type,
 
     if (entry < FD_CACHE_ENTRIES && fd_cache[entry])
     {
+    #if defined(__powerpc__)
         fd = fd_cache[entry][idx].fd - 1;
         if (type) *type = fd_cache[entry][idx].type;
         if (access) *access = fd_cache[entry][idx].access;
         if (options) *options = fd_cache[entry][idx].options;
+    #else
+        struct fd_cache_entry cache;
+        interlocked_read_fd_cache( &fd_cache[entry][idx], &cache );
+        fd = cache.fd - 1;
+        if (type) *type = cache.type;
+        if (access) *access = cache.access;
+        if (options) *options = cache.options;
+    #endif
     }
     return fd;
 }
@@ -903,6 +968,11 @@ int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
     *needs_close = 0;
     wanted_access &= FILE_READ_DATA | FILE_WRITE_DATA | FILE_APPEND_DATA;
 
+#if !defined(__powerpc__)
+    fd = get_cached_fd( handle, type, &access, options );
+    if (fd != -1) goto done_unlocked;
+#endif
+
     server_enter_uninterrupted_section( &fd_cache_section, &sigset );
 
     fd = get_cached_fd( handle, type, &access, options );
@@ -930,6 +1000,10 @@ int server_get_unix_fd( HANDLE handle, unsigned int wanted_access, int *unix_fd,
 
 done:
     server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+
+#if !defined(__powerpc__)
+done_unlocked:
+#endif
     if (!ret && ((access & wanted_access) != wanted_access))
     {
         ret = STATUS_ACCESS_DENIED;
@@ -941,6 +1015,87 @@ done:
 
 
 /***********************************************************************
+ *           server_get_shared_memory_fd
+ *
+ * Receive a file descriptor to a server shared memory block.
+ */
+static int server_get_shared_memory_fd( HANDLE thread, int *unix_fd )
+{
+    obj_handle_t dummy;
+    sigset_t sigset;
+    int ret;
+
+    server_enter_uninterrupted_section( &fd_cache_section, &sigset );
+
+    SERVER_START_REQ( get_shared_memory )
+    {
+        req->tid = HandleToULong(thread);
+        if (!(ret = wine_server_call( req )))
+        {
+            *unix_fd = receive_fd( &dummy );
+            if (*unix_fd == -1) ret = STATUS_NOT_SUPPORTED;
+        }
+    }
+    SERVER_END_REQ;
+
+    server_leave_uninterrupted_section( &fd_cache_section, &sigset );
+    return ret;
+}
+
+/* The shared memory wineserver communication is still highly experimental
+ * and might cause unexpected results when the client/server status gets
+ * out of synchronization. The feature will be disabled by default until it
+ * is tested a bit more. */
+static inline BOOL experimental_SHARED_MEMORY( void )
+{
+    static int enabled = -1;
+    if (enabled == -1)
+    {
+        const char *str = getenv( "STAGING_SHARED_MEMORY" );
+        enabled = str && (atoi(str) != 0);
+    }
+    return enabled;
+}
+
+
+/***********************************************************************
+ *           server_get_shared_memory
+ *
+ * Get address of a shared memory block.
+ */
+void *server_get_shared_memory( HANDLE thread )
+{
+    static shmglobal_t *shmglobal = (void *)-1;
+    void *mem = NULL;
+    int fd = -1;
+
+    if (!experimental_SHARED_MEMORY())
+        return NULL;
+
+    /* The global memory block is only requested once. No locking is
+     * required because this function is called very early during the
+     * process initialization for the first time. */
+    if (!thread && shmglobal != (void *)-1)
+        return shmglobal;
+
+    if (!server_get_shared_memory_fd( thread, &fd ))
+    {
+        SIZE_T size = thread ? sizeof(shmlocal_t) : sizeof(shmglobal_t);
+        virtual_map_shared_memory( fd, &mem, 0, &size, PAGE_READONLY );
+        close( fd );
+    }
+
+    if (!thread)
+    {
+        if (mem) WARN_(winediag)("Using shared memory wineserver communication\n");
+        shmglobal = mem;
+    }
+
+    return mem;
+}
+
+
+/***********************************************************************
  *           wine_server_fd_to_handle   (NTDLL.@)
  *
  * Allocate a file handle for a Unix file descriptor.
@@ -974,6 +1129,27 @@ int CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int at
 
 
 /***********************************************************************
+ *           wine_server_handle_exists   (NTDLL.@)
+ *
+ * Checks if a file handle exists (without duplicating it).
+ *
+ * PARAMS
+ *     handle  [I] Wine file handle.
+ *     access  [I] Win32 file access rights requested.
+ *
+ * RETURNS
+ *     NTSTATUS code
+ */
+int CDECL wine_server_handle_exists( HANDLE handle, unsigned int access )
+{
+    int unix_fd, needs_close, ret;
+    ret = server_get_unix_fd( handle, access, &unix_fd, &needs_close, NULL, NULL );
+    if (!ret && needs_close) close( unix_fd );
+    return !ret;
+}
+
+
+/***********************************************************************
  *           wine_server_handle_to_fd   (NTDLL.@)
  *
  * Retrieve the file descriptor corresponding to a file handle.
@@ -1472,6 +1648,10 @@ size_t server_init_thread( void *entry_point )
     }
     SERVER_END_REQ;
 
+    /* initialize thread shared memory pointers */
+    NtCurrentTeb()->Reserved5[0] = server_get_shared_memory( 0 );
+    NtCurrentTeb()->Reserved5[1] = server_get_shared_memory( NtCurrentTeb()->ClientId.UniqueThread );
+
     is_wow64 = !is_win64 && (server_cpus & (1 << CPU_x86_64)) != 0;
     ntdll_get_thread_data()->wow64_redir = is_wow64;
 
diff --git a/dlls/ntdll/signal_arm.c b/dlls/ntdll/signal_arm.c
index bdb27af..834db84 100644
--- a/dlls/ntdll/signal_arm.c
+++ b/dlls/ntdll/signal_arm.c
@@ -977,6 +977,12 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+}
 
 /**********************************************************************
  *              __wine_enter_vm86   (NTDLL.@)
diff --git a/dlls/ntdll/signal_arm64.c b/dlls/ntdll/signal_arm64.c
index ccbdf4c..50a65ab 100644
--- a/dlls/ntdll/signal_arm64.c
+++ b/dlls/ntdll/signal_arm64.c
@@ -791,6 +791,12 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+}
 
 /**********************************************************************
  *              __wine_enter_vm86   (NTDLL.@)
diff --git a/dlls/ntdll/signal_i386.c b/dlls/ntdll/signal_i386.c
index 5c3aa819..94e7b28 100644
--- a/dlls/ntdll/signal_i386.c
+++ b/dlls/ntdll/signal_i386.c
@@ -96,6 +96,14 @@ typedef struct
     BYTE Reserved4[96];
 } XMM_SAVE_AREA32;
 
+#include "pshpack1.h"
+struct idtr
+{
+    WORD  limit;
+    BYTE *base;
+};
+#include "poppack.h"
+
 /***********************************************************************
  * signal context platform-specific definitions
  */
@@ -1572,6 +1580,214 @@ static inline DWORD is_privileged_instr( CONTEXT *context )
     }
 }
 
+
+#ifdef EXAGEAR_COMPAT
+
+/***********************************************************************
+ *           INSTR_GetOperandAddr
+ *
+ * Return the address of an instruction operand (from the mod/rm byte).
+ */
+static BYTE *INSTR_GetOperandAddr( CONTEXT *context, const BYTE *instr,
+                                   int long_addr, int segprefix, int *len )
+{
+    int mod, rm, base = 0, index = 0, ss = 0, off;
+
+#define GET_VAL(val,type) \
+    { *val = *(type *)instr; instr += sizeof(type); *len += sizeof(type); }
+
+    *len = 0;
+    GET_VAL( &mod, BYTE );
+    rm = mod & 7;
+    mod >>= 6;
+
+    if (mod == 3)
+    {
+        switch(rm)
+        {
+        case 0: return (BYTE *)&context->Eax;
+        case 1: return (BYTE *)&context->Ecx;
+        case 2: return (BYTE *)&context->Edx;
+        case 3: return (BYTE *)&context->Ebx;
+        case 4: return (BYTE *)&context->Esp;
+        case 5: return (BYTE *)&context->Ebp;
+        case 6: return (BYTE *)&context->Esi;
+        case 7: return (BYTE *)&context->Edi;
+        }
+    }
+
+    if (long_addr)
+    {
+        if (rm == 4)
+        {
+            BYTE sib;
+            GET_VAL( &sib, BYTE );
+            rm = sib & 7;
+            ss = sib >> 6;
+            switch((sib >> 3) & 7)
+            {
+            case 0: index = context->Eax; break;
+            case 1: index = context->Ecx; break;
+            case 2: index = context->Edx; break;
+            case 3: index = context->Ebx; break;
+            case 4: index = 0; break;
+            case 5: index = context->Ebp; break;
+            case 6: index = context->Esi; break;
+            case 7: index = context->Edi; break;
+            }
+        }
+
+        switch(rm)
+        {
+        case 0: base = context->Eax; break;
+        case 1: base = context->Ecx; break;
+        case 2: base = context->Edx; break;
+        case 3: base = context->Ebx; break;
+        case 4: base = context->Esp; break;
+        case 5: base = context->Ebp; break;
+        case 6: base = context->Esi; break;
+        case 7: base = context->Edi; break;
+        }
+        switch (mod)
+        {
+        case 0:
+            if (rm == 5)  /* special case: ds:(disp32) */
+            {
+                GET_VAL( &base, DWORD );
+            }
+            break;
+
+        case 1:  /* 8-bit disp */
+            GET_VAL( &off, BYTE );
+            base += (signed char)off;
+            break;
+
+        case 2:  /* 32-bit disp */
+            GET_VAL( &off, DWORD );
+            base += (signed long)off;
+            break;
+        }
+    }
+    else  /* short address */
+    {
+        switch(rm)
+        {
+        case 0:  /* ds:(bx,si) */
+            base = LOWORD(context->Ebx) + LOWORD(context->Esi);
+            break;
+        case 1:  /* ds:(bx,di) */
+            base = LOWORD(context->Ebx) + LOWORD(context->Edi);
+            break;
+        case 2:  /* ss:(bp,si) */
+            base = LOWORD(context->Ebp) + LOWORD(context->Esi);
+            break;
+        case 3:  /* ss:(bp,di) */
+            base = LOWORD(context->Ebp) + LOWORD(context->Edi);
+            break;
+        case 4:  /* ds:(si) */
+            base = LOWORD(context->Esi);
+            break;
+        case 5:  /* ds:(di) */
+            base = LOWORD(context->Edi);
+            break;
+        case 6:  /* ss:(bp) */
+            base = LOWORD(context->Ebp);
+            break;
+        case 7:  /* ds:(bx) */
+            base = LOWORD(context->Ebx);
+            break;
+        }
+
+        switch(mod)
+        {
+        case 0:
+            if (rm == 6)  /* special case: ds:(disp16) */
+            {
+                GET_VAL( &base, WORD );
+            }
+            break;
+
+        case 1:  /* 8-bit disp */
+            GET_VAL( &off, BYTE );
+            base += (signed char)off;
+            break;
+
+        case 2:  /* 16-bit disp */
+            GET_VAL( &off, WORD );
+            base += (signed short)off;
+            break;
+        }
+        base &= 0xffff;
+    }
+    /* FIXME: we assume that all segments have a base of 0 */
+    return (BYTE *)(base + (index << ss));
+#undef GET_VAL
+}
+
+
+/***********************************************************************
+ *           check_invalid_instr
+ *
+ * Support for instructions not implemented by Exagear.
+ */
+static inline BOOL check_invalid_instr( CONTEXT *context )
+{
+    const BYTE *instr;
+    unsigned int prefix_count = 0;
+    int len, long_addr = 1;
+
+    if (!wine_ldt_is_system( context->SegCs )) return FALSE;
+    instr = (BYTE *)context->Eip;
+
+    for (;;) switch (*instr)
+    {
+    /* instruction prefixes */
+    case 0x2e:  /* %cs: */
+    case 0x36:  /* %ss: */
+    case 0x3e:  /* %ds: */
+    case 0x26:  /* %es: */
+    case 0x64:  /* %fs: */
+    case 0x65:  /* %gs: */
+    case 0x66:  /* opcode size */
+    case 0x67:  /* addr size */
+    case 0xf0:  /* lock */
+    case 0xf2:  /* repne */
+    case 0xf3:  /* repe */
+        if (++prefix_count >= 15) return FALSE;
+        if (*instr == 0x67) long_addr = !long_addr; /* addr size */
+        instr++;
+        continue;
+    case 0x0f: /* extended instruction */
+        switch (instr[1])
+        {
+        case 0x01:
+            if (((instr[2] >> 3) & 7) == 1) /* sidt m */
+            {
+                struct idtr ret;
+                BYTE *addr;
+
+                if ((instr[2] >> 6) == 3) return FALSE; /* loading to register not allowed */
+                addr = INSTR_GetOperandAddr( context, instr + 2, long_addr, 0, &len );
+
+                /* fake IDT structure */
+                ret.limit = 0xfff;
+                ret.base  = (void *)0xff000000;
+                memcpy(addr, &ret, sizeof(ret));
+
+                context->Eip += prefix_count + len + 2;
+                return TRUE;
+            }
+            break;
+        }
+        return FALSE;
+    default:
+        return FALSE;
+    }
+}
+
+#endif /* EXAGEAR_COMPAT */
+
+
 /***********************************************************************
  *           check_invalid_gs
  *
@@ -1669,13 +1885,13 @@ static BOOL check_atl_thunk( EXCEPTION_RECORD *rec, CONTEXT *context )
     union atl_thunk thunk_copy;
     SIZE_T thunk_len;
 
-    thunk_len = virtual_uninterrupted_read_memory( thunk, &thunk_copy, sizeof(*thunk) );
+    thunk_len = wine_uninterrupted_read_memory( thunk, &thunk_copy, sizeof(*thunk) );
     if (!thunk_len) return FALSE;
 
     if (thunk_len >= sizeof(thunk_copy.t1) && thunk_copy.t1.movl == 0x042444c7 &&
                                               thunk_copy.t1.jmp == 0xe9)
     {
-        if (virtual_uninterrupted_write_memory( (DWORD *)context->Esp + 1,
+        if (wine_uninterrupted_write_memory( (DWORD *)context->Esp + 1,
             &thunk_copy.t1.this, sizeof(DWORD) ) == sizeof(DWORD))
         {
             context->Eip = (DWORD_PTR)(&thunk->t1.func + 1) + thunk_copy.t1.func;
@@ -1719,11 +1935,11 @@ static BOOL check_atl_thunk( EXCEPTION_RECORD *rec, CONTEXT *context )
                                                    thunk_copy.t5.inst2 == 0x0460)
     {
         DWORD func, stack[2];
-        if (virtual_uninterrupted_read_memory( (DWORD *)context->Esp,
+        if (wine_uninterrupted_read_memory( (DWORD *)context->Esp,
             stack, sizeof(stack) ) == sizeof(stack) &&
-            virtual_uninterrupted_read_memory( (DWORD *)stack[1] + 1,
+            wine_uninterrupted_read_memory( (DWORD *)stack[1] + 1,
             &func, sizeof(DWORD) ) == sizeof(DWORD) &&
-            virtual_uninterrupted_write_memory( (DWORD *)context->Esp + 1,
+            wine_uninterrupted_write_memory( (DWORD *)context->Esp + 1,
             &stack[0], sizeof(stack[0]) ) == sizeof(stack[0]))
         {
             context->Ecx = stack[0];
@@ -1901,6 +2117,14 @@ static void WINAPI raise_segv_exception( EXCEPTION_RECORD *rec, CONTEXT *context
 
     switch(rec->ExceptionCode)
     {
+#ifdef EXAGEAR_COMPAT
+    case EXCEPTION_ILLEGAL_INSTRUCTION:
+        {
+            if (check_invalid_instr( context ))
+                goto done;
+        }
+        break;
+#endif
     case EXCEPTION_ACCESS_VIOLATION:
         if (rec->NumberParameters == 2)
         {
@@ -2035,6 +2259,30 @@ static void usr2_handler( int signal, siginfo_t *siginfo, void *sigcontext )
 
 
 /**********************************************************************
+ *    segv_handler_early
+ *
+ * Handler for SIGSEGV and related errors. Used only during the initialization
+ * of the process to handle virtual faults.
+ */
+static void segv_handler_early( int signal, siginfo_t *siginfo, void *sigcontext )
+{
+    WORD fs, gs;
+    ucontext_t *context = sigcontext;
+    init_handler( sigcontext, &fs, &gs );
+
+    switch(get_trap_code(context))
+    {
+    case TRAP_x86_PAGEFLT:  /* Page fault */
+        if (!virtual_handle_fault( siginfo->si_addr, (get_error_code(context) >> 1) & 0x09, TRUE ))
+            return;
+        /* fall-through */
+    default:
+        WINE_ERR( "Got unexpected trap %d during process initialization\n", get_trap_code(context) );
+        break;
+    }
+}
+
+/**********************************************************************
  *		segv_handler
  *
  * Handler for SIGSEGV and related errors.
@@ -2466,6 +2714,29 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+    struct sigaction sig_act;
+
+    sig_act.sa_mask = server_block_set;
+    sig_act.sa_flags = SA_SIGINFO | SA_RESTART;
+#ifdef SA_ONSTACK
+    sig_act.sa_flags |= SA_ONSTACK;
+#endif
+#ifdef __ANDROID__
+    sig_act.sa_flags |= SA_RESTORER;
+    sig_act.sa_restorer = rt_sigreturn;
+#endif
+    sig_act.sa_sigaction = segv_handler_early;
+    if (sigaction( SIGSEGV, &sig_act, NULL ) == -1)
+    {
+        perror("sigaction");
+        exit(1);
+    }
+}
 
 #ifdef __HAVE_VM86
 /**********************************************************************
diff --git a/dlls/ntdll/signal_powerpc.c b/dlls/ntdll/signal_powerpc.c
index 886da86..d2e7819 100644
--- a/dlls/ntdll/signal_powerpc.c
+++ b/dlls/ntdll/signal_powerpc.c
@@ -1048,6 +1048,12 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+}
 
 /**********************************************************************
  *              __wine_enter_vm86   (NTDLL.@)
diff --git a/dlls/ntdll/signal_x86_64.c b/dlls/ntdll/signal_x86_64.c
index 493a9f7..8cd26c2 100644
--- a/dlls/ntdll/signal_x86_64.c
+++ b/dlls/ntdll/signal_x86_64.c
@@ -2623,6 +2623,12 @@ void signal_init_process(void)
     exit(1);
 }
 
+/**********************************************************************
+ *    signal_init_early
+ */
+void signal_init_early(void)
+{
+}
 
 /**********************************************************************
  *              RtlAddFunctionTable   (NTDLL.@)
diff --git a/dlls/ntdll/sync.c b/dlls/ntdll/sync.c
index 04c6de30..d576ee7 100644
--- a/dlls/ntdll/sync.c
+++ b/dlls/ntdll/sync.c
@@ -635,8 +635,37 @@ NTSTATUS WINAPI NtTerminateJobObject( HANDLE handle, NTSTATUS status )
 NTSTATUS WINAPI NtQueryInformationJobObject( HANDLE handle, JOBOBJECTINFOCLASS class, PVOID info,
                                              ULONG len, PULONG ret_len )
 {
+    JOBOBJECT_EXTENDED_LIMIT_INFORMATION *extended_limit;
+    JOBOBJECT_BASIC_LIMIT_INFORMATION *basic_limit;
+
     FIXME( "stub: %p %u %p %u %p\n", handle, class, info, len, ret_len );
-    return STATUS_NOT_IMPLEMENTED;
+
+    if (class >= MaxJobObjectInfoClass)
+        return STATUS_INVALID_PARAMETER;
+
+    switch (class)
+    {
+    case JobObjectExtendedLimitInformation:
+        if (len < sizeof(JOBOBJECT_EXTENDED_LIMIT_INFORMATION))
+            return STATUS_INVALID_PARAMETER;
+
+        extended_limit = (JOBOBJECT_EXTENDED_LIMIT_INFORMATION *)info;
+        memset(extended_limit, 0, sizeof(*extended_limit));
+        if (ret_len) *ret_len = sizeof(*extended_limit);
+        return STATUS_SUCCESS;
+
+    case JobObjectBasicLimitInformation:
+        if (len < sizeof(JOBOBJECT_BASIC_LIMIT_INFORMATION))
+            return STATUS_INVALID_PARAMETER;
+
+        basic_limit = (JOBOBJECT_BASIC_LIMIT_INFORMATION *)info;
+        memset(basic_limit, 0, sizeof(*basic_limit));
+        if (ret_len) *ret_len = sizeof(*basic_limit);
+        return STATUS_SUCCESS;
+
+    default:
+        return STATUS_NOT_IMPLEMENTED;
+    }
 }
 
 /******************************************************************************
diff --git a/dlls/ntdll/tests/directory.c b/dlls/ntdll/tests/directory.c
index f190ff4..68b5406 100644
--- a/dlls/ntdll/tests/directory.c
+++ b/dlls/ntdll/tests/directory.c
@@ -51,7 +51,6 @@ static NTSTATUS (WINAPI *pRtlWow64EnableFsRedirectionEx)( ULONG disable, ULONG *
 
 /* The attribute sets to test */
 static struct testfile_s {
-    BOOL todo;                /* set if it doesn't work on wine yet */
     BOOL attr_done;           /* set if attributes were tested for this file already */
     const DWORD attr;         /* desired attribute */
     const char *name;         /* filename to use */
@@ -60,13 +59,13 @@ static struct testfile_s {
     int nfound;               /* How many were found (expect 1) */
     WCHAR nameW[20];          /* unicode version of name (filled in later) */
 } testfiles[] = {
-    { 0, 0, FILE_ATTRIBUTE_NORMAL,    "n.tmp", NULL, "normal" },
-    { 1, 0, FILE_ATTRIBUTE_HIDDEN,    "h.tmp", NULL, "hidden" },
-    { 1, 0, FILE_ATTRIBUTE_SYSTEM,    "s.tmp", NULL, "system" },
-    { 0, 0, FILE_ATTRIBUTE_DIRECTORY, "d.tmp", NULL, "directory" },
-    { 0, 0, FILE_ATTRIBUTE_DIRECTORY, ".",     NULL, ". directory" },
-    { 0, 0, FILE_ATTRIBUTE_DIRECTORY, "..",    NULL, ".. directory" },
-    { 0, 0, 0, NULL }
+    { 0, FILE_ATTRIBUTE_NORMAL,    "n.tmp", NULL, "normal" },
+    { 0, FILE_ATTRIBUTE_HIDDEN,    "h.tmp", NULL, "hidden" },
+    { 0, FILE_ATTRIBUTE_SYSTEM,    "s.tmp", NULL, "system" },
+    { 0, FILE_ATTRIBUTE_DIRECTORY, "d.tmp", NULL, "directory" },
+    { 0, FILE_ATTRIBUTE_DIRECTORY, ".",     NULL, ". directory" },
+    { 0, FILE_ATTRIBUTE_DIRECTORY, "..",    NULL, ".. directory" },
+    { 0, 0, NULL }
 };
 static const int max_test_dir_size = 20;  /* size of above plus some for .. etc */
 
@@ -147,12 +146,7 @@ static void tally_test_file(FILE_BOTH_DIRECTORY_INFORMATION *dir_info)
         if (namelen != len || memcmp(nameW, testfiles[i].nameW, len*sizeof(WCHAR)))
             continue;
         if (!testfiles[i].attr_done) {
-            if (testfiles[i].todo) {
-                todo_wine
-                ok (attrib == (testfiles[i].attr & attribmask), "file %s: expected %s (%x), got %x (is your linux new enough?)\n", testfiles[i].name, testfiles[i].description, testfiles[i].attr, attrib);
-            } else {
-                ok (attrib == (testfiles[i].attr & attribmask), "file %s: expected %s (%x), got %x (is your linux new enough?)\n", testfiles[i].name, testfiles[i].description, testfiles[i].attr, attrib);
-            }
+            ok (attrib == (testfiles[i].attr & attribmask), "file %s: expected %s (%x), got %x (is your linux new enough?)\n", testfiles[i].name, testfiles[i].description, testfiles[i].attr, attrib);
             testfiles[i].attr_done = TRUE;
         }
         testfiles[i].nfound++;
diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index a594e3f..063dde6 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -52,6 +52,7 @@ static NTSTATUS  (WINAPI *pNtTerminateProcess)(HANDLE handle, LONG exit_code);
 static NTSTATUS  (WINAPI *pNtQueryInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);
 static NTSTATUS  (WINAPI *pNtSetInformationProcess)(HANDLE, PROCESSINFOCLASS, PVOID, ULONG);
 static BOOL      (WINAPI *pIsWow64Process)(HANDLE, PBOOL);
+static NTSTATUS  (WINAPI *pNtClose)(HANDLE);
 
 #if defined(__x86_64__)
 static BOOLEAN   (CDECL *pRtlAddFunctionTable)(RUNTIME_FUNCTION*, DWORD, DWORD64);
@@ -937,6 +938,16 @@ static void test_debugger(void)
                         /* here we handle exception */
                     }
                 }
+                else if (stage == 7 || stage == 8)
+                {
+                    ok(de.u.Exception.ExceptionRecord.ExceptionCode == EXCEPTION_INVALID_HANDLE,
+                       "unexpected exception code %08x, expected %08x\n", de.u.Exception.ExceptionRecord.ExceptionCode,
+                       EXCEPTION_INVALID_HANDLE);
+                    ok(de.u.Exception.ExceptionRecord.NumberParameters == 0,
+                       "unexpected number of parameters %d, expected 0\n", de.u.Exception.ExceptionRecord.NumberParameters);
+
+                    if (stage == 8) continuestatus = DBG_EXCEPTION_NOT_HANDLED;
+                }
                 else
                     ok(FALSE, "unexpected stage %x\n", stage);
 
@@ -1715,7 +1726,7 @@ static LONG CALLBACK outputdebugstring_vectored_handler(EXCEPTION_POINTERS *Exce
     return EXCEPTION_CONTINUE_SEARCH;
 }
 
-static void test_outputdebugstring(DWORD numexc, BOOL todo)
+static void test_outputdebugstring(DWORD numexc)
 {
     PVOID vectored_handler;
 
@@ -1730,13 +1741,8 @@ static void test_outputdebugstring(DWORD numexc, BOOL todo)
 
     outputdebugstring_exceptions = 0;
     OutputDebugStringA("Hello World");
-    if (todo)
-        todo_wine
-        ok(outputdebugstring_exceptions == numexc, "OutputDebugStringA generated %d exceptions, expected %d\n",
-           outputdebugstring_exceptions, numexc);
-    else
-        ok(outputdebugstring_exceptions == numexc, "OutputDebugStringA generated %d exceptions, expected %d\n",
-           outputdebugstring_exceptions, numexc);
+    ok(outputdebugstring_exceptions == numexc, "OutputDebugStringA generated %d exceptions, expected %d\n",
+       outputdebugstring_exceptions, numexc);
 
     pRtlRemoveVectoredExceptionHandler(vectored_handler);
 }
@@ -1790,6 +1796,53 @@ static void test_ripevent(DWORD numexc)
     pRtlRemoveVectoredExceptionHandler(vectored_handler);
 }
 
+static DWORD invalid_handle_exceptions;
+
+static LONG CALLBACK invalid_handle_vectored_handler(EXCEPTION_POINTERS *ExceptionInfo)
+{
+    PEXCEPTION_RECORD rec = ExceptionInfo->ExceptionRecord;
+    trace("vect. handler %08x addr:%p\n", rec->ExceptionCode, rec->ExceptionAddress);
+
+    ok(rec->ExceptionCode == EXCEPTION_INVALID_HANDLE, "ExceptionCode is %08x instead of %08x\n",
+       rec->ExceptionCode, EXCEPTION_INVALID_HANDLE);
+    ok(rec->NumberParameters == 0, "ExceptionParameters is %d instead of 0\n", rec->NumberParameters);
+
+    invalid_handle_exceptions++;
+    return (rec->ExceptionCode == EXCEPTION_INVALID_HANDLE) ? EXCEPTION_CONTINUE_EXECUTION : EXCEPTION_CONTINUE_SEARCH;
+}
+
+static void test_closehandle(DWORD numexc)
+{
+    PVOID vectored_handler;
+    NTSTATUS status;
+    DWORD res;
+
+    if (!pRtlAddVectoredExceptionHandler || !pRtlRemoveVectoredExceptionHandler || !pRtlRaiseException)
+    {
+        skip("RtlAddVectoredExceptionHandler or RtlRemoveVectoredExceptionHandler or RtlRaiseException not found\n");
+        return;
+    }
+
+    vectored_handler = pRtlAddVectoredExceptionHandler(TRUE, &invalid_handle_vectored_handler);
+    ok(vectored_handler != 0, "RtlAddVectoredExceptionHandler failed\n");
+
+    invalid_handle_exceptions = 0;
+    res = CloseHandle((HANDLE)0xdeadbeef);
+    ok(!res, "CloseHandle(0xdeadbeef) unexpectedly succeeded\n");
+    ok(GetLastError() == ERROR_INVALID_HANDLE, "wrong error code %d instead of %d",
+       GetLastError(), ERROR_INVALID_HANDLE);
+    ok(invalid_handle_exceptions == numexc, "CloseHandle generated %d exceptions, expected %d\n",
+       invalid_handle_exceptions, numexc);
+
+    invalid_handle_exceptions = 0;
+    status = pNtClose((HANDLE)0xdeadbeef);
+    ok(status == STATUS_INVALID_HANDLE, "NtClose(0xdeadbeef) returned status %08x\n", status);
+    ok(invalid_handle_exceptions == numexc, "NtClose generated %d exceptions, expected %d\n",
+       invalid_handle_exceptions, numexc);
+
+    pRtlRemoveVectoredExceptionHandler(vectored_handler);
+}
+
 static void test_vectored_continue_handler(void)
 {
     PVOID handler1, handler2;
@@ -1842,6 +1895,7 @@ START_TEST(exception)
     pNtGetContextThread  = (void *)GetProcAddress( hntdll, "NtGetContextThread" );
     pNtSetContextThread  = (void *)GetProcAddress( hntdll, "NtSetContextThread" );
     pNtReadVirtualMemory = (void *)GetProcAddress( hntdll, "NtReadVirtualMemory" );
+    pNtClose             = (void *)GetProcAddress( hntdll, "NtClose" );
     pRtlUnwind           = (void *)GetProcAddress( hntdll, "RtlUnwind" );
     pRtlRaiseException   = (void *)GetProcAddress( hntdll, "RtlRaiseException" );
     pNtTerminateProcess  = (void *)GetProcAddress( hntdll, "NtTerminateProcess" );
@@ -1902,13 +1956,17 @@ START_TEST(exception)
             run_rtlraiseexception_test(EXCEPTION_BREAKPOINT);
             run_rtlraiseexception_test(EXCEPTION_INVALID_HANDLE);
             test_stage = 3;
-            test_outputdebugstring(0, FALSE);
+            test_outputdebugstring(0);
             test_stage = 4;
-            test_outputdebugstring(2, TRUE); /* is this a Windows bug? */
+            test_outputdebugstring(2);
             test_stage = 5;
             test_ripevent(0);
             test_stage = 6;
             test_ripevent(1);
+            test_stage = 7;
+            test_closehandle(0);
+            test_stage = 8;
+            test_closehandle(1);
         }
         else
             skip( "RtlRaiseException not found\n" );
@@ -1920,8 +1978,9 @@ START_TEST(exception)
     test_unwind();
     test_exceptions();
     test_rtlraiseexception();
-    test_outputdebugstring(1, FALSE);
+    test_outputdebugstring(1);
     test_ripevent(1);
+    test_closehandle(0);
     test_vectored_continue_handler();
     test_debugger();
     test_simd_exceptions();
@@ -1939,8 +1998,9 @@ START_TEST(exception)
     pRtlLookupFunctionEntry            = (void *)GetProcAddress( hntdll,
                                                                  "RtlLookupFunctionEntry" );
 
-    test_outputdebugstring(1, FALSE);
+    test_outputdebugstring(1);
     test_ripevent(1);
+    test_closehandle(0);
     test_vectored_continue_handler();
     test_virtual_unwind();
 
diff --git a/dlls/ntdll/tests/file.c b/dlls/ntdll/tests/file.c
index d70ed6b..91ac6a7 100644
--- a/dlls/ntdll/tests/file.c
+++ b/dlls/ntdll/tests/file.c
@@ -37,6 +37,7 @@
 #include "winternl.h"
 #include "winuser.h"
 #include "winioctl.h"
+#include "ntifs.h"
 
 #ifndef IO_COMPLETION_ALL_ACCESS
 #define IO_COMPLETION_ALL_ACCESS 0x001F0003
@@ -1234,7 +1235,7 @@ static void test_file_basic_information(void)
     memset(&fbi, 0, sizeof(fbi));
     res = pNtQueryInformationFile(h, &io, &fbi, sizeof fbi, FileBasicInformation);
     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
-    todo_wine ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM\n", fbi.FileAttributes );
+    ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM (ok in old linux without xattr)\n", fbi.FileAttributes );
 
     /* Then HIDDEN */
     memset(&fbi, 0, sizeof(fbi));
@@ -1247,7 +1248,7 @@ static void test_file_basic_information(void)
     memset(&fbi, 0, sizeof(fbi));
     res = pNtQueryInformationFile(h, &io, &fbi, sizeof fbi, FileBasicInformation);
     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
-    todo_wine ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN\n", fbi.FileAttributes );
+    ok ( (fbi.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN (ok in old linux without xattr)\n", fbi.FileAttributes );
 
     /* Check NORMAL last of all (to make sure we can clear attributes) */
     memset(&fbi, 0, sizeof(fbi));
@@ -1304,7 +1305,7 @@ static void test_file_all_information(void)
     memset(&fai_buf.fai, 0, sizeof(fai_buf.fai));
     res = pNtQueryInformationFile(h, &io, &fai_buf.fai, sizeof fai_buf, FileAllInformation);
     ok ( res == STATUS_SUCCESS, "can't get attributes, res %x\n", res);
-    todo_wine ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM\n", fai_buf.fai.BasicInformation.FileAttributes );
+    ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_SYSTEM, "attribute %x not FILE_ATTRIBUTE_SYSTEM (ok in old linux without xattr)\n", fai_buf.fai.BasicInformation.FileAttributes );
 
     /* Then HIDDEN */
     memset(&fai_buf.fai.BasicInformation, 0, sizeof(fai_buf.fai.BasicInformation));
@@ -1317,7 +1318,7 @@ static void test_file_all_information(void)
     memset(&fai_buf.fai, 0, sizeof(fai_buf.fai));
     res = pNtQueryInformationFile(h, &io, &fai_buf.fai, sizeof fai_buf, FileAllInformation);
     ok ( res == STATUS_SUCCESS, "can't get attributes\n");
-    todo_wine ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN\n", fai_buf.fai.BasicInformation.FileAttributes );
+    ok ( (fai_buf.fai.BasicInformation.FileAttributes & attrib_mask) == FILE_ATTRIBUTE_HIDDEN, "attribute %x not FILE_ATTRIBUTE_HIDDEN (ok in old linux without xattr)\n", fai_buf.fai.BasicInformation.FileAttributes );
 
     /* Check NORMAL last of all (to make sure we can clear attributes) */
     memset(&fai_buf.fai.BasicInformation, 0, sizeof(fai_buf.fai.BasicInformation));
@@ -1355,11 +1356,12 @@ static void test_file_disposition_information(void)
 {
     char tmp_path[MAX_PATH], buffer[MAX_PATH + 16];
     DWORD dirpos;
-    HANDLE handle, handle2;
+    HANDLE handle, handle2, mapping;
     NTSTATUS res;
     IO_STATUS_BLOCK io;
     FILE_DISPOSITION_INFORMATION fdi;
     BOOL fileDeleted;
+    void *ptr;
 
     GetTempPathA( MAX_PATH, tmp_path );
 
@@ -1371,7 +1373,6 @@ static void test_file_disposition_information(void)
     ok( res == STATUS_INVALID_INFO_CLASS || res == STATUS_NOT_IMPLEMENTED, "Unexpected NtQueryInformationFile result (expected STATUS_INVALID_INFO_CLASS, got %x)\n", res );
     fdi.DoDeleteFile = TRUE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_ACCESS_DENIED, "unexpected FileDispositionInformation result (expected STATUS_ACCESS_DENIED, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
@@ -1384,16 +1385,28 @@ static void test_file_disposition_information(void)
     ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
     fdi.DoDeleteFile = TRUE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
-    todo_wine
     ok( fileDeleted, "File should have been deleted\n" );
     DeleteFileA( buffer );
 
     /* cannot set disposition on readonly file */
     GetTempFileNameA( tmp_path, "dis", 0, buffer );
+    DeleteFileA( buffer );
+    handle = CreateFileA(buffer, GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_READONLY, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
+    fdi.DoDeleteFile = TRUE;
+    res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
+    ok( res == STATUS_CANNOT_DELETE, "unexpected FileDispositionInformation result (expected STATUS_CANNOT_DELETE, got %x)\n", res );
+    CloseHandle( handle );
+    fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    ok( !fileDeleted, "File shouldn't have been deleted\n" );
+    SetFileAttributesA( buffer, FILE_ATTRIBUTE_NORMAL );
+    DeleteFileA( buffer );
+
+    /* cannot set disposition on readonly file */
+    GetTempFileNameA( tmp_path, "dis", 0, buffer );
     handle = CreateFileA(buffer, GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_READONLY, 0);
     ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
     fdi.DoDeleteFile = TRUE;
@@ -1402,6 +1415,21 @@ static void test_file_disposition_information(void)
     ok( res == STATUS_CANNOT_DELETE, "unexpected FileDispositionInformation result (expected STATUS_CANNOT_DELETE, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    todo_wine
+    ok( !fileDeleted, "File shouldn't have been deleted\n" );
+    SetFileAttributesA( buffer, FILE_ATTRIBUTE_NORMAL );
+    DeleteFileA( buffer );
+
+    /* cannot set disposition on readonly file */
+    GetTempFileNameA( tmp_path, "dis", 0, buffer );
+    DeleteFileA( buffer );
+    handle = CreateFileA(buffer, GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_READONLY, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
+    fdi.DoDeleteFile = TRUE;
+    res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
+    ok( res == STATUS_CANNOT_DELETE, "unexpected FileDispositionInformation result (expected STATUS_CANNOT_DELETE, got %x)\n", res );
+    CloseHandle( handle );
+    fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
     ok( !fileDeleted, "File shouldn't have been deleted\n" );
     SetFileAttributesA( buffer, FILE_ATTRIBUTE_NORMAL );
     DeleteFileA( buffer );
@@ -1412,11 +1440,9 @@ static void test_file_disposition_information(void)
     ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
     fdi.DoDeleteFile = TRUE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     fdi.DoDeleteFile = FALSE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
@@ -1429,7 +1455,6 @@ static void test_file_disposition_information(void)
     ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
     fdi.DoDeleteFile = FALSE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
@@ -1444,7 +1469,6 @@ static void test_file_disposition_information(void)
     CloseHandle( handle );
     fdi.DoDeleteFile = FALSE;
     res = pNtSetInformationFile( handle2, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     CloseHandle( handle2 );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
@@ -1459,11 +1483,9 @@ static void test_file_disposition_information(void)
     ok( handle != INVALID_HANDLE_VALUE, "failed to open a directory\n" );
     fdi.DoDeleteFile = TRUE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
-    todo_wine
     ok( fileDeleted, "Directory should have been deleted\n" );
     RemoveDirectoryA( buffer );
 
@@ -1476,7 +1498,6 @@ static void test_file_disposition_information(void)
     RemoveDirectoryA( buffer );
     fdi.DoDeleteFile = FALSE;
     res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
-    todo_wine
     ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
@@ -1501,8 +1522,75 @@ static void test_file_disposition_information(void)
     buffer[dirpos] = '\0';
     CloseHandle( handle );
     fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    todo_wine
     ok( !fileDeleted, "Directory shouldn't have been deleted\n" );
     RemoveDirectoryA( buffer );
+
+    /* cannot set disposition on file with file mapping opened */
+    GetTempFileNameA( tmp_path, "dis", 0, buffer );
+    handle = CreateFileA(buffer, GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
+    mapping = CreateFileMappingA( handle, NULL, PAGE_READWRITE, 0, 64 * 1024, "DelFileTest" );
+    ok( mapping != NULL, "failed to create file mapping\n");
+    fdi.DoDeleteFile = TRUE;
+    res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
+    ok( res == STATUS_CANNOT_DELETE, "unexpected FileDispositionInformation result (expected STATUS_CANNOT_DELETE, got %x)\n", res );
+    CloseHandle( handle );
+    fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    ok( !fileDeleted, "File shouldn't have been deleted\n" );
+    CloseHandle( mapping );
+    DeleteFileA( buffer );
+
+    /* can set disposition on file with file mapping closed */
+    GetTempFileNameA( tmp_path, "dis", 0, buffer );
+    handle = CreateFileA(buffer, GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
+    mapping = CreateFileMappingA( handle, NULL, PAGE_READWRITE, 0, 64 * 1024, "DelFileTest" );
+    ok( mapping != NULL, "failed to create file mapping\n");
+    CloseHandle( mapping );
+    fdi.DoDeleteFile = TRUE;
+    res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
+    ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
+    CloseHandle( handle );
+    fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    ok( fileDeleted, "File should have been deleted\n" );
+    DeleteFileA( buffer );
+
+    /* cannot set disposition on file which is mapped to memory */
+    GetTempFileNameA( tmp_path, "dis", 0, buffer );
+    handle = CreateFileA(buffer, GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
+    mapping = CreateFileMappingA( handle, NULL, PAGE_READWRITE, 0, 64 * 1024, "DelFileTest" );
+    ok( mapping != NULL, "failed to create file mapping\n");
+    ptr = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 4096 );
+    ok( ptr != NULL, "MapViewOfFile failed\n");
+    CloseHandle( mapping );
+    fdi.DoDeleteFile = TRUE;
+    res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
+    ok( res == STATUS_CANNOT_DELETE, "unexpected FileDispositionInformation result (expected STATUS_CANNOT_DELETE, got %x)\n", res );
+    CloseHandle( handle );
+    fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    ok( !fileDeleted, "File shouldn't have been deleted\n" );
+    UnmapViewOfFile( ptr );
+    DeleteFileA( buffer );
+
+    /* can set disposition on file which is mapped to memory and unmapped again */
+    GetTempFileNameA( tmp_path, "dis", 0, buffer );
+    handle = CreateFileA(buffer, GENERIC_READ | GENERIC_WRITE | DELETE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok( handle != INVALID_HANDLE_VALUE, "failed to create temp file\n" );
+    mapping = CreateFileMappingA( handle, NULL, PAGE_READWRITE, 0, 64 * 1024, "DelFileTest" );
+    ok( mapping != NULL, "failed to create file mapping\n");
+    ptr = MapViewOfFile( mapping, FILE_MAP_READ, 0, 0, 4096 );
+    ok( ptr != NULL, "MapViewOfFile failed\n");
+    CloseHandle( mapping );
+    UnmapViewOfFile( ptr );
+    fdi.DoDeleteFile = TRUE;
+    res = pNtSetInformationFile( handle, &io, &fdi, sizeof fdi, FileDispositionInformation );
+    ok( res == STATUS_SUCCESS, "unexpected FileDispositionInformation result (expected STATUS_SUCCESS, got %x)\n", res );
+    CloseHandle( handle );
+    fileDeleted = GetFileAttributesA( buffer ) == INVALID_FILE_ATTRIBUTES && GetLastError() == ERROR_FILE_NOT_FOUND;
+    ok( fileDeleted, "File should have been deleted\n" );
+    DeleteFileA( buffer );
 }
 
 static void test_iocompletion(void)
@@ -2683,6 +2771,178 @@ todo_wine
     CloseHandle(hfile);
 }
 
+static INT build_reparse_buffer(WCHAR *filename, REPARSE_DATA_BUFFER **pbuffer)
+{
+    REPARSE_DATA_BUFFER *buffer;
+    INT buffer_len, string_len;
+    WCHAR *dest;
+
+    string_len = (lstrlenW(filename)+1)*sizeof(WCHAR);
+    buffer_len = FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer.PathBuffer[1]) + string_len;
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    buffer->ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+    buffer->ReparseDataLength = sizeof(buffer->MountPointReparseBuffer) + string_len;
+    buffer->MountPointReparseBuffer.SubstituteNameLength = string_len - sizeof(WCHAR);
+    buffer->MountPointReparseBuffer.PrintNameOffset = string_len;
+    dest = &buffer->MountPointReparseBuffer.PathBuffer[0];
+    memcpy(dest, filename, string_len);
+    *pbuffer = buffer;
+    return buffer_len;
+}
+
+static void test_junction_points(void)
+{
+    static const WCHAR junctionW[] = {'\\','j','u','n','c','t','i','o','n',0};
+    WCHAR path[MAX_PATH], junction_path[MAX_PATH], target_path[MAX_PATH];
+    static const WCHAR targetW[] = {'\\','t','a','r','g','e','t',0};
+    FILE_BASIC_INFORMATION old_attrib, new_attrib;
+    static const WCHAR fooW[] = {'f','o','o',0};
+    static WCHAR volW[] = {'c',':','\\',0};
+    REPARSE_GUID_DATA_BUFFER guid_buffer;
+    static const WCHAR dotW[] = {'.',0};
+    REPARSE_DATA_BUFFER *buffer = NULL;
+    DWORD dwret, dwLen, dwFlags, err;
+    INT buffer_len, string_len;
+    IO_STATUS_BLOCK iosb;
+    UNICODE_STRING nameW;
+    HANDLE hJunction;
+    WCHAR *dest;
+    BOOL bret;
+
+    /* Create a temporary folder for the junction point tests */
+    GetTempFileNameW(dotW, fooW, 0, path);
+    DeleteFileW(path);
+    if (!CreateDirectoryW(path, NULL))
+    {
+        win_skip("Unable to create a temporary junction point directory.\n");
+        return;
+    }
+
+    /* Check that the volume this folder is located on supports junction points */
+    pRtlDosPathNameToNtPathName_U(path, &nameW, NULL, NULL);
+    volW[0] = nameW.Buffer[4];
+    pRtlFreeUnicodeString( &nameW );
+    GetVolumeInformationW(volW, 0, 0, 0, &dwLen, &dwFlags, 0, 0);
+    if (!(dwFlags & FILE_SUPPORTS_REPARSE_POINTS))
+    {
+        skip("File system does not support junction points.\n");
+        RemoveDirectoryW(path);
+        return;
+    }
+
+    /* Create the folder to be replaced by a junction point */
+    lstrcpyW(junction_path, path);
+    lstrcatW(junction_path, junctionW);
+    bret = CreateDirectoryW(junction_path, NULL);
+    ok(bret, "Failed to create junction point directory.\n");
+
+    /* Create a destination folder for the junction point to target */
+    lstrcpyW(target_path, path);
+    lstrcatW(target_path, targetW);
+    bret = CreateDirectoryW(target_path, NULL);
+    ok(bret, "Failed to create junction point target directory.\n");
+    pRtlDosPathNameToNtPathName_U(target_path, &nameW, NULL, NULL);
+
+    /* Create the junction point */
+    hJunction = CreateFileW(junction_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    if (hJunction == INVALID_HANDLE_VALUE)
+    {
+        win_skip("Failed to open junction point directory handle (0x%x).\n", GetLastError());
+        goto cleanup;
+    }
+    dwret = NtQueryInformationFile(hJunction, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
+    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
+    bret = DeviceIoControl(hJunction, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+
+    /* Check the file attributes of the junction point */
+    dwret = GetFileAttributesW(junction_path);
+    ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%x)!\n", dwret);
+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: %d)\n", dwret);
+
+    /* Read back the junction point */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    buffer_len = sizeof(*buffer) + MAX_PATH*sizeof(WCHAR);
+    buffer = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, buffer_len);
+    bret = DeviceIoControl(hJunction, FSCTL_GET_REPARSE_POINT, NULL, 0, (LPVOID)buffer, buffer_len, &dwret, 0);
+    string_len = buffer->MountPointReparseBuffer.SubstituteNameLength;
+    dest = &buffer->MountPointReparseBuffer.PathBuffer[buffer->MountPointReparseBuffer.SubstituteNameOffset/sizeof(WCHAR)];
+    ok(bret, "Failed to read junction point!\n");
+    ok((memcmp(dest, nameW.Buffer, string_len) == 0), "Junction point destination does not match ('%s' != '%s')!\n",
+                                                      wine_dbgstr_w(dest), wine_dbgstr_w(nameW.Buffer));
+
+    /* Delete the junction point */
+    memset(&old_attrib, 0x00, sizeof(old_attrib));
+    old_attrib.LastAccessTime.QuadPart = 0x200deadcafebeef;
+    dwret = NtSetInformationFile(hJunction, &iosb, &old_attrib, sizeof(old_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to set junction point folder's attributes (0x%x).\n", dwret);
+    memset(&guid_buffer, 0x00, sizeof(guid_buffer));
+    guid_buffer.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;
+    bret = DeviceIoControl(hJunction, FSCTL_DELETE_REPARSE_POINT, (LPVOID)&guid_buffer,
+                           REPARSE_GUID_DATA_BUFFER_HEADER_SIZE, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to delete junction point! (0x%x)\n", GetLastError());
+    memset(&new_attrib, 0x00, sizeof(new_attrib));
+    dwret = NtQueryInformationFile(hJunction, &iosb, &new_attrib, sizeof(new_attrib), FileBasicInformation);
+    ok(dwret == STATUS_SUCCESS, "Failed to get junction point folder's attributes (0x%x).\n", dwret);
+    ok(old_attrib.LastAccessTime.QuadPart == new_attrib.LastAccessTime.QuadPart,
+       "Junction point folder's access time does not match (0x%llx != 0x%llx).\n",
+       new_attrib.LastAccessTime.QuadPart, old_attrib.LastAccessTime.QuadPart);
+    CloseHandle(hJunction);
+
+    /* Check deleting a junction point as if it were a directory */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    hJunction = CreateFileW(junction_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
+    bret = DeviceIoControl(hJunction, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+    CloseHandle(hJunction);
+    bret = RemoveDirectoryW(junction_path);
+    ok(bret, "Failed to delete junction point as directory!\n");
+    dwret = GetFileAttributesW(junction_path);
+    ok(dwret == (DWORD)~0, "Junction point still exists (attributes: 0x%x)!\n", dwret);
+
+    /* Check deleting a junction point as if it were a file */
+    HeapFree(GetProcessHeap(), 0, buffer);
+    bret = CreateDirectoryW(junction_path, NULL);
+    ok(bret, "Failed to create junction point target directory.\n");
+    hJunction = CreateFileW(junction_path, GENERIC_READ | GENERIC_WRITE, 0, 0, OPEN_EXISTING,
+                            FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, 0);
+    buffer_len = build_reparse_buffer(nameW.Buffer, &buffer);
+    bret = DeviceIoControl(hJunction, FSCTL_SET_REPARSE_POINT, (LPVOID)buffer, buffer_len, NULL, 0, &dwret, 0);
+    ok(bret, "Failed to create junction point! (0x%x)\n", GetLastError());
+    CloseHandle(hJunction);
+    bret = DeleteFileW(junction_path);
+    ok(!bret, "Succeeded in deleting junction point as file!\n");
+    err = GetLastError();
+    ok(err == ERROR_ACCESS_DENIED, "Expected last error 0x%x for DeleteFile on junction point (actually 0x%x)!\n",
+                                   ERROR_ACCESS_DENIED, err);
+    dwret = GetFileAttributesW(junction_path);
+    ok(dwret != (DWORD)~0, "Junction point doesn't exist (attributes: 0x%x)!\n", dwret);
+    ok(dwret & FILE_ATTRIBUTE_REPARSE_POINT, "File is not a junction point! (attributes: 0x%x)\n", dwret);
+
+    /* Test deleting a junction point's target */
+    dwret = GetFileAttributesW(junction_path);
+    ok(dwret == 0x410 || broken(dwret == 0x430) /* win2k */,
+       "Unexpected junction point attributes (0x%x != 0x410)!\n", dwret);
+    bret = RemoveDirectoryW(target_path);
+    ok(bret, "Failed to delete junction point target!\n");
+    bret = CreateDirectoryW(target_path, NULL);
+    ok(bret, "Failed to create junction point target directory.\n");
+
+cleanup:
+    /* Cleanup */
+    pRtlFreeUnicodeString( &nameW );
+    HeapFree(GetProcessHeap(), 0, buffer);
+    bret = RemoveDirectoryW(junction_path);
+    ok(bret, "Failed to remove temporary junction point directory!\n");
+    bret = RemoveDirectoryW(target_path);
+    ok(bret, "Failed to remove temporary target directory!\n");
+    RemoveDirectoryW(path);
+}
+
 START_TEST(file)
 {
     HMODULE hkernel32 = GetModuleHandleA("kernel32.dll");
@@ -2736,4 +2996,5 @@ START_TEST(file)
     test_file_disposition_information();
     test_query_volume_information_file();
     test_query_attribute_information_file();
+    test_junction_points();
 }
diff --git a/dlls/ntdll/tests/rtl.c b/dlls/ntdll/tests/rtl.c
index e8eb04a..c36dbf5 100644
--- a/dlls/ntdll/tests/rtl.c
+++ b/dlls/ntdll/tests/rtl.c
@@ -25,6 +25,7 @@
 
 #include "ntdll_test.h"
 #include "inaddr.h"
+#include "in6addr.h"
 
 #ifndef __WINE_WINTERNL_H
 
@@ -62,6 +63,9 @@ static inline USHORT __my_ushort_swap(USHORT s)
 
 /* Function ptrs for ntdll calls */
 static HMODULE hntdll = 0;
+static PVOID     (WINAPI *pWinSqmStartSession)(PVOID unknown1, DWORD unknown2, DWORD unknown3);
+static BOOL      (WINAPI *pWinSqmIsOptedIn)(void);
+static NTSTATUS  (WINAPI *pWinSqmEndSession)(PVOID unknown1);
 static SIZE_T    (WINAPI  *pRtlCompareMemory)(LPCVOID,LPCVOID,SIZE_T);
 static SIZE_T    (WINAPI  *pRtlCompareMemoryUlong)(PULONG, SIZE_T, ULONG);
 static NTSTATUS  (WINAPI  *pRtlDeleteTimer)(HANDLE, HANDLE, HANDLE);
@@ -89,9 +93,21 @@ static IMAGE_BASE_RELOCATION *(WINAPI *pLdrProcessRelocationBlock)(void*,UINT,US
 static CHAR *    (WINAPI *pRtlIpv4AddressToStringA)(const IN_ADDR *, LPSTR);
 static NTSTATUS  (WINAPI *pRtlIpv4AddressToStringExA)(const IN_ADDR *, USHORT, LPSTR, PULONG);
 static NTSTATUS  (WINAPI *pRtlIpv4StringToAddressA)(PCSTR, BOOLEAN, PCSTR *, IN_ADDR *);
+static NTSTATUS  (WINAPI *pRtlIpv4StringToAddressExA)(PCSTR, BOOLEAN, IN_ADDR *, PUSHORT);
+static CHAR *    (WINAPI *pRtlIpv6AddressToStringA)(struct in6_addr *, PSTR);
+static NTSTATUS  (WINAPI *pRtlIpv6AddressToStringExA)(struct in6_addr *, ULONG, USHORT, PCHAR, PULONG);
+static NTSTATUS  (WINAPI *pRtlIpv6StringToAddressA)(PCSTR, PCSTR *, struct in6_addr *);
+static NTSTATUS  (WINAPI *pRtlIpv6StringToAddressW)(PCWSTR, PCWSTR *, struct in6_addr *);
+static NTSTATUS  (WINAPI *pRtlIpv6StringToAddressExA)(PCSTR, struct in6_addr *, PULONG, PUSHORT);
+static NTSTATUS  (WINAPI *pRtlIpv6StringToAddressExW)(PCWSTR, struct in6_addr *, PULONG, PUSHORT);
 static NTSTATUS  (WINAPI *pLdrAddRefDll)(ULONG, HMODULE);
 static NTSTATUS  (WINAPI *pLdrLockLoaderLock)(ULONG, ULONG*, ULONG_PTR*);
 static NTSTATUS  (WINAPI *pLdrUnlockLoaderLock)(ULONG, ULONG_PTR);
+static NTSTATUS  (WINAPI *pRtlMultiByteToUnicodeN)(LPWSTR, DWORD, LPDWORD, LPCSTR, DWORD);
+static NTSTATUS  (WINAPI *pRtlGetCompressionWorkSpaceSize)(USHORT, PULONG, PULONG);
+static NTSTATUS  (WINAPI *pRtlDecompressBuffer)(USHORT, PUCHAR, ULONG, const UCHAR*, ULONG, PULONG);
+static NTSTATUS  (WINAPI *pRtlDecompressFragment)(USHORT, PUCHAR, ULONG, const UCHAR*, ULONG, ULONG, PULONG, PVOID);
+static NTSTATUS  (WINAPI *pRtlCompressBuffer)(USHORT, const UCHAR*, ULONG, PUCHAR, ULONG, ULONG, PULONG, PVOID);
 
 static HMODULE hkernel32 = 0;
 static BOOL      (WINAPI *pIsWow64Process)(HANDLE, PBOOL);
@@ -109,6 +125,9 @@ static void InitFunctionPtrs(void)
     hntdll = LoadLibraryA("ntdll.dll");
     ok(hntdll != 0, "LoadLibrary failed\n");
     if (hntdll) {
+        pWinSqmStartSession = (void *)GetProcAddress(hntdll, "WinSqmStartSession");
+        pWinSqmIsOptedIn = (void *)GetProcAddress(hntdll, "WinSqmIsOptedIn");
+        pWinSqmEndSession = (void *)GetProcAddress(hntdll, "WinSqmEndSession");
 	pRtlCompareMemory = (void *)GetProcAddress(hntdll, "RtlCompareMemory");
 	pRtlCompareMemoryUlong = (void *)GetProcAddress(hntdll, "RtlCompareMemoryUlong");
         pRtlDeleteTimer = (void *)GetProcAddress(hntdll, "RtlDeleteTimer");
@@ -136,9 +155,21 @@ static void InitFunctionPtrs(void)
         pRtlIpv4AddressToStringA = (void *)GetProcAddress(hntdll, "RtlIpv4AddressToStringA");
         pRtlIpv4AddressToStringExA = (void *)GetProcAddress(hntdll, "RtlIpv4AddressToStringExA");
         pRtlIpv4StringToAddressA = (void *)GetProcAddress(hntdll, "RtlIpv4StringToAddressA");
+        pRtlIpv4StringToAddressExA = (void *)GetProcAddress(hntdll, "RtlIpv4StringToAddressExA");
+        pRtlIpv6AddressToStringA = (void *)GetProcAddress(hntdll, "RtlIpv6AddressToStringA");
+        pRtlIpv6AddressToStringExA = (void *)GetProcAddress(hntdll, "RtlIpv6AddressToStringExA");
+        pRtlIpv6StringToAddressA = (void *)GetProcAddress(hntdll, "RtlIpv6StringToAddressA");
+        pRtlIpv6StringToAddressW = (void *)GetProcAddress(hntdll, "RtlIpv6StringToAddressW");
+        pRtlIpv6StringToAddressExA = (void *)GetProcAddress(hntdll, "RtlIpv6StringToAddressExA");
+        pRtlIpv6StringToAddressExW = (void *)GetProcAddress(hntdll, "RtlIpv6StringToAddressExW");
         pLdrAddRefDll = (void *)GetProcAddress(hntdll, "LdrAddRefDll");
         pLdrLockLoaderLock = (void *)GetProcAddress(hntdll, "LdrLockLoaderLock");
         pLdrUnlockLoaderLock = (void *)GetProcAddress(hntdll, "LdrUnlockLoaderLock");
+        pRtlMultiByteToUnicodeN = (void *)GetProcAddress(hntdll, "RtlMultiByteToUnicodeN");
+        pRtlGetCompressionWorkSpaceSize = (void *)GetProcAddress(hntdll, "RtlGetCompressionWorkSpaceSize");
+        pRtlDecompressBuffer = (void *)GetProcAddress(hntdll, "RtlDecompressBuffer");
+        pRtlDecompressFragment = (void *)GetProcAddress(hntdll, "RtlDecompressFragment");
+        pRtlCompressBuffer = (void *)GetProcAddress(hntdll, "RtlCompressBuffer");
     }
     hkernel32 = LoadLibraryA("kernel32.dll");
     ok(hkernel32 != 0, "LoadLibrary failed\n");
@@ -149,6 +180,48 @@ static void InitFunctionPtrs(void)
     ok(strlen(src) == 15, "Source must be 16 bytes long!\n");
 }
 
+#ifdef __i386__
+const char stdcall3_thunk[] =
+    "\x56"              /* push %esi */
+    "\x89\xE6"          /* mov %esp, %esi */
+    "\xFF\x74\x24\x14"  /* pushl 20(%esp) */
+    "\xFF\x74\x24\x14"  /* pushl 20(%esp) */
+    "\xFF\x74\x24\x14"  /* pushl 20(%esp) */
+    "\xFF\x54\x24\x14"  /* calll 20(%esp) */
+    "\x89\xF0"          /* mov %esi, %eax */
+    "\x29\xE0"          /* sub %esp, %eax */
+    "\x89\xF4"          /* mov %esi, %esp */
+    "\x5E"              /* pop %esi */
+    "\xC2\x10\x00"      /* ret $16 */
+;
+
+static INT (WINAPI *call_stdcall_func3)(PVOID func, PVOID arg0, DWORD arg1, DWORD arg2) = NULL;
+
+static void test_WinSqm(void)
+{
+    INT args;
+
+    if (!pWinSqmStartSession)
+    {
+        win_skip("WinSqmStartSession() is not available\n");
+        return;
+    }
+
+    call_stdcall_func3 = (void*) VirtualAlloc( NULL, sizeof(stdcall3_thunk) - 1, MEM_COMMIT,
+                                               PAGE_EXECUTE_READWRITE );
+    memcpy( call_stdcall_func3, stdcall3_thunk, sizeof(stdcall3_thunk) - 1 );
+
+    args = 3 - call_stdcall_func3( pWinSqmStartSession, NULL, 0, 0 ) / 4;
+    ok(args == 3, "WinSqmStartSession expected to take %d arguments instead of 3\n", args);
+    args = 3 - call_stdcall_func3( pWinSqmIsOptedIn, NULL, 0, 0 ) / 4;
+    ok(args == 0, "WinSqmIsOptedIn expected to take %d arguments instead of 0\n", args);
+    args = 3 - call_stdcall_func3( pWinSqmEndSession, NULL, 0, 0 ) / 4;
+    ok(args == 1, "WinSqmEndSession expected to take %d arguments instead of 1\n", args);
+
+    VirtualFree( call_stdcall_func3, 0, MEM_RELEASE );
+}
+#endif
+
 #define COMP(str1,str2,cmplen,len) size = pRtlCompareMemory(str1, str2, cmplen); \
   ok(size == len, "Expected %ld, got %ld\n", size, (SIZE_T)len)
 
@@ -1320,98 +1393,109 @@ static void test_RtlIpv4AddressToStringEx(void)
         res, size, buffer);
 }
 
+static struct
+{
+    PCSTR address;
+    NTSTATUS res;
+    int terminator_offset;
+    int ip[4];
+    enum { normal_4, strict_diff_4 = 1, ex_fail_4 = 2 } flags;
+    NTSTATUS res_strict;
+    int terminator_offset_strict;
+    int ip_strict[4];
+} ipv4_tests[] =
+{
+    { "",                       STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { " ",                      STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { "1.1.1.1",                STATUS_SUCCESS,            7, {   1,   1,   1,   1 } },
+    { "0.0.0.0",                STATUS_SUCCESS,            7, {   0,   0,   0,   0 } },
+    { "255.255.255.255",        STATUS_SUCCESS,           15, { 255, 255, 255, 255 } },
+    { "255.255.255.255:123",    STATUS_SUCCESS,           15, { 255, 255, 255, 255 } },
+    { "255.255.255.256",        STATUS_INVALID_PARAMETER, 15, { -1 } },
+    { "255.255.255.4294967295", STATUS_INVALID_PARAMETER, 22, { -1 } },
+    { "255.255.255.4294967296", STATUS_INVALID_PARAMETER, 21, { -1 } },
+    { "255.255.255.4294967297", STATUS_INVALID_PARAMETER, 21, { -1 } },
+    { "a",                      STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { "1.1.1.0xaA",             STATUS_SUCCESS,           10, {   1,   1,   1, 170 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.0XaA",             STATUS_SUCCESS,           10, {   1,   1,   1, 170 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.0x",               STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.0xff",             STATUS_SUCCESS,           10, {   1,   1,   1, 255 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.0x100",            STATUS_INVALID_PARAMETER, 11, { -1 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.0xffffffff",       STATUS_INVALID_PARAMETER, 16, { -1 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.0x100000000",      STATUS_INVALID_PARAMETER, 16, { -1, 0, 0, 0 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "1.1.1.010",              STATUS_SUCCESS,            9, {   1,   1,   1,   8 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "1.1.1.00",               STATUS_SUCCESS,            8, {   1,   1,   1,   0 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "1.1.1.007",              STATUS_SUCCESS,            9, {   1,   1,   1,   7 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "1.1.1.08",               STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "1.1.1.008",              STATUS_SUCCESS,            8, {   1,   1,   1,   0 }, strict_diff_4 | ex_fail_4,
+                                STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "1.1.1.0a",               STATUS_SUCCESS,            7, {   1,   1,   1,   0 }, ex_fail_4 },
+    { "1.1.1.0o10",             STATUS_SUCCESS,            7, {   1,   1,   1,   0 }, ex_fail_4 },
+    { "1.1.1.0b10",             STATUS_SUCCESS,            7, {   1,   1,   1,   0 }, ex_fail_4 },
+    { "1.1.1.-2",               STATUS_INVALID_PARAMETER,  6, { -1 } },
+    { "1",                      STATUS_SUCCESS,            1, {   0,   0,   0,   1 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  1, { -1 } },
+    { "-1",                     STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { "203569230",              STATUS_SUCCESS,            9, {  12,  34,  56,  78 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  9, { -1 } },
+    { "1.223756",               STATUS_SUCCESS,            8, {   1,   3, 106,  12 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  8, { -1 } },
+    { "3.4.756",                STATUS_SUCCESS,            7, {   3,   4,   2, 244 }, strict_diff_4,
+                                STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "3.4.756.1",              STATUS_INVALID_PARAMETER,  9, { -1 } },
+    { "3.4.65536",              STATUS_INVALID_PARAMETER,  9, { -1 } },
+    { "3.4.5.6.7",              STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "3.4.5.+6",               STATUS_INVALID_PARAMETER,  6, { -1 } },
+    { " 3.4.5.6",               STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { "\t3.4.5.6",              STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { "3.4.5.6 ",               STATUS_SUCCESS,            7, {   3,   4,   5,   6 }, ex_fail_4 },
+    { "3. 4.5.6",               STATUS_INVALID_PARAMETER,  2, { -1 } },
+    { ".",                      STATUS_INVALID_PARAMETER,  1, { -1 } },
+    { "..",                     STATUS_INVALID_PARAMETER,  1, { -1 } },
+    { "1.",                     STATUS_INVALID_PARAMETER,  2, { -1 } },
+    { "1..",                    STATUS_INVALID_PARAMETER,  3, { -1 } },
+    { ".1",                     STATUS_INVALID_PARAMETER,  1, { -1 } },
+    { ".1.",                    STATUS_INVALID_PARAMETER,  1, { -1 } },
+    { ".1.2.3",                 STATUS_INVALID_PARAMETER,  1, { -1 } },
+    { "0.1.2.3",                STATUS_SUCCESS,            7, {   0,   1,   2,   3 } },
+    { "0.1.2.3.",               STATUS_INVALID_PARAMETER,  7, { -1 } },
+    { "[0.1.2.3]",              STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { "::1",                    STATUS_INVALID_PARAMETER,  0, { -1 } },
+    { ":1",                     STATUS_INVALID_PARAMETER,  0, { -1 } },
+};
+const unsigned int ipv4_testcount = sizeof(ipv4_tests) / sizeof(ipv4_tests[0]);
+
+static void init_ip4(IN_ADDR* addr, const int src[4])
+{
+    if (!src || src[0] == -1)
+    {
+        addr->S_un.S_addr = 0xabababab;
+    }
+    else
+    {
+        addr->S_un.S_un_b.s_b1 = src[0];
+        addr->S_un.S_un_b.s_b2 = src[1];
+        addr->S_un.S_un_b.s_b3 = src[2];
+        addr->S_un.S_un_b.s_b4 = src[3];
+    }
+}
+
 static void test_RtlIpv4StringToAddress(void)
 {
     NTSTATUS res;
     IN_ADDR ip, expected_ip;
     PCSTR terminator;
     CHAR dummy;
-    struct
-    {
-        PCSTR address;
-        NTSTATUS res;
-        int terminator_offset;
-        int ip[4];
-        BOOL strict_is_different;
-        NTSTATUS res_strict;
-        int terminator_offset_strict;
-        int ip_strict[4];
-    } tests[] =
-    {
-        { "",                STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { " ",               STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { "1.1.1.1",         STATUS_SUCCESS,            7, {   1,   1,   1,   1 } },
-        { "0.0.0.0",         STATUS_SUCCESS,            7, {   0,   0,   0,   0 } },
-        { "255.255.255.255", STATUS_SUCCESS,           15, { 255, 255, 255, 255 } },
-        { "255.255.255.255:123",
-                             STATUS_SUCCESS,           15, { 255, 255, 255, 255 } },
-        { "255.255.255.256", STATUS_INVALID_PARAMETER, 15, { -1 } },
-        { "255.255.255.4294967295",
-                             STATUS_INVALID_PARAMETER, 22, { -1 } },
-        { "255.255.255.4294967296",
-                             STATUS_INVALID_PARAMETER, 21, { -1 } },
-        { "255.255.255.4294967297",
-                             STATUS_INVALID_PARAMETER, 21, { -1 } },
-        { "a",               STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { "1.1.1.0xaA",      STATUS_SUCCESS,           10, {   1,   1,   1, 170 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.0XaA",      STATUS_SUCCESS,           10, {   1,   1,   1, 170 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.0x",        STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.0xff",      STATUS_SUCCESS,           10, {   1,   1,   1, 255 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.0x100",     STATUS_INVALID_PARAMETER, 11, { -1 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.0xffffffff",STATUS_INVALID_PARAMETER, 16, { -1 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.0x100000000",
-                             STATUS_INVALID_PARAMETER, 16, { -1, 0, 0, 0 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "1.1.1.010",       STATUS_SUCCESS,            9, {   1,   1,   1,   8 },
-                       TRUE, STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "1.1.1.00",        STATUS_SUCCESS,            8, {   1,   1,   1,   0 },
-                       TRUE, STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "1.1.1.007",       STATUS_SUCCESS,            9, {   1,   1,   1,   7 },
-                       TRUE, STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "1.1.1.08",        STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "1.1.1.008",       STATUS_SUCCESS,            8, {   1,   1,   1,   0 },
-                       TRUE, STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "1.1.1.0a",        STATUS_SUCCESS,            7, {   1,   1,   1,   0 } },
-        { "1.1.1.0o10",      STATUS_SUCCESS,            7, {   1,   1,   1,   0 } },
-        { "1.1.1.0b10",      STATUS_SUCCESS,            7, {   1,   1,   1,   0 } },
-        { "1.1.1.-2",        STATUS_INVALID_PARAMETER,  6, { -1 } },
-        { "1",               STATUS_SUCCESS,            1, {   0,   0,   0,   1 },
-                       TRUE, STATUS_INVALID_PARAMETER,  1, { -1 } },
-        { "-1",              STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { "203569230",       STATUS_SUCCESS,            9, {  12,  34,  56,  78 },
-                       TRUE, STATUS_INVALID_PARAMETER,  9, { -1 } },
-        { "1.223756",        STATUS_SUCCESS,            8, {   1,   3, 106,  12 },
-                       TRUE, STATUS_INVALID_PARAMETER,  8, { -1 } },
-        { "3.4.756",         STATUS_SUCCESS,            7, {   3,   4,   2, 244 },
-                       TRUE, STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "3.4.756.1",       STATUS_INVALID_PARAMETER,  9, { -1 } },
-        { "3.4.65536",       STATUS_INVALID_PARAMETER,  9, { -1 } },
-        { "3.4.5.6.7",       STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "3.4.5.+6",        STATUS_INVALID_PARAMETER,  6, { -1 } },
-        { " 3.4.5.6",        STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { "\t3.4.5.6",       STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { "3.4.5.6 ",        STATUS_SUCCESS,            7, {   3,   4,   5,   6 } },
-        { "3. 4.5.6",        STATUS_INVALID_PARAMETER,  2, { -1 } },
-        { ".",               STATUS_INVALID_PARAMETER,  1, { -1 } },
-        { "..",              STATUS_INVALID_PARAMETER,  1, { -1 } },
-        { "1.",              STATUS_INVALID_PARAMETER,  2, { -1 } },
-        { "1..",             STATUS_INVALID_PARAMETER,  3, { -1 } },
-        { ".1",              STATUS_INVALID_PARAMETER,  1, { -1 } },
-        { ".1.",             STATUS_INVALID_PARAMETER,  1, { -1 } },
-        { ".1.2.3",          STATUS_INVALID_PARAMETER,  1, { -1 } },
-        { "0.1.2.3",         STATUS_SUCCESS,            7, {   0,   1,   2,   3 } },
-        { "0.1.2.3.",        STATUS_INVALID_PARAMETER,  7, { -1 } },
-        { "[0.1.2.3]",       STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { "::1",             STATUS_INVALID_PARAMETER,  0, { -1 } },
-        { ":1",              STATUS_INVALID_PARAMETER,  0, { -1 } },
-    };
-    const int testcount = sizeof(tests) / sizeof(tests[0]);
-    int i;
+    unsigned int i;
 
     if (!pRtlIpv4StringToAddressA)
     {
@@ -1433,62 +1517,1095 @@ static void test_RtlIpv4StringToAddress(void)
         */
     }
 
-    for (i = 0; i < testcount; i++)
+    for (i = 0; i < ipv4_testcount; i++)
     {
         /* non-strict */
         terminator = &dummy;
         ip.S_un.S_addr = 0xabababab;
-        res = pRtlIpv4StringToAddressA(tests[i].address, FALSE, &terminator, &ip);
-        ok(res == tests[i].res,
+        res = pRtlIpv4StringToAddressA(ipv4_tests[i].address, FALSE, &terminator, &ip);
+        ok(res == ipv4_tests[i].res,
            "[%s] res = 0x%08x, expected 0x%08x\n",
-           tests[i].address, res, tests[i].res);
-        ok(terminator == tests[i].address + tests[i].terminator_offset,
+           ipv4_tests[i].address, res, ipv4_tests[i].res);
+        ok(terminator == ipv4_tests[i].address + ipv4_tests[i].terminator_offset,
            "[%s] terminator = %p, expected %p\n",
-           tests[i].address, terminator, tests[i].address + tests[i].terminator_offset);
-        if (tests[i].ip[0] == -1)
-            expected_ip.S_un.S_addr = 0xabababab;
-        else
-        {
-            expected_ip.S_un.S_un_b.s_b1 = tests[i].ip[0];
-            expected_ip.S_un.S_un_b.s_b2 = tests[i].ip[1];
-            expected_ip.S_un.S_un_b.s_b3 = tests[i].ip[2];
-            expected_ip.S_un.S_un_b.s_b4 = tests[i].ip[3];
-        }
+           ipv4_tests[i].address, terminator, ipv4_tests[i].address + ipv4_tests[i].terminator_offset);
+
+        init_ip4(&expected_ip, ipv4_tests[i].ip);
         ok(ip.S_un.S_addr == expected_ip.S_un.S_addr,
            "[%s] ip = %08x, expected %08x\n",
-           tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
+           ipv4_tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
 
-        if (!tests[i].strict_is_different)
+        if (!(ipv4_tests[i].flags & strict_diff_4))
         {
-            tests[i].res_strict = tests[i].res;
-            tests[i].terminator_offset_strict = tests[i].terminator_offset;
-            tests[i].ip_strict[0] = tests[i].ip[0];
-            tests[i].ip_strict[1] = tests[i].ip[1];
-            tests[i].ip_strict[2] = tests[i].ip[2];
-            tests[i].ip_strict[3] = tests[i].ip[3];
+            ipv4_tests[i].res_strict = ipv4_tests[i].res;
+            ipv4_tests[i].terminator_offset_strict = ipv4_tests[i].terminator_offset;
+            ipv4_tests[i].ip_strict[0] = ipv4_tests[i].ip[0];
+            ipv4_tests[i].ip_strict[1] = ipv4_tests[i].ip[1];
+            ipv4_tests[i].ip_strict[2] = ipv4_tests[i].ip[2];
+            ipv4_tests[i].ip_strict[3] = ipv4_tests[i].ip[3];
         }
         /* strict */
         terminator = &dummy;
         ip.S_un.S_addr = 0xabababab;
-        res = pRtlIpv4StringToAddressA(tests[i].address, TRUE, &terminator, &ip);
-        ok(res == tests[i].res_strict,
+        res = pRtlIpv4StringToAddressA(ipv4_tests[i].address, TRUE, &terminator, &ip);
+        ok(res == ipv4_tests[i].res_strict,
            "[%s] res = 0x%08x, expected 0x%08x\n",
-           tests[i].address, res, tests[i].res_strict);
-        ok(terminator == tests[i].address + tests[i].terminator_offset_strict,
+           ipv4_tests[i].address, res, ipv4_tests[i].res_strict);
+        ok(terminator == ipv4_tests[i].address + ipv4_tests[i].terminator_offset_strict,
            "[%s] terminator = %p, expected %p\n",
-           tests[i].address, terminator, tests[i].address + tests[i].terminator_offset_strict);
-        if (tests[i].ip_strict[0] == -1)
-            expected_ip.S_un.S_addr = 0xabababab;
+           ipv4_tests[i].address, terminator, ipv4_tests[i].address + ipv4_tests[i].terminator_offset_strict);
+
+        init_ip4(&expected_ip, ipv4_tests[i].ip_strict);
+        ok(ip.S_un.S_addr == expected_ip.S_un.S_addr,
+           "[%s] ip = %08x, expected %08x\n",
+           ipv4_tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
+    }
+}
+
+static void test_RtlIpv4StringToAddressEx(void)
+{
+    NTSTATUS res;
+    IN_ADDR ip, expected_ip;
+    USHORT port;
+    static const struct
+    {
+        PCSTR address;
+        NTSTATUS res;
+        int ip[4];
+        USHORT port;
+    } ipv4_ex_tests[] =
+    {
+        { "",               STATUS_INVALID_PARAMETER,   { -1 },         0xdead },
+        { " ",              STATUS_INVALID_PARAMETER,   { -1 },         0xdead },
+        { "1.1.1.1:",       STATUS_INVALID_PARAMETER,   { 1, 1, 1, 1 }, 0xdead },
+        { "1.1.1.1+",       STATUS_INVALID_PARAMETER,   { 1, 1, 1, 1 }, 0xdead },
+        { "1.1.1.1:1",      STATUS_SUCCESS,             { 1, 1, 1, 1 }, 0x100 },
+        { "256.1.1.1:1",    STATUS_INVALID_PARAMETER,   { -1 },         0xdead },
+        { "-1.1.1.1:1",     STATUS_INVALID_PARAMETER,   { -1 },         0xdead },
+        { "0.0.0.0:0",      STATUS_INVALID_PARAMETER,   { 0, 0, 0, 0 }, 0xdead },
+        { "0.0.0.0:1",      STATUS_SUCCESS,             { 0, 0, 0, 0 }, 0x100 },
+        { "1.2.3.4:65535",  STATUS_SUCCESS,             { 1, 2, 3, 4 }, 65535 },
+        { "1.2.3.4:65536",  STATUS_INVALID_PARAMETER,   { 1, 2, 3, 4 }, 0xdead },
+        { "1.2.3.4:0xffff", STATUS_SUCCESS,             { 1, 2, 3, 4 }, 65535 },
+        { "1.2.3.4:0XfFfF", STATUS_SUCCESS,             { 1, 2, 3, 4 }, 65535 },
+        { "1.2.3.4:011064", STATUS_SUCCESS,             { 1, 2, 3, 4 }, 0x3412 },
+        { "1.2.3.4:1234a",  STATUS_INVALID_PARAMETER,   { 1, 2, 3, 4 }, 0xdead },
+        { "1.2.3.4:1234+",  STATUS_INVALID_PARAMETER,   { 1, 2, 3, 4 }, 0xdead },
+        { "1.2.3.4: 1234",  STATUS_INVALID_PARAMETER,   { 1, 2, 3, 4 }, 0xdead },
+        { "1.2.3.4:\t1234", STATUS_INVALID_PARAMETER,   { 1, 2, 3, 4 }, 0xdead },
+    };
+    const unsigned int ipv4_ex_testcount = sizeof(ipv4_ex_tests) / sizeof(ipv4_ex_tests[0]);
+    unsigned int i;
+    BOOLEAN strict;
+
+    if (!pRtlIpv4StringToAddressExA)
+    {
+        skip("RtlIpv4StringToAddressEx not available\n");
+        return;
+    }
+
+    /* do not crash, and do not touch the ip / port. */
+    ip.S_un.S_addr = 0xabababab;
+    port = 0xdead;
+    res = pRtlIpv4StringToAddressExA(NULL, FALSE, &ip, &port);
+    ok(res == STATUS_INVALID_PARAMETER, "[null address] res = 0x%08x, expected 0x%08x\n",
+       res, STATUS_INVALID_PARAMETER);
+    ok(ip.S_un.S_addr == 0xabababab, "RtlIpv4StringToAddressExA should not touch the ip!, ip == %x\n", ip.S_un.S_addr);
+    ok(port == 0xdead, "RtlIpv4StringToAddressExA should not touch the port!, port == %x\n", port);
+
+    port = 0xdead;
+    res = pRtlIpv4StringToAddressExA("1.1.1.1", FALSE, NULL, &port);
+    ok(res == STATUS_INVALID_PARAMETER, "[null ip] res = 0x%08x, expected 0x%08x\n",
+       res, STATUS_INVALID_PARAMETER);
+    ok(port == 0xdead, "RtlIpv4StringToAddressExA should not touch the port!, port == %x\n", port);
+
+    ip.S_un.S_addr = 0xabababab;
+    port = 0xdead;
+    res = pRtlIpv4StringToAddressExA("1.1.1.1", FALSE, &ip, NULL);
+    ok(res == STATUS_INVALID_PARAMETER, "[null port] res = 0x%08x, expected 0x%08x\n",
+       res, STATUS_INVALID_PARAMETER);
+    ok(ip.S_un.S_addr == 0xabababab, "RtlIpv4StringToAddressExA should not touch the ip!, ip == %x\n", ip.S_un.S_addr);
+    ok(port == 0xdead, "RtlIpv4StringToAddressExA should not touch the port!, port == %x\n", port);
+
+    /* first we run the non-ex testcases on the ex function */
+    for (i = 0; i < ipv4_testcount; i++)
+    {
+        NTSTATUS expect_res = (ipv4_tests[i].flags & ex_fail_4) ? STATUS_INVALID_PARAMETER : ipv4_tests[i].res;
+
+        /* non-strict */
+        port = 0xdead;
+        ip.S_un.S_addr = 0xabababab;
+        res = pRtlIpv4StringToAddressExA(ipv4_tests[i].address, FALSE, &ip, &port);
+        ok(res == expect_res, "[%s] res = 0x%08x, expected 0x%08x\n",
+           ipv4_tests[i].address, res, expect_res);
+
+        init_ip4(&expected_ip, ipv4_tests[i].ip);
+        ok(ip.S_un.S_addr == expected_ip.S_un.S_addr, "[%s] ip = %08x, expected %08x\n",
+           ipv4_tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
+
+        if (!(ipv4_tests[i].flags & strict_diff_4))
+        {
+            ipv4_tests[i].res_strict = ipv4_tests[i].res;
+            ipv4_tests[i].terminator_offset_strict = ipv4_tests[i].terminator_offset;
+            ipv4_tests[i].ip_strict[0] = ipv4_tests[i].ip[0];
+            ipv4_tests[i].ip_strict[1] = ipv4_tests[i].ip[1];
+            ipv4_tests[i].ip_strict[2] = ipv4_tests[i].ip[2];
+            ipv4_tests[i].ip_strict[3] = ipv4_tests[i].ip[3];
+        }
+        /* strict */
+        expect_res = (ipv4_tests[i].flags & ex_fail_4) ? STATUS_INVALID_PARAMETER : ipv4_tests[i].res_strict;
+        port = 0xdead;
+        ip.S_un.S_addr = 0xabababab;
+        res = pRtlIpv4StringToAddressExA(ipv4_tests[i].address, TRUE, &ip, &port);
+        ok(res == expect_res, "[%s] res = 0x%08x, expected 0x%08x\n",
+           ipv4_tests[i].address, res, expect_res);
+
+        init_ip4(&expected_ip, ipv4_tests[i].ip_strict);
+        ok(ip.S_un.S_addr == expected_ip.S_un.S_addr, "[%s] ip = %08x, expected %08x\n",
+           ipv4_tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
+    }
+
+
+    for (i = 0; i < ipv4_ex_testcount; i++)
+    {
+        /* Strict is only relevant for the ip address, so make sure that it does not influence the port */
+        for (strict = 0; strict < 2; strict++)
+        {
+            ip.S_un.S_addr = 0xabababab;
+            port = 0xdead;
+            res = pRtlIpv4StringToAddressExA(ipv4_ex_tests[i].address, strict, &ip, &port);
+            ok(res == ipv4_ex_tests[i].res, "[%s] res = 0x%08x, expected 0x%08x\n",
+               ipv4_ex_tests[i].address, res, ipv4_ex_tests[i].res);
+
+            init_ip4(&expected_ip, ipv4_ex_tests[i].ip);
+            ok(ip.S_un.S_addr == expected_ip.S_un.S_addr, "[%s] ip = %08x, expected %08x\n",
+               ipv4_ex_tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
+            ok(port == ipv4_ex_tests[i].port, "[%s] port = %u, expected %u\n",
+               ipv4_ex_tests[i].address, port, ipv4_ex_tests[i].port);
+        }
+    }
+}
+
+/* ipv6 addresses based on the set from https://github.com/beaugunderson/javascript-ipv6/tree/master/test/data */
+static const struct
+{
+    PCSTR address;
+    NTSTATUS res;
+    int terminator_offset;
+    int ip[8];
+    /* win_broken: older versions of windows do not handle this correct
+        ex_fail: Ex function does need the string to be terminated, non-Ex does not.
+        ex_skip: test doesnt make sense for Ex (f.e. it's invalid for non-Ex but valid for Ex) */
+    enum { normal_6, win_broken_6 = 1, ex_fail_6 = 2, ex_skip_6 = 4 } flags;
+} ipv6_tests[] =
+{
+    { "0000:0000:0000:0000:0000:0000:0000:0000",        STATUS_SUCCESS,             39,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "0000:0000:0000:0000:0000:0000:0000:0001",        STATUS_SUCCESS,             39,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+    { "0:0:0:0:0:0:0:0",                                STATUS_SUCCESS,             15,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "0:0:0:0:0:0:0:1",                                STATUS_SUCCESS,             15,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+    { "0:0:0:0:0:0:0::",                                STATUS_SUCCESS,             13,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, win_broken_6 },
+    { "0:0:0:0:0:0:13.1.68.3",                          STATUS_SUCCESS,             21,
+            { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+    { "0:0:0:0:0:0::",                                  STATUS_SUCCESS,             13,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "0:0:0:0:0::",                                    STATUS_SUCCESS,             11,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "0:0:0:0:0:FFFF:129.144.52.38",                   STATUS_SUCCESS,             28,
+            { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+    { "0::",                                            STATUS_SUCCESS,             3,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "0:1:2:3:4:5:6:7",                                STATUS_SUCCESS,             15,
+            { 0, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700 } },
+    { "1080:0:0:0:8:800:200c:417a",                     STATUS_SUCCESS,             26,
+            { 0x8010, 0, 0, 0, 0x800, 0x8, 0x0c20, 0x7a41 } },
+    { "0:a:b:c:d:e:f::",                                STATUS_SUCCESS,             13,
+            { 0, 0xa00, 0xb00, 0xc00, 0xd00, 0xe00, 0xf00, 0 }, win_broken_6 },
+    { "1111:2222:3333:4444:5555:6666:123.123.123.123",  STATUS_SUCCESS,             45,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+    { "1111:2222:3333:4444:5555:6666:7777:8888",        STATUS_SUCCESS,             39,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+    { "1111:2222:3333:4444:0x5555:6666:7777:8888",      STATUS_INVALID_PARAMETER,   21,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:x555:6666:7777:8888",        STATUS_INVALID_PARAMETER,   20,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:0r5555:6666:7777:8888",      STATUS_INVALID_PARAMETER,   21,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:r5555:6666:7777:8888",       STATUS_INVALID_PARAMETER,   20,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:5555:6666:7777::",           STATUS_SUCCESS,             34,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0 }, win_broken_6 },
+    { "1111:2222:3333:4444:5555:6666::",                STATUS_SUCCESS,             31,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0, 0 } },
+    { "1111:2222:3333:4444:5555:6666::8888",            STATUS_SUCCESS,             35,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0, 0x8888 } },
+    { "1111:2222:3333:4444:5555::",                     STATUS_SUCCESS,             26,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0 } },
+    { "1111:2222:3333:4444:5555::123.123.123.123",      STATUS_SUCCESS,             41,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0x7b7b, 0x7b7b } },
+    { "1111:2222:3333:4444:5555::0x1.123.123.123",      STATUS_SUCCESS,             27,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x100 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555::0x88",                 STATUS_SUCCESS,             27,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x8800 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555::0X88",                 STATUS_SUCCESS,             27,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x8800 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555::0X",                   STATUS_SUCCESS,             27,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555::0X88:7777",            STATUS_SUCCESS,             27,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x8800 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555::0x8888",               STATUS_SUCCESS,             27,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x8888 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555::08888",                STATUS_INVALID_PARAMETER,   31,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:5555::fffff",                STATUS_INVALID_PARAMETER,   31,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444::fffff",                     STATUS_INVALID_PARAMETER,   26,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333::fffff",                          STATUS_INVALID_PARAMETER,   21,
+            { 0x1111, 0x2222, 0x3333, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:5555::7777:8888",            STATUS_SUCCESS,             35,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0x7777, 0x8888 } },
+    { "1111:2222:3333:4444:5555::8888",                 STATUS_SUCCESS,             30,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x8888 } },
+    { "1111::",                                         STATUS_SUCCESS,             6,
+            { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+    { "1111::123.123.123.123",                          STATUS_SUCCESS,             21,
+            { 0x1111, 0, 0, 0, 0, 0, 0x7b7b, 0x7b7b } },
+    { "1111::3333:4444:5555:6666:123.123.123.123",      STATUS_SUCCESS,             41,
+            { 0x1111, 0, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+    { "1111::3333:4444:5555:6666:7777:8888",            STATUS_SUCCESS,             35,
+            { 0x1111, 0, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+    { "1111::4444:5555:6666:123.123.123.123",           STATUS_SUCCESS,             36,
+            { 0x1111, 0, 0, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+    { "1111::4444:5555:6666:7777:8888",                 STATUS_SUCCESS,             30,
+            { 0x1111, 0, 0, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+    { "1111::5555:6666:123.123.123.123",                STATUS_SUCCESS,             31,
+            { 0x1111, 0, 0, 0, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+    { "1111::5555:6666:7777:8888",                      STATUS_SUCCESS,             25,
+            { 0x1111, 0, 0, 0, 0x5555, 0x6666, 0x7777, 0x8888 } },
+    { "1111::6666:123.123.123.123",                     STATUS_SUCCESS,             26,
+            { 0x1111, 0, 0, 0, 0, 0x6666, 0x7b7b, 0x7b7b } },
+    { "1111::6666:7777:8888",                           STATUS_SUCCESS,             20,
+            { 0x1111, 0, 0, 0, 0, 0x6666, 0x7777, 0x8888 } },
+    { "1111::7777:8888",                                STATUS_SUCCESS,             15,
+            { 0x1111, 0, 0, 0, 0, 0, 0x7777, 0x8888 } },
+    { "1111::8888",                                     STATUS_SUCCESS,             10,
+            { 0x1111, 0, 0, 0, 0, 0, 0, 0x8888 } },
+    { "1:2:3:4:5:6:1.2.3.4",                            STATUS_SUCCESS,             19,
+            { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x201, 0x403 } },
+    { "1:2:3:4:5:6:7:8",                                STATUS_SUCCESS,             15,
+            { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800 } },
+    { "1:2:3:4:5:6::",                                  STATUS_SUCCESS,             13,
+            { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0, 0 } },
+    { "1:2:3:4:5:6::8",                                 STATUS_SUCCESS,             14,
+            { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0, 0x800 } },
+    { "2001:0000:1234:0000:0000:C1C0:ABCD:0876",        STATUS_SUCCESS,             39,
+            { 0x120, 0, 0x3412, 0, 0, 0xc0c1, 0xcdab, 0x7608 } },
+    { "2001:0000:4136:e378:8000:63bf:3fff:fdd2",        STATUS_SUCCESS,             39,
+            { 0x120, 0, 0x3641, 0x78e3, 0x80, 0xbf63, 0xff3f, 0xd2fd } },
+    { "2001:0db8:0:0:0:0:1428:57ab",                    STATUS_SUCCESS,             27,
+            { 0x120, 0xb80d, 0, 0, 0, 0, 0x2814, 0xab57 } },
+    { "2001:0db8:1234:ffff:ffff:ffff:ffff:ffff",        STATUS_SUCCESS,             39,
+            { 0x120, 0xb80d, 0x3412, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff } },
+    { "2001::CE49:7601:2CAD:DFFF:7C94:FFFE",            STATUS_SUCCESS,             35,
+            { 0x120, 0, 0x49ce, 0x176, 0xad2c, 0xffdf, 0x947c, 0xfeff } },
+    { "2001:db8:85a3::8a2e:370:7334",                   STATUS_SUCCESS,             28,
+            { 0x120, 0xb80d, 0xa385, 0, 0, 0x2e8a, 0x7003, 0x3473 } },
+    { "3ffe:0b00:0000:0000:0001:0000:0000:000a",        STATUS_SUCCESS,             39,
+            { 0xfe3f, 0xb, 0, 0, 0x100, 0, 0, 0xa00 } },
+    { "::",                                             STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::%16",                                          STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::/16",                                          STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "::0",                                            STATUS_SUCCESS,             3,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::0:0",                                          STATUS_SUCCESS,             5,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::0:0:0",                                        STATUS_SUCCESS,             7,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::0:0:0:0",                                      STATUS_SUCCESS,             9,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::0:0:0:0:0",                                    STATUS_SUCCESS,             11,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    { "::0:0:0:0:0:0",                                  STATUS_SUCCESS,             13,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+    /* this one and the next one are incorrectly parsed by windows,
+        it adds one zero too many in front, cutting off the last digit. */
+    { "::0:0:0:0:0:0:0",                                STATUS_SUCCESS,             13,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "::0:a:b:c:d:e:f",                                STATUS_SUCCESS,             13,
+            { 0, 0, 0, 0xa00, 0xb00, 0xc00, 0xd00, 0xe00 }, ex_fail_6 },
+    { "::123.123.123.123",                              STATUS_SUCCESS,             17,
+            { 0, 0, 0, 0, 0, 0, 0x7b7b, 0x7b7b } },
+    { "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",        STATUS_SUCCESS,             39,
+            { 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff } },
+
+    { "':10.0.0.1",                                     STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { "-1",                                             STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { "02001:0000:1234:0000:0000:C1C0:ABCD:0876",       STATUS_INVALID_PARAMETER,   -1,
+            { -1 } },
+    { "2001:00000:1234:0000:0000:C1C0:ABCD:0876",       STATUS_INVALID_PARAMETER,   -1,
+            { 0x120, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "2001:0000:01234:0000:0000:C1C0:ABCD:0876",       STATUS_INVALID_PARAMETER,   -1,
+            { 0x120, 0, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1.2.3.4",                                        STATUS_INVALID_PARAMETER,   7,
+            { 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1.2.3.4:1111::5555",                             STATUS_INVALID_PARAMETER,   7,
+            { 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1.2.3.4::5555",                                  STATUS_INVALID_PARAMETER,   7,
+            { 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "11112222:3333:4444:5555:6666:1.2.3.4",           STATUS_INVALID_PARAMETER,   -1,
+            { -1 } },
+    { "11112222:3333:4444:5555:6666:7777:8888",         STATUS_INVALID_PARAMETER,   -1,
+            { -1 } },
+    { "1111",                                           STATUS_INVALID_PARAMETER,   4,
+            { -1 } },
+    { "1111:22223333:4444:5555:6666:1.2.3.4",           STATUS_INVALID_PARAMETER,   -1,
+            { 0x1111, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:22223333:4444:5555:6666:7777:8888",         STATUS_INVALID_PARAMETER,   -1,
+            { 0x1111, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:",                                     STATUS_INVALID_PARAMETER,   10,
+            { 0x1111, 0x2222, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:1.2.3.4",                              STATUS_INVALID_PARAMETER,   17,
+            { 0x1111, 0x2222, 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333",                                 STATUS_INVALID_PARAMETER,   14,
+            { 0x1111, 0x2222, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111:2222:3333:4444:5555:6666:7777:1.2.3.4",     STATUS_SUCCESS,             36,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x100 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555:6666:7777:8888:",       STATUS_SUCCESS,             39,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555:6666:7777:8888:1.2.3.4",STATUS_SUCCESS,             39,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 }, ex_fail_6 },
+    { "1111:2222:3333:4444:5555:6666:7777:8888:9999",   STATUS_SUCCESS,             39,
+            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 }, ex_fail_6 },
+    { "1111:2222:::",                                   STATUS_SUCCESS,             11,
+            { 0x1111, 0x2222, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "1111::5555:",                                    STATUS_INVALID_PARAMETER,   11,
+            { 0x1111, 0x5555, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1111::3333:4444:5555:6666:7777::",               STATUS_SUCCESS,             30,
+            { 0x1111, 0, 0, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777 }, ex_fail_6 },
+    { "1111:2222:::4444:5555:6666:1.2.3.4",             STATUS_SUCCESS,             11,
+            { 0x1111, 0x2222, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "1111::3333::5555:6666:1.2.3.4",                  STATUS_SUCCESS,             10,
+            { 0x1111, 0, 0, 0, 0, 0, 0, 0x3333 }, ex_fail_6 },
+    { "12345::6:7:8",                                   STATUS_INVALID_PARAMETER,   -1,
+            { -1 } },
+    { "1::1.2.256.4",                                   STATUS_INVALID_PARAMETER,   -1,
+            { 0x100, 0x201, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.3.256",                                   STATUS_INVALID_PARAMETER,   12,
+            { 0x100, 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.3.300",                                   STATUS_INVALID_PARAMETER,   12,
+            { 0x100, 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2::1",                                      STATUS_INVALID_PARAMETER,   6,
+            { 0x100, 0xab01, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.3.4::1",                                  STATUS_SUCCESS,             10,
+            { 0x100, 0, 0, 0, 0, 0, 0x201, 0x403 }, ex_fail_6 },
+    { "1::1.",                                          STATUS_INVALID_PARAMETER,   5,
+            { 0x100, 0xab01, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2",                                         STATUS_INVALID_PARAMETER,   6,
+            { 0x100, 0xab01, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.",                                        STATUS_INVALID_PARAMETER,   7,
+            { 0x100, 0x201, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.3",                                       STATUS_INVALID_PARAMETER,   8,
+            { 0x100, 0x201, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.3.",                                      STATUS_INVALID_PARAMETER,   9,
+            { 0x100, 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.3.4",                                     STATUS_SUCCESS,             10,
+            { 0x100, 0, 0, 0, 0, 0, 0x201, 0x403 } },
+    { "1::1.2.3.900",                                   STATUS_INVALID_PARAMETER,   12,
+            { 0x100, 0x201, 0xab03, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.2.300.4",                                   STATUS_INVALID_PARAMETER,   -1,
+            { 0x100, 0x201, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::1.256.3.4",                                   STATUS_INVALID_PARAMETER,   -1,
+            { 0x100, 0xab01, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::256.2.3.4",                                   STATUS_INVALID_PARAMETER,   -1,
+            { 0x100, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "1::2::3",                                        STATUS_SUCCESS,             4,
+            { 0x100, 0, 0, 0, 0, 0, 0, 0x200 }, ex_fail_6 },
+    { "2001:0000:1234: 0000:0000:C1C0:ABCD:0876",       STATUS_INVALID_PARAMETER,   15,
+            { 0x120, 0, 0x3412, 0xabab, 0xabab, 0xabab, 0xabab, 0xabab } },
+    { "2001:0000:1234:0000:0000:C1C0:ABCD:0876  0",     STATUS_SUCCESS,             39,
+            { 0x120, 0, 0x3412, 0, 0, 0xc0c1, 0xcdab, 0x7608 }, ex_fail_6 },
+    { "2001:1:1:1:1:1:255Z255X255Y255",                 STATUS_INVALID_PARAMETER,   18,
+            { 0x120, 0x100, 0x100, 0x100, 0x100, 0x100, 0xabab, 0xabab } },
+    { "2001::FFD3::57ab",                               STATUS_SUCCESS,             10,
+            { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff }, ex_fail_6 },
+    { ":",                                              STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { ":1111:2222:3333:4444:5555:6666:1.2.3.4",         STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { ":1111:2222:3333:4444:5555:6666:7777:8888",       STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { ":1111::",                                        STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { "::-1",                                           STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "::.",                                            STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "::..",                                           STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "::...",                                          STATUS_SUCCESS,             2,
+            { 0, 0, 0, 0, 0, 0, 0, 0 }, ex_fail_6 },
+    { "XXXX:XXXX:XXXX:XXXX:XXXX:XXXX:1.2.3.4",          STATUS_INVALID_PARAMETER,   0,
+            { -1 } },
+    { "[::]",                                           STATUS_INVALID_PARAMETER,   0,
+            { -1 }, ex_skip_6 },
+};
+const unsigned int ipv6_testcount = sizeof(ipv6_tests) / sizeof(ipv6_tests[0]);
+
+static void init_ip6(IN6_ADDR* addr, const int src[8])
+{
+    unsigned int j;
+    if (!src || src[0] == -1)
+    {
+        for (j = 0; j < 8; ++j)
+            addr->s6_words[j] = 0xabab;
+    }
+    else
+    {
+        for (j = 0; j < 8; ++j)
+            addr->s6_words[j] = src[j];
+    }
+}
+
+static void test_RtlIpv6AddressToString(void)
+{
+    CHAR buffer[50];
+    LPCSTR result;
+    IN6_ADDR ip;
+    DWORD_PTR len;
+    struct
+    {
+        PCSTR address;
+        int ip[8];
+    } tests[] =
+    {
+        /* ipv4 addresses & ISATAP addresses */
+        { "::13.1.68.3",                                { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+        { "::ffff:13.1.68.3",                           { 0, 0, 0, 0, 0, 0xffff, 0x10d, 0x344 } },
+        { "::feff:d01:4403",                            { 0, 0, 0, 0, 0, 0xfffe, 0x10d, 0x344 } },
+        { "::fffe:d01:4403",                            { 0, 0, 0, 0, 0, 0xfeff, 0x10d, 0x344 } },
+        { "::100:d01:4403",                             { 0, 0, 0, 0, 0, 1, 0x10d, 0x344 } },
+        { "::1:d01:4403",                               { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+        { "::ffff:0:4403",                              { 0, 0, 0, 0, 0, 0xffff, 0, 0x344 } },
+        { "::ffff:13.1.0.0",                            { 0, 0, 0, 0, 0, 0xffff, 0x10d, 0 } },
+        { "::ffff:0:0",                                 { 0, 0, 0, 0, 0, 0xffff, 0, 0 } },
+        { "::ffff:0:13.1.68.3",                         { 0, 0, 0, 0, 0xffff, 0, 0x10d, 0x344 } },
+        { "::ffff:ffff:d01:4403",                       { 0, 0, 0, 0, 0xffff, 0xffff, 0x10d, 0x344 } },
+        { "::ffff:0:0:d01:4403",                        { 0, 0, 0, 0xffff, 0, 0, 0x10d, 0x344 } },
+        { "::ffff:255.255.255.255",                     { 0, 0, 0, 0, 0, 0xffff, 0xffff, 0xffff } },
+        { "::ffff:129.144.52.38",                       { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+        { "::5efe:129.144.52.38",                       { 0, 0, 0, 0, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "1111:2222:3333:4444:0:5efe:129.144.52.38",   { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "1111:2222:3333::5efe:129.144.52.38",         { 0x1111, 0x2222, 0x3333, 0, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "1111:2222::5efe:129.144.52.38",              { 0x1111, 0x2222, 0, 0, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "1111::5efe:129.144.52.38",                   { 0x1111, 0, 0, 0, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "::200:5efe:129.144.52.38",                   { 0, 0, 0, 0, 2, 0xfe5e, 0x9081, 0x2634 } },
+        { "::100:5efe:8190:3426",                       { 0, 0, 0, 0, 1, 0xfe5e, 0x9081, 0x2634 } },
+        /* 'normal' addresses */
+        { "::1",                                        { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "0:1:2:3:4:5:6:7",                            { 0, 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700 } },
+        { "1080::8:800:200c:417a",                      { 0x8010, 0, 0, 0, 0x800, 0x8, 0x0c20, 0x7a41 } },
+        { "1111:2222:3333:4444:5555:6666:7b7b:7b7b",    { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111:2222:3333:4444:5555:6666:7777:8888",    { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+        { "1111:2222:3333:4444:5555:6666::",            { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0, 0 } },
+        { "1111:2222:3333:4444:5555:6666:0:8888",       { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0, 0x8888 } },
+        { "1111:2222:3333:4444:5555::",                 { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0 } },
+        { "1111:2222:3333:4444:5555:0:7b7b:7b7b",       { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0x7b7b, 0x7b7b } },
+        { "1111:2222:3333:4444:5555:0:7777:8888",       { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0x7777, 0x8888 } },
+        { "1111:2222:3333:4444:5555::8888",             { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0, 0, 0x8888 } },
+        { "1111::",                                     { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+        { "1111::7b7b:7b7b",                            { 0x1111, 0, 0, 0, 0, 0, 0x7b7b, 0x7b7b } },
+        { "1111:0:3333:4444:5555:6666:7b7b:7b7b",       { 0x1111, 0, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111:0:3333:4444:5555:6666:7777:8888",       { 0x1111, 0, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+        { "1111::4444:5555:6666:7b7b:7b7b",             { 0x1111, 0, 0, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111::4444:5555:6666:7777:8888",             { 0x1111, 0, 0, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+        { "1111::5555:6666:7b7b:7b7b",                  { 0x1111, 0, 0, 0, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111::5555:6666:7777:8888",                  { 0x1111, 0, 0, 0, 0x5555, 0x6666, 0x7777, 0x8888 } },
+        { "1111::6666:7b7b:7b7b",                       { 0x1111, 0, 0, 0, 0, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111::6666:7777:8888",                       { 0x1111, 0, 0, 0, 0, 0x6666, 0x7777, 0x8888 } },
+        { "1111::7777:8888",                            { 0x1111, 0, 0, 0, 0, 0, 0x7777, 0x8888 } },
+        { "1111::8888",                                 { 0x1111, 0, 0, 0, 0, 0, 0, 0x8888 } },
+        { "1:2:3:4:5:6:102:304",                        { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x201, 0x403 } },
+        { "1:2:3:4:5:6:7:8",                            { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0x700, 0x800 } },
+        { "1:2:3:4:5:6::",                              { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0, 0 } },
+        { "1:2:3:4:5:6:0:8",                            { 0x100, 0x200, 0x300, 0x400, 0x500, 0x600, 0, 0x800 } },
+        { "2001:0:1234::c1c0:abcd:876",                 { 0x120, 0, 0x3412, 0, 0, 0xc0c1, 0xcdab, 0x7608 } },
+        { "2001:0:4136:e378:8000:63bf:3fff:fdd2",       { 0x120, 0, 0x3641, 0x78e3, 0x80, 0xbf63, 0xff3f, 0xd2fd } },
+        { "2001:db8::1428:57ab",                        { 0x120, 0xb80d, 0, 0, 0, 0, 0x2814, 0xab57 } },
+        { "2001:db8:1234:ffff:ffff:ffff:ffff:ffff",     { 0x120, 0xb80d, 0x3412, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff } },
+        { "2001:0:ce49:7601:2cad:dfff:7c94:fffe",       { 0x120, 0, 0x49ce, 0x176, 0xad2c, 0xffdf, 0x947c, 0xfeff } },
+        { "2001:db8:85a3::8a2e:370:7334",               { 0x120, 0xb80d, 0xa385, 0, 0, 0x2e8a, 0x7003, 0x3473 } },
+        { "3ffe:b00::1:0:0:a",                          { 0xfe3f, 0xb, 0, 0, 0x100, 0, 0, 0xa00 } },
+        { "::a:b:c:d:e",                                { 0, 0, 0, 0xa00, 0xb00, 0xc00, 0xd00, 0xe00 } },
+        { "::123.123.123.123",                          { 0, 0, 0, 0, 0, 0, 0x7b7b, 0x7b7b } },
+        { "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",    { 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff, 0xffff } },
+        { "1111:2222:3333:4444:5555:6666:7777:1",       { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x100 } },
+        { "1111:2222:3333:4444:5555:6666:7777:8888",    { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777, 0x8888 } },
+        { "1111:2222::",                                { 0x1111, 0x2222, 0, 0, 0, 0, 0, 0 } },
+        { "1111::3333:4444:5555:6666:7777",             { 0x1111, 0, 0, 0x3333, 0x4444, 0x5555, 0x6666, 0x7777 } },
+        { "1111:2222::",                                { 0x1111, 0x2222, 0, 0, 0, 0, 0, 0 } },
+        { "1111::3333",                                 { 0x1111, 0, 0, 0, 0, 0, 0, 0x3333 } },
+        { "2001:0:1234::c1c0:abcd:876",                 { 0x120, 0, 0x3412, 0, 0, 0xc0c1, 0xcdab, 0x7608 } },
+        { "2001::ffd3",                                 { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+    };
+    const size_t testcount = sizeof(tests) / sizeof(tests[0]);
+    unsigned int i;
+
+    if (!pRtlIpv6AddressToStringA)
+    {
+        skip("RtlIpv6AddressToStringA not available\n");
+        return;
+    }
+
+    memset(buffer, '#', sizeof(buffer));
+    buffer[sizeof(buffer)-1] = 0;
+    memset(&ip, 0, sizeof(ip));
+    result = pRtlIpv6AddressToStringA(&ip, buffer);
+
+    len = strlen(buffer);
+    ok(result == (buffer + len) && !strcmp(buffer, "::"),
+       "got %p with '%s' (expected %p with '::')\n", result, buffer, buffer + len);
+
+    result = pRtlIpv6AddressToStringA(&ip, NULL);
+    ok(result == (LPCSTR)~0 || broken(result == (LPCSTR)len) /* WinXP / Win2k3 */,
+       "got %p, expected %p\n", result, (LPCSTR)~0);
+
+    for (i = 0; i < testcount; i++)
+    {
+        init_ip6(&ip, tests[i].ip);
+        memset(buffer, '#', sizeof(buffer));
+        buffer[sizeof(buffer)-1] = 0;
+
+        result = pRtlIpv6AddressToStringA(&ip, buffer);
+        len = strlen(buffer);
+        ok(result == (buffer + len) && !strcmp(buffer, tests[i].address),
+           "got %p with '%s' (expected %p with '%s')\n", result, buffer, buffer + len, tests[i].address);
+
+        ok(buffer[45] == 0 || broken(buffer[45] != 0) /* WinXP / Win2k3 */,
+           "expected data at buffer[45] to always be NULL\n");
+        ok(buffer[46] == '#', "expected data at buffer[46] not to change\n");
+    }
+}
+
+static void test_RtlIpv6AddressToStringEx(void)
+{
+    CHAR buffer[70];
+    NTSTATUS res;
+    IN6_ADDR ip;
+    ULONG len;
+    struct
+    {
+        PCSTR address;
+        ULONG scopeid;
+        USHORT port;
+        int ip[8];
+    } tests[] =
+    {
+        /* ipv4 addresses & ISATAP addresses */
+        { "::13.1.68.3",                                                0,          0, { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+        { "::13.1.68.3%1",                                              1,          0, { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+        { "::13.1.68.3%4294949819",                                     0xffffbbbb, 0, { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+        { "[::13.1.68.3%4294949819]:65518",                             0xffffbbbb, 0xeeff, { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+        { "[::13.1.68.3%4294949819]:256",                               0xffffbbbb, 1, { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+        { "[::13.1.68.3]:256",                                          0,          1, { 0, 0, 0, 0, 0, 0, 0x10d, 0x344 } },
+
+        { "::1:d01:4403",                                               0,          0, { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+        { "::1:d01:4403%1",                                             1,          0, { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+        { "::1:d01:4403%4294949819",                                    0xffffbbbb, 0, { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+        { "[::1:d01:4403%4294949819]:65518",                            0xffffbbbb, 0xeeff, { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+        { "[::1:d01:4403%4294949819]:256",                              0xffffbbbb, 1, { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+        { "[::1:d01:4403]:256",                                         0,          1, { 0, 0, 0, 0, 0, 0x100, 0x10d, 0x344 } },
+
+        { "1111:2222:3333:4444:0:5efe:129.144.52.38",                   0,          0, { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "1111:2222:3333:4444:0:5efe:129.144.52.38%1",                 1,          0, { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "1111:2222:3333:4444:0:5efe:129.144.52.38%4294949819",        0xffffbbbb, 0, { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "[1111:2222:3333:4444:0:5efe:129.144.52.38%4294949819]:65518",0xffffbbbb, 0xeeff, { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "[1111:2222:3333:4444:0:5efe:129.144.52.38%4294949819]:256",  0xffffbbbb, 1, { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+        { "[1111:2222:3333:4444:0:5efe:129.144.52.38]:256",             0,          1, { 0x1111, 0x2222, 0x3333, 0x4444, 0, 0xfe5e, 0x9081, 0x2634 } },
+
+        { "::1",                                                        0,          0, { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "::1%1",                                                      1,          0, { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "::1%4294949819",                                             0xffffbbbb, 0, { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1%4294949819]:65518",                                     0xffffbbbb, 0xeeff, { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1%4294949819]:256",                                       0xffffbbbb, 1, { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1]:256",                                                  0,          1, { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+
+        { "1111:2222:3333:4444:5555:6666:7b7b:7b7b",                    0,          0, { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111:2222:3333:4444:5555:6666:7b7b:7b7b%1",                  1,          0, { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "1111:2222:3333:4444:5555:6666:7b7b:7b7b%4294949819",         0xffffbbbb, 0, { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "[1111:2222:3333:4444:5555:6666:7b7b:7b7b%4294949819]:65518", 0xffffbbbb, 0xeeff, { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "[1111:2222:3333:4444:5555:6666:7b7b:7b7b%4294949819]:256",   0xffffbbbb, 1, { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+        { "[1111:2222:3333:4444:5555:6666:7b7b:7b7b]:256",              0,          1, { 0x1111, 0x2222, 0x3333, 0x4444, 0x5555, 0x6666, 0x7b7b, 0x7b7b } },
+
+        { "1111::",                                                     0,          0, { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+        { "1111::%1",                                                   1,          0, { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+        { "1111::%4294949819",                                          0xffffbbbb, 0, { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+        { "[1111::%4294949819]:65518",                                  0xffffbbbb, 0xeeff, { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+        { "[1111::%4294949819]:256",                                    0xffffbbbb, 1, { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+        { "[1111::]:256",                                               0,          1, { 0x1111, 0, 0, 0, 0, 0, 0, 0 } },
+
+        { "2001::ffd3",                                                 0,          0, { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+        { "2001::ffd3%1",                                               1,          0, { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+        { "2001::ffd3%4294949819",                                      0xffffbbbb, 0, { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+        { "[2001::ffd3%4294949819]:65518",                              0xffffbbbb, 0xeeff, { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+        { "[2001::ffd3%4294949819]:256",                                0xffffbbbb, 1, { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+        { "[2001::ffd3]:256",                                           0,          1, { 0x120, 0, 0, 0, 0, 0, 0, 0xd3ff } },
+    };
+    const size_t testcount = sizeof(tests) / sizeof(tests[0]);
+    unsigned int i;
+
+    if (!pRtlIpv6AddressToStringExA)
+    {
+        skip("RtlIpv6AddressToStringExA not available\n");
+        return;
+    }
+
+    memset(buffer, '#', sizeof(buffer));
+    buffer[sizeof(buffer)-1] = 0;
+    memset(&ip, 0, sizeof(ip));
+    len = sizeof(buffer);
+    res = pRtlIpv6AddressToStringExA(&ip, 0, 0, buffer, &len);
+
+    ok(res == STATUS_SUCCESS, "[validate] res = 0x%08x, expected STATUS_SUCCESS\n", res);
+    ok(len == 3 && !strcmp(buffer, "::"),
+        "got len %d with '%s' (expected 3 with '::')\n", len, buffer);
+
+    memset(buffer, '#', sizeof(buffer));
+    buffer[sizeof(buffer)-1] = 0;
+
+    len = sizeof(buffer);
+    res = pRtlIpv6AddressToStringExA(NULL, 0, 0, buffer, &len);
+    ok(res == STATUS_INVALID_PARAMETER, "[null ip] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+
+    len = sizeof(buffer);
+    res = pRtlIpv6AddressToStringExA(&ip, 0, 0, NULL, &len);
+    ok(res == STATUS_INVALID_PARAMETER, "[null buffer] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+
+    res = pRtlIpv6AddressToStringExA(&ip, 0, 0, buffer, NULL);
+    ok(res == STATUS_INVALID_PARAMETER, "[null length] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+
+    len = 2;
+    memset(buffer, '#', sizeof(buffer));
+    buffer[sizeof(buffer)-1] = 0;
+    res = pRtlIpv6AddressToStringExA(&ip, 0, 0, buffer, &len);
+    ok(res == STATUS_INVALID_PARAMETER, "[null length] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+    ok(buffer[0] == '#', "got first char %c (expected '#')\n", buffer[0]);
+    ok(len == 3, "got len %d (expected len 3)\n", len);
+
+    for (i = 0; i < testcount; i++)
+    {
+        init_ip6(&ip, tests[i].ip);
+        len = sizeof(buffer);
+        memset(buffer, '#', sizeof(buffer));
+        buffer[sizeof(buffer)-1] = 0;
+
+        res = pRtlIpv6AddressToStringExA(&ip, tests[i].scopeid, tests[i].port, buffer, &len);
+
+        ok(res == STATUS_SUCCESS, "[validate] res = 0x%08x, expected STATUS_SUCCESS\n", res);
+        ok(len == (strlen(tests[i].address) + 1) && !strcmp(buffer, tests[i].address),
+           "got len %d with '%s' (expected %d with '%s')\n", len, buffer, strlen(tests[i].address), tests[i].address);
+    }
+}
+
+static void compare_RtlIpv6StringToAddressW(PCSTR name_a, int terminator_offset_a,
+                                            const struct in6_addr *addr_a, NTSTATUS res_a)
+{
+    WCHAR name[512];
+    NTSTATUS res;
+    IN6_ADDR ip;
+    PCWSTR terminator;
+
+    if (!pRtlIpv6StringToAddressW)
+        return;
+
+    pRtlMultiByteToUnicodeN(name, sizeof(name), NULL, name_a, strlen(name_a) + 1);
+
+    init_ip6(&ip, NULL);
+    terminator = (void *)0xdeadbeef;
+    res = pRtlIpv6StringToAddressW(name, &terminator, &ip);
+    ok(res == res_a, "[W:%s] res = 0x%08x, expected 0x%08x\n", name_a, res, res_a);
+
+    if (terminator_offset_a < 0)
+    {
+        ok(terminator == (void *)0xdeadbeef,
+           "[W:%s] terminator = %p, expected it not to change\n",
+           name_a, terminator);
+    }
+    else
+    {
+        ok(terminator == name + terminator_offset_a,
+           "[W:%s] terminator = %p, expected %p\n",
+           name_a, terminator, name + terminator_offset_a);
+    }
+
+    ok(!memcmp(&ip, addr_a, sizeof(ip)),
+       "[W:%s] ip = %x:%x:%x:%x:%x:%x:%x:%x, expected %x:%x:%x:%x:%x:%x:%x:%x\n",
+       name_a,
+       ip.s6_words[0], ip.s6_words[1], ip.s6_words[2], ip.s6_words[3],
+       ip.s6_words[4], ip.s6_words[5], ip.s6_words[6], ip.s6_words[7],
+       addr_a->s6_words[0], addr_a->s6_words[1], addr_a->s6_words[2], addr_a->s6_words[3],
+       addr_a->s6_words[4], addr_a->s6_words[5], addr_a->s6_words[6], addr_a->s6_words[7]);
+}
+
+static void test_RtlIpv6StringToAddress(void)
+{
+    NTSTATUS res;
+    IN6_ADDR ip, expected_ip;
+    PCSTR terminator;
+    unsigned int i;
+
+    if (!pRtlIpv6StringToAddressW)
+    {
+        skip("RtlIpv6StringToAddressW not available\n");
+        /* we can continue, just not test W */
+    }
+
+    if (!pRtlIpv6StringToAddressA)
+    {
+        skip("RtlIpv6StringToAddressA not available\n");
+        return; /* all tests are centered around A, we cannot continue */
+    }
+
+    res = pRtlIpv6StringToAddressA("::", &terminator, &ip);
+    ok(res == STATUS_SUCCESS, "[validate] res = 0x%08x, expected STATUS_SUCCESS\n", res);
+    if (0)
+    {
+        /* any of these crash */
+        res = pRtlIpv6StringToAddressA(NULL, &terminator, &ip);
+        ok(res == STATUS_INVALID_PARAMETER, "[null string] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+        res = pRtlIpv6StringToAddressA("::", NULL, &ip);
+        ok(res == STATUS_INVALID_PARAMETER, "[null terminator] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+        res = pRtlIpv6StringToAddressA("::", &terminator, NULL);
+        ok(res == STATUS_INVALID_PARAMETER, "[null result] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+    }
+
+    /* sanity check */
+    ok(sizeof(ip) == sizeof(USHORT)* 8, "sizeof(ip)\n");
+
+    for (i = 0; i < ipv6_testcount; i++)
+    {
+        init_ip6(&ip, NULL);
+        terminator = (void *)0xdeadbeef;
+        res = pRtlIpv6StringToAddressA(ipv6_tests[i].address, &terminator, &ip);
+        compare_RtlIpv6StringToAddressW(ipv6_tests[i].address, (terminator != (void *)0xdeadbeef) ?
+                                        (terminator - ipv6_tests[i].address) : -1, &ip, res);
+
+        if (ipv6_tests[i].flags & win_broken_6)
+        {
+            ok(res == ipv6_tests[i].res || broken(res == STATUS_INVALID_PARAMETER),
+               "[%s] res = 0x%08x, expected 0x%08x\n",
+               ipv6_tests[i].address, res, ipv6_tests[i].res);
+
+            if (res == STATUS_INVALID_PARAMETER)
+                continue;
+        }
         else
         {
-            expected_ip.S_un.S_un_b.s_b1 = tests[i].ip_strict[0];
-            expected_ip.S_un.S_un_b.s_b2 = tests[i].ip_strict[1];
-            expected_ip.S_un.S_un_b.s_b3 = tests[i].ip_strict[2];
-            expected_ip.S_un.S_un_b.s_b4 = tests[i].ip_strict[3];
+            ok(res == ipv6_tests[i].res,
+               "[%s] res = 0x%08x, expected 0x%08x\n",
+               ipv6_tests[i].address, res, ipv6_tests[i].res);
         }
-        ok(ip.S_un.S_addr == expected_ip.S_un.S_addr,
-           "[%s] ip = %08x, expected %08x\n",
-           tests[i].address, ip.S_un.S_addr, expected_ip.S_un.S_addr);
+
+        if (ipv6_tests[i].terminator_offset < 0)
+        {
+            ok(terminator == (void *)0xdeadbeef,
+               "[%s] terminator = %p, expected it not to change\n",
+               ipv6_tests[i].address, terminator);
+        }
+        else if (ipv6_tests[i].flags & win_broken_6)
+        {
+            PCSTR expected = ipv6_tests[i].address + ipv6_tests[i].terminator_offset;
+            ok(terminator == expected || broken(terminator == expected + 2),
+               "[%s] terminator = %p, expected %p\n",
+               ipv6_tests[i].address, terminator, expected);
+        }
+        else
+        {
+            ok(terminator == ipv6_tests[i].address + ipv6_tests[i].terminator_offset,
+               "[%s] terminator = %p, expected %p\n",
+               ipv6_tests[i].address, terminator, ipv6_tests[i].address + ipv6_tests[i].terminator_offset);
+        }
+
+        init_ip6(&expected_ip, ipv6_tests[i].ip);
+        ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+           "[%s] ip = %x:%x:%x:%x:%x:%x:%x:%x, expected %x:%x:%x:%x:%x:%x:%x:%x\n",
+           ipv6_tests[i].address,
+           ip.s6_words[0], ip.s6_words[1], ip.s6_words[2], ip.s6_words[3],
+           ip.s6_words[4], ip.s6_words[5], ip.s6_words[6], ip.s6_words[7],
+           expected_ip.s6_words[0], expected_ip.s6_words[1], expected_ip.s6_words[2], expected_ip.s6_words[3],
+           expected_ip.s6_words[4], expected_ip.s6_words[5], expected_ip.s6_words[6], expected_ip.s6_words[7]);
+    }
+}
+
+static void compare_RtlIpv6StringToAddressExW(PCSTR name_a, const struct in6_addr *addr_a, HRESULT res_a, ULONG scope_a, USHORT port_a)
+{
+    WCHAR name[512];
+    NTSTATUS res;
+    IN6_ADDR ip;
+    ULONG scope = 0xbadf00d;
+    USHORT port = 0xbeef;
+
+    if (!pRtlIpv6StringToAddressExW)
+        return;
+
+    pRtlMultiByteToUnicodeN(name, sizeof(name), NULL, name_a, strlen(name_a) + 1);
+
+    init_ip6(&ip, NULL);
+    res = pRtlIpv6StringToAddressExW(name, &ip, &scope, &port);
+
+    ok(res == res_a, "[W:%s] res = 0x%08x, expected 0x%08x\n", name_a, res, res_a);
+    ok(scope == scope_a, "[W:%s] scope = 0x%08x, expected 0x%08x\n", name_a, scope, scope_a);
+    ok(port == port_a, "[W:%s] port = 0x%08x, expected 0x%08x\n", name_a, port, port_a);
+
+    ok(!memcmp(&ip, addr_a, sizeof(ip)),
+       "[W:%s] ip = %x:%x:%x:%x:%x:%x:%x:%x, expected %x:%x:%x:%x:%x:%x:%x:%x\n",
+       name_a,
+       ip.s6_words[0], ip.s6_words[1], ip.s6_words[2], ip.s6_words[3],
+       ip.s6_words[4], ip.s6_words[5], ip.s6_words[6], ip.s6_words[7],
+       addr_a->s6_words[0], addr_a->s6_words[1], addr_a->s6_words[2], addr_a->s6_words[3],
+       addr_a->s6_words[4], addr_a->s6_words[5], addr_a->s6_words[6], addr_a->s6_words[7]);
+}
+
+static void test_RtlIpv6StringToAddressEx(void)
+{
+    NTSTATUS res;
+    IN6_ADDR ip, expected_ip;
+    ULONG scope;
+    USHORT port;
+    static const struct
+    {
+        PCSTR address;
+        NTSTATUS res;
+        ULONG scope;
+        USHORT port;
+        int ip[8];
+    } ipv6_ex_tests[] =
+    {
+        { "[::]",                                           STATUS_SUCCESS,             0,          0,
+            { 0, 0, 0, 0, 0, 0, 0, 0 } },
+        { "[::1]:8080",                                     STATUS_SUCCESS,             0,          0x901f,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1]:0x80",                                     STATUS_SUCCESS,             0,          0x8000,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1]:0X80",                                     STATUS_SUCCESS,             0,          0x8000,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1]:080",                                      STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[::1]:800000000080",                             STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0, 0, 0, 0, 0, 0, 0, 0x100 } },
+        { "[FEDC:BA98:7654:3210:FEDC:BA98:7654:3210]:80",   STATUS_SUCCESS,             0,          0x5000,
+            { 0xdcfe, 0x98ba, 0x5476, 0x1032, 0xdcfe, 0x98ba, 0x5476, 0x1032 } },
+        { "[1080:0:0:0:8:800:200C:417A]:1234",              STATUS_SUCCESS,             0,          0xd204,
+            { 0x8010, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[3ffe:2a00:100:7031::1]:8080",                   STATUS_SUCCESS,             0,          0x901f,
+            { 0xfe3f, 0x2a, 1, 0x3170, 0, 0, 0, 0x100 } },
+        { "[ 3ffe:2a00:100:7031::1]:8080",                  STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { -1 } },
+        { "[3ffe:2a00:100:7031::1 ]:8080",                  STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0xfe3f, 0x2a, 1, 0x3170, 0, 0, 0, 0x100 } },
+        { "[3ffe:2a00:100:7031::1].8080",                   STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0xfe3f, 0x2a, 1, 0x3170, 0, 0, 0, 0x100 } },
+        { "[1080::8:800:200C:417A]:8080",                   STATUS_SUCCESS,             0,          0x901f,
+            { 0x8010, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[1080::8:800:200C:417A]!8080",                   STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0x8010, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[::FFFF:129.144.52.38]:80",                      STATUS_SUCCESS,             0,          0x5000,
+            { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+        { "[::FFFF:129.144.52.38]:-80",                     STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+        { "[::FFFF:129.144.52.38]:999999999999",            STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+        { "[::FFFF:129.144.52.38%-8]:80",                   STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+        { "[::FFFF:129.144.52.38]:80",                      STATUS_SUCCESS,             0,          0x5000,
+            { 0, 0, 0, 0, 0, 0xffff, 0x9081, 0x2634 } },
+        { "[12345::6:7:8]:80",                              STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { -1 } },
+        { "[ff01::8:800:200C:417A%16]:8080",                STATUS_SUCCESS,             16,         0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%100]:8080",               STATUS_SUCCESS,             100,        0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%1000]:8080",              STATUS_SUCCESS,             1000,       0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%10000]:8080",             STATUS_SUCCESS,             10000,      0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%1000000]:8080",           STATUS_SUCCESS,             1000000,    0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%4294967295]:8080",        STATUS_SUCCESS,             0xffffffff, 0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%4294967296]:8080",        STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%-1]:8080",                STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%0]:8080",                 STATUS_SUCCESS,             0,          0x901f,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%1",                       STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A%0x1000]:8080",            STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+        { "[ff01::8:800:200C:417A/16]:8080",                STATUS_INVALID_PARAMETER,   0xbadf00d,  0xbeef,
+            { 0x1ff, 0, 0, 0, 0x800, 8, 0xc20, 0x7a41 } },
+    };
+    const unsigned int ipv6_ex_testcount = sizeof(ipv6_ex_tests) / sizeof(ipv6_ex_tests[0]);
+    const char *simple_ip = "::";
+    unsigned int i;
+
+    if (!pRtlIpv6StringToAddressExW)
+    {
+        skip("RtlIpv6StringToAddressExW not available\n");
+        /* we can continue, just not test W */
+    }
+
+    if (!pRtlIpv6StringToAddressExA)
+    {
+        skip("RtlIpv6StringToAddressExA not available\n");
+        return;
+    }
+
+    res = pRtlIpv6StringToAddressExA(simple_ip, &ip, &scope, &port);
+    ok(res == STATUS_SUCCESS, "[validate] res = 0x%08x, expected STATUS_SUCCESS\n", res);
+
+    init_ip6(&ip, NULL);
+    init_ip6(&expected_ip, NULL);
+    scope = 0xbadf00d;
+    port = 0xbeef;
+    res = pRtlIpv6StringToAddressExA(NULL, &ip, &scope, &port);
+    ok(res == STATUS_INVALID_PARAMETER,
+       "[null string] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+    ok(scope == 0xbadf00d, "[null string] scope = 0x%08x, expected 0xbadf00d\n", scope);
+    ok(port == 0xbeef, "[null string] port = 0x%08x, expected 0xbeef\n", port);
+    ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+       "[null string] ip is changed, expected it not to change\n");
+
+
+    init_ip6(&ip, NULL);
+    scope = 0xbadf00d;
+    port = 0xbeef;
+    res = pRtlIpv6StringToAddressExA(simple_ip, NULL, &scope, &port);
+    ok(res == STATUS_INVALID_PARAMETER,
+       "[null result] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+    ok(scope == 0xbadf00d, "[null result] scope = 0x%08x, expected 0xbadf00d\n", scope);
+    ok(port == 0xbeef, "[null result] port = 0x%08x, expected 0xbeef\n", port);
+    ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+       "[null result] ip is changed, expected it not to change\n");
+
+    init_ip6(&ip, NULL);
+    scope = 0xbadf00d;
+    port = 0xbeef;
+    res = pRtlIpv6StringToAddressExA(simple_ip, &ip, NULL, &port);
+    ok(res == STATUS_INVALID_PARAMETER,
+       "[null scope] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+    ok(scope == 0xbadf00d, "[null scope] scope = 0x%08x, expected 0xbadf00d\n", scope);
+    ok(port == 0xbeef, "[null scope] port = 0x%08x, expected 0xbeef\n", port);
+    ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+       "[null scope] ip is changed, expected it not to change\n");
+
+    init_ip6(&ip, NULL);
+    scope = 0xbadf00d;
+    port = 0xbeef;
+    res = pRtlIpv6StringToAddressExA(simple_ip, &ip, &scope, NULL);
+    ok(res == STATUS_INVALID_PARAMETER,
+       "[null port] res = 0x%08x, expected STATUS_INVALID_PARAMETER\n", res);
+    ok(scope == 0xbadf00d, "[null port] scope = 0x%08x, expected 0xbadf00d\n", scope);
+    ok(port == 0xbeef, "[null port] port = 0x%08x, expected 0xbeef\n", port);
+    ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+       "[null port] ip is changed, expected it not to change\n");
+
+    /* sanity check */
+    ok(sizeof(ip) == sizeof(USHORT)* 8, "sizeof(ip)\n");
+
+    /* first we run all ip related tests, to make sure someone didnt accidentally reimplement instead of re-use. */
+    for (i = 0; i < ipv6_testcount; i++)
+    {
+        ULONG scope = 0xbadf00d;
+        USHORT port = 0xbeef;
+        NTSTATUS expect_ret = (ipv6_tests[i].flags & ex_fail_6) ? STATUS_INVALID_PARAMETER : ipv6_tests[i].res;
+
+        if (ipv6_tests[i].flags & ex_skip_6)
+            continue;
+
+        init_ip6(&ip, NULL);
+        res = pRtlIpv6StringToAddressExA(ipv6_tests[i].address, &ip, &scope, &port);
+        compare_RtlIpv6StringToAddressExW(ipv6_tests[i].address, &ip, res, scope, port);
+
+        /* make sure nothing was changed if this function fails. */
+        if (res == STATUS_INVALID_PARAMETER)
+        {
+            ok(scope == 0xbadf00d, "[%s] scope = 0x%08x, expected 0xbadf00d\n",
+               ipv6_tests[i].address, scope);
+            ok(port == 0xbeef, "[%s] port = 0x%08x, expected 0xbeef\n",
+               ipv6_tests[i].address, port);
+        }
+        else
+        {
+            ok(scope != 0xbadf00d, "[%s] scope = 0x%08x, not expected 0xbadf00d\n",
+               ipv6_tests[i].address, scope);
+            ok(port != 0xbeef, "[%s] port = 0x%08x, not expected 0xbeef\n",
+               ipv6_tests[i].address, port);
+        }
+
+        if (ipv6_tests[i].flags & win_broken_6)
+        {
+            ok(res == expect_ret || broken(res == STATUS_INVALID_PARAMETER),
+               "[%s] res = 0x%08x, expected 0x%08x\n", ipv6_tests[i].address, res, expect_ret);
+
+            if (res == STATUS_INVALID_PARAMETER)
+                continue;
+        }
+        else
+        {
+            ok(res == expect_ret, "[%s] res = 0x%08x, expected 0x%08x\n",
+               ipv6_tests[i].address, res, expect_ret);
+        }
+
+        /* If ex fails but non-ex does not we cannot check if the part that is converted
+           before it failed was correct, since there is no data for it in the table. */
+        if (res == expect_ret)
+        {
+            init_ip6(&expected_ip, ipv6_tests[i].ip);
+            ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+               "[%s] ip = %x:%x:%x:%x:%x:%x:%x:%x, expected %x:%x:%x:%x:%x:%x:%x:%x\n",
+               ipv6_tests[i].address,
+               ip.s6_words[0], ip.s6_words[1], ip.s6_words[2], ip.s6_words[3],
+               ip.s6_words[4], ip.s6_words[5], ip.s6_words[6], ip.s6_words[7],
+               expected_ip.s6_words[0], expected_ip.s6_words[1], expected_ip.s6_words[2], expected_ip.s6_words[3],
+               expected_ip.s6_words[4], expected_ip.s6_words[5], expected_ip.s6_words[6], expected_ip.s6_words[7]);
+        }
+    }
+
+    /* now we run scope / port related tests */
+    for (i = 0; i < ipv6_ex_testcount; i++)
+    {
+        scope = 0xbadf00d;
+        port = 0xbeef;
+        init_ip6(&ip, NULL);
+        res = pRtlIpv6StringToAddressExA(ipv6_ex_tests[i].address, &ip, &scope, &port);
+        compare_RtlIpv6StringToAddressExW(ipv6_ex_tests[i].address, &ip, res, scope, port);
+
+        ok(res == ipv6_ex_tests[i].res, "[%s] res = 0x%08x, expected 0x%08x\n",
+           ipv6_ex_tests[i].address, res, ipv6_ex_tests[i].res);
+        ok(scope == ipv6_ex_tests[i].scope, "[%s] scope = 0x%08x, expected 0x%08x\n",
+           ipv6_ex_tests[i].address, scope, ipv6_ex_tests[i].scope);
+        ok(port == ipv6_ex_tests[i].port, "[%s] port = 0x%08x, expected 0x%08x\n",
+           ipv6_ex_tests[i].address, port, ipv6_ex_tests[i].port);
+
+        init_ip6(&expected_ip, ipv6_ex_tests[i].ip);
+        ok(!memcmp(&ip, &expected_ip, sizeof(ip)),
+           "[%s] ip = %x:%x:%x:%x:%x:%x:%x:%x, expected %x:%x:%x:%x:%x:%x:%x:%x\n",
+           ipv6_ex_tests[i].address,
+           ip.s6_words[0], ip.s6_words[1], ip.s6_words[2], ip.s6_words[3],
+           ip.s6_words[4], ip.s6_words[5], ip.s6_words[6], ip.s6_words[7],
+           expected_ip.s6_words[0], expected_ip.s6_words[1], expected_ip.s6_words[2], expected_ip.s6_words[3],
+           expected_ip.s6_words[4], expected_ip.s6_words[5], expected_ip.s6_words[6], expected_ip.s6_words[7]);
     }
 }
 
@@ -1599,10 +2716,740 @@ static void test_LdrLockLoaderLock(void)
     pLdrUnlockLoaderLock(0, magic);
 }
 
+static void test_RtlGetCompressionWorkSpaceSize(void)
+{
+    ULONG compress_workspace, decompress_workspace;
+    NTSTATUS status;
+
+    if (!pRtlGetCompressionWorkSpaceSize)
+    {
+        win_skip("RtlGetCompressionWorkSpaceSize is not available\n");
+        return;
+    }
+
+    status = pRtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_NONE, &compress_workspace,
+                                             &decompress_workspace);
+    ok(status == STATUS_INVALID_PARAMETER, "got wrong status 0x%08x\n", status);
+
+    status = pRtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_DEFAULT, &compress_workspace,
+                                             &decompress_workspace);
+    ok(status == STATUS_INVALID_PARAMETER, "got wrong status 0x%08x\n", status);
+
+    status = pRtlGetCompressionWorkSpaceSize(0xFF, &compress_workspace, &decompress_workspace);
+    ok(status == STATUS_UNSUPPORTED_COMPRESSION, "got wrong status 0x%08x\n", status);
+
+    compress_workspace = decompress_workspace = 0xdeadbeef;
+    status = pRtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1, &compress_workspace,
+                                             &decompress_workspace);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    ok(compress_workspace != 0, "got wrong compress_workspace %d\n", compress_workspace);
+    ok(decompress_workspace == 0x1000, "got wrong decompress_workspace %d\n", decompress_workspace);
+
+    compress_workspace = decompress_workspace = 0xdeadbeef;
+    status = pRtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM,
+                                             &compress_workspace, &decompress_workspace);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    ok(compress_workspace != 0, "got wrong compress_workspace %d\n", compress_workspace);
+    ok(decompress_workspace == 0x1000, "got wrong decompress_workspace %d\n", decompress_workspace);
+}
+
+/* helper for test_RtlDecompressBuffer, checks if a chunk is incomplete */
+static BOOL is_incomplete_chunk(const UCHAR *compressed, ULONG compressed_size, BOOL check_all)
+{
+    ULONG chunk_size;
+    if (compressed_size <= sizeof(WORD))
+        return TRUE;
+    while (compressed_size >= sizeof(WORD))
+    {
+        chunk_size = (*(WORD *)compressed & 0xFFF) + 1;
+        if (compressed_size < sizeof(WORD) + chunk_size)
+            return TRUE;
+        if (!check_all)
+            break;
+        compressed      += sizeof(WORD) + chunk_size;
+        compressed_size -= sizeof(WORD) + chunk_size;
+    }
+    return FALSE;
+}
+
+#define DECOMPRESS_BROKEN_TRUNCATED    1
+#define DECOMPRESS_BROKEN_FRAGMENT     2
+
+static void test_RtlDecompressBuffer(void)
+{
+    static const UCHAR test_multiple_chunks[] = {0x03, 0x30, 'W', 'i', 'n', 'e',
+                                                 0x03, 0x30, 'W', 'i', 'n', 'e'};
+    static const struct
+    {
+        UCHAR compressed[32];
+        ULONG compressed_size;
+        NTSTATUS status;
+        UCHAR uncompressed[32];
+        ULONG uncompressed_size;
+        DWORD broken_flags;
+    }
+    test_lznt[] =
+    {
+        /* 4 byte uncompressed chunk */
+        {
+            {0x03, 0x30, 'W', 'i', 'n', 'e'},
+            6,
+            STATUS_SUCCESS,
+            "Wine",
+            4,
+            DECOMPRESS_BROKEN_FRAGMENT
+        },
+        /* 8 byte uncompressed chunk */
+        {
+            {0x07, 0x30, 'W', 'i', 'n', 'e', 'W', 'i', 'n', 'e'},
+            10,
+            STATUS_SUCCESS,
+            "WineWine",
+            8,
+            DECOMPRESS_BROKEN_FRAGMENT
+        },
+        /* 4 byte compressed chunk */
+        {
+            {0x04, 0xB0, 0x00, 'W', 'i', 'n', 'e'},
+            7,
+            STATUS_SUCCESS,
+            "Wine",
+            4
+        },
+        /* 8 byte compressed chunk */
+        {
+            {0x08, 0xB0, 0x00, 'W', 'i', 'n', 'e', 'W', 'i', 'n', 'e'},
+            11,
+            STATUS_SUCCESS,
+            "WineWine",
+            8
+        },
+        /* compressed chunk using backwards reference */
+        {
+            {0x06, 0xB0, 0x10, 'W', 'i', 'n', 'e', 0x01, 0x30},
+            9,
+            STATUS_SUCCESS,
+            "WineWine",
+            8,
+            DECOMPRESS_BROKEN_TRUNCATED
+        },
+        /* compressed chunk using backwards reference with length > bytes_read */
+        {
+            {0x06, 0xB0, 0x10, 'W', 'i', 'n', 'e', 0x05, 0x30},
+            9,
+            STATUS_SUCCESS,
+            "WineWineWine",
+            12,
+            DECOMPRESS_BROKEN_TRUNCATED
+        },
+        /* same as above, but unused bits != 0 */
+        {
+            {0x06, 0xB0, 0x30, 'W', 'i', 'n', 'e', 0x01, 0x30},
+            9,
+            STATUS_SUCCESS,
+            "WineWine",
+            8,
+            DECOMPRESS_BROKEN_TRUNCATED
+        },
+        /* compressed chunk without backwards reference and unused bits != 0 */
+        {
+            {0x01, 0xB0, 0x02, 'W'},
+            4,
+            STATUS_SUCCESS,
+            "W",
+            1
+        },
+        /* termination sequence after first chunk */
+        {
+            {0x03, 0x30, 'W', 'i', 'n', 'e', 0x00, 0x00, 0x03, 0x30, 'W', 'i', 'n', 'e'},
+            14,
+            STATUS_SUCCESS,
+            "Wine",
+            4,
+            DECOMPRESS_BROKEN_FRAGMENT
+        },
+        /* compressed chunk using backwards reference with 4 bit offset, 12 bit length */
+        {
+            {0x14, 0xB0, 0x00, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
+                         0x00, 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                         0x01, 0x01, 0xF0},
+            23,
+            STATUS_SUCCESS,
+            "ABCDEFGHIJKLMNOPABCD",
+            20,
+            DECOMPRESS_BROKEN_TRUNCATED
+        },
+        /* compressed chunk using backwards reference with 5 bit offset, 11 bit length */
+        {
+            {0x15, 0xB0, 0x00, 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
+                         0x00, 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
+                         0x02, 'A', 0x00, 0x78},
+            24,
+            STATUS_SUCCESS,
+            "ABCDEFGHIJKLMNOPABCD",
+            20,
+            DECOMPRESS_BROKEN_TRUNCATED
+        },
+        /* uncompressed chunk with invalid magic */
+        {
+            {0x03, 0x20, 'W', 'i', 'n', 'e'},
+            6,
+            STATUS_SUCCESS,
+            "Wine",
+            4,
+            DECOMPRESS_BROKEN_FRAGMENT
+        },
+        /* compressed chunk with invalid magic */
+        {
+            {0x04, 0xA0, 0x00, 'W', 'i', 'n', 'e'},
+            7,
+            STATUS_SUCCESS,
+            "Wine",
+            4
+        },
+        /* garbage byte after end of buffer */
+        {
+            {0x00, 0xB0, 0x02, 0x01},
+            4,
+            STATUS_SUCCESS,
+            "",
+            0
+        },
+        /* empty compressed chunk */
+        {
+            {0x00, 0xB0, 0x00},
+            3,
+            STATUS_SUCCESS,
+            "",
+            0
+        },
+        /* empty compressed chunk with unused bits != 0 */
+        {
+            {0x00, 0xB0, 0x01},
+            3,
+            STATUS_SUCCESS,
+            "",
+            0
+        },
+        /* empty input buffer */
+        {
+            {},
+            0,
+            STATUS_BAD_COMPRESSION_BUFFER,
+        },
+        /* incomplete chunk header */
+        {
+            {0x01},
+            1,
+            STATUS_BAD_COMPRESSION_BUFFER
+        },
+        /* incomplete chunk header */
+        {
+            {0x00, 0x30},
+            2,
+            STATUS_BAD_COMPRESSION_BUFFER
+        },
+        /* compressed chunk with invalid backwards reference */
+        {
+            {0x06, 0xB0, 0x10, 'W', 'i', 'n', 'e', 0x05, 0x40},
+            9,
+            STATUS_BAD_COMPRESSION_BUFFER
+        },
+        /* compressed chunk with incomplete backwards reference */
+        {
+            {0x05, 0xB0, 0x10, 'W', 'i', 'n', 'e', 0x05},
+            8,
+            STATUS_BAD_COMPRESSION_BUFFER
+        },
+        /* incomplete uncompressed chunk */
+        {
+            {0x07, 0x30, 'W', 'i', 'n', 'e'},
+            6,
+            STATUS_BAD_COMPRESSION_BUFFER
+        },
+        /* incomplete compressed chunk */
+        {
+            {0x08, 0xB0, 0x00, 'W', 'i', 'n', 'e'},
+            7,
+            STATUS_BAD_COMPRESSION_BUFFER
+        },
+        /* two compressed chunks, the second one incomplete */
+        {
+            {0x00, 0xB0, 0x02, 0x00, 0xB0},
+            5,
+            STATUS_BAD_COMPRESSION_BUFFER,
+        }
+    };
+
+    static UCHAR buf[0x2000], workspace[0x1000];
+    NTSTATUS status, expected_status;
+    ULONG final_size;
+    int i;
+
+    if (!pRtlDecompressBuffer || !pRtlDecompressFragment)
+    {
+        win_skip("RtlDecompressBuffer or RtlDecompressFragment is not available\n");
+        return;
+    }
+
+    /* test compression format / engine */
+    final_size = 0xdeadbeef;
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_NONE, buf, sizeof(buf) - 1, test_lznt[0].compressed,
+                                  test_lznt[0].compressed_size, &final_size);
+    ok(status == STATUS_INVALID_PARAMETER, "got wrong status 0x%08x\n", status);
+    ok(final_size == 0xdeadbeef, "got wrong final_size %d\n", final_size);
+
+    final_size = 0xdeadbeef;
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_DEFAULT, buf, sizeof(buf) - 1, test_lznt[0].compressed,
+                                  test_lznt[0].compressed_size, &final_size);
+    ok(status == STATUS_INVALID_PARAMETER, "got wrong status 0x%08x\n", status);
+    ok(final_size == 0xdeadbeef, "got wrong final_size %d\n", final_size);
+
+    final_size = 0xdeadbeef;
+    status = pRtlDecompressBuffer(0xFF, buf, sizeof(buf) - 1, test_lznt[0].compressed,
+                                  test_lznt[0].compressed_size, &final_size);
+    ok(status == STATUS_UNSUPPORTED_COMPRESSION, "got wrong status 0x%08x\n", status);
+    ok(final_size == 0xdeadbeef, "got wrong final_size %d\n", final_size);
+
+    /* regular tests for RtlDecompressBuffer */
+    for (i = 0; i < sizeof(test_lznt) / sizeof(test_lznt[0]); i++)
+    {
+        trace("Running test %d (compressed_size=%d, compressed_size=%d, status=%d)\n",
+              i, test_lznt[i].compressed_size, test_lznt[i].compressed_size, test_lznt[i].status);
+
+        /* test with very big buffer */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_lznt[i].compressed,
+                                      test_lznt[i].compressed_size, &final_size);
+        ok(status == test_lznt[i].status || broken(status == STATUS_BAD_COMPRESSION_BUFFER &&
+           (test_lznt[i].broken_flags & DECOMPRESS_BROKEN_FRAGMENT)), "%d: got wrong status 0x%08x\n", i, status);
+        if (!status)
+        {
+            ok(final_size == test_lznt[i].uncompressed_size,
+               "%d: got wrong final_size %d\n", i, final_size);
+            ok(!memcmp(buf, test_lznt[i].uncompressed, test_lznt[i].uncompressed_size),
+               "%d: got wrong decoded data\n", i);
+            ok(buf[test_lznt[i].uncompressed_size] == 0x11,
+               "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size);
+        }
+
+        /* test that modifier for compression engine is ignored */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1 | COMPRESSION_ENGINE_MAXIMUM, buf, sizeof(buf),
+                                      test_lznt[i].compressed, test_lznt[i].compressed_size, &final_size);
+        ok(status == test_lznt[i].status || broken(status == STATUS_BAD_COMPRESSION_BUFFER &&
+           (test_lznt[i].broken_flags & DECOMPRESS_BROKEN_FRAGMENT)), "%d: got wrong status 0x%08x\n", i, status);
+        if (!status)
+        {
+            ok(final_size == test_lznt[i].uncompressed_size,
+               "%d: got wrong final_size %d\n", i, final_size);
+            ok(!memcmp(buf, test_lznt[i].uncompressed, test_lznt[i].uncompressed_size),
+               "%d: got wrong decoded data\n", i);
+            ok(buf[test_lznt[i].uncompressed_size] == 0x11,
+               "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size);
+        }
+
+        /* test with expected output size */
+        if (test_lznt[i].uncompressed_size > 0)
+        {
+            final_size = 0xdeadbeef;
+            memset(buf, 0x11, sizeof(buf));
+            status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, test_lznt[i].uncompressed_size,
+                                          test_lznt[i].compressed, test_lznt[i].compressed_size, &final_size);
+            ok(status == test_lznt[i].status, "%d: got wrong status 0x%08x\n", i, status);
+            if (!status)
+            {
+                ok(final_size == test_lznt[i].uncompressed_size,
+                   "%d: got wrong final_size %d\n", i, final_size);
+                ok(!memcmp(buf, test_lznt[i].uncompressed, test_lznt[i].uncompressed_size),
+                   "%d: got wrong decoded data\n", i);
+                ok(buf[test_lznt[i].uncompressed_size] == 0x11,
+                   "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size);
+            }
+        }
+
+        /* test with smaller output size */
+        if (test_lznt[i].uncompressed_size > 1)
+        {
+            final_size = 0xdeadbeef;
+            memset(buf, 0x11, sizeof(buf));
+            status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, test_lznt[i].uncompressed_size - 1,
+                                          test_lznt[i].compressed, test_lznt[i].compressed_size, &final_size);
+            ok(status == test_lznt[i].status || broken(status == STATUS_BAD_COMPRESSION_BUFFER &&
+               (test_lznt[i].broken_flags & DECOMPRESS_BROKEN_TRUNCATED)), "%d: got wrong status 0x%08x\n", i, status);
+            if (!status)
+            {
+                ok(final_size == test_lznt[i].uncompressed_size - 1,
+                   "%d: got wrong final_size %d\n", i, final_size);
+                ok(!memcmp(buf, test_lznt[i].uncompressed, test_lznt[i].uncompressed_size - 1),
+                   "%d: got wrong decoded data\n", i);
+                ok(buf[test_lznt[i].uncompressed_size - 1] == 0x11,
+                   "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size - 1);
+            }
+        }
+
+        /* test with zero output size */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, 0, test_lznt[i].compressed,
+                                      test_lznt[i].compressed_size, &final_size);
+        if (is_incomplete_chunk(test_lznt[i].compressed, test_lznt[i].compressed_size, FALSE))
+        {
+            ok(status == STATUS_BAD_COMPRESSION_BUFFER, "%d: got wrong status 0x%08x\n", i, status);
+        }
+        else
+        {
+            ok(status == STATUS_SUCCESS, "%d: got wrong status 0x%08x\n", i, status);
+            ok(final_size == 0, "%d: got wrong final_size %d\n", i, final_size);
+            ok(buf[0] == 0x11, "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size);
+        }
+
+        /* test RtlDecompressBuffer with offset = 0 */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_lznt[i].compressed,
+                                        test_lznt[i].compressed_size, 0, &final_size, workspace);
+        ok(status == test_lznt[i].status || broken(status == STATUS_BAD_COMPRESSION_BUFFER &&
+           (test_lznt[i].broken_flags & DECOMPRESS_BROKEN_FRAGMENT)), "%d: got wrong status 0x%08x\n", i, status);
+        if (!status)
+        {
+            ok(final_size == test_lznt[i].uncompressed_size,
+               "%d: got wrong final_size %d\n", i, final_size);
+            ok(!memcmp(buf, test_lznt[i].uncompressed, test_lznt[i].uncompressed_size),
+               "%d: got wrong decoded data\n", i);
+            ok(buf[test_lznt[i].uncompressed_size] == 0x11,
+               "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size);
+        }
+
+        /* test RtlDecompressBuffer with offset = 1 */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_lznt[i].compressed,
+                                        test_lznt[i].compressed_size, 1, &final_size, workspace);
+        ok(status == test_lznt[i].status || broken(status == STATUS_BAD_COMPRESSION_BUFFER &&
+           (test_lznt[i].broken_flags & DECOMPRESS_BROKEN_FRAGMENT)), "%d: got wrong status 0x%08x\n", i, status);
+        if (!status)
+        {
+            if (test_lznt[i].uncompressed_size == 0)
+            {
+                todo_wine
+                ok(final_size == 4095,
+                   "%d: got wrong final size %d\n", i, final_size);
+                /* Buffer doesn't contain any useful value on Windows */
+                ok(buf[4095] == 0x11,
+                   "%d: buf[4095] overwritten\n", i);
+            }
+            else
+            {
+                ok(final_size == test_lznt[i].uncompressed_size - 1,
+                   "%d: got wrong final_size %d\n", i, final_size);
+                ok(!memcmp(buf, test_lznt[i].uncompressed + 1, test_lznt[i].uncompressed_size - 1),
+                   "%d: got wrong decoded data\n", i);
+                ok(buf[test_lznt[i].uncompressed_size - 1] == 0x11,
+                   "%d: buf[%d] overwritten\n", i, test_lznt[i].uncompressed_size - 1);
+            }
+        }
+
+        /* test RtlDecompressBuffer with offset = 4095 */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_lznt[i].compressed,
+                                        test_lznt[i].compressed_size, 4095, &final_size, workspace);
+        ok(status == test_lznt[i].status || broken(status == STATUS_BAD_COMPRESSION_BUFFER &&
+           (test_lznt[i].broken_flags & DECOMPRESS_BROKEN_FRAGMENT)), "%d: got wrong status 0x%08x\n", i, status);
+        if (!status)
+        {
+            todo_wine
+            ok(final_size == 1,
+               "%d: got wrong final size %d\n", i, final_size);
+            todo_wine
+            ok(buf[0] == 0,
+               "%d: padding is not zero\n", i);
+            ok(buf[1] == 0x11,
+               "%d: buf[1] overwritten\n", i);
+        }
+
+        /* test RtlDecompressBuffer with offset = 4096 */
+        final_size = 0xdeadbeef;
+        memset(buf, 0x11, sizeof(buf));
+        status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_lznt[i].compressed,
+                                        test_lznt[i].compressed_size, 4096, &final_size, workspace);
+        expected_status = is_incomplete_chunk(test_lznt[i].compressed, test_lznt[i].compressed_size, TRUE) ?
+                          test_lznt[i].status : STATUS_SUCCESS;
+        ok(status == expected_status, "%d: got wrong status 0x%08x, expected 0x%08x\n", i, status, expected_status);
+        if (!status)
+        {
+            ok(final_size == 0,
+               "%d: got wrong final size %d\n", i, final_size);
+            ok(buf[0] == 0x11,
+               "%d: buf[4096] overwritten\n", i);
+        }
+    }
+
+    /* test decoding of multiple chunks with pRtlDecompressBuffer */
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_multiple_chunks,
+                                  sizeof(test_multiple_chunks), &final_size);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4100, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "Wine", 4), "got wrong decoded data at offset 0\n");
+        ok(buf[4] == 0 && buf[4095] == 0, "padding is not zero\n");
+        ok(!memcmp(buf + 4096, "Wine", 4), "got wrong decoded data at offset 4096\n");
+        ok(buf[4100] == 0x11, "buf[4100] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, 4097, test_multiple_chunks,
+                                  sizeof(test_multiple_chunks), &final_size);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4097, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "Wine", 4), "got wrong decoded data at offset 0\n");
+        ok(buf[4] == 0 && buf[4095] == 0, "padding is not zero\n");
+        ok(buf[4096], "got wrong decoded data at offset 4096\n");
+        ok(buf[4097] == 0x11, "buf[4097] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, 4096, test_multiple_chunks,
+                                  sizeof(test_multiple_chunks), &final_size);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "Wine", 4), "got wrong decoded data at offset 0\n");
+        ok(buf[4] == 0x11, "buf[4] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, 4, test_multiple_chunks,
+                                  sizeof(test_multiple_chunks), &final_size);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "Wine", 4), "got wrong decoded data at offset 0\n");
+        ok(buf[4] == 0x11, "buf[4] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, 3, test_multiple_chunks,
+                                  sizeof(test_multiple_chunks), &final_size);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 3, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "Wine", 3), "got wrong decoded data at offset 0\n");
+        ok(buf[3] == 0x11, "buf[3] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf, 0, test_multiple_chunks,
+                                  sizeof(test_multiple_chunks), &final_size);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 0, "got wrong final_size %d\n", final_size);
+        ok(buf[0] == 0x11, "buf[0] overwritten\n");
+    }
+
+    /* test multiple chunks in combination with RtlDecompressBuffer and offset=1 */
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 1, &final_size, workspace);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4099, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "ine", 3), "got wrong decoded data at offset 0\n");
+        ok(buf[3] == 0 && buf[4094] == 0, "padding is not zero\n");
+        ok(!memcmp(buf + 4095, "Wine", 4), "got wrong decoded data at offset 4095\n");
+        ok(buf[4099] == 0x11, "buf[4099] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, 4096, test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 1, &final_size, workspace);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4096, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "ine", 3), "got wrong decoded data at offset 0\n");
+        ok(buf[3] == 0 && buf[4094] == 0, "padding is not zero\n");
+        ok(buf[4095] == 'W', "got wrong decoded data at offset 4095\n");
+        ok(buf[4096] == 0x11, "buf[4096] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, 4095, test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 1, &final_size, workspace);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 3, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "ine", 3), "got wrong decoded data at offset 0\n");
+        ok(buf[4] == 0x11, "buf[4] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, 3, test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 1, &final_size, workspace);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 3, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "ine", 3), "got wrong decoded data at offset 0\n");
+        ok(buf[3] == 0x11, "buf[3] overwritten\n");
+    }
+
+    /* test multiple chunks in combination with RtlDecompressBuffer and offset=4 */
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 4, &final_size, workspace);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4096, "got wrong final_size %d\n", final_size);
+        ok(buf[0] == 0 && buf[4091] == 0, "padding is not zero\n");
+        ok(!memcmp(buf + 4092, "Wine", 4), "got wrong decoded data at offset 4092\n");
+        ok(buf[4096] == 0x11, "buf[4096] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 4095, &final_size, workspace);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 5, "got wrong final_size %d\n", final_size);
+        ok(buf[0] == 0, "padding is not zero\n");
+        ok(!memcmp(buf + 1, "Wine", 4), "got wrong decoded data at offset 1\n");
+        ok(buf[5] == 0x11, "buf[5] overwritten\n");
+    }
+
+    final_size = 0xdeadbeef;
+    memset(buf, 0x11, sizeof(buf));
+    status = pRtlDecompressFragment(COMPRESSION_FORMAT_LZNT1, buf, sizeof(buf), test_multiple_chunks,
+                                    sizeof(test_multiple_chunks), 4096, &final_size, workspace);
+    ok(status == STATUS_SUCCESS || broken(status == STATUS_BAD_COMPRESSION_BUFFER),
+       "got wrong status 0x%08x\n", status);
+    if (!status)
+    {
+        ok(final_size == 4, "got wrong final_size %d\n", final_size);
+        ok(!memcmp(buf, "Wine", 4), "got wrong decoded data at offset 0\n");
+        ok(buf[4] == 0x11, "buf[4] overwritten\n");
+    }
+
+}
+
+static void test_RtlCompressBuffer(void)
+{
+    ULONG compress_workspace, decompress_workspace;
+    static const UCHAR test_buffer[] = "WineWineWine";
+    static UCHAR buf1[0x1000], buf2[0x1000], *workspace;
+    ULONG final_size, buf_size;
+    NTSTATUS status;
+
+    if (!pRtlCompressBuffer || !pRtlGetCompressionWorkSpaceSize)
+    {
+        win_skip("RtlCompressBuffer or RtlGetCompressionWorkSpaceSize is not available\n");
+        return;
+    }
+
+    compress_workspace = decompress_workspace = 0xdeadbeef;
+    status = pRtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_LZNT1, &compress_workspace,
+                                             &decompress_workspace);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    ok(compress_workspace != 0, "got wrong compress_workspace %d\n", compress_workspace);
+
+    workspace = HeapAlloc( GetProcessHeap(), 0, compress_workspace );
+    ok(workspace != NULL, "HeapAlloc failed %x\n", GetLastError());
+
+    /* test compression format / engine */
+    final_size = 0xdeadbeef;
+    status = pRtlCompressBuffer(COMPRESSION_FORMAT_NONE, test_buffer, sizeof(test_buffer),
+                                buf1, sizeof(buf1) - 1, 4096, &final_size, workspace);
+    ok(status == STATUS_INVALID_PARAMETER, "got wrong status 0x%08x\n", status);
+    ok(final_size == 0xdeadbeef, "got wrong final_size %d\n", final_size);
+
+    final_size = 0xdeadbeef;
+    status = pRtlCompressBuffer(COMPRESSION_FORMAT_DEFAULT, test_buffer, sizeof(test_buffer),
+                                buf1, sizeof(buf1) - 1, 4096, &final_size, workspace);
+    ok(status == STATUS_INVALID_PARAMETER, "got wrong status 0x%08x\n", status);
+    ok(final_size == 0xdeadbeef, "got wrong final_size %d\n", final_size);
+
+    final_size = 0xdeadbeef;
+    status = pRtlCompressBuffer(0xFF, test_buffer, sizeof(test_buffer),
+                                buf1, sizeof(buf1) - 1, 4096, &final_size, workspace);
+    ok(status == STATUS_UNSUPPORTED_COMPRESSION, "got wrong status 0x%08x\n", status);
+    ok(final_size == 0xdeadbeef, "got wrong final_size %d\n", final_size);
+
+    /* test compression */
+    final_size = 0xdeadbeef;
+    memset(buf1, 0x11, sizeof(buf1));
+    status = pRtlCompressBuffer(COMPRESSION_FORMAT_LZNT1, test_buffer, sizeof(test_buffer),
+                                buf1, sizeof(buf1), 4096, &final_size, workspace);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    ok((*(WORD *)buf1 & 0x7000) == 0x3000, "no chunk signature found %04x\n", *(WORD *)buf1);
+    buf_size = final_size;
+    todo_wine
+    ok(final_size < sizeof(test_buffer), "got wrong final_size %d\n", final_size);
+
+    /* test decompression */
+    final_size = 0xdeadbeef;
+    memset(buf2, 0x11, sizeof(buf2));
+    status = pRtlDecompressBuffer(COMPRESSION_FORMAT_LZNT1, buf2, sizeof(buf2),
+                                  buf1, buf_size, &final_size);
+    ok(status == STATUS_SUCCESS, "got wrong status 0x%08x\n", status);
+    ok(final_size == sizeof(test_buffer), "got wrong final_size %d\n", final_size);
+    ok(!memcmp(buf2, test_buffer, sizeof(test_buffer)), "got wrong decoded data\n");
+    ok(buf2[sizeof(test_buffer)] == 0x11, "buf[%u] overwritten\n", (DWORD)sizeof(test_buffer));
+
+    /* buffer too small */
+    final_size = 0xdeadbeef;
+    memset(buf1, 0x11, sizeof(buf1));
+    status = pRtlCompressBuffer(COMPRESSION_FORMAT_LZNT1, test_buffer, sizeof(test_buffer),
+                                buf1, 4, 4096, &final_size, workspace);
+    ok(status == STATUS_BUFFER_TOO_SMALL, "got wrong status 0x%08x\n", status);
+
+    HeapFree(GetProcessHeap(), 0, workspace);
+}
+
 START_TEST(rtl)
 {
     InitFunctionPtrs();
 
+#ifdef __i386__
+    test_WinSqm();
+#else
+    skip("stdcall-style parameter checks are not supported on this platform.\n");
+#endif
+
     test_RtlCompareMemory();
     test_RtlCompareMemoryUlong();
     test_RtlMoveMemory();
@@ -1623,6 +3470,14 @@ START_TEST(rtl)
     test_RtlIpv4AddressToString();
     test_RtlIpv4AddressToStringEx();
     test_RtlIpv4StringToAddress();
+    test_RtlIpv4StringToAddressEx();
+    test_RtlIpv6AddressToString();
+    test_RtlIpv6AddressToStringEx();
+    test_RtlIpv6StringToAddress();
+    test_RtlIpv6StringToAddressEx();
     test_LdrAddRefDll();
     test_LdrLockLoaderLock();
+    test_RtlGetCompressionWorkSpaceSize();
+    test_RtlDecompressBuffer();
+    test_RtlCompressBuffer();
 }
diff --git a/dlls/ntdll/tests/threadpool.c b/dlls/ntdll/tests/threadpool.c
index 2e31b34..91d1b95 100644
--- a/dlls/ntdll/tests/threadpool.c
+++ b/dlls/ntdll/tests/threadpool.c
@@ -21,9 +21,39 @@
 #include "ntdll_test.h"
 
 static HMODULE hntdll = 0;
+static NTSTATUS (WINAPI *pTpAllocCleanupGroup)(TP_CLEANUP_GROUP **);
+static NTSTATUS (WINAPI *pTpAllocIoCompletion)(TP_IO **,HANDLE,PTP_WIN32_IO_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
 static NTSTATUS (WINAPI *pTpAllocPool)(TP_POOL **,PVOID);
+static NTSTATUS (WINAPI *pTpAllocTimer)(TP_TIMER **,PTP_TIMER_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+static NTSTATUS (WINAPI *pTpAllocWait)(TP_WAIT **,PTP_WAIT_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+static NTSTATUS (WINAPI *pTpAllocWork)(TP_WORK **,PTP_WORK_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+static VOID     (WINAPI *pTpCallbackLeaveCriticalSectionOnCompletion)(TP_CALLBACK_INSTANCE *,CRITICAL_SECTION *);
+static NTSTATUS (WINAPI *pTpCallbackMayRunLong)(TP_CALLBACK_INSTANCE *);
+static VOID     (WINAPI *pTpCallbackReleaseMutexOnCompletion)(TP_CALLBACK_INSTANCE *,HANDLE);
+static VOID     (WINAPI *pTpCallbackReleaseSemaphoreOnCompletion)(TP_CALLBACK_INSTANCE *,HANDLE,DWORD);
+static VOID     (WINAPI *pTpCallbackSetEventOnCompletion)(TP_CALLBACK_INSTANCE *,HANDLE);
+static VOID     (WINAPI *pTpCallbackUnloadDllOnCompletion)(TP_CALLBACK_INSTANCE *,HMODULE);
+static VOID     (WINAPI *pTpCancelAsyncIoOperation)(TP_IO *);
+static VOID     (WINAPI *pTpDisassociateCallback)(TP_CALLBACK_INSTANCE *);
+static BOOL     (WINAPI *pTpIsTimerSet)(TP_TIMER *);
+static VOID     (WINAPI *pTpPostWork)(TP_WORK *);
+static VOID     (WINAPI *pTpReleaseCleanupGroup)(TP_CLEANUP_GROUP *);
+static VOID     (WINAPI *pTpReleaseCleanupGroupMembers)(TP_CLEANUP_GROUP *,BOOL,PVOID);
+static VOID     (WINAPI *pTpReleaseIoCompletion)(TP_IO *);
 static VOID     (WINAPI *pTpReleasePool)(TP_POOL *);
+static VOID     (WINAPI *pTpReleaseTimer)(TP_TIMER *);
+static VOID     (WINAPI *pTpReleaseWait)(TP_WAIT *);
+static VOID     (WINAPI *pTpReleaseWork)(TP_WORK *);
+static VOID     (WINAPI *pTpSetPoolMaxThreads)(TP_POOL *,DWORD);
+static BOOL     (WINAPI *pTpSetPoolMinThreads)(TP_POOL *,DWORD);
+static VOID     (WINAPI *pTpSetTimer)(TP_TIMER *,LARGE_INTEGER *,LONG,LONG);
+static VOID     (WINAPI *pTpSetWait)(TP_WAIT *,HANDLE,LARGE_INTEGER *);
 static NTSTATUS (WINAPI *pTpSimpleTryPost)(PTP_SIMPLE_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+static VOID     (WINAPI *pTpStartAsyncIoOperation)(TP_IO *);
+static VOID     (WINAPI *pTpWaitForIoCompletion)(TP_IO *,BOOL);
+static VOID     (WINAPI *pTpWaitForTimer)(TP_TIMER *,BOOL);
+static VOID     (WINAPI *pTpWaitForWait)(TP_WAIT *,BOOL);
+static VOID     (WINAPI *pTpWaitForWork)(TP_WORK *,BOOL);
 
 #define NTDLL_GET_PROC(func) \
     do \
@@ -42,13 +72,43 @@ static BOOL init_threadpool(void)
         return FALSE;
     }
 
+    NTDLL_GET_PROC(TpAllocCleanupGroup);
+    NTDLL_GET_PROC(TpAllocIoCompletion);
     NTDLL_GET_PROC(TpAllocPool);
+    NTDLL_GET_PROC(TpAllocTimer);
+    NTDLL_GET_PROC(TpAllocWait);
+    NTDLL_GET_PROC(TpAllocWork);
+    NTDLL_GET_PROC(TpCallbackLeaveCriticalSectionOnCompletion);
+    NTDLL_GET_PROC(TpCallbackMayRunLong);
+    NTDLL_GET_PROC(TpCallbackReleaseMutexOnCompletion);
+    NTDLL_GET_PROC(TpCallbackReleaseSemaphoreOnCompletion);
+    NTDLL_GET_PROC(TpCallbackSetEventOnCompletion);
+    NTDLL_GET_PROC(TpCallbackUnloadDllOnCompletion);
+    NTDLL_GET_PROC(TpCancelAsyncIoOperation);
+    NTDLL_GET_PROC(TpDisassociateCallback);
+    NTDLL_GET_PROC(TpIsTimerSet);
+    NTDLL_GET_PROC(TpPostWork);
+    NTDLL_GET_PROC(TpReleaseCleanupGroup);
+    NTDLL_GET_PROC(TpReleaseCleanupGroupMembers);
+    NTDLL_GET_PROC(TpReleaseIoCompletion);
     NTDLL_GET_PROC(TpReleasePool);
+    NTDLL_GET_PROC(TpReleaseTimer);
+    NTDLL_GET_PROC(TpReleaseWait);
+    NTDLL_GET_PROC(TpReleaseWork);
+    NTDLL_GET_PROC(TpSetPoolMaxThreads);
+    NTDLL_GET_PROC(TpSetPoolMinThreads);
+    NTDLL_GET_PROC(TpSetTimer);
+    NTDLL_GET_PROC(TpSetWait);
     NTDLL_GET_PROC(TpSimpleTryPost);
+    NTDLL_GET_PROC(TpStartAsyncIoOperation);
+    NTDLL_GET_PROC(TpWaitForIoCompletion);
+    NTDLL_GET_PROC(TpWaitForTimer);
+    NTDLL_GET_PROC(TpWaitForWait);
+    NTDLL_GET_PROC(TpWaitForWork);
 
     if (!pTpAllocPool)
     {
-        skip("Threadpool functions not supported, skipping tests\n");
+        win_skip("Threadpool functions not supported, skipping tests\n");
         return FALSE;
     }
 
@@ -65,13 +125,23 @@ static void CALLBACK simple_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
     ReleaseSemaphore(semaphore, 1, NULL);
 }
 
+static void CALLBACK simple2_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running simple2 callback\n");
+    Sleep(100);
+    InterlockedIncrement((LONG *)userdata);
+}
+
 static void test_tp_simple(void)
 {
     TP_CALLBACK_ENVIRON environment;
+    TP_CLEANUP_GROUP *group;
     HANDLE semaphore;
     NTSTATUS status;
     TP_POOL *pool;
+    LONG userdata;
     DWORD result;
+    int i;
 
     semaphore = CreateSemaphoreA(NULL, 0, 1, NULL);
     ok(semaphore != NULL, "CreateSemaphoreA failed %u\n", GetLastError());
@@ -105,6 +175,7 @@ static void test_tp_simple(void)
     environment.Version = 9999;
     environment.Pool = pool;
     status = pTpSimpleTryPost(simple_cb, semaphore, &environment);
+    todo_wine
     ok(status == STATUS_INVALID_PARAMETER || broken(!status) /* Vista/2008 */,
        "TpSimpleTryPost unexpectedly returned status %x\n", status);
     if (!status)
@@ -113,15 +184,892 @@ static void test_tp_simple(void)
         ok(result == WAIT_OBJECT_0, "WaitForSingleObject returned %u\n", result);
     }
 
+    /* allocate a cleanup group for synchronization */
+    group = NULL;
+    status = pTpAllocCleanupGroup(&group);
+    ok(!status, "TpAllocCleanupGroup failed with status %x\n", status);
+    ok(group != NULL, "expected pool != NULL\n");
+
+    /* use cleanup group to wait for a simple callback */
+    userdata = 0;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.CleanupGroup = group;
+    status = pTpSimpleTryPost(simple2_cb, &userdata, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+    pTpReleaseCleanupGroupMembers(group, FALSE, NULL);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+
+    /* test cancellation of pending simple callbacks */
+    userdata = 0;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.CleanupGroup = group;
+    for (i = 0; i < 100; i++)
+    {
+        status = pTpSimpleTryPost(simple2_cb, &userdata, &environment);
+        ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+    }
+    pTpReleaseCleanupGroupMembers(group, TRUE, NULL);
+    ok(userdata < 100, "expected userdata < 100, got %u\n", userdata);
+
     /* cleanup */
+    pTpReleaseCleanupGroup(group);
     pTpReleasePool(pool);
     CloseHandle(semaphore);
 }
 
+static void CALLBACK work_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WORK *work)
+{
+    trace("Running work callback\n");
+    Sleep(10);
+    InterlockedIncrement((LONG *)userdata);
+}
+
+static void CALLBACK work2_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WORK *work)
+{
+    trace("Running work2 callback\n");
+    Sleep(10);
+    InterlockedExchangeAdd((LONG *)userdata, 0x10000);
+}
+
+static void test_tp_work(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    TP_WORK *work;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata;
+    int i;
+
+    /* allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* allocate new work item */
+    work = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpAllocWork(&work, work_cb, &userdata, &environment);
+    ok(!status, "TpAllocWork failed with status %x\n", status);
+    ok(work != NULL, "expected work != NULL\n");
+
+    /* post 10 identical work items at once */
+    userdata = 0;
+    for (i = 0; i < 10; i++)
+        pTpPostWork(work);
+    pTpWaitForWork(work, FALSE);
+    ok(userdata == 10, "expected userdata = 10, got %u\n", userdata);
+
+    /* add more tasks and cancel them immediately */
+    userdata = 0;
+    for (i = 0; i < 10; i++)
+        pTpPostWork(work);
+    pTpWaitForWork(work, TRUE);
+    ok(userdata < 10, "expected userdata < 10, got %u\n", userdata);
+
+    /* cleanup */
+    pTpReleaseWork(work);
+    pTpReleasePool(pool);
+}
+
+static void test_tp_work_scheduler(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    TP_CLEANUP_GROUP *group;
+    TP_WORK *work, *work2;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata;
+    int i;
+
+    /* allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* we limit the pool to a single thread */
+    pTpSetPoolMaxThreads(pool, 1);
+
+    /* create a cleanup group */
+    group = NULL;
+    status = pTpAllocCleanupGroup(&group);
+    ok(!status, "TpAllocCleanupGroup failed with status %x\n", status);
+    ok(group != NULL, "expected pool != NULL\n");
+
+    /* the first work item has no cleanup group associated */
+    work = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpAllocWork(&work, work_cb, &userdata, &environment);
+    ok(!status, "TpAllocWork failed with status %x\n", status);
+    ok(work != NULL, "expected work != NULL\n");
+
+    /* allocate a second work item with a cleanup group */
+    work2 = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.CleanupGroup = group;
+    status = pTpAllocWork(&work2, work2_cb, &userdata, &environment);
+    ok(!status, "TpAllocWork failed with status %x\n", status);
+    ok(work2 != NULL, "expected work2 != NULL\n");
+
+    /* the 'work' callbacks are not blocking execution of 'work2' callbacks */
+    userdata = 0;
+    for (i = 0; i < 10; i++)
+        pTpPostWork(work);
+    for (i = 0; i < 10; i++)
+        pTpPostWork(work2);
+    Sleep(30);
+    pTpWaitForWork(work, TRUE);
+    pTpWaitForWork(work2, TRUE);
+    ok(userdata & 0xffff, "expected userdata & 0xffff != 0, got %u\n", userdata & 0xffff);
+    ok(userdata >> 16, "expected userdata >> 16 != 0, got %u\n", userdata >> 16);
+
+    /* test ReleaseCleanupGroupMembers on a work item */
+    userdata = 0;
+    for (i = 0; i < 100; i++)
+        pTpPostWork(work);
+    for (i = 0; i < 10; i++)
+        pTpPostWork(work2);
+    pTpReleaseCleanupGroupMembers(group, FALSE, NULL);
+    pTpWaitForWork(work, TRUE);
+    ok((userdata & 0xffff) < 100, "expected userdata & 0xffff < 100, got %u\n", userdata & 0xffff);
+    ok((userdata >> 16) == 10, "expected userdata >> 16 == 10, got %u\n", userdata >> 16);
+
+    /* cleanup */
+    pTpReleaseWork(work);
+    pTpReleaseCleanupGroup(group);
+    pTpReleasePool(pool);
+}
+
+static void CALLBACK instance_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running instance callback\n");
+    pTpCallbackMayRunLong(instance);
+    Sleep(100);
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+static void CALLBACK instance2_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running instance2 callback\n");
+    ok(*(LONG *)userdata == 1, "expected *userdata = 1, got %u\n", *(LONG *)userdata);
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+static void CALLBACK instance3_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running instance3 callback\n");
+    pTpDisassociateCallback(instance);
+    Sleep(100);
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+static void CALLBACK instance4_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running instance4 callback\n");
+    pTpCallbackReleaseSemaphoreOnCompletion(instance, userdata, 1);
+}
+
+static HANDLE instance_finalization_semaphore;
+
+static void CALLBACK instance_finalization_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    DWORD ret;
+    trace("Running instance finalization callback\n");
+    ok(*(LONG *)userdata == 1, "expected *userdata = 1, got %u\n", *(LONG *)userdata);
+
+    /* Make sure that this callback is called before the regular instance cleanup tasks */
+    ret = WaitForSingleObject(instance_finalization_semaphore, 100);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+static void CALLBACK instance5_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running instance5 callback\n");
+    pTpCallbackReleaseSemaphoreOnCompletion(instance, instance_finalization_semaphore, 1);
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+
+static void test_tp_instance(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    TP_CLEANUP_GROUP *group;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata;
+    HANDLE semaphore;
+    DWORD ret;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* We limit the pool to a single thread */
+    pTpSetPoolMaxThreads(pool, 1);
+
+    /* Test behaviour of TpCallbackMayRunLong when the max number of threads is reached */
+    userdata = 0;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpSimpleTryPost(instance_cb, &userdata, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+    status = pTpSimpleTryPost(instance2_cb, &userdata, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+    while (userdata != 2) Sleep(10);
+
+    /* Test behaviour of TpDisassociateCallback on wait functions */
+    group = NULL;
+    status = pTpAllocCleanupGroup(&group);
+    ok(!status, "TpAllocCleanupGroup failed with status %x\n", status);
+    ok(group != NULL, "expected pool != NULL\n");
+
+    userdata = 0;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.CleanupGroup = group;
+    status = pTpSimpleTryPost(instance3_cb, &userdata, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+
+    pTpReleaseCleanupGroupMembers(group, FALSE, NULL);
+    todo_wine /* behaviour contradicts the MSDN description? */
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    while (userdata == 0) Sleep(10);
+
+    pTpReleaseCleanupGroup(group);
+
+    /* Test for TpCallbackReleaseSemaphoreOnCompletion */
+    semaphore = CreateSemaphoreW(NULL, 0, 1, NULL);
+    ok(semaphore != NULL, "failed to create semaphore\n");
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpSimpleTryPost(instance4_cb, semaphore, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+    ret = WaitForSingleObject(semaphore, 1000);
+    ok(ret == WAIT_OBJECT_0, "expected ret = WAIT_OBJECT_0, got %u\n", ret);
+
+    /* Test for finalization callback */
+    userdata = 0;
+    instance_finalization_semaphore = semaphore;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.FinalizationCallback = instance_finalization_cb;
+    status = pTpSimpleTryPost(instance5_cb, &userdata, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+    ret = WaitForSingleObject(semaphore, 1000);
+    ok(ret == WAIT_OBJECT_0, "expected ret = WAIT_OBJECT_0, got %u\n", ret);
+    while (userdata != 2) Sleep(10);
+
+    CloseHandle(semaphore);
+
+    /* Cleanup */
+    pTpReleasePool(pool);
+}
+
+static DWORD group_cancel_tid;
+
+static void CALLBACK group_cancel_cleanup_cb(void *object, void *userdata)
+{
+    trace("Running group cancel cleanup callback\n");
+    InterlockedIncrement( (LONG *)userdata );
+    group_cancel_tid = GetCurrentThreadId();
+}
+
+static void CALLBACK group_cancel_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    trace("Running group cancel callback\n");
+    pTpCallbackMayRunLong(instance);
+    Sleep(100);
+    ok(*(LONG *)userdata == 1, "expected *userdata = 1, got %u\n", *(LONG *)userdata);
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+static void CALLBACK dummy_cb(TP_CALLBACK_INSTANCE *instance, void *userdata)
+{
+    ok(0, "Unexpected call to dummy_cb function\n");
+}
+
+static void test_tp_group_cancel(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    TP_CLEANUP_GROUP *group;
+    TP_WORK *work;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata, userdata2;
+    int i;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* We limit the pool to a single thread */
+    pTpSetPoolMaxThreads(pool, 1);
+
+    /* Allocate a cleanup group */
+    group = NULL;
+    status = pTpAllocCleanupGroup(&group);
+    ok(!status, "TpAllocCleanupGroup failed with status %x\n", status);
+    ok(group != NULL, "expected pool != NULL\n");
+
+    /* Test execution of cancellation callback */
+    userdata = 0;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpSimpleTryPost(group_cancel_cb, &userdata, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.CleanupGroup = group;
+    environment.CleanupGroupCancelCallback = group_cancel_cleanup_cb;
+    status = pTpSimpleTryPost(dummy_cb, NULL, &environment);
+    ok(!status, "TpSimpleTryPost failed with status %x\n", status);
+
+    group_cancel_tid = 0;
+    pTpReleaseCleanupGroupMembers(group, TRUE, &userdata);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ok(group_cancel_tid == GetCurrentThreadId(), "expected tid %x, got %x\n",
+       GetCurrentThreadId(), group_cancel_tid);
+    while (userdata != 2) Sleep(10);
+
+    /* Test cancellation callback for elements with multiple instances */
+    /* Allocate new work item */
+    work = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    environment.CleanupGroup = group;
+    environment.CleanupGroupCancelCallback = group_cancel_cleanup_cb;
+    status = pTpAllocWork(&work, work_cb, &userdata, &environment);
+    ok(!status, "TpAllocWork failed with status %x\n", status);
+    ok(work != NULL, "expected work != NULL\n");
+
+    /* Post 10 identical work items at once */
+    userdata = userdata2 = 0;
+    for (i = 0; i < 10; i++)
+        pTpPostWork(work);
+
+    /* Check if we get multiple cancellation callbacks */
+    group_cancel_tid = 0;
+    pTpReleaseCleanupGroupMembers(group, TRUE, &userdata2);
+    ok(userdata < 10, "expected userdata < 10, got %u\n", userdata);
+    ok(userdata2 == 1, "expected only one cancellation callback, got %u\n", userdata2);
+    ok(group_cancel_tid == GetCurrentThreadId(), "expected tid %x, got %x\n",
+       GetCurrentThreadId(), group_cancel_tid);
+
+    /* Cleanup */
+    pTpReleaseCleanupGroup(group);
+    pTpReleasePool(pool);
+}
+
+static void CALLBACK timer_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_TIMER *timer)
+{
+    trace("Running timer callback\n");
+    InterlockedIncrement( (LONG *)userdata );
+}
+
+static void test_tp_timer(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    TP_TIMER *timer;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata;
+    BOOL success;
+    LARGE_INTEGER when;
+    DWORD ticks;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* Allocate new timer item */
+    timer = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpAllocTimer(&timer, timer_cb, &userdata, &environment);
+    ok(!status, "TpAllocTimer failed with status %x\n", status);
+    ok(timer != NULL, "expected timer != NULL\n");
+
+    success = pTpIsTimerSet(timer);
+    ok(!success, "expected TpIsTimerSet(...) = FALSE\n");
+
+    /* Set a relative timeout */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetTimer(timer, &when, 0, 0);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Wait until timer has triggered */
+    pTpWaitForTimer(timer, FALSE);
+    Sleep(250);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    while (userdata == 0) Sleep(10);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Set an absolute timeout */
+    userdata = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)500 * 10000;
+    pTpSetTimer(timer, &when, 0, 0);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Wait until timer has triggered */
+    pTpWaitForTimer(timer, FALSE);
+    Sleep(250);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    while (userdata == 0) Sleep(10);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Test a relative timeout repeated periodically */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)50 * -10000;
+    pTpSetTimer(timer, &when, 50, 0);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Wait until the timer was triggered a couple of times */
+    ticks = GetTickCount();
+    while (userdata < 100) Sleep(10);
+    ticks = GetTickCount() - ticks;
+    pTpSetTimer(timer, NULL, 0, 0);
+    pTpWaitForTimer(timer, TRUE);
+    ok(ticks >= 4500 && ticks <= 5500, "expected approximately 5000 ticks, got %u\n", ticks);
+    success = pTpIsTimerSet(timer);
+    ok(!success, "expected TpIsTimerSet(...) = FALSE\n");
+
+    /* Test with zero timeout, we expect a call immediately */
+    userdata = 0;
+    when.QuadPart = 0;
+    pTpSetTimer(timer, &when, 0, 0);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Wait until timer has triggered */
+    pTpWaitForTimer(timer, FALSE);
+    ok(userdata == 1 || broken(userdata == 0) /* Win 8 */,
+       "expected userdata = 1, got %u\n", userdata);
+    while (userdata == 0) Sleep(10);
+    success = pTpIsTimerSet(timer);
+    ok(success, "expected TpIsTimerSet(...) = TRUE\n");
+
+    /* Unset the timer again */
+    pTpSetTimer(timer, NULL, 0, 0);
+    success = pTpIsTimerSet(timer);
+    ok(!success, "expected TpIsTimerSet(...) = FALSE\n");
+
+    /* Cleanup */
+    pTpReleaseTimer(timer);
+    pTpReleasePool(pool);
+}
+
+static void CALLBACK window_length_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_TIMER *timer)
+{
+    trace("Running window length callback\n");
+    (*(DWORD *)userdata) = GetTickCount();
+}
+
+static void test_tp_window_length(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    TP_TIMER *timer, *timer2;
+    DWORD ticks, ticks2;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LARGE_INTEGER when;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* Allocate two identical timers */
+    timer = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpAllocTimer(&timer, window_length_cb, &ticks, &environment);
+    ok(!status, "TpAllocTimer failed with status %x\n", status);
+    ok(timer != NULL, "expected timer != NULL\n");
+
+    timer2 = NULL;
+    status = pTpAllocTimer(&timer2, window_length_cb, &ticks2, &environment);
+    ok(!status, "TpAllocTimer failed with status %x\n", status);
+    ok(timer2 != NULL, "expected timer2 != NULL\n");
+
+    /* Choose parameters so that timers are not merged */
+    ticks = ticks2 = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)500 * 10000;
+    pTpSetTimer(timer2, &when, 0, 0);
+    Sleep(50);
+    when.QuadPart -= (ULONGLONG)400 * 10000;
+    pTpSetTimer(timer, &when, 0, 200);
+    while (!ticks || !ticks2) Sleep(10);
+    ok(ticks2 >= ticks + 150, "expected that timers are not merged\n");
+
+    /* On Windows the timers also get merged in this case */
+    ticks = ticks2 = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)100 * 10000;
+    pTpSetTimer(timer, &when, 0, 450);
+    Sleep(50);
+    when.QuadPart += (ULONGLONG)400 * 10000;
+    pTpSetTimer(timer2, &when, 0, 0);
+    while (!ticks || !ticks2) Sleep(10);
+    todo_wine
+    ok(ticks2 >= ticks - 50 && ticks2 <= ticks + 50, "expected that timers are merged\n");
+
+    /* Timers will be merged */
+    ticks = ticks2 = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)500 * 10000;
+    pTpSetTimer(timer2, &when, 0, 0);
+    Sleep(50);
+    when.QuadPart -= (ULONGLONG)400 * 10000;
+    pTpSetTimer(timer, &when, 0, 450);
+    while (!ticks || !ticks2) Sleep(10);
+    ok(ticks2 >= ticks - 50 && ticks2 <= ticks + 50, "expected that timers are merged\n");
+
+    /* Cleanup */
+    pTpReleaseTimer(timer);
+    pTpReleaseTimer(timer2);
+    pTpReleasePool(pool);
+}
+
+static void CALLBACK wait_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WAIT *wait, TP_WAIT_RESULT result)
+{
+    trace("Running wait callback\n");
+
+    if (result == WAIT_OBJECT_0)
+        InterlockedIncrement((LONG *)userdata);
+    else if (result == WAIT_TIMEOUT)
+        InterlockedExchangeAdd((LONG *)userdata, 0x10000);
+    else
+        ok(0, "unexpected result %u\n", result);
+}
+
+static void test_tp_wait(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    HANDLE semaphore;
+    TP_WAIT *wait, *wait2;
+    TP_POOL *pool;
+    NTSTATUS status;
+    LONG userdata;
+    LARGE_INTEGER when;
+    DWORD ret;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    /* Allocate new wait items */
+    wait = NULL;
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+    status = pTpAllocWait(&wait, wait_cb, &userdata, &environment);
+    ok(!status, "TpAllocWait failed with status %x\n", status);
+    ok(wait != NULL, "expected wait != NULL\n");
+
+    wait2 = NULL;
+    status = pTpAllocWait(&wait2, wait_cb, &userdata, &environment);
+    ok(!status, "TpAllocWait failed with status %x\n", status);
+    ok(wait != NULL, "expected wait != NULL\n");
+
+    semaphore = CreateSemaphoreW(NULL, 0, 1, NULL);
+    ok(semaphore != NULL, "failed to create semaphore\n");
+
+    /* Infinite timeout, signal the semaphore immediately */
+    userdata = 0;
+    pTpSetWait(wait, semaphore, NULL);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+
+    /* Relative timeout, no event */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)50 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    Sleep(100);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Relative timeout, with event */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Absolute timeout, no event */
+    userdata = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)50 * 10000;
+    pTpSetWait(wait, semaphore, &when);
+    Sleep(100);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Absolute timeout, with event */
+    userdata = 0;
+    NtQuerySystemTime( &when );
+    when.QuadPart += (ULONGLONG)500 * 10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Trigger event immediately */
+    userdata = 0;
+    when.QuadPart = 0;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, FALSE);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    /* Cancel a pending wait */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    pTpSetWait(wait, NULL, (void *)0xdeadbeef);
+    Sleep(50);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(50);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 1000);
+    ok(ret == WAIT_OBJECT_0, "expected ret = WAIT_OBJECT_0, got %u\n", ret);
+
+    /* Test with INVALID_HANDLE_VALUE */
+    userdata = 0;
+    when.QuadPart = 0;
+    pTpSetWait(wait, INVALID_HANDLE_VALUE, &when);
+    Sleep(50);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+
+    /* Cancel a pending wait with INVALID_HANDLE_VALUE */
+    userdata = 0;
+    when.QuadPart = (ULONGLONG)500 * -10000;
+    pTpSetWait(wait, semaphore, &when);
+    pTpWaitForWait(wait, TRUE);
+    Sleep(250);
+    when.QuadPart = (ULONGLONG)100 * -10000;
+    pTpSetWait(wait, INVALID_HANDLE_VALUE, &when);
+    Sleep(250);
+    ok(userdata == 0x10000, "expected userdata = 0x10000, got %u\n", userdata);
+
+    /* Add two objects with the same semaphore */
+    userdata = 0;
+    pTpSetWait(wait, semaphore, NULL);
+    pTpSetWait(wait2, semaphore, NULL);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    ReleaseSemaphore(semaphore, 1, NULL);
+    Sleep(10);
+    pTpWaitForWait(wait, FALSE);
+    pTpWaitForWait(wait2, FALSE);
+    ok(userdata == 1, "expected userdata = 1, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    CloseHandle(semaphore);
+    semaphore = CreateSemaphoreW(NULL, 0, 2, NULL);
+    ok(semaphore != NULL, "failed to create semaphore\n");
+
+    /* Repeat test above, but with a semaphore of count 2 */
+    userdata = 0;
+    pTpSetWait(wait, semaphore, NULL);
+    pTpSetWait(wait2, semaphore, NULL);
+    ok(userdata == 0, "expected userdata = 0, got %u\n", userdata);
+    ReleaseSemaphore(semaphore, 2, NULL);
+    Sleep(10);
+    pTpWaitForWait(wait, FALSE);
+    pTpWaitForWait(wait2, FALSE);
+    ok(userdata == 2, "expected userdata = 2, got %u\n", userdata);
+    ret = WaitForSingleObject(semaphore, 50);
+    ok(ret == WAIT_TIMEOUT, "expected ret = WAIT_TIMEOUT, got %u\n", ret);
+
+    CloseHandle(semaphore);
+
+    /* Cleanup */
+    pTpReleaseWait(wait2);
+    pTpReleaseWait(wait);
+    pTpReleasePool(pool);
+}
+
+static LONG multi_wait_callbacks;
+static DWORD multi_wait_result;
+
+static void CALLBACK multi_wait_cb(TP_CALLBACK_INSTANCE *instance, void *userdata, TP_WAIT *wait, TP_WAIT_RESULT result)
+{
+    DWORD index = (DWORD)(DWORD_PTR)userdata;
+    InterlockedIncrement(&multi_wait_callbacks);
+
+    if (result == WAIT_OBJECT_0)
+        multi_wait_result = index;
+    else if (result == WAIT_TIMEOUT)
+        multi_wait_result = 0x10000 | index;
+    else
+        ok(0, "unexpected result %u\n", result);
+}
+
+static void test_tp_multi_wait(void)
+{
+    TP_CALLBACK_ENVIRON environment;
+    HANDLE semaphores[512];
+    TP_WAIT *waits[512];
+    TP_POOL *pool;
+    NTSTATUS status;
+    LARGE_INTEGER when;
+    int i;
+
+    /* Allocate new threadpool */
+    pool = NULL;
+    status = pTpAllocPool(&pool, NULL);
+    ok(!status, "TpAllocPool failed with status %x\n", status);
+    ok(pool != NULL, "expected pool != NULL\n");
+
+    memset(&environment, 0, sizeof(environment));
+    environment.Version = 1;
+    environment.Pool = pool;
+
+    /* Create semaphores, wait objects and enable them */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        semaphores[i] = CreateSemaphoreW(NULL, 0, 1, NULL);
+        ok(semaphores[i] != NULL, "failed to create semaphores[%d]\n", i);
+
+        waits[i] = NULL;
+        status = pTpAllocWait(&waits[i], multi_wait_cb, (void *)i, &environment);
+        ok(!status, "TpAllocWait failed with status %x\n", status);
+        ok(waits[i] != NULL, "expected waits[%d] != NULL\n", i);
+
+        pTpSetWait(waits[i], semaphores[i], NULL);
+    }
+
+    /* Now test releasing the semaphores */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        multi_wait_callbacks = 0;
+        multi_wait_result = 0;
+
+        ReleaseSemaphore(semaphores[i], 1, NULL);
+        while (multi_wait_callbacks == 0) Sleep(10);
+        ok(multi_wait_callbacks == 1, "expected multi_wait_callbacks = 1, got %u\n", multi_wait_callbacks);
+        ok(multi_wait_result == i, "expected multi_wait_result = %u, got %u\n", multi_wait_result, i);
+
+        pTpSetWait(waits[i], semaphores[i], NULL);
+    }
+
+    /* Now again in the reversed order */
+    for (i = sizeof(semaphores)/sizeof(semaphores[0]) - 1; i >= 0; i--)
+    {
+        multi_wait_callbacks = 0;
+        multi_wait_result = 0;
+
+        ReleaseSemaphore(semaphores[i], 1, NULL);
+        while (multi_wait_callbacks == 0) Sleep(10);
+        ok(multi_wait_callbacks == 1, "expected multi_wait_callbacks = 1, got %u\n", multi_wait_callbacks);
+        ok(multi_wait_result == i, "expected multi_wait_result = %u, got %u\n", multi_wait_result, i);
+
+        pTpSetWait(waits[i], semaphores[i], NULL);
+    }
+
+    /* Now test with a timeout */
+    multi_wait_callbacks = 0;
+    multi_wait_result = 0;
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        when.QuadPart = 0;
+        pTpSetWait(waits[i], semaphores[i], &when);
+    }
+    Sleep(50);
+    ok(multi_wait_callbacks == sizeof(semaphores)/sizeof(semaphores[0]),
+       "got wrong multi_wait_callbacks %u\n", multi_wait_callbacks);
+    ok(multi_wait_result >> 16, "expected multi_wait_result >> 16 != 0\n");
+
+    /* Add them all again, we want that the wait is pending while destroying it */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+        pTpSetWait(waits[i], semaphores[i], NULL);
+
+    /* Destroy the objects and semaphores */
+    for (i = 0; i < sizeof(semaphores)/sizeof(semaphores[0]); i++)
+    {
+        pTpReleaseWait(waits[i]);
+        NtClose(semaphores[i]);
+    }
+
+    pTpReleasePool(pool);
+}
+
 START_TEST(threadpool)
 {
     if (!init_threadpool())
         return;
 
     test_tp_simple();
+    test_tp_work();
+    test_tp_work_scheduler();
+    test_tp_instance();
+    test_tp_group_cancel();
+    test_tp_timer();
+    test_tp_window_length();
+    test_tp_wait();
+    test_tp_multi_wait();
+
+    /* FIXME: Make sure worker threads have terminated before. */
+    Sleep(100);
 }
diff --git a/dlls/ntdll/thread.c b/dlls/ntdll/thread.c
index 3696c8e..30a4720 100644
--- a/dlls/ntdll/thread.c
+++ b/dlls/ntdll/thread.c
@@ -23,6 +23,8 @@
 
 #include <assert.h>
 #include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
 #include <sys/types.h>
 #ifdef HAVE_SYS_MMAN_H
 #include <sys/mman.h>
@@ -202,6 +204,26 @@ static ULONG64 get_dyld_image_info_addr(void)
 }
 #endif  /* __APPLE__ */
 
+
+/**************************************************************************
+ *  __wine_user_shared_data   (NTDLL.@)
+ *
+ * Update user shared data and return the address of the structure.
+ */
+void* CDECL __wine_user_shared_data(void)
+{
+    LARGE_INTEGER now;
+    NtQuerySystemTime( &now );
+    user_shared_data->SystemTime.LowPart = now.u.LowPart;
+    user_shared_data->SystemTime.High1Time = user_shared_data->SystemTime.High2Time = now.u.HighPart;
+    user_shared_data->u.TickCountQuad = (now.QuadPart - server_start_time) / 10000;
+    user_shared_data->u.TickCount.High2Time = user_shared_data->u.TickCount.High1Time;
+    user_shared_data->TickCountLowDeprecated = user_shared_data->u.TickCount.LowPart;
+    user_shared_data->TickCountMultiplier = 1 << 24;
+    return user_shared_data;
+}
+
+
 /***********************************************************************
  *           thread_init
  *
@@ -215,7 +237,6 @@ HANDLE thread_init(void)
     void *addr;
     SIZE_T size, info_size;
     HANDLE exe_file = 0;
-    LARGE_INTEGER now;
     NTSTATUS status;
     struct ntdll_thread_data *thread_data;
     static struct debug_info debug_info;  /* debug info for initial thread */
@@ -224,6 +245,7 @@ HANDLE thread_init(void)
 #endif
 
     virtual_init();
+    signal_init_early();
 
     /* reserve space for shared user data */
 
@@ -331,15 +353,8 @@ HANDLE thread_init(void)
             wine_server_fd_to_handle( 2, GENERIC_WRITE|SYNCHRONIZE, OBJ_INHERIT, &params.hStdError );
     }
 
-    /* initialize time values in user_shared_data */
-    NtQuerySystemTime( &now );
-    user_shared_data->SystemTime.LowPart = now.u.LowPart;
-    user_shared_data->SystemTime.High1Time = user_shared_data->SystemTime.High2Time = now.u.HighPart;
-    user_shared_data->u.TickCountQuad = (now.QuadPart - server_start_time) / 10000;
-    user_shared_data->u.TickCount.High2Time = user_shared_data->u.TickCount.High1Time;
-    user_shared_data->TickCountLowDeprecated = user_shared_data->u.TickCount.LowPart;
-    user_shared_data->TickCountMultiplier = 1 << 24;
-
+    /* initialize user_shared_data */
+    __wine_user_shared_data();
     fill_cpu_info();
 
     NtCreateKeyedEvent( &keyed_event, GENERIC_READ | GENERIC_WRITE, NULL, 0 );
@@ -370,6 +385,8 @@ void terminate_thread( int status )
 void exit_thread( int status )
 {
     static void *prev_teb;
+    shmlocal_t *shmlocal;
+    sigset_t sigset;
     TEB *teb;
 
     if (status)  /* send the exit code to the server (0 is already the default) */
@@ -383,7 +400,7 @@ void exit_thread( int status )
         SERVER_END_REQ;
     }
 
-    if (interlocked_xchg_add( &nb_threads, -1 ) <= 1)
+    if (interlocked_xchg_add( &nb_threads, 0 ) <= 1)
     {
         LdrShutdownProcess();
         exit( status );
@@ -392,6 +409,9 @@ void exit_thread( int status )
     LdrShutdownThread();
     RtlFreeThreadActivationContextStack();
 
+    shmlocal = interlocked_xchg_ptr( &NtCurrentTeb()->Reserved5[1], NULL );
+    if (shmlocal) NtUnmapViewOfSection( NtCurrentProcess(), shmlocal );
+
     pthread_sigmask( SIG_BLOCK, &server_block_set, NULL );
 
     if ((teb = interlocked_xchg_ptr( &prev_teb, NtCurrentTeb() )))
@@ -405,6 +425,11 @@ void exit_thread( int status )
         }
     }
 
+    sigemptyset( &sigset );
+    sigaddset( &sigset, SIGQUIT );
+    pthread_sigmask( SIG_BLOCK, &sigset, NULL );
+    if (interlocked_xchg_add( &nb_threads, -1 ) <= 1) _exit( status );
+
     close( ntdll_get_thread_data()->wait_fd[0] );
     close( ntdll_get_thread_data()->wait_fd[1] );
     close( ntdll_get_thread_data()->reply_fd );
@@ -962,47 +987,91 @@ NTSTATUS WINAPI NtQueryInformationThread( HANDLE handle, THREADINFOCLASS class,
     case ThreadTimes:
         {
             KERNEL_USER_TIMES   kusrt;
-            /* We need to do a server call to get the creation time or exit time */
+            int unix_pid, unix_tid;
+
+            /* We need to do a server call to get the creation time, exit time, PID and TID */
             /* This works on any thread */
-            SERVER_START_REQ( get_thread_info )
+            SERVER_START_REQ( get_thread_times )
             {
                 req->handle = wine_server_obj_handle( handle );
-                req->tid_in = 0;
                 status = wine_server_call( req );
                 if (status == STATUS_SUCCESS)
                 {
                     kusrt.CreateTime.QuadPart = reply->creation_time;
                     kusrt.ExitTime.QuadPart = reply->exit_time;
+                    unix_pid = reply->unix_pid;
+                    unix_tid = reply->unix_tid;
                 }
             }
             SERVER_END_REQ;
             if (status == STATUS_SUCCESS)
             {
-                /* We call times(2) for kernel time or user time */
-                /* We can only (portably) do this for the current thread */
-                if (handle == GetCurrentThread())
+                unsigned long clk_tck = sysconf(_SC_CLK_TCK);
+                BOOL filled_times = FALSE;
+
+#ifdef __linux__
+                /* only /proc provides exact values for a specific thread */
+                if (unix_pid != -1 && unix_tid != -1)
                 {
-                    struct tms time_buf;
-                    long clocks_per_sec = sysconf(_SC_CLK_TCK);
+                    unsigned long usr, sys;
+                    char buf[512], *pos;
+                    FILE *fp;
+                    int i;
+
+                    /* based on https://github.com/torvalds/linux/blob/master/fs/proc/array.c */
+                    sprintf( buf, "/proc/%u/task/%u/stat", unix_pid, unix_tid );
+                    if ((fp = fopen( buf, "r" )))
+                    {
+                        pos = fgets( buf, sizeof(buf), fp );
+                        fclose( fp );
+
+                        /* format of first chunk is "%d (%s) %c" - we have to skip to the last ')'
+                         * to avoid misinterpreting the string. */
+                        if (pos) pos = strrchr( pos, ')' );
+                        if (pos) pos = strchr( pos + 1, ' ' );
+                        if (pos) pos++;
+
+                        /* skip over the following fields: state, ppid, pgid, sid, tty_nr, tty_pgrp,
+                         * task->flags, min_flt, cmin_flt, maj_flt, cmaj_flt */
+                        for (i = 0; (i < 11) && pos; i++)
+                        {
+                            pos = strchr( pos + 1, ' ' );
+                            if (pos) pos++;
+                        }
+
+                        /* the next two values are user and system time */
+                        if (pos && (sscanf( pos, "%lu %lu", &usr, &sys ) == 2))
+                        {
+                            kusrt.KernelTime.QuadPart = (ULONGLONG)sys * 10000000 / clk_tck;
+                            kusrt.UserTime.QuadPart   = (ULONGLONG)usr * 10000000 / clk_tck;
+                            filled_times = TRUE;
+                        }
+                    }
+                }
+#endif
 
+                /* get values for current process instead */
+                if (!filled_times && handle == GetCurrentThread())
+                {
+                    struct tms time_buf;
                     times(&time_buf);
-                    kusrt.KernelTime.QuadPart = (ULONGLONG)time_buf.tms_stime * 10000000 / clocks_per_sec;
-                    kusrt.UserTime.QuadPart = (ULONGLONG)time_buf.tms_utime * 10000000 / clocks_per_sec;
+
+                    kusrt.KernelTime.QuadPart = (ULONGLONG)time_buf.tms_stime * 10000000 / clk_tck;
+                    kusrt.UserTime.QuadPart   = (ULONGLONG)time_buf.tms_utime * 10000000 / clk_tck;
+                    filled_times = TRUE;
                 }
-                else
+
+                /* unable to determine exact values, fill with zero */
+                if (!filled_times)
                 {
-                    static BOOL reported = FALSE;
+                    static int once;
+                    if (!once++)
+                        FIXME("Cannot get kerneltime or usertime of other threads\n");
 
                     kusrt.KernelTime.QuadPart = 0;
-                    kusrt.UserTime.QuadPart = 0;
-                    if (reported)
-                        TRACE("Cannot get kerneltime or usertime of other threads\n");
-                    else
-                    {
-                        FIXME("Cannot get kerneltime or usertime of other threads\n");
-                        reported = TRUE;
-                    }
+                    kusrt.UserTime.QuadPart   = 0;
                 }
+
                 if (data) memcpy( data, &kusrt, min( length, sizeof(kusrt) ));
                 if (ret_len) *ret_len = min( length, sizeof(kusrt) );
             }
diff --git a/dlls/ntdll/threadpool.c b/dlls/ntdll/threadpool.c
index 513c13d..7df8cb1 100644
--- a/dlls/ntdll/threadpool.c
+++ b/dlls/ntdll/threadpool.c
@@ -2,6 +2,7 @@
  * Thread pooling
  *
  * Copyright (c) 2006 Robert Shearman
+ * Copyright (c) 2014-2015 Sebastian Lackner
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -37,6 +38,10 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(threadpool);
 
+/*
+ * Old thread pooling API
+ */
+
 #define OLD_WORKER_TIMEOUT 30000        /* 30 seconds */
 #define EXPIRE_NEVER       (~(ULONGLONG)0)
 #define TIMER_QUEUE_MAGIC  0x516d6954   /* TimQ */
@@ -127,6 +132,227 @@ struct timer_queue
     HANDLE thread;
 };
 
+/*
+ * New object-oriented thread pooling API
+ */
+
+#define THREADPOOL_WORKER_TIMEOUT 5000
+#define MAXIMUM_WAITQUEUE_OBJECTS (MAXIMUM_WAIT_OBJECTS - 1)
+
+/* internal threadpool representation */
+struct threadpool
+{
+    LONG                    refcount;
+    BOOL                    shutdown;
+    CRITICAL_SECTION        cs;
+    /* pool of work items, locked via .cs */
+    struct list             pool;
+    RTL_CONDITION_VARIABLE  update_event;
+    /* information about worker threads, locked via .cs */
+    int                     max_workers;
+    int                     min_workers;
+    int                     num_workers;
+    int                     num_busy_workers;
+};
+
+enum threadpool_objtype
+{
+    TP_OBJECT_TYPE_SIMPLE,
+    TP_OBJECT_TYPE_WORK,
+    TP_OBJECT_TYPE_TIMER,
+    TP_OBJECT_TYPE_WAIT
+};
+
+/* internal threadpool object representation */
+struct threadpool_object
+{
+    LONG                    refcount;
+    BOOL                    shutdown;
+    /* read-only information */
+    enum threadpool_objtype type;
+    struct threadpool       *pool;
+    struct threadpool_group *group;
+    PVOID                   userdata;
+    PTP_CLEANUP_GROUP_CANCEL_CALLBACK group_cancel_callback;
+    PTP_SIMPLE_CALLBACK     finalization_callback;
+    BOOL                    may_run_long;
+    HMODULE                 race_dll;
+    /* information about the group, locked via .group->cs */
+    struct list             group_entry;
+    BOOL                    is_group_member;
+    /* information about the pool, locked via .pool->cs */
+    struct list             pool_entry;
+    RTL_CONDITION_VARIABLE  finished_event;
+    LONG                    num_pending_callbacks;
+    LONG                    num_running_callbacks;
+    /* arguments for callback */
+    union
+    {
+        struct
+        {
+            PTP_SIMPLE_CALLBACK callback;
+        } simple;
+        struct
+        {
+            PTP_WORK_CALLBACK callback;
+        } work;
+        struct
+        {
+            PTP_TIMER_CALLBACK callback;
+            /* information about the timer, locked via timerqueue.cs */
+            BOOL            timer_initialized;
+            BOOL            timer_pending;
+            struct list     timer_entry;
+            BOOL            timer_set;
+            ULONGLONG       timeout;
+            LONG            period;
+            LONG            window_length;
+        } timer;
+        struct
+        {
+            PTP_WAIT_CALLBACK callback;
+            LONG            signaled;
+            /* information about the wait, locked via waitqueue.cs */
+            struct waitqueue_bucket *bucket;
+            BOOL            wait_pending;
+            struct list     wait_entry;
+            ULONGLONG       timeout;
+            HANDLE          handle;
+        } wait;
+    } u;
+};
+
+/* internal threadpool instance representation */
+struct threadpool_instance
+{
+    struct threadpool_object *object;
+    DWORD                   threadid;
+    BOOL                    disassociated;
+    BOOL                    may_run_long;
+    struct
+    {
+        CRITICAL_SECTION    *critical_section;
+        HANDLE              mutex;
+        HANDLE              semaphore;
+        LONG                semaphore_count;
+        HANDLE              event;
+        HMODULE             library;
+    } cleanup;
+};
+
+/* internal threadpool group representation */
+struct threadpool_group
+{
+    LONG                    refcount;
+    BOOL                    shutdown;
+    CRITICAL_SECTION        cs;
+    /* list of group members, locked via .cs */
+    struct list             members;
+};
+
+/* global timerqueue object */
+static RTL_CRITICAL_SECTION_DEBUG timerqueue_debug;
+
+static struct
+{
+    CRITICAL_SECTION        cs;
+    BOOL                    thread_running;
+    LONG                    num_timers;
+    struct list             pending_timers;
+    RTL_CONDITION_VARIABLE  update_event;
+}
+timerqueue =
+{
+    { &timerqueue_debug, -1, 0, 0, 0, 0 },
+    FALSE,
+    0,
+    LIST_INIT( timerqueue.pending_timers ),
+    RTL_CONDITION_VARIABLE_INIT
+};
+
+static RTL_CRITICAL_SECTION_DEBUG timerqueue_debug =
+{
+    0, 0, &timerqueue.cs,
+    { &timerqueue_debug.ProcessLocksList, &timerqueue_debug.ProcessLocksList },
+    0, 0, { (DWORD_PTR)(__FILE__ ": timerqueue.cs") }
+};
+
+struct waitqueue_bucket
+{
+    struct list             bucket_entry;
+    LONG                    num_waits;
+    struct list             reserved;
+    struct list             waits;
+    HANDLE                  update_event;
+};
+
+/* global waitqueue object */
+static RTL_CRITICAL_SECTION_DEBUG waitqueue_debug;
+
+static struct
+{
+    CRITICAL_SECTION        cs;
+    LONG                    num_buckets;
+    struct list             buckets;
+}
+waitqueue =
+{
+    { &waitqueue_debug, -1, 0, 0, 0, 0 },
+    0,
+    LIST_INIT( waitqueue.buckets )
+};
+
+static RTL_CRITICAL_SECTION_DEBUG waitqueue_debug =
+{
+    0, 0, &waitqueue.cs,
+    { &waitqueue_debug.ProcessLocksList, &waitqueue_debug.ProcessLocksList },
+    0, 0, { (DWORD_PTR)(__FILE__ ": waitqueue.cs") }
+};
+
+static inline struct threadpool *impl_from_TP_POOL( TP_POOL *pool )
+{
+    return (struct threadpool *)pool;
+}
+
+static inline struct threadpool_object *impl_from_TP_WORK( TP_WORK *work )
+{
+    struct threadpool_object *object = (struct threadpool_object *)work;
+    assert( !object || object->type == TP_OBJECT_TYPE_WORK );
+    return object;
+}
+
+static inline struct threadpool_object *impl_from_TP_TIMER( TP_TIMER *timer )
+{
+    struct threadpool_object *object = (struct threadpool_object *)timer;
+    assert( !object || object->type == TP_OBJECT_TYPE_TIMER );
+    return object;
+}
+
+static inline struct threadpool_object *impl_from_TP_WAIT( TP_WAIT *wait )
+{
+    struct threadpool_object *object = (struct threadpool_object *)wait;
+    assert( !object || object->type == TP_OBJECT_TYPE_WAIT );
+    return object;
+}
+
+static inline struct threadpool_group *impl_from_TP_CLEANUP_GROUP( TP_CLEANUP_GROUP *group )
+{
+    return (struct threadpool_group *)group;
+}
+
+static inline struct threadpool_instance *impl_from_TP_CALLBACK_INSTANCE( TP_CALLBACK_INSTANCE *instance )
+{
+    return (struct threadpool_instance *)instance;
+}
+
+static void CALLBACK threadpool_worker_proc( void *param );
+static void CALLBACK timerqueue_thread_proc( void *param );
+static void CALLBACK waitqueue_thread_proc( void *param );
+static void tp_object_submit( struct threadpool_object *object, BOOL success );
+static void tp_object_shutdown( struct threadpool_object *object );
+static BOOL tp_object_release( struct threadpool_object *object );
+static struct threadpool *default_threadpool = NULL;
+
 static inline LONG interlocked_inc( PLONG dest )
 {
     return interlocked_xchg_add( dest, 1 ) + 1;
@@ -1044,3 +1270,1671 @@ NTSTATUS WINAPI RtlDeleteTimer(HANDLE TimerQueue, HANDLE Timer,
 
     return status;
 }
+
+static NTSTATUS tp_timerqueue_acquire( struct threadpool_object *timer )
+{
+    NTSTATUS status = STATUS_SUCCESS;
+    assert( timer->type == TP_OBJECT_TYPE_TIMER );
+
+    timer->u.timer.timer_initialized    = TRUE;
+    timer->u.timer.timer_pending        = FALSE;
+    memset( &timer->u.timer.timer_entry, 0, sizeof(timer->u.timer.timer_entry) );
+    timer->u.timer.timer_set            = FALSE;
+    timer->u.timer.timeout              = 0;
+    timer->u.timer.period               = 0;
+    timer->u.timer.window_length        = 0;
+
+    RtlEnterCriticalSection( &timerqueue.cs );
+
+    if (!timerqueue.thread_running)
+    {
+        HANDLE thread;
+        status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                      timerqueue_thread_proc, NULL, &thread, NULL );
+        if (status == STATUS_SUCCESS)
+        {
+            NtClose( thread );
+            timerqueue.thread_running = TRUE;
+        }
+    }
+
+    if (!status) timerqueue.num_timers++;
+    RtlLeaveCriticalSection( &timerqueue.cs );
+    return status;
+}
+
+static void tp_timerqueue_release( struct threadpool_object *timer )
+{
+    assert( timer->type == TP_OBJECT_TYPE_TIMER );
+    RtlEnterCriticalSection( &timerqueue.cs );
+    if (timer->u.timer.timer_initialized)
+    {
+
+        if (timer->u.timer.timer_pending)
+        {
+            list_remove( &timer->u.timer.timer_entry );
+            timer->u.timer.timer_pending = FALSE;
+        }
+
+        if (!--timerqueue.num_timers)
+        {
+            assert( list_empty( &timerqueue.pending_timers ) );
+            RtlWakeAllConditionVariable( &timerqueue.update_event );
+        }
+
+        timer->u.timer.timer_initialized = FALSE;
+    }
+    RtlLeaveCriticalSection( &timerqueue.cs );
+}
+
+static void tp_timerqueue_update_timer( struct threadpool_object *new_timer, LARGE_INTEGER *timeout,
+                                        LONG period, LONG window_length )
+{
+    BOOL submit_timer = FALSE;
+    struct threadpool_object *timer;
+    ULONGLONG when;
+
+    assert( new_timer->type == TP_OBJECT_TYPE_TIMER );
+    RtlEnterCriticalSection( &timerqueue.cs );
+    assert( new_timer->u.timer.timer_initialized );
+
+    /* Remember if the timer is set or unset */
+    new_timer->u.timer.timer_set = timeout != NULL;
+
+    if (timeout)
+    {
+        when = timeout->QuadPart;
+
+        /* A timeout of zero means that the timer should be submitted immediately */
+        if (when == 0)
+        {
+            submit_timer = TRUE;
+            if (!period)
+            {
+                timeout = NULL;
+                goto update_timer;
+            }
+            when = (ULONGLONG)period * -10000;
+        }
+
+        /* Convert relative timeout to absolute */
+        if ((LONGLONG)when < 0)
+        {
+            LARGE_INTEGER now;
+            NtQuerySystemTime( &now );
+            when = now.QuadPart - when;
+        }
+    }
+
+update_timer:
+
+    /* If timer is still pending, then remove the old one */
+    if (new_timer->u.timer.timer_pending)
+    {
+        list_remove( &new_timer->u.timer.timer_entry );
+        memset( &new_timer->u.timer.timer_entry, 0, sizeof(new_timer->u.timer.timer_entry) );
+        new_timer->u.timer.timer_pending = FALSE;
+    }
+
+    /* Timer should be enabled again, add it to the queue */
+    if (timeout)
+    {
+        new_timer->u.timer.timeout       = when;
+        new_timer->u.timer.period        = period;
+        new_timer->u.timer.window_length = window_length;
+
+        /* insert new_timer into the timer queue */
+        LIST_FOR_EACH_ENTRY( timer, &timerqueue.pending_timers, struct threadpool_object, u.timer.timer_entry )
+        {
+            assert( timer->type == TP_OBJECT_TYPE_TIMER );
+            if (new_timer->u.timer.timeout < timer->u.timer.timeout)
+                break;
+        }
+        list_add_before( &timer->u.timer.timer_entry, &new_timer->u.timer.timer_entry );
+
+        /* wake up thread if it should expire earlier than before */
+        if (list_head( &timerqueue.pending_timers ) == &new_timer->u.timer.timer_entry )
+            RtlWakeAllConditionVariable( &timerqueue.update_event );
+
+        new_timer->u.timer.timer_pending = TRUE;
+    }
+
+    RtlLeaveCriticalSection( &timerqueue.cs );
+
+    if (submit_timer)
+       tp_object_submit( new_timer, FALSE );
+}
+
+static void CALLBACK timerqueue_thread_proc( void *param )
+{
+    LARGE_INTEGER now, timeout;
+    ULONGLONG timeout_lower, timeout_upper;
+    struct threadpool_object *other_timer;
+    struct list *ptr;
+
+    RtlEnterCriticalSection( &timerqueue.cs );
+
+    for (;;)
+    {
+        NtQuerySystemTime( &now );
+
+        while ((ptr = list_head( &timerqueue.pending_timers )))
+        {
+            struct threadpool_object *timer = LIST_ENTRY( ptr, struct threadpool_object, u.timer.timer_entry );
+            assert( timer->type == TP_OBJECT_TYPE_TIMER );
+
+            /* Timeout didn't expire yet, nothing to do */
+            if (timer->u.timer.timeout > now.QuadPart)
+                break;
+
+            /* Queue a new callback in one of the worker threads */
+            list_remove( &timer->u.timer.timer_entry );
+            tp_object_submit( timer, FALSE );
+
+            /* Requeue the timer, except its marked for shutdown */
+            if (!timer->shutdown && timer->u.timer.period)
+            {
+                /* Update the timeout, make sure its at least the current time (to avoid too many work items) */
+                timer->u.timer.timeout += (ULONGLONG)timer->u.timer.period * 10000;
+                if (timer->u.timer.timeout <= now.QuadPart)
+                    timer->u.timer.timeout = now.QuadPart + 1;
+
+                /* Insert timer back into the timer queue */
+                LIST_FOR_EACH_ENTRY( other_timer, &timerqueue.pending_timers, struct threadpool_object, u.timer.timer_entry )
+                {
+                    assert( other_timer->type == TP_OBJECT_TYPE_TIMER );
+                    if (timer->u.timer.timeout < other_timer->u.timer.timeout)
+                        break;
+                }
+                list_add_before( &other_timer->u.timer.timer_entry, &timer->u.timer.timer_entry );
+            }
+            else
+            {
+                /* The element is no longer queued */
+                timer->u.timer.timer_pending = FALSE;
+            }
+        }
+
+        /* Determine next timeout - we use the window_length arguments to optimize wakeup times */
+        timeout_lower = timeout_upper = TIMEOUT_INFINITE;
+        LIST_FOR_EACH_ENTRY( other_timer, &timerqueue.pending_timers, struct threadpool_object, u.timer.timer_entry )
+        {
+            ULONGLONG new_timeout_upper;
+            assert( other_timer->type == TP_OBJECT_TYPE_TIMER );
+            if (other_timer->u.timer.timeout >= timeout_upper)
+                break;
+
+            timeout_lower     = other_timer->u.timer.timeout;
+            new_timeout_upper = timeout_lower + (ULONGLONG)other_timer->u.timer.window_length * 10000;
+
+            if (timeout_upper > new_timeout_upper)
+                timeout_upper = new_timeout_upper;
+        }
+
+
+        if (!timerqueue.num_timers)
+        {
+            /* All timers have been destroyed, if no new timers are created within some amount of
+             * time, then we can shutdown this thread. */
+            timeout.QuadPart = (ULONGLONG)THREADPOOL_WORKER_TIMEOUT * -10000;
+            if (RtlSleepConditionVariableCS( &timerqueue.update_event,
+                &timerqueue.cs, &timeout ) == STATUS_TIMEOUT && !timerqueue.num_timers)
+            {
+                break;
+            }
+        }
+        else
+        {
+            /* Wait for timer update events or until the next timer expires. */
+            timeout.QuadPart = timeout_lower;
+            RtlSleepConditionVariableCS( &timerqueue.update_event, &timerqueue.cs, &timeout );
+        }
+    }
+
+    timerqueue.thread_running = FALSE;
+    RtlLeaveCriticalSection( &timerqueue.cs );
+}
+
+static NTSTATUS tp_waitqueue_acquire( struct threadpool_object *wait )
+{
+    struct waitqueue_bucket *bucket;
+    NTSTATUS status;
+    HANDLE thread;
+    assert( wait->type = TP_OBJECT_TYPE_WAIT );
+
+    wait->u.wait.signaled       = 0;
+    wait->u.wait.bucket         = NULL;
+    wait->u.wait.wait_pending   = FALSE;
+    memset( &wait->u.wait.wait_entry, 0, sizeof(wait->u.wait.wait_entry) );
+    wait->u.wait.timeout        = 0;
+    wait->u.wait.handle         = INVALID_HANDLE_VALUE;
+
+    RtlEnterCriticalSection( &waitqueue.cs );
+
+    LIST_FOR_EACH_ENTRY( bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
+    {
+        if (bucket->num_waits < MAXIMUM_WAITQUEUE_OBJECTS)
+        {
+            bucket->num_waits++;
+            wait->u.wait.bucket = bucket;
+            list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+
+            status = STATUS_SUCCESS;
+            goto out;
+        }
+    }
+
+    bucket = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*bucket) );
+    if (!bucket)
+    {
+        status = STATUS_NO_MEMORY;
+        goto out;
+    }
+
+    bucket->num_waits = 1;
+    list_init( &bucket->reserved );
+    list_init( &bucket->waits );
+
+    status = NtCreateEvent( &bucket->update_event, EVENT_ALL_ACCESS, NULL, SynchronizationEvent, FALSE );
+    if (status)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, bucket );
+        goto out;
+    }
+
+    status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                  waitqueue_thread_proc, bucket, &thread, NULL );
+    if (status == STATUS_SUCCESS)
+    {
+        waitqueue.num_buckets++;
+        list_add_tail( &waitqueue.buckets, &bucket->bucket_entry );
+
+        wait->u.wait.bucket = bucket;
+        list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+
+        NtClose( thread );
+    }
+    else
+    {
+        NtClose( bucket->update_event );
+        RtlFreeHeap( GetProcessHeap(), 0, bucket );
+    }
+
+out:
+    RtlLeaveCriticalSection( &waitqueue.cs );
+    return status;
+}
+
+/* Decrement the refcount of a timer queue. */
+static void tp_waitqueue_release( struct threadpool_object *wait )
+{
+    assert( wait->type == TP_OBJECT_TYPE_WAIT );
+    RtlEnterCriticalSection( &waitqueue.cs );
+
+    if (wait->u.wait.bucket)
+    {
+        struct waitqueue_bucket *bucket = wait->u.wait.bucket;
+        assert( bucket->num_waits > 0 );
+
+        bucket->num_waits--;
+        list_remove( &wait->u.wait.wait_entry );
+        NtSetEvent( bucket->update_event, NULL );
+
+        wait->u.wait.bucket = NULL;
+    }
+
+    RtlLeaveCriticalSection( &waitqueue.cs );
+}
+
+static void tp_waitqueue_update_wait( struct threadpool_object *new_wait, HANDLE handle, LARGE_INTEGER *timeout )
+{
+    BOOL submit_wait = FALSE;
+
+    assert( new_wait->type == TP_OBJECT_TYPE_WAIT );
+    RtlEnterCriticalSection( &waitqueue.cs );
+    assert( new_wait->u.wait.bucket );
+
+    /* update wait handle */
+    new_wait->u.wait.handle = handle;
+
+    /* for performance reasons we only wake up when something has changed */
+    if (handle || new_wait->u.wait.wait_pending)
+    {
+        struct waitqueue_bucket *bucket = new_wait->u.wait.bucket;
+        list_remove( &new_wait->u.wait.wait_entry );
+
+        if (handle)
+        {
+            ULONGLONG when = TIMEOUT_INFINITE;
+
+            if (timeout)
+            {
+                when = timeout->QuadPart;
+
+                /* A timeout of zero means that the wait should be submitted immediately */
+                if (when == 0)
+                {
+                    submit_wait = TRUE;
+                    goto remove_wait;
+                }
+
+                /* Convert relative timeout to absolute */
+                if ((LONGLONG)when < 0)
+                {
+                    LARGE_INTEGER now;
+                    NtQuerySystemTime( &now );
+                    when = now.QuadPart - when;
+                }
+            }
+
+            list_add_tail( &bucket->waits, &new_wait->u.wait.wait_entry );
+            new_wait->u.wait.wait_pending = TRUE;
+            new_wait->u.wait.timeout = when;
+        }
+        else
+        {
+remove_wait:
+            list_add_tail( &bucket->reserved, &new_wait->u.wait.wait_entry );
+            new_wait->u.wait.wait_pending = FALSE;
+        }
+
+        NtSetEvent( bucket->update_event, NULL );
+    }
+
+    RtlLeaveCriticalSection( &waitqueue.cs );
+
+    if (submit_wait)
+        tp_object_submit( new_wait, FALSE );
+}
+
+static void CALLBACK waitqueue_thread_proc( void *param )
+{
+    HANDLE handles[MAXIMUM_WAITQUEUE_OBJECTS + 1];
+    struct threadpool_object *objects[MAXIMUM_WAITQUEUE_OBJECTS];
+    struct waitqueue_bucket *bucket = param;
+    LARGE_INTEGER now, timeout;
+    struct threadpool_object *wait, *next;
+    DWORD num_handles;
+    NTSTATUS status;
+
+    RtlEnterCriticalSection( &waitqueue.cs );
+
+    for (;;)
+    {
+        NtQuerySystemTime( &now );
+        timeout.QuadPart = TIMEOUT_INFINITE;
+        num_handles = 0;
+
+        LIST_FOR_EACH_ENTRY_SAFE( wait, next, &bucket->waits, struct threadpool_object, u.wait.wait_entry )
+        {
+            assert( wait->type == TP_OBJECT_TYPE_WAIT );
+
+            /* Timeout expired or object was signaled */
+            if (wait->u.wait.timeout <= now.QuadPart)
+            {
+                list_remove( &wait->u.wait.wait_entry );
+                list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                tp_object_submit( wait, FALSE );
+            }
+            else
+            {
+                if (wait->u.wait.timeout < timeout.QuadPart)
+                    timeout.QuadPart = wait->u.wait.timeout;
+
+                /* We will have to wait for this object - keep a reference to make sure it doesn't get destroyed */
+                assert( num_handles < MAXIMUM_WAITQUEUE_OBJECTS );
+                interlocked_inc( &wait->refcount );
+                objects[num_handles] = wait;
+                handles[num_handles] = wait->u.wait.handle;
+                num_handles++;
+            }
+        }
+
+        if (!bucket->num_waits)
+        {
+            assert( num_handles == 0 );
+
+            /* All wait objects have been destroyed, if there are no new wait objects within some
+             * amount of time, then we can shutdown this thread. */
+            RtlLeaveCriticalSection( &waitqueue.cs );
+            timeout.QuadPart = (ULONGLONG)THREADPOOL_WORKER_TIMEOUT * -10000;
+            status = NtWaitForMultipleObjects( 1, &bucket->update_event, TRUE, FALSE, &timeout );
+            RtlEnterCriticalSection( &waitqueue.cs );
+
+            if (status == STATUS_TIMEOUT && !bucket->num_waits)
+                break;
+        }
+        else
+        {
+            handles[num_handles] = bucket->update_event;
+
+            /* Wait for a wait queue update event or until an event is triggered */
+            RtlLeaveCriticalSection( &waitqueue.cs );
+            status = NtWaitForMultipleObjects( num_handles + 1, handles, TRUE, FALSE, &timeout );
+            RtlEnterCriticalSection( &waitqueue.cs );
+
+            if (status >= STATUS_WAIT_0 && status < STATUS_WAIT_0 + num_handles)
+            {
+                wait = objects[status - STATUS_WAIT_0];
+                assert( wait->type == TP_OBJECT_TYPE_WAIT );
+
+                if (wait->u.wait.bucket)
+                {
+                    assert( wait->u.wait.bucket == bucket );
+                    list_remove( &wait->u.wait.wait_entry );
+                    list_add_tail( &bucket->reserved, &wait->u.wait.wait_entry );
+                    tp_object_submit( wait, TRUE );
+                }
+                else
+                    FIXME("Wait object triggered while object was destroyed, race-condition.\n");
+            }
+
+            while (num_handles)
+            {
+                wait = objects[--num_handles];
+                assert( wait->type == TP_OBJECT_TYPE_WAIT );
+                tp_object_release( wait );
+            }
+        }
+
+        /* Try to merge with other buckets */
+        if (waitqueue.num_buckets > 1 && bucket->num_waits && bucket->num_waits < MAXIMUM_WAITQUEUE_OBJECTS / 2)
+        {
+            struct waitqueue_bucket *other_bucket;
+            LIST_FOR_EACH_ENTRY( other_bucket, &waitqueue.buckets, struct waitqueue_bucket, bucket_entry )
+            {
+                if (other_bucket != bucket && other_bucket->num_waits &&
+                    other_bucket->num_waits + bucket->num_waits <= MAXIMUM_WAITQUEUE_OBJECTS)
+                {
+                    other_bucket->num_waits += bucket->num_waits;
+                    bucket->num_waits = 0;
+
+                    LIST_FOR_EACH_ENTRY( wait, &bucket->reserved, struct threadpool_object, u.wait.wait_entry )
+                    {
+                        assert( wait->type == TP_OBJECT_TYPE_WAIT );
+                        wait->u.wait.bucket = other_bucket;
+                    }
+                    list_move_tail( &other_bucket->reserved, &bucket->reserved );
+
+                    LIST_FOR_EACH_ENTRY( wait, &bucket->waits, struct threadpool_object, u.wait.wait_entry )
+                    {
+                        assert( wait->type == TP_OBJECT_TYPE_WAIT );
+                        wait->u.wait.bucket = other_bucket;
+                    }
+                    list_move_tail( &other_bucket->waits, &bucket->waits );
+
+                    /* we will not terminate immediately, but instead after a timeout. Make sure that this
+                     * bucket appears as the last one in the list, otherwise there is a high risk that
+                     * elements will be added again. */
+                    list_remove( &bucket->bucket_entry );
+                    list_add_tail( &waitqueue.buckets, &bucket->bucket_entry );
+
+                    NtSetEvent( other_bucket->update_event, NULL );
+                    break;
+                }
+            }
+        }
+    }
+
+    waitqueue.num_buckets--;
+    list_remove( &bucket->bucket_entry );
+    if (!waitqueue.num_buckets)
+        assert( list_empty( &waitqueue.buckets ) );
+    RtlLeaveCriticalSection( &waitqueue.cs );
+
+    assert( bucket->num_waits == 0 );
+    assert( list_empty( &bucket->reserved ) );
+    assert( list_empty( &bucket->waits ) );
+
+    NtClose( bucket->update_event );
+    RtlFreeHeap( GetProcessHeap(), 0, bucket );
+}
+
+/* allocate a new threadpool (with at least one worker thread) */
+static NTSTATUS tp_threadpool_alloc( struct threadpool **out )
+{
+    struct threadpool *pool;
+    NTSTATUS status;
+    HANDLE thread;
+
+    pool = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*pool) );
+    if (!pool)
+        return STATUS_NO_MEMORY;
+
+    pool->refcount              = 2; /* this thread + worker proc */
+    pool->shutdown              = FALSE;
+
+    RtlInitializeCriticalSection( &pool->cs );
+    pool->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": threadpool.cs");
+
+    list_init( &pool->pool );
+    RtlInitializeConditionVariable( &pool->update_event );
+
+    pool->max_workers           = 500;
+    pool->min_workers           = 1;
+    pool->num_workers           = 1;
+    pool->num_busy_workers      = 0;
+
+    status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                  threadpool_worker_proc, pool, &thread, NULL );
+    if (status != STATUS_SUCCESS)
+    {
+        pool->cs.DebugInfo->Spare[0] = 0;
+        RtlDeleteCriticalSection( &pool->cs );
+        RtlFreeHeap( GetProcessHeap(), 0, pool );
+        return status;
+    }
+    NtClose( thread );
+
+    TRACE("allocated threadpool %p\n", pool);
+
+    *out = pool;
+    return STATUS_SUCCESS;
+}
+
+/* shutdown all threads of the threadpool */
+static void tp_threadpool_shutdown( struct threadpool *pool )
+{
+    assert( pool != default_threadpool );
+
+    pool->shutdown = TRUE;
+    RtlWakeAllConditionVariable( &pool->update_event );
+}
+
+/* release a reference to a threadpool */
+static BOOL tp_threadpool_release( struct threadpool *pool )
+{
+    if (interlocked_dec( &pool->refcount ))
+        return FALSE;
+
+    TRACE("destroying threadpool %p\n", pool);
+
+    assert( pool->shutdown );
+    assert( list_empty( &pool->pool ) );
+
+    pool->cs.DebugInfo->Spare[0] = 0;
+    RtlDeleteCriticalSection( &pool->cs );
+
+    RtlFreeHeap( GetProcessHeap(), 0, pool );
+    return TRUE;
+}
+
+/* returns the threadpool based on the environment structure */
+static struct threadpool *get_threadpool( TP_CALLBACK_ENVIRON *environment )
+{
+    struct threadpool *pool;
+
+    if (environment)
+    {
+        pool = (struct threadpool *)environment->Pool;
+        if (pool) return pool;
+    }
+
+    if (!default_threadpool)
+    {
+        if (tp_threadpool_alloc( &pool ) != STATUS_SUCCESS)
+            return NULL;
+
+        if (interlocked_cmpxchg_ptr( (void *)&default_threadpool, pool, NULL ) != NULL)
+        {
+            tp_threadpool_shutdown( pool );
+            tp_threadpool_release( pool );
+        }
+    }
+
+    return default_threadpool;
+}
+
+/* allocates a new cleanup group */
+static NTSTATUS tp_group_alloc( struct threadpool_group **out )
+{
+    struct threadpool_group *group;
+
+    group = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*group) );
+    if (!group)
+        return STATUS_NO_MEMORY;
+
+    group->refcount     = 1;
+    group->shutdown     = FALSE;
+
+    RtlInitializeCriticalSection( &group->cs );
+    group->cs.DebugInfo->Spare[0] = (DWORD_PTR)(__FILE__ ": threadpool_group.cs");
+
+    list_init( &group->members );
+
+    TRACE("allocated group %p\n", group);
+
+    *out = group;
+    return STATUS_SUCCESS;
+}
+
+/* marks a cleanup group for shutdown */
+static void tp_group_shutdown( struct threadpool_group *group )
+{
+    group->shutdown = TRUE;
+}
+
+/* releases a reference to a cleanup group */
+static BOOL tp_group_release( struct threadpool_group *group )
+{
+    if (interlocked_dec( &group->refcount ))
+        return FALSE;
+
+    TRACE("destroying group %p\n", group);
+
+    assert( group->shutdown );
+    assert( list_empty( &group->members ) );
+
+    group->cs.DebugInfo->Spare[0] = 0;
+    RtlDeleteCriticalSection( &group->cs );
+
+    RtlFreeHeap( GetProcessHeap(), 0, group );
+    return TRUE;
+}
+
+/* initializes a new threadpool object */
+static void tp_object_initialize( struct threadpool_object *object, struct threadpool *pool,
+                                  PVOID userdata, TP_CALLBACK_ENVIRON *environment )
+{
+    BOOL simple_cb = (object->type == TP_OBJECT_TYPE_SIMPLE);
+
+    object->refcount                = 1;
+    object->shutdown                = FALSE;
+
+    object->pool                    = pool;
+    object->group                   = NULL;
+    object->userdata                = userdata;
+    object->group_cancel_callback   = NULL;
+    object->finalization_callback   = NULL;
+    object->may_run_long            = 0;
+    object->race_dll                = NULL;
+
+    memset( &object->group_entry, 0, sizeof(object->group_entry) );
+    object->is_group_member         = FALSE;
+
+    memset( &object->pool_entry, 0, sizeof(object->pool_entry) );
+    RtlInitializeConditionVariable( &object->finished_event );
+    object->num_pending_callbacks   = 0;
+    object->num_running_callbacks   = 0;
+
+    if (environment)
+    {
+        if (environment->Version != 1)
+            FIXME("unsupported environment version %u\n", environment->Version);
+
+        object->group = impl_from_TP_CLEANUP_GROUP( environment->CleanupGroup );
+        object->group_cancel_callback   = environment->CleanupGroupCancelCallback;
+        object->finalization_callback   = environment->FinalizationCallback;
+        object->may_run_long            = environment->u.s.LongFunction != 0;
+        object->race_dll                = environment->RaceDll;
+
+        if (environment->ActivationContext)
+            FIXME("activation context not supported yet\n");
+
+        if (environment->u.s.Persistent)
+            FIXME("persistent thread support not supported yet\n");
+    }
+
+    /* Increase dll refcount */
+    if (object->race_dll)
+        LdrAddRefDll( 0, object->race_dll );
+
+    /* Increase reference-count on the pool */
+    interlocked_inc( &pool->refcount );
+
+    TRACE("allocated object %p of type %u\n", object, object->type);
+
+    /* For simple callbacks we have to run tp_object_submit before adding this object
+     * to the cleanup group. As soon as the cleanup group members are released ->shutdown
+     * will be set, and tp_object_submit would fail with an assertion. */
+    if (simple_cb)
+        tp_object_submit( object, FALSE );
+
+    if (object->group)
+    {
+        struct threadpool_group *group = object->group;
+        interlocked_inc( &group->refcount );
+
+        RtlEnterCriticalSection( &group->cs );
+        list_add_tail( &group->members, &object->group_entry );
+        object->is_group_member = TRUE;
+        RtlLeaveCriticalSection( &group->cs );
+    }
+
+    if (simple_cb)
+    {
+        tp_object_shutdown( object );
+        tp_object_release( object );
+    }
+}
+
+/* submits an object to a threadpool */
+static void tp_object_submit( struct threadpool_object *object, BOOL success )
+{
+    struct threadpool *pool = object->pool;
+
+    assert( !object->shutdown );
+    assert( !pool->shutdown );
+
+    RtlEnterCriticalSection( &pool->cs );
+
+    /* Start new worker threads if required (and allowed) */
+    if (pool->num_busy_workers >= pool->num_workers && pool->num_workers < pool->max_workers)
+    {
+        NTSTATUS status;
+        HANDLE thread;
+
+        status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                      threadpool_worker_proc, pool, &thread, NULL );
+        if (status == STATUS_SUCCESS)
+        {
+            interlocked_inc( &pool->refcount );
+            pool->num_workers++;
+            NtClose( thread );
+            goto out;
+        }
+    }
+
+    assert( pool->num_workers > 0 );
+    RtlWakeConditionVariable( &pool->update_event );
+
+out:
+    /* Queue work item into pool and increment refcount */
+    interlocked_inc( &object->refcount );
+    if (!object->num_pending_callbacks++)
+        list_add_tail( &pool->pool, &object->pool_entry );
+
+    /* increment success counter by one */
+    if (object->type == TP_OBJECT_TYPE_WAIT && success)
+        object->u.wait.signaled++;
+
+    RtlLeaveCriticalSection( &pool->cs );
+}
+
+static void tp_object_cancel( struct threadpool_object *object, BOOL group_cancel, PVOID userdata )
+{
+    struct threadpool *pool = object->pool;
+    LONG pending_callbacks = 0;
+
+    RtlEnterCriticalSection( &pool->cs );
+
+    /* Remove the pending callbacks from the pool */
+    if (object->num_pending_callbacks)
+    {
+        pending_callbacks = object->num_pending_callbacks;
+        object->num_pending_callbacks = 0;
+        list_remove( &object->pool_entry );
+    }
+
+    if (object->type == TP_OBJECT_TYPE_WAIT)
+        object->u.wait.signaled = 0;
+
+    RtlLeaveCriticalSection( &pool->cs );
+
+    /* Execute group cancellation callback if defined, and if this was actually a group cancel. */
+    if (pending_callbacks && group_cancel && object->group_cancel_callback)
+    {
+        TRACE( "executing group cancel callback %p(%p, %p)\n", object->group_cancel_callback, object, userdata );
+        object->group_cancel_callback( object, userdata );
+        TRACE( "callback %p returned\n", object->group_cancel_callback );
+    }
+
+    /* Release references */
+    while (pending_callbacks--)
+        tp_object_release( object );
+}
+
+static void tp_object_wait( struct threadpool_object *object )
+{
+    struct threadpool *pool = object->pool;
+
+    RtlEnterCriticalSection( &pool->cs );
+
+    /* Wait until there are no longer pending or running callbacks */
+    while (object->num_pending_callbacks || object->num_running_callbacks)
+        RtlSleepConditionVariableCS( &object->finished_event, &pool->cs, NULL );
+
+    RtlLeaveCriticalSection( &pool->cs );
+}
+
+/* mark an object as 'shutdown', submitting is no longer possible */
+static void tp_object_shutdown( struct threadpool_object *object )
+{
+    if (object->type == TP_OBJECT_TYPE_TIMER)
+        tp_timerqueue_release( object );
+    else if (object->type == TP_OBJECT_TYPE_WAIT)
+        tp_waitqueue_release( object );
+
+    object->shutdown = TRUE;
+}
+
+/* release a reference to a threadpool object */
+static BOOL tp_object_release( struct threadpool_object *object )
+{
+    if (interlocked_dec( &object->refcount ))
+        return FALSE;
+
+    TRACE("destroying object %p of type %u\n", object, object->type);
+
+    assert( object->shutdown );
+    assert( !object->num_pending_callbacks );
+    assert( !object->num_running_callbacks );
+
+    /* release reference to the group */
+    if (object->group)
+    {
+        struct threadpool_group *group = object->group;
+
+        RtlEnterCriticalSection( &group->cs );
+        if (object->is_group_member)
+        {
+            list_remove( &object->group_entry );
+            object->is_group_member = FALSE;
+        }
+        RtlLeaveCriticalSection( &group->cs );
+
+        tp_group_release( group );
+    }
+
+    /* release reference to threadpool */
+    tp_threadpool_release( object->pool );
+
+    /* release reference to library */
+    if (object->race_dll)
+        LdrUnloadDll( object->race_dll );
+
+    RtlFreeHeap( GetProcessHeap(), 0, object );
+    return TRUE;
+}
+
+/* initializes a threadpool instance structure */
+static void tp_instance_initialize( struct threadpool_instance *instance, struct threadpool_object *object )
+{
+    instance->object                    = object;
+    instance->threadid                  = GetCurrentThreadId();
+    instance->disassociated             = FALSE;
+    instance->may_run_long              = object->may_run_long;
+    instance->cleanup.critical_section  = NULL;
+    instance->cleanup.mutex             = NULL;
+    instance->cleanup.semaphore         = NULL;
+    instance->cleanup.semaphore_count   = 0;
+    instance->cleanup.event             = NULL;
+    instance->cleanup.library           = NULL;
+}
+
+static NTSTATUS tp_instance_cleanup( struct threadpool_instance *instance )
+{
+    NTSTATUS status;
+
+    if (instance->cleanup.critical_section)
+    {
+        RtlLeaveCriticalSection( instance->cleanup.critical_section );
+    }
+    if (instance->cleanup.mutex)
+    {
+        status = NtReleaseMutant( instance->cleanup.mutex, NULL );
+        if (status != STATUS_SUCCESS)
+            return status;
+    }
+    if (instance->cleanup.semaphore)
+    {
+        status = NtReleaseSemaphore( instance->cleanup.semaphore, instance->cleanup.semaphore_count, NULL );
+        if (status != STATUS_SUCCESS)
+            return status;
+    }
+    if (instance->cleanup.event)
+    {
+        status = NtSetEvent( instance->cleanup.event, NULL );
+        if (status != STATUS_SUCCESS)
+            return status;
+    }
+    if (instance->cleanup.library)
+    {
+        status = LdrUnloadDll( instance->cleanup.library );
+        if (status != STATUS_SUCCESS)
+            return status;
+    }
+
+    return STATUS_SUCCESS;
+ }
+
+/* disassociates the current thread from the threadpool object */
+static void tp_instance_disassociate_thread( struct threadpool_instance *instance )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+
+    if (instance->threadid != GetCurrentThreadId())
+    {
+        ERR("called from wrong thread, ignoring\n");
+        return;
+    }
+
+    if (instance->disassociated)
+        return;
+
+    object = instance->object;
+    pool   = object->pool;
+    RtlEnterCriticalSection( &pool->cs );
+
+    object->num_running_callbacks--;
+    if (!object->num_pending_callbacks && !object->num_running_callbacks)
+        RtlWakeAllConditionVariable( &object->finished_event );
+
+    RtlLeaveCriticalSection( &pool->cs );
+    instance->disassociated = TRUE;
+}
+
+/* hint for the threadpool that the execution might take long, spawn additional workers */
+static BOOL tp_instance_may_run_long( struct threadpool_instance *instance )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+    NTSTATUS status = STATUS_SUCCESS;
+
+    if (instance->threadid != GetCurrentThreadId())
+    {
+        ERR("called from wrong thread, ignoring\n");
+        return FALSE;
+    }
+
+    if (instance->may_run_long)
+        return TRUE;
+
+    object = instance->object;
+    pool   = object->pool;
+    RtlEnterCriticalSection( &pool->cs );
+
+    if (pool->num_busy_workers >= pool->num_workers && pool->num_workers < pool->max_workers)
+    {
+        HANDLE thread;
+        status = RtlCreateUserThread( GetCurrentProcess(), NULL, FALSE, NULL, 0, 0,
+                                      threadpool_worker_proc, pool, &thread, NULL );
+        if (status == STATUS_SUCCESS)
+        {
+            interlocked_inc( &pool->refcount );
+            pool->num_workers++;
+            NtClose( thread );
+        }
+    }
+
+    RtlLeaveCriticalSection( &pool->cs );
+    instance->may_run_long = TRUE;
+    return !status;
+}
+
+/* threadpool worker function */
+static void CALLBACK threadpool_worker_proc( void *param )
+{
+    struct threadpool_instance instance;
+    TP_CALLBACK_INSTANCE *cb_instance = (TP_CALLBACK_INSTANCE *)&instance;
+    struct threadpool *pool = param;
+    TP_WAIT_RESULT wait_result;
+    LARGE_INTEGER timeout;
+    struct list *ptr;
+
+    RtlEnterCriticalSection( &pool->cs );
+    for (;;)
+    {
+        while ((ptr = list_head( &pool->pool )))
+        {
+            struct threadpool_object *object = LIST_ENTRY( ptr, struct threadpool_object, pool_entry );
+            assert( object->num_pending_callbacks > 0 );
+
+            /* If further pending callbacks are queued, move the work item to
+             * the end of the pool list. Otherwise remove it from the pool. */
+            list_remove( &object->pool_entry );
+            if (--object->num_pending_callbacks)
+                list_add_tail( &pool->pool, &object->pool_entry );
+
+            /* for wait objects, determine if the object was signaled or if this
+             * is a timeout. */
+            if (object->type == TP_OBJECT_TYPE_WAIT)
+            {
+                if (object->u.wait.signaled > 0)
+                {
+                    wait_result = WAIT_OBJECT_0;
+                    object->u.wait.signaled--;
+                }
+                else wait_result = WAIT_TIMEOUT;
+            }
+
+            /* Leave critical section and do the actual callback. */
+            object->num_running_callbacks++;
+            pool->num_busy_workers++;
+            RtlLeaveCriticalSection( &pool->cs );
+            tp_instance_initialize( &instance, object );
+
+            switch (object->type)
+            {
+                case TP_OBJECT_TYPE_SIMPLE:
+                {
+                    TRACE( "executing simple callback %p(%p, %p)\n",
+                           object->u.simple.callback, cb_instance, object->userdata );
+                    object->u.simple.callback( cb_instance, object->userdata );
+                    TRACE( "callback %p returned\n", object->u.simple.callback );
+                    break;
+                }
+
+                case TP_OBJECT_TYPE_WORK:
+                {
+                    TRACE( "executing work callback %p(%p, %p, %p)\n",
+                           object->u.work.callback, cb_instance, object->userdata, object );
+                    object->u.work.callback( cb_instance, object->userdata, (TP_WORK *)object );
+                    TRACE( "callback %p returned\n", object->u.work.callback );
+                    break;
+                }
+
+                case TP_OBJECT_TYPE_TIMER:
+                {
+                    TRACE( "executing timer callback %p(%p, %p, %p)\n",
+                           object->u.timer.callback, cb_instance, object->userdata, object );
+                    object->u.timer.callback( cb_instance, object->userdata, (TP_TIMER *)object );
+                    TRACE( "callback %p returned\n", object->u.timer.callback );
+                    break;
+                }
+
+                case TP_OBJECT_TYPE_WAIT:
+                {
+                    TRACE( "executing wait callback %p(%p, %p, %p, %u)\n",
+                           object->u.wait.callback, cb_instance, object->userdata, object, wait_result );
+                    object->u.wait.callback( cb_instance, object->userdata, (TP_WAIT *)object, wait_result );
+                    TRACE( "callback %p returned\n", object->u.wait.callback );
+                    break;
+                }
+
+                default:
+                    assert(0);
+                    break;
+            }
+
+            /* Execute finalization callback */
+            if (object->finalization_callback)
+            {
+                TRACE( "executing finalization callback %p(%p, %p)\n",
+                       object->finalization_callback, cb_instance, object->userdata );
+                object->finalization_callback( cb_instance, object->userdata );
+                TRACE( "callback %p returned\n", object->finalization_callback );
+            }
+
+            tp_instance_cleanup( &instance );
+            RtlEnterCriticalSection( &pool->cs );
+            pool->num_busy_workers--;
+            if (!instance.disassociated)
+            {
+                object->num_running_callbacks--;
+                if (!object->num_pending_callbacks && !object->num_running_callbacks)
+                    RtlWakeAllConditionVariable( &object->finished_event );
+            }
+            tp_object_release( object );
+        }
+
+        /* Shutdown worker thread if requested. */
+        if (pool->shutdown)
+            break;
+
+        /* Wait for new tasks or until timeout expires. Never terminate the last worker. */
+        timeout.QuadPart = (ULONGLONG)THREADPOOL_WORKER_TIMEOUT * -10000;
+        if (RtlSleepConditionVariableCS( &pool->update_event, &pool->cs, &timeout ) == STATUS_TIMEOUT &&
+            !list_head( &pool->pool ) && pool->num_workers > 1)
+        {
+            break;
+        }
+    }
+    pool->num_workers--;
+    RtlLeaveCriticalSection( &pool->cs );
+    tp_threadpool_release( pool );
+}
+
+
+/***********************************************************************
+ *           TpAllocCleanupGroup    (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocCleanupGroup( TP_CLEANUP_GROUP **out )
+{
+    TRACE("%p\n", out);
+
+    if (!out)
+        return STATUS_ACCESS_VIOLATION;
+
+    return tp_group_alloc( (struct threadpool_group **)out );
+}
+
+/***********************************************************************
+ *           TpAllocPool    (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocPool( TP_POOL **out, PVOID reserved )
+{
+    TRACE("%p %p\n", out, reserved);
+
+    if (reserved)
+        FIXME("reserved argument is nonzero (%p)", reserved);
+
+    if (!out)
+        return STATUS_ACCESS_VIOLATION;
+
+    return tp_threadpool_alloc( (struct threadpool **)out );
+}
+
+/***********************************************************************
+ *           TpAllocTimer    (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocTimer( TP_TIMER **out, PTP_TIMER_CALLBACK callback, PVOID userdata,
+                              TP_CALLBACK_ENVIRON *environment )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+    NTSTATUS status;
+
+    TRACE("%p %p %p %p\n", out, callback, userdata, environment);
+
+    if (!(pool = get_threadpool( environment )))
+        return STATUS_NO_MEMORY;
+
+    object = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*object) );
+    if (!object)
+        return STATUS_NO_MEMORY;
+
+    object->type = TP_OBJECT_TYPE_TIMER;
+    object->u.timer.callback = callback;
+
+    status = tp_timerqueue_acquire( object );
+    if (status)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, object );
+        return status;
+    }
+
+    tp_object_initialize( object, pool, userdata, environment );
+
+    *out = (TP_TIMER *)object;
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           TpAllocWait     (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocWait( TP_WAIT **out, PTP_WAIT_CALLBACK callback, PVOID userdata,
+                             TP_CALLBACK_ENVIRON *environment )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+    NTSTATUS status;
+
+    TRACE("%p %p %p %p\n", out, callback, userdata, environment);
+
+    if (!(pool = get_threadpool( environment )))
+        return STATUS_NO_MEMORY;
+
+    object = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*object) );
+    if (!object)
+        return STATUS_NO_MEMORY;
+
+    object->type = TP_OBJECT_TYPE_WAIT;
+    object->u.wait.callback = callback;
+
+    status = tp_waitqueue_acquire( object );
+    if (status)
+    {
+        RtlFreeHeap( GetProcessHeap(), 0, object );
+        return status;
+    }
+
+    tp_object_initialize( object, pool, userdata, environment );
+
+    *out = (TP_WAIT *)object;
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           TpAllocWork    (NTDLL.@)
+ */
+NTSTATUS WINAPI TpAllocWork( TP_WORK **out, PTP_WORK_CALLBACK callback, PVOID userdata,
+                             TP_CALLBACK_ENVIRON *environment )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+
+    TRACE("%p %p %p %p\n", out, callback, userdata, environment);
+
+    if (!(pool = get_threadpool( environment )))
+        return STATUS_NO_MEMORY;
+
+    object = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*object) );
+    if (!object)
+        return STATUS_NO_MEMORY;
+
+    object->type = TP_OBJECT_TYPE_WORK;
+    object->u.work.callback = callback;
+    tp_object_initialize( object, pool, userdata, environment );
+
+    *out = (TP_WORK *)object;
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           TpCallbackLeaveCriticalSectionOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackLeaveCriticalSectionOnCompletion( TP_CALLBACK_INSTANCE *instance, CRITICAL_SECTION *crit )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p %p\n", instance, crit);
+
+    if (!this)
+        return;
+
+    if (this->cleanup.critical_section)
+    {
+        FIXME("attempt to set multiple cleanup critical sections\n");
+        return;
+    }
+
+    this->cleanup.critical_section = crit;
+}
+
+/***********************************************************************
+ *           TpCallbackMayRunLong    (NTDLL.@)
+ */
+NTSTATUS WINAPI TpCallbackMayRunLong( TP_CALLBACK_INSTANCE *instance )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p\n", instance);
+
+    if (!this)
+        return STATUS_ACCESS_VIOLATION;
+
+    return tp_instance_may_run_long( this );
+}
+
+/***********************************************************************
+ *           TpCallbackReleaseMutexOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackReleaseMutexOnCompletion( TP_CALLBACK_INSTANCE *instance, HANDLE mutex )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p %p\n", instance, mutex);
+
+    if (!this)
+        return;
+
+    if (this->cleanup.mutex)
+    {
+        FIXME("attempt to set multiple cleanup mutexes\n");
+        return;
+    }
+
+    this->cleanup.mutex = mutex;
+}
+
+/***********************************************************************
+ *           TpCallbackReleaseSemaphoreOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackReleaseSemaphoreOnCompletion( TP_CALLBACK_INSTANCE *instance, HANDLE semaphore, DWORD count )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p %p %u\n", instance, semaphore, count);
+
+    if (!this)
+        return;
+
+    if (this->cleanup.semaphore)
+    {
+        FIXME("attempt to set multiple cleanup semaphores\n");
+        return;
+    }
+
+    this->cleanup.semaphore = semaphore;
+    this->cleanup.semaphore_count = count;
+}
+
+/***********************************************************************
+ *           TpCallbackSetEventOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackSetEventOnCompletion( TP_CALLBACK_INSTANCE *instance, HANDLE event )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p %p\n", instance, event);
+
+    if (!this)
+        return;
+
+    if (this->cleanup.event)
+    {
+        FIXME("attempt to set multiple cleanup events\n");
+        return;
+    }
+
+    this->cleanup.event = event;
+}
+
+/***********************************************************************
+ *           TpCallbackUnloadDllOnCompletion    (NTDLL.@)
+ */
+VOID WINAPI TpCallbackUnloadDllOnCompletion( TP_CALLBACK_INSTANCE *instance, HMODULE module )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p %p\n", instance, module);
+
+    if (!this)
+        return;
+
+    if (this->cleanup.library)
+    {
+        FIXME("attempt to set multiple cleanup libraries\n");
+        return;
+    }
+
+    this->cleanup.library = module;
+}
+
+/***********************************************************************
+ *           TpDisassociateCallback    (NTDLL.@)
+ */
+VOID WINAPI TpDisassociateCallback( TP_CALLBACK_INSTANCE *instance )
+{
+    struct threadpool_instance *this = impl_from_TP_CALLBACK_INSTANCE( instance );
+    TRACE("%p\n", instance);
+
+    if (this)
+    {
+        tp_instance_disassociate_thread( this );
+    }
+}
+
+/***********************************************************************
+ *           TpIsTimerSet    (NTDLL.@)
+ */
+BOOL WINAPI TpIsTimerSet( TP_TIMER *timer )
+{
+    struct threadpool_object *this = impl_from_TP_TIMER( timer );
+    TRACE("%p\n", timer);
+
+    return this ? this->u.timer.timer_set : FALSE;
+}
+
+/***********************************************************************
+ *           TpPostWork    (NTDLL.@)
+ */
+VOID WINAPI TpPostWork( TP_WORK *work )
+{
+    struct threadpool_object *this = impl_from_TP_WORK( work );
+    TRACE("%p\n", work);
+
+    if (this)
+    {
+        tp_object_submit( this, FALSE );
+    }
+}
+
+/***********************************************************************
+ *           TpReleaseCleanupGroup    (NTDLL.@)
+ */
+VOID WINAPI TpReleaseCleanupGroup( TP_CLEANUP_GROUP *group )
+{
+    struct threadpool_group *this = impl_from_TP_CLEANUP_GROUP( group );
+    TRACE("%p\n", group);
+
+    if (this)
+    {
+        tp_group_shutdown( this );
+        tp_group_release( this );
+    }
+}
+
+/***********************************************************************
+ *           TpReleaseCleanupGroupMembers    (NTDLL.@)
+ */
+VOID WINAPI TpReleaseCleanupGroupMembers( TP_CLEANUP_GROUP *group, BOOL cancel_pending, PVOID userdata )
+{
+    struct threadpool_group *this = impl_from_TP_CLEANUP_GROUP( group );
+    struct threadpool_object *object, *next;
+    struct list members;
+
+    TRACE("%p %d %p\n", group, cancel_pending, userdata);
+
+    if (!this)
+        return;
+
+    RtlEnterCriticalSection( &this->cs );
+
+    /* Unset group, increase references, and mark objects for shutdown */
+    LIST_FOR_EACH_ENTRY_SAFE( object, next, &this->members, struct threadpool_object, group_entry )
+    {
+        assert( object->group == this );
+        assert( object->is_group_member );
+
+        /* Simple callbacks are very special. The user doesn't hold any reference, so
+         * they would be released too early. Add one additional temporary reference. */
+        if (object->type == TP_OBJECT_TYPE_SIMPLE)
+        {
+            if (interlocked_inc( &object->refcount ) == 1)
+            {
+                /* Object is basically already destroyed, but group reference
+                 * was not deleted yet. We can safely ignore this object. */
+                interlocked_dec( &object->refcount );
+                list_remove( &object->group_entry );
+                object->is_group_member = FALSE;
+                continue;
+            }
+        }
+
+        object->is_group_member = FALSE;
+        tp_object_shutdown( object );
+    }
+
+    /* Move members to a local list */
+    list_init( &members );
+    list_move_tail( &members, &this->members );
+
+    RtlLeaveCriticalSection( &this->cs );
+
+    /* Cancel pending callbacks if requested */
+    if (cancel_pending)
+    {
+        LIST_FOR_EACH_ENTRY( object, &members, struct threadpool_object, group_entry )
+        {
+            tp_object_cancel( object, TRUE, userdata );
+        }
+    }
+
+    /* Wait for remaining callbacks to finish */
+    LIST_FOR_EACH_ENTRY_SAFE( object, next, &members, struct threadpool_object, group_entry )
+    {
+        tp_object_wait( object );
+        tp_object_release( object );
+    }
+}
+
+/***********************************************************************
+ *           TpReleasePool    (NTDLL.@)
+ */
+VOID WINAPI TpReleasePool( TP_POOL *pool )
+{
+    struct threadpool *this = impl_from_TP_POOL( pool );
+    TRACE("%p\n", pool);
+
+    if (this)
+    {
+        tp_threadpool_shutdown( this );
+        tp_threadpool_release( this );
+    }
+}
+
+/***********************************************************************
+ *           TpReleaseTimer     (NTDLL.@)
+ */
+VOID WINAPI TpReleaseTimer( TP_TIMER *timer )
+{
+    struct threadpool_object *this = impl_from_TP_TIMER( timer );
+    TRACE("%p\n", timer);
+
+    if (this)
+    {
+        tp_object_shutdown( this );
+        tp_object_release( this );
+    }
+}
+
+/***********************************************************************
+ *           TpReleaseWait    (NTDLL.@)
+ */
+VOID WINAPI TpReleaseWait( TP_WAIT *wait )
+{
+    struct threadpool_object *this = impl_from_TP_WAIT( wait );
+    TRACE("%p\n", wait);
+
+    if (this)
+    {
+        tp_object_shutdown( this );
+        tp_object_release( this );
+    }
+}
+
+/***********************************************************************
+ *           TpReleaseWork    (NTDLL.@)
+ */
+VOID WINAPI TpReleaseWork( TP_WORK *work )
+{
+    struct threadpool_object *this = impl_from_TP_WORK( work );
+    TRACE("%p\n", work);
+
+    if (this)
+    {
+        tp_object_shutdown( this );
+        tp_object_release( this );
+    }
+}
+
+/***********************************************************************
+ *           TpSetPoolMaxThreads    (NTDLL.@)
+ */
+VOID WINAPI TpSetPoolMaxThreads( TP_POOL *pool, DWORD maximum )
+{
+    struct threadpool *this = impl_from_TP_POOL( pool );
+    TRACE("%p %d\n", pool, maximum);
+
+    if (this)
+    {
+        RtlEnterCriticalSection( &this->cs );
+        this->max_workers = max( maximum, 1 );
+        this->min_workers = min( this->min_workers, this->max_workers );
+        RtlLeaveCriticalSection( &this->cs );
+    }
+}
+
+/***********************************************************************
+ *           TpSetPoolMinThreads    (NTDLL.@)
+ */
+BOOL WINAPI TpSetPoolMinThreads( TP_POOL *pool, DWORD minimum )
+{
+    struct threadpool *this = impl_from_TP_POOL( pool );
+    FIXME("%p %d: semi-stub\n", pool, minimum);
+
+    if (this)
+    {
+        RtlEnterCriticalSection( &this->cs );
+        this->min_workers = max( minimum, 1 );
+        this->max_workers = max( this->min_workers, this->max_workers );
+        RtlLeaveCriticalSection( &this->cs );
+    }
+    return TRUE;
+}
+
+/***********************************************************************
+ *           TpSetTimer    (NTDLL.@)
+ */
+VOID WINAPI TpSetTimer( TP_TIMER *timer, LARGE_INTEGER *timeout, LONG period, LONG window_length )
+{
+    struct threadpool_object *this = impl_from_TP_TIMER( timer );
+    TRACE("%p %p %u %u\n", timer, timeout, period, window_length);
+
+    if (this)
+    {
+        tp_timerqueue_update_timer( this, timeout, period, window_length );
+    }
+}
+
+/***********************************************************************
+ *           TpSetWait    (KERNEL32.@)
+ */
+VOID WINAPI TpSetWait( TP_WAIT *wait, HANDLE handle, LARGE_INTEGER *timeout )
+{
+    struct threadpool_object *this = impl_from_TP_WAIT( wait );
+    TRACE("%p %p %p\n", wait, handle, timeout);
+
+    if (this)
+    {
+        tp_waitqueue_update_wait( this, handle, timeout );
+    }
+}
+
+/***********************************************************************
+ *           TpSimpleTryPost    (NTDLL.@)
+ */
+NTSTATUS WINAPI TpSimpleTryPost( PTP_SIMPLE_CALLBACK callback, PVOID userdata,
+                                 TP_CALLBACK_ENVIRON *environment )
+{
+    struct threadpool_object *object;
+    struct threadpool *pool;
+
+    TRACE("%p %p %p\n", callback, userdata, environment);
+
+    if (!(pool = get_threadpool( environment )))
+        return STATUS_NO_MEMORY;
+
+    object = RtlAllocateHeap( GetProcessHeap(), 0, sizeof(*object) );
+    if (!object)
+        return STATUS_NO_MEMORY;
+
+    object->type = TP_OBJECT_TYPE_SIMPLE;
+    object->u.simple.callback = callback;
+    tp_object_initialize( object, pool, userdata, environment );
+
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *           TpWaitForTimer    (NTDLL.@)
+ */
+VOID WINAPI TpWaitForTimer( TP_TIMER *timer, BOOL cancel_pending )
+{
+    struct threadpool_object *this = impl_from_TP_TIMER( timer );
+    TRACE("%p %d\n", timer, cancel_pending);
+    if (this)
+    {
+        if (cancel_pending)
+            tp_object_cancel( this, FALSE, NULL );
+        tp_object_wait( this );
+    }
+}
+
+/***********************************************************************
+ *           TpWaitForWait    (KERNEL32.@)
+ */
+VOID WINAPI TpWaitForWait( TP_WAIT *wait, BOOL cancel_pending )
+{
+    struct threadpool_object *this = impl_from_TP_WAIT( wait );
+    TRACE("%p %d\n", wait, cancel_pending);
+    if (this)
+    {
+        if (cancel_pending)
+            tp_object_cancel( this, FALSE, NULL );
+        tp_object_wait( this );
+    }
+}
+
+/***********************************************************************
+ *           TpWaitForWork    (NTDLL.@)
+ */
+VOID WINAPI TpWaitForWork( TP_WORK *work, BOOL cancel_pending )
+{
+    struct threadpool_object *this = impl_from_TP_WORK( work );
+    TRACE("%p %d\n", work, cancel_pending);
+
+    if (this)
+    {
+        if (cancel_pending)
+            tp_object_cancel( this, FALSE, NULL );
+        tp_object_wait( this );
+    }
+}
diff --git a/dlls/ntdll/time.c b/dlls/ntdll/time.c
index 69bd736..65bd2b6 100644
--- a/dlls/ntdll/time.c
+++ b/dlls/ntdll/time.c
@@ -592,11 +592,23 @@ static void find_reg_tz_info(RTL_TIME_ZONE_INFORMATION *tzi)
         'W','i','n','d','o','w','s',' ','N','T','\\',
         'C','u','r','r','e','n','t','V','e','r','s','i','o','n','\\',
         'T','i','m','e',' ','Z','o','n','e','s',0 };
+    static const WCHAR Dynamic_DstW[] = { 'D','y','n','a','m','i','c',' ','D','S','T',0 };
+    static const WCHAR fmtW[] = { '%','d',0 };
     HANDLE hkey;
     ULONG idx;
-    OBJECT_ATTRIBUTES attr;
-    UNICODE_STRING nameW;
-    WCHAR buf[128];
+    OBJECT_ATTRIBUTES attr, attrDynamic;
+    UNICODE_STRING nameW, nameDynamicW;
+    WCHAR buf[128], yearW[16];
+
+    sprintfW(yearW, fmtW, tzi->DaylightDate.wYear);
+
+    attrDynamic.Length = sizeof(attrDynamic);
+    attrDynamic.RootDirectory = 0; /* will be replaced later */
+    attrDynamic.ObjectName = &nameDynamicW;
+    attrDynamic.Attributes = 0;
+    attrDynamic.SecurityDescriptor = NULL;
+    attrDynamic.SecurityQualityOfService = NULL;
+    RtlInitUnicodeString(&nameDynamicW, Dynamic_DstW);
 
     attr.Length = sizeof(attr);
     attr.RootDirectory = 0;
@@ -622,7 +634,9 @@ static void find_reg_tz_info(RTL_TIME_ZONE_INFORMATION *tzi)
         static const WCHAR dltW[] = { 'D','l','t',0 };
         static const WCHAR tziW[] = { 'T','Z','I',0 };
         RTL_TIME_ZONE_INFORMATION reg_tzi;
-        HANDLE hSubkey;
+        HANDLE hSubkey, hSubkeyDynamicDST;
+        BOOL is_dynamic = FALSE;
+
         struct tz_reg_data
         {
             LONG bias;
@@ -654,7 +668,17 @@ static void find_reg_tz_info(RTL_TIME_ZONE_INFORMATION *tzi)
 
         get_value(hSubkey, stdW, REG_SZ, reg_tzi.StandardName, sizeof(reg_tzi.StandardName));
         get_value(hSubkey, dltW, REG_SZ, reg_tzi.DaylightName, sizeof(reg_tzi.DaylightName));
-        get_value(hSubkey, tziW, REG_BINARY, &tz_data, sizeof(tz_data));
+
+        /* Check for Dynamic DST entry first */
+        attrDynamic.RootDirectory = hSubkey;
+        if (!NtOpenKey(&hSubkeyDynamicDST, KEY_READ, &attrDynamic))
+        {
+            is_dynamic = reg_query_value(hSubkeyDynamicDST, yearW, REG_BINARY, &tz_data, sizeof(tz_data));
+            NtClose(hSubkeyDynamicDST);
+        }
+
+        if (!is_dynamic)
+            get_value(hSubkey, tziW, REG_BINARY, &tz_data, sizeof(tz_data));
 
 #undef get_value
 
diff --git a/dlls/ntdll/version.c b/dlls/ntdll/version.c
index a6340eb..5d1b445 100644
--- a/dlls/ntdll/version.c
+++ b/dlls/ntdll/version.c
@@ -657,6 +657,35 @@ BOOLEAN WINAPI RtlGetNtProductType( LPDWORD type )
 }
 
 
+static inline UCHAR version_update_condition(PUCHAR last_condition, UCHAR condition)
+{
+    switch (*last_condition)
+    {
+        case 0:
+            *last_condition = condition;
+            break;
+        case VER_EQUAL:
+            if (condition >= VER_EQUAL && condition <= VER_LESS_EQUAL)
+            {
+                *last_condition = condition;
+                return condition;
+            }
+            break;
+        case VER_GREATER:
+        case VER_GREATER_EQUAL:
+            if (condition >= VER_EQUAL && condition <= VER_GREATER_EQUAL)
+                return condition;
+            break;
+        case VER_LESS:
+        case VER_LESS_EQUAL:
+            if (condition == VER_EQUAL || (condition >= VER_LESS && condition <= VER_LESS_EQUAL))
+                return condition;
+            break;
+    }
+    if (!condition) *last_condition |= 0x10;
+    return *last_condition & 0xf;
+}
+
 static inline NTSTATUS version_compare_values(ULONG left, ULONG right, UCHAR condition)
 {
     switch (condition) {
@@ -732,38 +761,33 @@ NTSTATUS WINAPI RtlVerifyVersionInfo( const RTL_OSVERSIONINFOEXW *info,
 
     if(dwTypeMask & (VER_MAJORVERSION|VER_MINORVERSION|VER_SERVICEPACKMAJOR|VER_SERVICEPACKMINOR))
     {
-        unsigned char condition = 0;
+        unsigned char condition, last_condition = 0;
         BOOLEAN do_next_check = TRUE;
 
         if(dwTypeMask & VER_MAJORVERSION)
-            condition = dwlConditionMask >> 1*3 & 0x07;
-        else if(dwTypeMask & VER_MINORVERSION)
-            condition = dwlConditionMask >> 0*3 & 0x07;
-        else if(dwTypeMask & VER_SERVICEPACKMAJOR)
-            condition = dwlConditionMask >> 5*3 & 0x07;
-        else if(dwTypeMask & VER_SERVICEPACKMINOR)
-            condition = dwlConditionMask >> 4*3 & 0x07;
-
-        if(dwTypeMask & VER_MAJORVERSION)
         {
+            condition = version_update_condition(&last_condition, dwlConditionMask >> 1*3 & 0x07);
             status = version_compare_values(ver.dwMajorVersion, info->dwMajorVersion, condition);
             do_next_check = (ver.dwMajorVersion == info->dwMajorVersion) &&
-                ((condition != VER_EQUAL) || (status == STATUS_SUCCESS));
+                ((condition >= VER_EQUAL) && (condition <= VER_LESS_EQUAL));
         }
         if((dwTypeMask & VER_MINORVERSION) && do_next_check)
         {
+            condition = version_update_condition(&last_condition, dwlConditionMask >> 0*3 & 0x07);
             status = version_compare_values(ver.dwMinorVersion, info->dwMinorVersion, condition);
             do_next_check = (ver.dwMinorVersion == info->dwMinorVersion) &&
-                ((condition != VER_EQUAL) || (status == STATUS_SUCCESS));
+                ((condition >= VER_EQUAL) && (condition <= VER_LESS_EQUAL));
         }
         if((dwTypeMask & VER_SERVICEPACKMAJOR) && do_next_check)
         {
+            condition = version_update_condition(&last_condition, dwlConditionMask >> 5*3 & 0x07);
             status = version_compare_values(ver.wServicePackMajor, info->wServicePackMajor, condition);
             do_next_check = (ver.wServicePackMajor == info->wServicePackMajor) &&
-                ((condition != VER_EQUAL) || (status == STATUS_SUCCESS));
+                ((condition >= VER_EQUAL) && (condition <= VER_LESS_EQUAL));
         }
         if((dwTypeMask & VER_SERVICEPACKMINOR) && do_next_check)
         {
+            condition = version_update_condition(&last_condition, dwlConditionMask >> 4*3 & 0x07);
             status = version_compare_values(ver.wServicePackMinor, info->wServicePackMinor, condition);
         }
 
diff --git a/dlls/ntdll/virtual.c b/dlls/ntdll/virtual.c
index 9d29c33..68f38ea 100644
--- a/dlls/ntdll/virtual.c
+++ b/dlls/ntdll/virtual.c
@@ -149,6 +149,13 @@ static void *preload_reserve_end;
 static BOOL use_locks;
 static BOOL force_exec_prot;  /* whether to force PROT_EXEC on all PROT_READ mmaps */
 
+#if defined(__i386__)
+NTSTATUS WINAPI NtProtectVirtualMemory( HANDLE process, PVOID *addr_ptr, SIZE_T *size_ptr,
+                                        ULONG new_prot, ULONG *old_prot ) DECLSPEC_ALIGN(4096);
+NTSTATUS WINAPI NtCreateSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_ATTRIBUTES *attr,
+                                 const LARGE_INTEGER *size, ULONG protect,
+                                 ULONG sec_flags, HANDLE file ) DECLSPEC_ALIGN(4096);
+#endif
 
 /***********************************************************************
  *           VIRTUAL_GetProtStr
@@ -165,6 +172,21 @@ static const char *VIRTUAL_GetProtStr( BYTE prot )
     return buffer;
 }
 
+/* This might look like a hack, but it actually isn't - the 'experimental' version
+ * is correct, but it already has revealed a couple of additional Wine bugs, which
+ * were not triggered before, and there are probably some more.
+ * To avoid breaking Wine for everyone, the new correct implementation has to be
+ * manually enabled, until it is tested a bit more. */
+static inline BOOL experimental_WRITECOPY( void )
+{
+    static int enabled = -1;
+    if (enabled == -1)
+    {
+        const char *str = getenv("STAGING_WRITECOPY");
+        enabled = str && (atoi(str) != 0);
+    }
+    return enabled;
+}
 
 /***********************************************************************
  *           VIRTUAL_GetUnixProt
@@ -178,8 +200,19 @@ static int VIRTUAL_GetUnixProt( BYTE vprot )
     {
         if (vprot & VPROT_READ) prot |= PROT_READ;
         if (vprot & VPROT_WRITE) prot |= PROT_WRITE | PROT_READ;
-        if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
         if (vprot & VPROT_EXEC) prot |= PROT_EXEC | PROT_READ;
+#if defined(__i386__)
+        if (vprot & VPROT_WRITECOPY)
+        {
+            if (experimental_WRITECOPY())
+                prot = (prot & ~PROT_WRITE) | PROT_READ;
+            else
+                prot |= PROT_WRITE | PROT_READ;
+        }
+#else
+        /* FIXME: Architecture needs implementation of signal_init_early. */
+        if (vprot & VPROT_WRITECOPY) prot |= PROT_WRITE | PROT_READ;
+#endif
         if (vprot & VPROT_WRITEWATCH) prot &= ~PROT_WRITE;
     }
     if (!prot) prot = PROT_NONE;
@@ -1531,16 +1564,42 @@ NTSTATUS virtual_handle_fault( LPCVOID addr, DWORD err, BOOL on_signal_stack )
     {
         void *page = ROUND_ADDR( addr, page_mask );
         BYTE *vprot = &view->prot[((const char *)page - (const char *)view->base) >> page_shift];
-        if ((err & EXCEPTION_WRITE_FAULT) && (view->protect & VPROT_WRITEWATCH))
+#ifdef EXAGEAR_COMPAT
+        /* Exagear doesn't correctly set err, so always check for write watches, and
+         * retry after removing the VPROT_WRITEWATCH or VPROT_WRITECOPY flag. In
+         * contrary to the general implementation below this is not completely race-
+         * condition safe. When multiple threads trigger the write watch at the same
+         * time only the first thread will properly continue the execution, the rest
+         * will crash. */
+        if ((view->protect & VPROT_WRITEWATCH) && (*vprot & VPROT_WRITEWATCH))
+        {
+            *vprot &= ~VPROT_WRITEWATCH;
+            VIRTUAL_SetProt( view, page, page_size, *vprot );
+            if (VIRTUAL_GetUnixProt( *vprot ) & PROT_WRITE) ret = STATUS_SUCCESS;
+        }
+        if (*vprot & VPROT_WRITECOPY)
         {
-            if (*vprot & VPROT_WRITEWATCH)
+            *vprot = (*vprot & ~VPROT_WRITECOPY) | VPROT_WRITE;
+            VIRTUAL_SetProt( view, page, page_size, *vprot );
+            if (VIRTUAL_GetUnixProt( *vprot ) & PROT_WRITE) ret = STATUS_SUCCESS;
+        }
+#else
+        if (err & EXCEPTION_WRITE_FAULT)
+        {
+            if ((view->protect & VPROT_WRITEWATCH) && (*vprot & VPROT_WRITEWATCH))
             {
                 *vprot &= ~VPROT_WRITEWATCH;
                 VIRTUAL_SetProt( view, page, page_size, *vprot );
             }
+            if (*vprot & VPROT_WRITECOPY)
+            {
+                *vprot = (*vprot & ~VPROT_WRITECOPY) | VPROT_WRITE;
+                VIRTUAL_SetProt( view, page, page_size, *vprot );
+            }
             /* ignore fault if page is writable now */
             if (VIRTUAL_GetUnixProt( *vprot ) & PROT_WRITE) ret = STATUS_SUCCESS;
         }
+#endif
         if (!on_signal_stack && (*vprot & VPROT_GUARD))
         {
             VIRTUAL_SetProt( view, page, page_size, *vprot & ~VPROT_GUARD );
@@ -1671,13 +1730,14 @@ BOOL virtual_check_buffer_for_write( void *ptr, SIZE_T size )
 
 
 /***********************************************************************
- *           virtual_uninterrupted_read_memory
+ *           wine_uninterrupted_read_memory  (NTDLL.@)
  *
  * Similar to NtReadVirtualMemory, but without wineserver calls. Moreover
  * permissions are checked before accessing each page, to ensure that no
- * exceptions can happen.
+ * exceptions can happen. When a NULL pointer is passed as buffer the
+ * permissions are only checked and no actual memcpy is performed.
  */
-SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size )
+SIZE_T CDECL wine_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size )
 {
     struct file_view *view;
     sigset_t sigset;
@@ -1696,10 +1756,14 @@ SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T
             while (bytes_read < size && (VIRTUAL_GetUnixProt( *p++ ) & PROT_READ))
             {
                 SIZE_T block_size = min( size, page_size - ((UINT_PTR)addr & page_mask) );
-                memcpy( buffer, addr, block_size );
 
-                addr   = (const void *)((const char *)addr + block_size);
-                buffer = (void *)((char *)buffer + block_size);
+                if (buffer)
+                {
+                    memcpy( buffer, addr, block_size );
+                    buffer = (void *)((char *)buffer + block_size);
+                }
+
+                addr = (const void *)((const char *)addr + block_size);
                 bytes_read += block_size;
             }
         }
@@ -1710,13 +1774,14 @@ SIZE_T virtual_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T
 
 
 /***********************************************************************
- *           virtual_uninterrupted_write_memory
+ *           wine_uninterrupted_write_memory  (NTDLL.@)
  *
  * Similar to NtWriteVirtualMemory, but without wineserver calls. Moreover
  * permissions are checked before accessing each page, to ensure that no
- * exceptions can happen.
+ * exceptions can happen. When a NULL pointer is passed as buffer the
+ * permissions are only checked and no actual memcpy is performed.
  */
-SIZE_T virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size )
+SIZE_T CDECL wine_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size )
 {
     struct file_view *view;
     sigset_t sigset;
@@ -1740,24 +1805,30 @@ SIZE_T virtual_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_
                  * exception. Similar to virtual_handle_fault. */
                 if (!(VIRTUAL_GetUnixProt( *p ) & PROT_WRITE))
                 {
-                    if (!(view->protect & VPROT_WRITEWATCH))
-                        break;
-
-                    if (*p & VPROT_WRITEWATCH)
+                    if ((view->protect & VPROT_WRITEWATCH) && (*p & VPROT_WRITEWATCH))
                     {
                         *p &= ~VPROT_WRITEWATCH;
                         VIRTUAL_SetProt( view, page, page_size, *p );
                     }
+                    if (*p & VPROT_WRITECOPY)
+                    {
+                        *p = (*p & ~VPROT_WRITECOPY) | VPROT_WRITE;
+                        VIRTUAL_SetProt( view, page, page_size, *p );
+                    }
                     /* ignore fault if page is writable now */
                     if (!(VIRTUAL_GetUnixProt( *p ) & PROT_WRITE))
                         break;
                 }
 
                 block_size = min( size, page_size - ((UINT_PTR)addr & page_mask) );
-                memcpy( addr, buffer, block_size );
 
-                addr   = (void *)((char *)addr + block_size);
-                buffer = (const void *)((const char *)buffer + block_size);
+                if (buffer)
+                {
+                    memcpy( addr, buffer, block_size );
+                    buffer = (const void *)((const char *)buffer + block_size);
+                }
+
+                addr = (void *)((char *)addr + block_size);
                 bytes_written += block_size;
             }
         }
@@ -2571,6 +2642,101 @@ NTSTATUS WINAPI NtOpenSection( HANDLE *handle, ACCESS_MASK access, const OBJECT_
 
 
 /***********************************************************************
+ *             NtQuerySection   (NTDLL.@)
+ */
+NTSTATUS WINAPI NtQuerySection( HANDLE handle, SECTION_INFORMATION_CLASS info_class,
+                                PVOID buffer, ULONG len, PULONG ret_len )
+{
+    HANDLE dup_mapping, shared_file;
+    unsigned protect;
+    LARGE_INTEGER size;
+    void *entry;
+    short machine, subsystem;
+    short major_subsystem, minor_subsystem;
+    short characteristics, dll_characteristics;
+    NTSTATUS res;
+
+    if (info_class == SectionBasicInformation)
+    {
+        if (len < sizeof(SECTION_BASIC_INFORMATION))
+            return STATUS_INFO_LENGTH_MISMATCH;
+    }
+    else if (info_class == SectionImageInformation)
+    {
+        if (len < sizeof(SECTION_IMAGE_INFORMATION))
+            return STATUS_INFO_LENGTH_MISMATCH;
+    }
+    else
+    {
+        FIXME("%p,info_class=%d,%p,%u,%p) Unknown information class\n",
+              handle, info_class, buffer, len, ret_len);
+        return STATUS_INVALID_INFO_CLASS;
+    }
+
+    if (!buffer) return STATUS_ACCESS_VIOLATION;
+
+    SERVER_START_REQ( get_mapping_info )
+    {
+        req->handle = wine_server_obj_handle( handle );
+        req->access = SECTION_QUERY;
+        res = wine_server_call( req );
+        protect             = reply->protect;
+        size.QuadPart       = reply->size;
+        dup_mapping         = wine_server_ptr_handle( reply->mapping );
+        shared_file         = wine_server_ptr_handle( reply->shared_file );
+        entry               = wine_server_get_ptr( reply->entry );
+        subsystem           = reply->subsystem;
+        major_subsystem     = reply->major_subsystem;
+        minor_subsystem     = reply->minor_subsystem;
+        characteristics     = reply->characteristics;
+        dll_characteristics = reply->dll_characteristics;
+        machine             = reply->machine;
+    }
+    SERVER_END_REQ;
+    if (res) return res;
+
+    if (dup_mapping) NtClose( dup_mapping );
+    if (shared_file) NtClose( shared_file );
+
+    if (info_class == SectionBasicInformation)
+    {
+        SECTION_BASIC_INFORMATION *info = buffer;
+
+        info->BaseAddress = NULL;
+        info->Size        = size;
+        info->Attributes  = (protect & VPROT_COMMITTED) ? SEC_COMMIT : SEC_RESERVE;
+        if (protect & VPROT_NOCACHE) info->Attributes |= SEC_NOCACHE;
+        if (protect & VPROT_IMAGE)   info->Attributes |= SEC_IMAGE;
+        /* FIXME: SEC_FILE */
+        if (ret_len) *ret_len = sizeof(*info);
+    }
+    else
+    {
+        SECTION_IMAGE_INFORMATION *info = buffer;
+
+        if (!(protect & VPROT_IMAGE))
+            return STATUS_SECTION_NOT_IMAGE;
+
+        memset( info, 0, sizeof(*info) );
+        info->TransferAddress      = entry;
+        info->ZeroBits             = 0; /* FIXME */
+        info->MaximumStackSize     = 0; /* FIXME */
+        info->CommittedStackSize   = 0; /* FIXME */
+        info->SubSystemType        = subsystem;
+        info->SubsystemVersionHigh = major_subsystem;
+        info->SubsystemVersionLow  = minor_subsystem;
+        info->ImageCharacteristics = characteristics;
+        info->DllCharacteristics   = dll_characteristics;
+        info->Machine              = machine;
+        info->ImageContainsCode    = TRUE; /* FIXME */
+        if (ret_len) *ret_len = sizeof(*info);
+    }
+
+    return STATUS_SUCCESS;
+}
+
+
+/***********************************************************************
  *             NtMapViewOfSection   (NTDLL.@)
  *             ZwMapViewOfSection   (NTDLL.@)
  */
@@ -2758,6 +2924,58 @@ done:
 
 
 /***********************************************************************
+ *           virtual_map_shared_memory
+ */
+NTSTATUS virtual_map_shared_memory( int fd, PVOID *addr_ptr, ULONG zero_bits,
+                                    SIZE_T *size_ptr, ULONG protect )
+{
+    SIZE_T size, mask = get_mask( zero_bits );
+    struct file_view *view;
+    unsigned int vprot;
+    sigset_t sigset;
+    NTSTATUS res;
+    int prot;
+
+    size = ROUND_SIZE( 0, *size_ptr );
+    if (size < *size_ptr)
+        return STATUS_INVALID_PARAMETER;
+
+    server_enter_uninterrupted_section( &csVirtual, &sigset );
+
+    get_vprot_flags( protect, &vprot, FALSE );
+    vprot |= VPROT_COMMITTED;
+    res = map_view( &view, *addr_ptr, size, mask, FALSE, vprot );
+    if (!res)
+    {
+        /* Map the shared memory */
+
+        prot = VIRTUAL_GetUnixProt( vprot );
+        if (force_exec_prot && !(vprot & VPROT_NOEXEC) && (vprot & VPROT_READ))
+        {
+            TRACE( "forcing exec permission on mapping %p-%p\n",
+                   (char *)view->base, (char *)view->base + size - 1 );
+            prot |= PROT_EXEC;
+        }
+
+        if (mmap( view->base, size, prot, MAP_FIXED | MAP_SHARED, fd, 0 ) != (void *)-1)
+        {
+            memset( view->prot, vprot, size >> page_shift );
+            *addr_ptr = view->base;
+            *size_ptr = size;
+        }
+        else
+        {
+            ERR( "virtual_map_shared_memory %p %lx failed\n", view->base, size );
+            delete_view( view );
+        }
+    }
+
+    server_leave_uninterrupted_section( &csVirtual, &sigset );
+    return res;
+}
+
+
+/***********************************************************************
  *             NtUnmapViewOfSection   (NTDLL.@)
  *             ZwUnmapViewOfSection   (NTDLL.@)
  */
diff --git a/dlls/ntoskrnl.exe/instr.c b/dlls/ntoskrnl.exe/instr.c
index 45021c6..68f9df5 100644
--- a/dlls/ntoskrnl.exe/instr.c
+++ b/dlls/ntoskrnl.exe/instr.c
@@ -4,6 +4,7 @@
  * Copyright 1995 Alexandre Julliard
  * Copyright 2005 Ivan Leo Puoti
  * Copyright 2005 Laurent Pinchart
+ * Copyright 2014 Sebastian Lackner
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -475,4 +476,294 @@ LONG CALLBACK vectored_handler( EXCEPTION_POINTERS *ptrs )
     return EXCEPTION_CONTINUE_SEARCH;
 }
 
-#endif  /* __i386__ */
+#elif defined(__x86_64__)  /* __i386__ */
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "winternl.h"
+#define WIN32_NO_STATUS
+#include "ddk/wdm.h"
+#include "excpt.h"
+#include "wine/debug.h"
+#include "wine/exception.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(int);
+
+#define REX_B   1
+#define REX_X   2
+#define REX_R   4
+#define REX_W   8
+
+#define REGMODRM_MOD( regmodrm, rex )   ((regmodrm) >> 6)
+#define REGMODRM_REG( regmodrm, rex )   (((regmodrm) >> 3) & 7) | (((rex) & REX_R) ? 8 : 0)
+#define REGMODRM_RM( regmodrm, rex )    (((regmodrm) & 7) | (((rex) & REX_B) ? 8 : 0))
+
+#define SIB_SS( sib, rex )      ((sib) >> 6)
+#define SIB_INDEX( sib, rex )   (((sib) >> 3) & 7) | (((rex) & REX_R) ? 8 : 0)
+#define SIB_BASE( sib, rex )    (((sib) & 7) | (((rex) & REX_B) ? 8 : 0))
+
+#define KI_USER_SHARED_DATA 0xfffff78000000000
+extern void* CDECL __wine_user_shared_data(void);
+
+static inline DWORD64 *get_int_reg( CONTEXT *context, int index )
+{
+    return &context->Rax + index; /* index should be in range 0 .. 15 */
+}
+
+static inline int get_op_size( int long_op, int rex )
+{
+    if (rex & REX_W)
+        return sizeof(DWORD64);
+    else if (long_op)
+        return sizeof(DWORD);
+    else
+        return sizeof(WORD);
+}
+
+/* store an operand into a register */
+static void store_reg_word( CONTEXT *context, BYTE regmodrm, const BYTE *addr, int long_op, int rex )
+{
+    int index = REGMODRM_REG( regmodrm, rex );
+    BYTE *reg = (BYTE *)get_int_reg( context, index );
+    memcpy( reg, addr, get_op_size( long_op, rex ) );
+}
+
+/* store an operand into a byte register */
+static void store_reg_byte( CONTEXT *context, BYTE regmodrm, const BYTE *addr, int rex )
+{
+    int index = REGMODRM_REG( regmodrm, rex );
+    BYTE *reg = (BYTE *)get_int_reg( context, index );
+    if (!rex && index >= 4 && index < 8) reg -= (4 * sizeof(DWORD64) - 1); /* special case: ah, ch, dh, bh */
+    *reg = *addr;
+}
+
+/***********************************************************************
+ *           INSTR_GetOperandAddr
+ *
+ * Return the address of an instruction operand (from the mod/rm byte).
+ */
+static BYTE *INSTR_GetOperandAddr( CONTEXT *context, BYTE *instr,
+                                   int long_addr, int rex, int segprefix, int *len )
+{
+    int mod, rm, ss = 0, off, have_sib = 0;
+    DWORD64 base = 0, index = 0;
+
+#define GET_VAL( val, type ) \
+    { *val = *(type *)instr; instr += sizeof(type); *len += sizeof(type); }
+
+    *len = 0;
+    GET_VAL( &mod, BYTE );
+    rm  = REGMODRM_RM( mod, rex );
+    mod = REGMODRM_MOD( mod, rex );
+
+    if (mod == 3)
+        return (BYTE *)get_int_reg( context, rm );
+
+    if ((rm & 7) == 4)
+    {
+        BYTE sib;
+        int id;
+
+        GET_VAL( &sib, BYTE );
+        rm = SIB_BASE( sib, rex );
+        id = SIB_INDEX( sib, rex );
+        ss = SIB_SS( sib, rex );
+
+        index = (id != 4) ? *get_int_reg( context, id ) : 0;
+        if (!long_addr) index &= 0xffffffff;
+        have_sib = 1;
+    }
+
+    base = *get_int_reg( context, rm );
+    if (!long_addr) base &= 0xffffffff;
+
+    switch (mod)
+    {
+    case 0:
+        if (rm == 5)  /* special case */
+        {
+            base = have_sib ? 0 : context->Rip;
+            if (!long_addr) base &= 0xffffffff;
+            GET_VAL( &off, DWORD );
+            base += (signed long)off;
+        }
+        break;
+
+    case 1:  /* 8-bit disp */
+        GET_VAL( &off, BYTE );
+        base += (signed char)off;
+        break;
+
+    case 2:  /* 32-bit disp */
+        GET_VAL( &off, DWORD );
+        base += (signed long)off;
+        break;
+    }
+
+    /* FIXME: we assume that all segments have a base of 0 */
+    return (BYTE *)(base + (index << ss));
+#undef GET_VAL
+}
+
+
+/***********************************************************************
+ *           emulate_instruction
+ *
+ * Emulate a privileged instruction.
+ * Returns exception continuation status.
+ */
+static DWORD emulate_instruction( EXCEPTION_RECORD *rec, CONTEXT *context )
+{
+    int prefix, segprefix, prefixlen, len, long_op, long_addr, rex;
+    BYTE *instr;
+
+    long_op = long_addr = 1;
+    instr = (BYTE *)context->Rip;
+    if (!instr) return ExceptionContinueSearch;
+
+    /* First handle any possible prefix */
+
+    segprefix = -1; /* no seg prefix */
+    rex = 0; /* no rex prefix */
+    prefix = 1;
+    prefixlen = 0;
+    while(prefix)
+    {
+        switch(*instr)
+        {
+        case 0x2e:
+            segprefix = context->SegCs;
+            break;
+        case 0x36:
+            segprefix = context->SegSs;
+            break;
+        case 0x3e:
+            segprefix = context->SegDs;
+            break;
+        case 0x26:
+            segprefix = context->SegEs;
+            break;
+        case 0x64:
+            segprefix = context->SegFs;
+            break;
+        case 0x65:
+            segprefix = context->SegGs;
+            break;
+        case 0x66:
+            long_op = !long_op;  /* opcode size prefix */
+            break;
+        case 0x67:
+            long_addr = !long_addr;  /* addr size prefix */
+            break;
+        case 0xf0:  /* lock */
+        break;
+        case 0xf2:  /* repne */
+        break;
+        case 0xf3:  /* repe */
+            break;
+        default:
+            prefix = 0;  /* no more prefixes */
+            break;
+        }
+        if (*instr >= 0x40 && *instr < 0x50)  /* rex */
+        {
+            rex = *instr;
+            prefix = TRUE;
+        }
+        if (prefix)
+        {
+            instr++;
+            prefixlen++;
+        }
+    }
+
+    /* Now look at the actual instruction */
+
+    switch(*instr)
+    {
+    case 0x8a: /* mov Eb, Gb */
+    case 0x8b: /* mov Ev, Gv */
+    {
+        BYTE *data = INSTR_GetOperandAddr( context, instr + 1, long_addr,
+                                           rex, segprefix, &len );
+        unsigned int data_size = (*instr == 0x8b) ? get_op_size( long_op, rex ) : 1;
+        unsigned int offset = data - (BYTE *)KI_USER_SHARED_DATA;
+
+        if (offset <= sizeof(KSHARED_USER_DATA) - data_size)
+        {
+            BYTE *user_shared_data = __wine_user_shared_data();
+            switch (*instr)
+            {
+            case 0x8a: store_reg_byte( context, instr[1], user_shared_data + offset, rex ); break;
+            case 0x8b: store_reg_word( context, instr[1], user_shared_data + offset, long_op, rex ); break;
+            }
+            context->Rip += prefixlen + len + 1;
+            return ExceptionContinueExecution;
+        }
+        break;  /* Unable to emulate it */
+    }
+
+    case 0xa0: /* mov Ob, AL */
+    case 0xa1: /* mov Ovqp, rAX */
+    {
+        BYTE *data = (BYTE *)(long_addr ? *(DWORD64 *)(instr + 1) : *(DWORD *)(instr + 1));
+        unsigned int data_size = (*instr == 0xa1) ? get_op_size( long_op, rex ) : 1;
+        unsigned int offset = data - (BYTE *)KI_USER_SHARED_DATA;
+        len = long_addr ? sizeof(DWORD64) : sizeof(DWORD);
+
+        if (offset <= sizeof(KSHARED_USER_DATA) - data_size)
+        {
+            BYTE *user_shared_data = __wine_user_shared_data();
+            memcpy( &context->Rax, user_shared_data + offset, data_size );
+            context->Rip += prefixlen + len + 1;
+            return ExceptionContinueExecution;
+        }
+        break;  /* Unable to emulate it */
+    }
+    }
+    return ExceptionContinueSearch;  /* Unable to emulate it */
+}
+
+
+/***********************************************************************
+ *           vectored_handler
+ *
+ * Vectored exception handler used to emulate protected instructions
+ * from 64-bit code.
+ */
+LONG CALLBACK vectored_handler( EXCEPTION_POINTERS *ptrs )
+{
+    EXCEPTION_RECORD *record = ptrs->ExceptionRecord;
+    CONTEXT *context = ptrs->ContextRecord;
+
+    if (record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)
+    {
+        DWORD64 rip = context->Rip;
+        if (emulate_instruction( record, context ) == ExceptionContinueExecution)
+        {
+
+            if (context->Rip - rip <= 32)
+            {
+                TRACE("emulated opcodes:");
+                for (; rip < context->Rip; rip++) TRACE(" %02x", *(BYTE *)rip);
+                TRACE("\n");
+            }
+            TRACE( "next instruction rip=%lx\n", context->Rip );
+            TRACE( "  rax=%016lx rbx=%016lx rcx=%016lx rdx=%016lx\n",
+                   context->Rax, context->Rbx, context->Rcx, context->Rdx );
+            TRACE( "  rsi=%016lx rdi=%016lx rbp=%016lx rsp=%016lx\n",
+                   context->Rsi, context->Rdi, context->Rbp, context->Rsp );
+            TRACE( "   r8=%016lx  r9=%016lx r10=%016lx r11=%016lx\n",
+                   context->R8, context->R9, context->R10, context->R11 );
+            TRACE( "  r12=%016lx r13=%016lx r14=%016lx r15=%016lx\n",
+                   context->R12, context->R13, context->R14, context->R15 );
+
+            return EXCEPTION_CONTINUE_EXECUTION;
+        }
+    }
+    return EXCEPTION_CONTINUE_SEARCH;
+}
+
+#endif  /* __x86_64__ */
\ No newline at end of file
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.c b/dlls/ntoskrnl.exe/ntoskrnl.c
index bb26424..10f8c44 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.c
+++ b/dlls/ntoskrnl.exe/ntoskrnl.c
@@ -29,6 +29,7 @@
 
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
+#include "ntdef.h"
 #include "windef.h"
 #include "winternl.h"
 #include "excpt.h"
@@ -261,6 +262,34 @@ NTSTATUS CDECL wine_ntoskrnl_main_loop( HANDLE stop_event )
 
 
 /***********************************************************************
+ *           ExAcquireFastMutexUnsafe  (NTOSKRNL.EXE.@)
+ */
+#ifdef DEFINE_FASTCALL1_ENTRYPOINT
+DEFINE_FASTCALL1_ENTRYPOINT(ExAcquireFastMutexUnsafe)
+void WINAPI __regs_ExAcquireFastMutexUnsafe(PFAST_MUTEX FastMutex)
+#else
+void WINAPI ExAcquireFastMutexUnsafe(PFAST_MUTEX FastMutex)
+#endif
+{
+    FIXME("(%p): stub\n", FastMutex);
+}
+
+
+/***********************************************************************
+ *           ExReleaseFastMutexUnsafe  (NTOSKRNL.EXE.@)
+ */
+#ifdef DEFINE_FASTCALL1_ENTRYPOINT
+DEFINE_FASTCALL1_ENTRYPOINT(ExReleaseFastMutexUnsafe)
+void WINAPI __regs_ExReleaseFastMutexUnsafe(PFAST_MUTEX FastMutex)
+#else
+void WINAPI ExReleaseFastMutexUnsafe(PFAST_MUTEX FastMutex)
+#endif
+{
+    FIXME("(%p): stub\n", FastMutex);
+}
+
+
+/***********************************************************************
  *           IoAcquireCancelSpinLock  (NTOSKRNL.EXE.@)
  */
 void WINAPI IoAcquireCancelSpinLock(PKIRQL irql)
@@ -272,9 +301,9 @@ void WINAPI IoAcquireCancelSpinLock(PKIRQL irql)
 /***********************************************************************
  *           IoReleaseCancelSpinLock  (NTOSKRNL.EXE.@)
  */
-void WINAPI IoReleaseCancelSpinLock(PKIRQL irql)
+void WINAPI IoReleaseCancelSpinLock(KIRQL irql)
 {
-    FIXME("(%p): stub\n", irql);
+    FIXME("(%u): stub\n", irql);
 }
 
 
@@ -825,6 +854,15 @@ NTSTATUS WINAPI IofCallDriver( DEVICE_OBJECT *device, IRP *irp )
     return IoCallDriver( device, irp );
 }
 
+/***********************************************************************
+ *           IoGetAttachedDeviceReference    (NTOSKRNL.EXE.@)
+ */
+PDEVICE_OBJECT WINAPI IoGetAttachedDeviceReference(PDEVICE_OBJECT obj)
+{
+    FIXME("(%p): stub\n", obj);
+
+    return obj;
+}
 
 /***********************************************************************
  *           IoGetRelatedDeviceObject    (NTOSKRNL.EXE.@)
@@ -1196,6 +1234,26 @@ NTSTATUS WINAPI ExInitializeResourceLite(PERESOURCE Resource)
 
 
 /***********************************************************************
+ *           ExAcquireResourceExclusiveLite   (NTOSKRNL.EXE.@)
+ */
+BOOLEAN WINAPI ExAcquireResourceExclusiveLite(PERESOURCE resource, BOOLEAN wait)
+{
+    FIXME("(%p, %u): stub\n", resource, wait);
+    return TRUE;
+}
+
+
+/***********************************************************************
+ *           ExDeleteResourceLite   (NTOSKRNL.EXE.@)
+ */
+NTSTATUS WINAPI ExDeleteResourceLite(PERESOURCE resource)
+{
+    FIXME("(%p): stub\n", resource);
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+
+/***********************************************************************
  *           ExInitializeNPagedLookasideList   (NTOSKRNL.EXE.@)
  */
 void WINAPI ExInitializeNPagedLookasideList(PNPAGED_LOOKASIDE_LIST Lookaside,
@@ -1263,6 +1321,19 @@ PRKTHREAD WINAPI KeGetCurrentThread(void)
     return NULL;
 }
 
+
+/***********************************************************************
+ *           KeDelayExecutionThread   (NTOSKRNL.EXE.@)
+ */
+NTSTATUS WINAPI KeDelayExecutionThread(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable,
+                                       PLARGE_INTEGER Interval)
+{
+    FIXME("(%d, %d, %p): stub\n", WaitMode, Alertable, Interval);
+
+    return STATUS_SUCCESS;
+}
+
+
 /***********************************************************************
  *           KeInitializeEvent   (NTOSKRNL.EXE.@)
  */
@@ -1277,7 +1348,13 @@ void WINAPI KeInitializeEvent( PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State )
  */
 void WINAPI KeInitializeMutex(PRKMUTEX Mutex, ULONG Level)
 {
-    FIXME( "stub: %p, %u\n", Mutex, Level );
+    TRACE( "%p, %u\n", Mutex, Level );
+    RtlZeroMemory( Mutex, sizeof(KMUTEX) );
+    Mutex->Header.Type = 2;
+    Mutex->Header.Size = 8;
+    Mutex->Header.SignalState = 1;
+    InitializeListHead( &Mutex->Header.WaitListHead );
+    Mutex->ApcDisable = 1;
 }
 
 
@@ -1298,7 +1375,7 @@ NTSTATUS WINAPI KeWaitForMutexObject(PRKMUTEX Mutex, KWAIT_REASON WaitReason, KP
 LONG WINAPI KeReleaseMutex(PRKMUTEX Mutex, BOOLEAN Wait)
 {
     FIXME( "stub: %p, %d\n", Mutex, Wait );
-    return STATUS_NOT_IMPLEMENTED;
+    return STATUS_SUCCESS;
 }
 
 
@@ -1308,6 +1385,9 @@ LONG WINAPI KeReleaseMutex(PRKMUTEX Mutex, BOOLEAN Wait)
 void WINAPI KeInitializeSemaphore( PRKSEMAPHORE Semaphore, LONG Count, LONG Limit )
 {
     FIXME( "(%p %d %d) stub\n", Semaphore , Count, Limit );
+
+    RtlZeroMemory(Semaphore, sizeof(KSEMAPHORE));
+    Semaphore->Header.Type = 5;
 }
 
 
@@ -1326,6 +1406,9 @@ void WINAPI KeInitializeSpinLock( PKSPIN_LOCK SpinLock )
 void WINAPI KeInitializeTimerEx( PKTIMER Timer, TIMER_TYPE Type )
 {
     FIXME( "stub: %p %d\n", Timer, Type );
+
+    RtlZeroMemory(Timer, sizeof(KTIMER));
+    Timer->Header.Type = Type ? 9 : 8;
 }
 
 
@@ -1472,6 +1555,19 @@ NTSTATUS WINAPI KeWaitForSingleObject(PVOID Object,
 }
 
 /***********************************************************************
+ *           KeWaitForMultipleObjects   (NTOSKRNL.EXE.@)
+ */
+NTSTATUS WINAPI KeWaitForMultipleObjects(ULONG Count, PVOID Object[], WAIT_TYPE WaitType,
+                                         KWAIT_REASON WaitReason, KPROCESSOR_MODE WaitMode,
+                                         BOOLEAN Alertable, PLARGE_INTEGER Timeout,
+                                         PKWAIT_BLOCK WaitBlockArray)
+{
+    FIXME( "stub: %u, %p, %d, %d, %d, %d, %p, %p\n", Count, Object, WaitType, WaitReason, WaitMode,
+           Alertable, Timeout, WaitBlockArray );
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+/***********************************************************************
  *           IoRegisterFileSystem   (NTOSKRNL.EXE.@)
  */
 VOID WINAPI IoRegisterFileSystem(PDEVICE_OBJECT DeviceObject)
@@ -1575,6 +1671,16 @@ VOID WINAPI MmLockPagableSectionByHandle(PVOID ImageSectionHandle)
     FIXME("stub %p\n", ImageSectionHandle);
 }
 
+ /***********************************************************************
+ *           MmMapLockedPages   (NTOSKRNL.EXE.@)
+ */
+PVOID WINAPI MmMapLockedPages(PMDL MemoryDescriptorList, KPROCESSOR_MODE AccessMode)
+{
+    TRACE("%p %d\n", MemoryDescriptorList, AccessMode);
+    return MemoryDescriptorList->MappedSystemVa;
+}
+
+
 /***********************************************************************
  *           MmMapLockedPagesSpecifyCache  (NTOSKRNL.EXE.@)
  */
@@ -1639,6 +1745,17 @@ VOID WINAPI MmUnmapIoSpace( PVOID BaseAddress, SIZE_T NumberOfBytes )
     FIXME( "stub: %p, %lu\n", BaseAddress, NumberOfBytes );
 }
 
+
+/***********************************************************************
+ *           MmUnmapLockedPages   (NTOSKRNL.EXE.@)
+ */
+void WINAPI MmUnmapLockedPages(PVOID BaseAddress, PMDLX MemoryDescriptorList)
+{
+    TRACE("%p %p\n", BaseAddress, MemoryDescriptorList);
+    /* Nothing to do */
+}
+
+
 /***********************************************************************
  *           ObfReferenceObject   (NTOSKRNL.EXE.@)
  */
@@ -1675,6 +1792,29 @@ NTSTATUS WINAPI ObReferenceObjectByName( UNICODE_STRING *ObjectName,
     return STATUS_NOT_IMPLEMENTED;
 }
 
+
+/***********************************************************************
+ *           ObReferenceObjectByPointer   (NTOSKRNL.EXE.@)
+ */
+NTSTATUS WINAPI ObReferenceObjectByPointer(VOID *obj, ACCESS_MASK access,
+                                           POBJECT_TYPE type,
+                                           KPROCESSOR_MODE mode)
+{
+    FIXME("(%p, %x, %p, %d): stub\n", obj, access, type, mode);
+
+    return STATUS_NOT_IMPLEMENTED;
+}
+
+
+/***********************************************************************
+ *           ObDereferenceObject   (NTOSKRNL.EXE.@)
+ */
+void WINAPI ObDereferenceObject(VOID *obj)
+{
+    FIXME("(%p): stub\n", obj);
+}
+
+
 /***********************************************************************
  *           ObfDereferenceObject   (NTOSKRNL.EXE.@)
  */
@@ -1685,7 +1825,7 @@ void WINAPI __regs_ObfDereferenceObject( VOID *obj )
 void WINAPI ObfDereferenceObject( VOID *obj )
 #endif
 {
-    FIXME( "stub: %p\n", obj );
+    ObDereferenceObject( obj );
 }
 
 
@@ -1845,6 +1985,16 @@ VOID WINAPI KeInitializeDpc(PRKDPC Dpc, PKDEFERRED_ROUTINE DeferredRoutine, PVOI
     FIXME("stub\n");
 }
 
+
+/***********************************************************************
+ *           ExReleaseResourceForThreadLite   (NTOSKRNL.EXE.@)
+ */
+VOID WINAPI ExReleaseResourceForThreadLite(PERESOURCE Resource, ERESOURCE_THREAD ResourceThreadId)
+{
+    FIXME("(%p, %08lx): stub\n", Resource, ResourceThreadId);
+}
+
+
 /***********************************************************************
  *           READ_REGISTER_BUFFER_UCHAR   (NTOSKRNL.EXE.@)
  */
@@ -1872,6 +2022,15 @@ NTSTATUS WINAPI IoWMIRegistrationControl(PDEVICE_OBJECT DeviceObject, ULONG Acti
 }
 
 /*****************************************************
+ *           PsRemoveLoadImageNotifyRoutine   (NTOSKRNL.EXE.@)
+ */
+NTSTATUS WINAPI PsRemoveLoadImageNotifyRoutine(PLOAD_IMAGE_NOTIFY_ROUTINE routine)
+{
+    FIXME("(%p) stub\n", routine);
+    return STATUS_SUCCESS;
+}
+
+/*****************************************************
  *           PsSetLoadImageNotifyRoutine   (NTOSKRNL.EXE.@)
  */
 NTSTATUS WINAPI PsSetLoadImageNotifyRoutine(PLOAD_IMAGE_NOTIFY_ROUTINE routine)
@@ -1936,7 +2095,7 @@ BOOL WINAPI DllMain( HINSTANCE inst, DWORD reason, LPVOID reserved )
     {
     case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls( inst );
-#ifdef __i386__
+#if defined(__i386__) || defined(__x86_64__)
         handler = RtlAddVectoredExceptionHandler( TRUE, vectored_handler );
 #endif
         KeQueryTickCount( &count );  /* initialize the global KeTickCount */
@@ -2038,3 +2197,19 @@ PLIST_ENTRY WINAPI ExfInterlockedRemoveHeadList(PLIST_ENTRY head, PKSPIN_LOCK lo
     FIXME("(%p %p) stub\n", head, lock);
     return ExInterlockedRemoveHeadList( head, lock );
 }
+
+/***********************************************************************
+ *           ProbeForRead   (NTOSKRNL.EXE.@)
+ */
+VOID WINAPI ProbeForRead(PVOID address, SIZE_T length, ULONG alignment)
+{
+    FIXME("%p %lu %u\n", address, length, alignment);
+}
+
+/***********************************************************************
+ *           ProbeForWrite   (NTOSKRNL.EXE.@)
+ */
+VOID WINAPI ProbeForWrite(PVOID address, SIZE_T length, ULONG alignment)
+{
+    FIXME("%p %lu %u\n", address, length, alignment);
+}
diff --git a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
index 11d1c62..1914b7f 100644
--- a/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
+++ b/dlls/ntoskrnl.exe/ntoskrnl.exe.spec
@@ -1,4 +1,4 @@
-@ stub ExAcquireFastMutexUnsafe
+@ stdcall -norelay ExAcquireFastMutexUnsafe(ptr)
 @ stub ExAcquireRundownProtection
 @ stub ExAcquireRundownProtectionEx
 @ stub ExInitializeRundownProtection
@@ -8,7 +8,7 @@
 @ stub ExInterlockedPopEntrySList
 @ stub ExInterlockedPushEntrySList
 @ stub ExReInitializeRundownProtection
-@ stub ExReleaseFastMutexUnsafe
+@ stdcall -norelay ExReleaseFastMutexUnsafe(ptr)
 @ stub ExReleaseResourceLite
 @ stub ExReleaseRundownProtection
 @ stub ExReleaseRundownProtectionEx
@@ -111,7 +111,7 @@
 @ stub DbgPrompt
 @ stub DbgQueryDebugFilterState
 @ stub DbgSetDebugFilterState
-@ stub ExAcquireResourceExclusiveLite
+@ stdcall ExAcquireResourceExclusiveLite(ptr long)
 @ stub ExAcquireResourceSharedLite
 @ stub ExAcquireSharedStarveExclusive
 @ stub ExAcquireSharedWaitForExclusive
@@ -125,7 +125,7 @@
 @ stdcall ExCreateCallback(ptr ptr long long)
 @ stub ExDeleteNPagedLookasideList
 @ stub ExDeletePagedLookasideList
-@ stub ExDeleteResourceLite
+@ stdcall ExDeleteResourceLite(ptr)
 @ stub ExDesktopObjectType
 @ stub ExDisableResourceBoostLite
 @ stub ExEnumHandleTable
@@ -168,7 +168,7 @@
 @ stub ExRaiseStatus
 @ stub ExRegisterCallback
 @ stub ExReinitializeResourceLite
-@ stub ExReleaseResourceForThreadLite
+@ stdcall ExReleaseResourceForThreadLite(ptr long)
 @ stub ExSemaphoreObjectType
 @ stub ExSetResourceOwnerPointer
 @ stub ExSetTimerResolution
@@ -374,7 +374,7 @@
 @ stdcall IoFreeMdl(ptr)
 @ stub IoFreeWorkItem
 @ stdcall IoGetAttachedDevice(ptr)
-@ stub IoGetAttachedDeviceReference
+@ stdcall IoGetAttachedDeviceReference(ptr)
 @ stub IoGetBaseFileSystemDeviceObject
 @ stub IoGetBootDiskInformation
 @ stdcall IoGetConfigurationInformation()
@@ -432,7 +432,7 @@
 @ stub IoRegisterLastChanceShutdownNotification
 @ stdcall IoRegisterPlugPlayNotification(long long ptr ptr ptr ptr ptr)
 @ stdcall IoRegisterShutdownNotification(ptr)
-@ stdcall IoReleaseCancelSpinLock(ptr)
+@ stdcall IoReleaseCancelSpinLock(long)
 @ stub IoReleaseRemoveLockAndWaitEx
 @ stub IoReleaseRemoveLockEx
 @ stub IoReleaseVpbSpinLock
@@ -518,7 +518,7 @@
 @ stub KeClearEvent
 @ stub KeConnectInterrupt
 @ stub KeDcacheFlushCount
-@ stub KeDelayExecutionThread
+@ stdcall KeDelayExecutionThread(long long ptr)
 @ stub KeDeregisterBugCheckCallback
 @ stub KeDeregisterBugCheckReasonCallback
 @ stub KeDetachProcess
@@ -627,7 +627,7 @@
 @ stub KeUpdateRunTime
 @ stub KeUpdateSystemTime
 @ stub KeUserModeCallback
-@ stub KeWaitForMultipleObjects
+@ stdcall KeWaitForMultipleObjects(long ptr long long long long ptr ptr)
 @ stdcall KeWaitForMutexObject(ptr long long long ptr)
 @ stdcall KeWaitForSingleObject(ptr long long long ptr)
 @ stub KiBugCheckData
@@ -689,7 +689,7 @@
 @ stub MmLockPagableImageSection
 @ stdcall MmLockPagableSectionByHandle(ptr)
 @ stdcall MmMapIoSpace(long long long long)
-@ stub MmMapLockedPages
+@ stdcall MmMapLockedPages(ptr long)
 @ stdcall MmMapLockedPagesSpecifyCache(ptr long long ptr long long)
 @ stub MmMapLockedPagesWithReservedMapping
 @ stub MmMapMemoryDumpMdl
@@ -719,7 +719,7 @@
 @ stdcall MmUnlockPagableImageSection(ptr)
 @ stdcall MmUnlockPages(ptr)
 @ stdcall MmUnmapIoSpace(ptr long)
-@ stub MmUnmapLockedPages
+@ stdcall MmUnmapLockedPages(ptr ptr)
 @ stub MmUnmapReservedMapping
 @ stub MmUnmapVideoDisplay
 @ stub MmUnmapViewInSessionSpace
@@ -798,7 +798,7 @@
 @ stub ObCloseHandle
 @ stub ObCreateObject
 @ stub ObCreateObjectType
-@ stub ObDereferenceObject
+@ stdcall ObDereferenceObject(ptr)
 @ stub ObDereferenceSecurityDescriptor
 @ stub ObFindHandleForObject
 @ stub ObGetObjectSecurity
@@ -811,7 +811,7 @@
 @ stub ObQueryObjectAuditingByHandle
 @ stdcall ObReferenceObjectByHandle(long long ptr long ptr ptr)
 @ stdcall ObReferenceObjectByName(ptr long ptr long ptr long ptr ptr)
-@ stub ObReferenceObjectByPointer
+@ stdcall ObReferenceObjectByPointer(ptr long ptr long)
 @ stub ObReferenceSecurityDescriptor
 @ stub ObReleaseObjectSecurity
 @ stub ObSetHandleAttributes
@@ -835,8 +835,8 @@
 @ stub PoShutdownBugCheck
 @ stub PoStartNextPowerIrp
 @ stub PoUnregisterSystemState
-@ stub ProbeForRead
-@ stub ProbeForWrite
+@ stdcall ProbeForRead(ptr long long)
+@ stdcall ProbeForWrite(ptr long long)
 @ stub PsAssignImpersonationToken
 @ stub PsChargePoolQuota
 @ stub PsChargeProcessNonPagedPoolQuota
@@ -899,7 +899,7 @@
 @ stub PsReferenceImpersonationToken
 @ stub PsReferencePrimaryToken
 @ stub PsRemoveCreateThreadNotifyRoutine
-@ stub PsRemoveLoadImageNotifyRoutine
+@ stdcall PsRemoveLoadImageNotifyRoutine(ptr)
 @ stub PsRestoreImpersonation
 @ stub PsReturnPoolQuota
 @ stub PsReturnProcessNonPagedPoolQuota
@@ -977,7 +977,7 @@
 @ stub RtlCustomCPToUnicodeN
 @ stdcall RtlDecompressBuffer(long ptr long ptr long ptr) ntdll.RtlDecompressBuffer
 @ stub RtlDecompressChunks
-@ stub RtlDecompressFragment
+@ stdcall RtlDecompressFragment(long ptr long ptr long long ptr ptr) ntdll.RtlDecompressFragment
 @ stub RtlDelete
 @ stdcall RtlDeleteAce(ptr long) ntdll.RtlDeleteAce
 @ stdcall RtlDeleteAtomFromAtomTable(ptr long) ntdll.RtlDeleteAtomFromAtomTable
@@ -1423,7 +1423,7 @@
 @ cdecl -private _strrev(str) msvcrt._strrev
 @ cdecl -private _strset(str long) msvcrt._strset
 @ cdecl -private _strupr(str) msvcrt._strupr
-@ cdecl -private _vsnprintf(ptr long str ptr) msvcrt._vsnprintf
+@ cdecl _vsnprintf(ptr long str ptr) msvcrt._vsnprintf
 @ cdecl -private _vsnwprintf(ptr long wstr ptr) msvcrt._vsnwprintf
 @ cdecl -private _wcsicmp(wstr wstr) msvcrt._wcsicmp
 @ cdecl -private _wcslwr(wstr) msvcrt._wcslwr
diff --git a/dlls/ole32/tests/compobj.c b/dlls/ole32/tests/compobj.c
index 4be9c8b..aa3f270 100644
--- a/dlls/ole32/tests/compobj.c
+++ b/dlls/ole32/tests/compobj.c
@@ -2105,6 +2105,22 @@ static DWORD CALLBACK release_semaphore_thread( LPVOID arg )
     return 0;
 }
 
+static DWORD CALLBACK send_message_thread(LPVOID arg)
+{
+    HWND hWnd = arg;
+    Sleep(50);
+    SendMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    return 0;
+}
+
+static DWORD CALLBACK post_message_thread(LPVOID arg)
+{
+    HWND hWnd = arg;
+    Sleep(50);
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    return 0;
+}
+
 static void test_CoWaitForMultipleHandles(void)
 {
     static const char cls_name[] = "cowait_test_class";
@@ -2185,6 +2201,32 @@ static void test_CoWaitForMultipleHandles(void)
     success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
     ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
 
+    /* test PostMessageA/SendMessageA from a different thread */
+
+    index = 0xdeadbeef;
+    thread = CreateThread(NULL, 0, post_message_thread, hWnd, 0, &tid);
+    ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+    hr = CoWaitForMultipleHandles(0, 100, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
+    index = WaitForSingleObject(thread, 200);
+    ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(thread);
+
+    index = 0xdeadbeef;
+    thread = CreateThread(NULL, 0, send_message_thread, hWnd, 0, &tid);
+    ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+    hr = CoWaitForMultipleHandles(0, 100, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
+    index = WaitForSingleObject(thread, 200);
+    ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(thread);
+
     ReleaseSemaphore(handles[0], 1, NULL);
     ReleaseSemaphore(handles[1], 1, NULL);
 
@@ -2266,7 +2308,7 @@ static void test_CoWaitForMultipleHandles(void)
     hr = CoWaitForMultipleHandles(COWAIT_INPUTAVAILABLE, 50, 2, handles, &index);
     ok(hr == RPC_S_CALLPENDING || broken(hr == E_INVALIDARG) || broken(hr == S_OK) /* Win 8 */,
        "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
-    ReleaseSemaphore(handles[1], 1, NULL);
+    if (hr != S_OK) ReleaseSemaphore(handles[1], 1, NULL);
     ok(index == 0 || broken(index == 1) /* Win 8 */, "expected index 0, got %u\n", index);
     success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
     ok(!success || broken(success && hr == E_INVALIDARG),
@@ -2275,6 +2317,115 @@ static void test_CoWaitForMultipleHandles(void)
     ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
     CloseHandle(thread);
 
+    /* test behaviour of WM_QUIT (semaphores are still locked) */
+
+    PostMessageA(hWnd, WM_QUIT, 40, 0);
+    memset(&msg, 0, sizeof(msg));
+    success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+    ok(success, "PeekMessageA failed, error %u\n", GetLastError());
+    ok(msg.message == WM_QUIT, "expected msg.message = WM_QUIT, got %u\n", msg.message);
+    ok(msg.wParam == 40, "expected msg.wParam = 40, got %lu\n", msg.wParam);
+    success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+    ok(!success, "PeekMessageA succeeded\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    PostMessageA(hWnd, WM_QUIT, 41, 0);
+    thread = CreateThread(NULL, 0, post_message_thread, hWnd, 0, &tid);
+    ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+    hr = CoWaitForMultipleHandles(0, 100, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    todo_wine
+    ok(success || broken(!success) /* Win 2000/XP/8 */, "PeekMessageA failed, error %u\n", GetLastError());
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "PeekMessageA succeeded\n");
+    memset(&msg, 0, sizeof(msg));
+    success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+    todo_wine
+    ok(!success || broken(success) /* Win 2000/XP/8 */, "PeekMessageA succeeded\n");
+    if (success)
+    {
+        ok(msg.message == WM_QUIT, "expected msg.message = WM_QUIT, got %u\n", msg.message);
+        ok(msg.wParam == 41, "expected msg.wParam = 41, got %lu\n", msg.wParam);
+    }
+    index = WaitForSingleObject(thread, 200);
+    ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(thread);
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    PostMessageA(hWnd, WM_QUIT, 42, 0);
+    thread = CreateThread(NULL, 0, send_message_thread, hWnd, 0, &tid);
+    ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+    hr = CoWaitForMultipleHandles(0, 100, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump all WM_DDE_FIRST messages\n");
+    memset(&msg, 0, sizeof(msg));
+    success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+    ok(success, "PeekMessageA failed, error %u\n", GetLastError());
+    ok(msg.message == WM_QUIT, "expected msg.message = WM_QUIT, got %u\n", msg.message);
+    ok(msg.wParam == 42, "expected msg.wParam = 42, got %lu\n", msg.wParam);
+    index = WaitForSingleObject(thread, 200);
+    ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(thread);
+
+    PostQuitMessage(43);
+    memset(&msg, 0, sizeof(msg));
+    success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+    ok(success || broken(!success) /* Win 8 */, "PeekMessageA failed, error %u\n", GetLastError());
+    if (!success)
+        win_skip("PostQuitMessage didn't queue a WM_QUIT message, skipping tests\n");
+    else
+    {
+        ok(msg.message == WM_QUIT, "expected msg.message = WM_QUIT, got %u\n", msg.message);
+        ok(msg.wParam == 43, "expected msg.wParam = 43, got %lu\n", msg.wParam);
+        success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+        ok(!success, "PeekMessageA succeeded\n");
+
+        index = 0xdeadbeef;
+        PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+        PostQuitMessage(44);
+        thread = CreateThread(NULL, 0, post_message_thread, hWnd, 0, &tid);
+        ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+        hr = CoWaitForMultipleHandles(0, 100, 2, handles, &index);
+        ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+        ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+        success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+        ok(success, "PeekMessageA failed, error %u\n", GetLastError());
+        success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+        todo_wine
+        ok(!success, "PeekMessageA succeeded\n");
+        success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+        todo_wine
+        ok(!success, "CoWaitForMultipleHandles didn't remove WM_QUIT messages\n");
+        index = WaitForSingleObject(thread, 200);
+        ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+        CloseHandle(thread);
+
+        index = 0xdeadbeef;
+        PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+        PostQuitMessage(45);
+        thread = CreateThread(NULL, 0, send_message_thread, hWnd, 0, &tid);
+        ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+        hr = CoWaitForMultipleHandles(0, 100, 2, handles, &index);
+        ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+        ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+        success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+        ok(success, "PeekMessageA failed, error %u\n", GetLastError());
+        success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+        todo_wine
+        ok(!success, "PeekMessageA succeeded\n");
+        success = PeekMessageA(&msg, hWnd, WM_QUIT, WM_QUIT, PM_REMOVE);
+        ok(!success, "CoWaitForMultipleHandles didn't remove WM_QUIT messages\n");
+        index = WaitForSingleObject(thread, 200);
+        ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+        CloseHandle(thread);
+    }
+
     CloseHandle(handles[0]);
     CloseHandle(handles[1]);
     DestroyWindow(hWnd);
diff --git a/dlls/opengl32/wgl.c b/dlls/opengl32/wgl.c
index 9482c75..1903807 100644
--- a/dlls/opengl32/wgl.c
+++ b/dlls/opengl32/wgl.c
@@ -875,10 +875,7 @@ PROC WINAPI wglGetProcAddress( LPCSTR name )
         void *driver_func = funcs->wgl.p_wglGetProcAddress( name );
 
         if (!is_extension_supported(ext_ret->extension))
-        {
             WARN("Extension %s required for %s not supported\n", ext_ret->extension, name);
-            return NULL;
-        }
 
         if (driver_func == NULL)
         {
diff --git a/dlls/quartz/filtergraph.c b/dlls/quartz/filtergraph.c
index fcdd05b..a2d5a4f 100644
--- a/dlls/quartz/filtergraph.c
+++ b/dlls/quartz/filtergraph.c
@@ -201,7 +201,6 @@ typedef struct _IFilterGraphImpl {
     GUID timeformatseek;
     REFERENCE_TIME start_time;
     REFERENCE_TIME pause_time;
-    LONGLONG stop_position;
     LONG recursioncount;
     IUnknown *pSite;
     LONG version;
@@ -2449,52 +2448,6 @@ static HRESULT WINAPI MediaSeeking_GetDuration(IMediaSeeking *iface, LONGLONG *p
     return hr;
 }
 
-static HRESULT WINAPI MediaSeeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *pStop)
-{
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
-    HRESULT hr = S_OK;
-
-    TRACE("(%p/%p)->(%p)\n", This, iface, pStop);
-
-    if (!pStop)
-        return E_POINTER;
-
-    EnterCriticalSection(&This->cs);
-    if (This->stop_position < 0)
-        /* Stop position not set, use duration instead */
-        hr = IMediaSeeking_GetDuration(iface, pStop);
-    else
-        *pStop = This->stop_position;
-    LeaveCriticalSection(&This->cs);
-
-    return hr;
-}
-
-static HRESULT WINAPI MediaSeeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *pCurrent)
-{
-    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
-    LONGLONG time = 0;
-
-    if (!pCurrent)
-        return E_POINTER;
-
-    EnterCriticalSection(&This->cs);
-    if (This->state == State_Running && This->refClock && This->start_time >= 0)
-    {
-        IReferenceClock_GetTime(This->refClock, &time);
-        if (time)
-            time -= This->start_time;
-    }
-    if (This->pause_time > 0)
-        time += This->pause_time;
-    *pCurrent = time;
-    LeaveCriticalSection(&This->cs);
-
-    TRACE("Time: %u.%03u\n", (DWORD)(*pCurrent / 10000000), (DWORD)((*pCurrent / 10000)%1000));
-
-    return S_OK;
-}
-
 static HRESULT WINAPI MediaSeeking_ConvertTimeFormat(IMediaSeeking *iface, LONGLONG *pTarget,
         const GUID *pTargetFormat, LONGLONG Source, const GUID *pSourceFormat)
 {
@@ -2536,11 +2489,6 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
         (dwCurrentFlags & 0x7) != AM_SEEKING_NoPositioning)
         FIXME("Adjust method %x not handled yet!\n", dwCurrentFlags & 0x7);
 
-    if ((dwStopFlags & 0x7) == AM_SEEKING_AbsolutePositioning)
-        This->stop_position = *pStop;
-    else if ((dwStopFlags & 0x7) != AM_SEEKING_NoPositioning)
-        FIXME("Stop position not handled yet!\n");
-
     if (state == State_Running && !(dwCurrentFlags & AM_SEEKING_NoFlush))
         IMediaControl_Pause(&This->IMediaControl_iface);
     args.current = pCurrent;
@@ -2558,16 +2506,68 @@ static HRESULT WINAPI MediaSeeking_SetPositions(IMediaSeeking *iface, LONGLONG *
     return hr;
 }
 
+static HRESULT WINAPI found_getposition(IFilterGraphImpl *This, IMediaSeeking *seek, DWORD_PTR pargs)
+{
+    struct pos_args *args = (void*)pargs;
+
+    return IMediaSeeking_GetPositions(seek, args->current, args->stop);
+}
+
 static HRESULT WINAPI MediaSeeking_GetPositions(IMediaSeeking *iface, LONGLONG *pCurrent,
         LONGLONG *pStop)
 {
     IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    struct pos_args args;
+    LONGLONG time = 0;
     HRESULT hr;
 
     TRACE("(%p/%p)->(%p, %p)\n", This, iface, pCurrent, pStop);
-    hr = IMediaSeeking_GetCurrentPosition(iface, pCurrent);
-    if (SUCCEEDED(hr))
-        hr = IMediaSeeking_GetStopPosition(iface, pStop);
+
+    args.current = pCurrent;
+    args.stop = pStop;
+    EnterCriticalSection(&This->cs);
+    hr = all_renderers_seek(This, found_getposition, (DWORD_PTR)&args);
+    if (This->state == State_Running && This->refClock && This->start_time >= 0)
+    {
+        IReferenceClock_GetTime(This->refClock, &time);
+        if (time)
+            time -= This->start_time;
+    }
+    if (This->pause_time > 0)
+        time += This->pause_time;
+    *pCurrent += time;
+    LeaveCriticalSection(&This->cs);
+
+    return hr;
+}
+
+static HRESULT WINAPI MediaSeeking_GetCurrentPosition(IMediaSeeking *iface, LONGLONG *pCurrent)
+{
+    LONGLONG time;
+    HRESULT hr;
+
+    if (!pCurrent)
+        return E_POINTER;
+
+    hr = MediaSeeking_GetPositions(iface, pCurrent, &time);
+
+    TRACE("Time: %u.%03u\n", (DWORD)(*pCurrent / 10000000), (DWORD)((*pCurrent / 10000)%1000));
+
+    return hr;
+}
+
+static HRESULT WINAPI MediaSeeking_GetStopPosition(IMediaSeeking *iface, LONGLONG *pStop)
+{
+    IFilterGraphImpl *This = impl_from_IMediaSeeking(iface);
+    LONGLONG time;
+    HRESULT hr;
+
+    TRACE("(%p/%p)->(%p)\n", This, iface, pStop);
+
+    if (!pStop)
+        return E_POINTER;
+
+    hr = MediaSeeking_GetPositions(iface, &time, pStop);
 
     return hr;
 }
@@ -5681,7 +5681,6 @@ HRESULT FilterGraph_create(IUnknown *pUnkOuter, LPVOID *ppObj)
     fimpl->nItfCacheEntries = 0;
     memcpy(&fimpl->timeformatseek, &TIME_FORMAT_MEDIA_TIME, sizeof(GUID));
     fimpl->start_time = fimpl->pause_time = 0;
-    fimpl->stop_position = -1;
     fimpl->punkFilterMapper2 = NULL;
     fimpl->recursioncount = 0;
     fimpl->version = 0;
diff --git a/dlls/riched20/richole.c b/dlls/riched20/richole.c
index 5d662e4..a307843 100644
--- a/dlls/riched20/richole.c
+++ b/dlls/riched20/richole.c
@@ -45,10 +45,14 @@ DEFINE_GUID(IID_ITextHost2, 0x13e670f5,0x1a5a,0x11cf,0xab,0xeb,0x00,0xaa,0x00,0x
 DEFINE_GUID(IID_ITextDocument, 0x8cc497c0, 0xa1df, 0x11ce, 0x80, 0x98, 0x00, 0xaa, 0x00, 0x47, 0xbe, 0x5d);
 DEFINE_GUID(IID_ITextRange, 0x8cc497c2, 0xa1df, 0x11ce, 0x80, 0x98, 0x00, 0xaa, 0x00, 0x47, 0xbe, 0x5d);
 DEFINE_GUID(IID_ITextSelection, 0x8cc497c1, 0xa1df, 0x11ce, 0x80, 0x98, 0x00, 0xaa, 0x00, 0x47, 0xbe, 0x5d);
+DEFINE_GUID(IID_ITextFont, 0x8cc497c3, 0xa1df, 0x11ce, 0x80, 0x98, 0x00, 0xaa, 0x00, 0x47, 0xbe, 0x5d);
+DEFINE_GUID(IID_ITextPara, 0x8cc497c4, 0xa1df, 0x11ce, 0x80, 0x98, 0x00, 0xaa, 0x00, 0x47, 0xbe, 0x5d);
 
 typedef struct ITextSelectionImpl ITextSelectionImpl;
 typedef struct IOleClientSiteImpl IOleClientSiteImpl;
 typedef struct ITextRangeImpl ITextRangeImpl;
+typedef struct ITextFontImpl ITextFontImpl;
+typedef struct ITextParaImpl ITextParaImpl;
 
 typedef struct IRichEditOleImpl {
     IUnknown IUnknown_inner;
@@ -61,8 +65,30 @@ typedef struct IRichEditOleImpl {
     ITextSelectionImpl *txtSel;
     IOleClientSiteImpl *clientSite;
     struct list rangelist;
+    struct list fontlist;
+    struct list paralist;
 } IRichEditOleImpl;
 
+struct ITextParaImpl {
+    ITextPara ITextPara_iface;
+    LONG ref;
+    struct list entry;
+
+    IRichEditOleImpl *reOle;
+    ITextRangeImpl *txtRge;
+    ITextSelectionImpl *txtSel;
+};
+
+struct ITextFontImpl {
+    ITextFont ITextFont_iface;
+    LONG ref;
+    struct list entry;
+
+    IRichEditOleImpl *reOle;
+    ITextRangeImpl *txtRge;
+    ITextSelectionImpl *txtSel;
+};
+
 struct ITextRangeImpl {
     ITextRange ITextRange_iface;
     LONG ref;
@@ -121,6 +147,14 @@ static HRESULT WINAPI IRichEditOleImpl_inner_fnQueryInterface(IUnknown *iface, R
         IUnknown_AddRef((IUnknown *)*ppvObj);
         return S_OK;
     }
+
+    if (IsEqualGUID(riid, &IID_ITextServices))
+    {
+        static int once;
+        if (!once++) FIXME("%p: unhandled interface IID_ITextServices\n", This);
+        return E_NOINTERFACE;
+    }
+
     FIXME("%p: unhandled interface %s\n", This, debugstr_guid(riid));
  
     return E_NOINTERFACE;   
@@ -146,6 +180,8 @@ static ULONG WINAPI IRichEditOleImpl_inner_fnRelease(IUnknown *iface)
     if (!ref)
     {
         ITextRangeImpl *txtRge;
+        ITextFontImpl *txtFont;
+        ITextParaImpl *txtPara;
 
         TRACE("Destroying %p\n", This);
         This->txtSel->reOle = NULL;
@@ -154,6 +190,10 @@ static ULONG WINAPI IRichEditOleImpl_inner_fnRelease(IUnknown *iface)
         IOleClientSite_Release(&This->clientSite->IOleClientSite_iface);
         LIST_FOR_EACH_ENTRY(txtRge, &This->rangelist, ITextRangeImpl, entry)
             txtRge->reOle = NULL;
+        LIST_FOR_EACH_ENTRY(txtFont, &This->fontlist, ITextFontImpl, entry)
+            txtFont->reOle = NULL;
+        LIST_FOR_EACH_ENTRY(txtPara, &This->paralist, ITextParaImpl, entry)
+            txtPara->reOle = NULL;
         heap_free(This);
     }
     return ref;
@@ -563,120 +603,1509 @@ IRichEditOle_fnGetClipboardData(IRichEditOle *me, CHARRANGE *lpchrg,
 
 static LONG WINAPI IRichEditOle_fnGetLinkCount(IRichEditOle *me)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnGetObject(IRichEditOle *me, LONG iob,
+               REOBJECT *lpreobject, DWORD dwFlags)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static LONG WINAPI
+IRichEditOle_fnGetObjectCount(IRichEditOle *me)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return 0;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnHandsOffStorage(IRichEditOle *me, LONG iob)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnImportDataObject(IRichEditOle *me, LPDATAOBJECT lpdataobj,
+               CLIPFORMAT cf, HGLOBAL hMetaPict)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnInPlaceDeactivate(IRichEditOle *me)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnInsertObject(IRichEditOle *me, REOBJECT *reo)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    TRACE("(%p,%p)\n", This, reo);
+
+    if (reo->cbStruct < sizeof(*reo)) return STG_E_INVALIDPARAMETER;
+
+    ME_InsertOLEFromCursor(This->editor, reo, 0);
+    ME_CommitUndo(This->editor);
+    ME_UpdateRepaint(This->editor, FALSE);
+    return S_OK;
+}
+
+static HRESULT WINAPI IRichEditOle_fnSaveCompleted(IRichEditOle *me, LONG iob,
+               LPSTORAGE lpstg)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnSetDvaspect(IRichEditOle *me, LONG iob, DWORD dvaspect)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI IRichEditOle_fnSetHostNames(IRichEditOle *me,
+               LPCSTR lpstrContainerApp, LPCSTR lpstrContainerObj)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p %s %s\n",This, lpstrContainerApp, lpstrContainerObj);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI
+IRichEditOle_fnSetLinkAvailable(IRichEditOle *me, LONG iob, BOOL fAvailable)
+{
+    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
+    FIXME("stub %p\n",This);
+    return E_NOTIMPL;
+}
+
+static const IRichEditOleVtbl revt = {
+    IRichEditOle_fnQueryInterface,
+    IRichEditOle_fnAddRef,
+    IRichEditOle_fnRelease,
+    IRichEditOle_fnGetClientSite,
+    IRichEditOle_fnGetObjectCount,
+    IRichEditOle_fnGetLinkCount,
+    IRichEditOle_fnGetObject,
+    IRichEditOle_fnInsertObject,
+    IRichEditOle_fnConvertObject,
+    IRichEditOle_fnActivateAs,
+    IRichEditOle_fnSetHostNames,
+    IRichEditOle_fnSetLinkAvailable,
+    IRichEditOle_fnSetDvaspect,
+    IRichEditOle_fnHandsOffStorage,
+    IRichEditOle_fnSaveCompleted,
+    IRichEditOle_fnInPlaceDeactivate,
+    IRichEditOle_fnContextSensitiveHelp,
+    IRichEditOle_fnGetClipboardData,
+    IRichEditOle_fnImportDataObject
+};
+
+/* ITextPara interface */
+static inline ITextParaImpl *impl_from_ITextPara(ITextPara *iface)
+{
+    return CONTAINING_RECORD(iface, ITextParaImpl, ITextPara_iface);
+}
+
+static HRESULT WINAPI ITextPara_fnQueryInterface(ITextPara *me, REFIID riid, void **ppvObj)
+{
+    *ppvObj = NULL;
+    if (IsEqualGUID(riid, &IID_IUnknown)
+        || IsEqualGUID(riid, &IID_ITextPara)
+        || IsEqualGUID(riid, &IID_IDispatch))
+    {
+        *ppvObj = me;
+        ITextPara_AddRef(me);
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ITextPara_fnAddRef(ITextPara *me)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    return InterlockedIncrement(&This->ref);
+}
+
+static ULONG WINAPI ITextPara_fnRelease(ITextPara *me)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE ("%p ref=%u\n", This, ref);
+    if (ref == 0)
+    {
+        if (This->txtRge)
+            ITextRange_Release(&This->txtRge->ITextRange_iface);
+        else
+            ITextSelection_Release(&This->txtSel->ITextSelection_iface);
+        This->txtRge = NULL;
+        This->txtSel = NULL;
+        if (This->reOle)
+        {
+            list_remove(&This->entry);
+            This->reOle = NULL;
+        }
+        heap_free(This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI ITextPara_fnGetTypeInfoCount(ITextPara *me, UINT *pctinfo)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetTypeInfo(ITextPara *me, UINT iTInfo, LCID lcid,
+                                              ITypeInfo **ppTInfo)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetIDsOfNames(ITextPara *me, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnInvoke(ITextPara *me, DISPID dispIdMember, REFIID riid,
+                                         LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                                         VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
+                                         UINT *puArgErr)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetDuplicate(ITextPara *me, ITextPara **ppPara)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetDuplicate(ITextPara *me, ITextPara *pPara)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnCanChange(ITextPara *me, LONG *pB)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnIsEqual(ITextPara *me, ITextPara *pPara, LONG *pB)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnReset(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetStyle(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetStyle(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetAlignment(ITextPara *me, LONG *pValue)
+{
+    static int once;
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    if (!once++) FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetAlignment(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetHyphenation(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetHyphenation(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetFirstLineIndent(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetKeepTogether(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetKeepTogether(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetKeepWithNext(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetKeepWithNext(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetLeftIndent(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetLineSpacing(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetLineSpacingRule(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetListAlignment(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetListAlignment(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetListLevelIndex(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetListLevelIndex(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetListStart(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetListStart(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetListTab(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetListTab(ITextPara *me, float Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetListType(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetListType(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetNoLineNumber(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetNoLineNumber(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetPageBreakBefore(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetPageBreakBefore(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetRightIndent(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetRightIndent(ITextPara *me, float Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetIndents(ITextPara *me, float StartIndent, float LeftIndent,
+                                             float RightIndent)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetLineSpacing(ITextPara *me, LONG LineSpacingRule, float LineSpacing)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetSpaceAfter(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetSpaceAfter(ITextPara *me, float Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetSpaceBefore(ITextPara *me, float *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetSpaceBefore(ITextPara *me, float Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetWindowControl(ITextPara *me, LONG *pValue)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnSetWindowControl(ITextPara *me, LONG Value)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetTabCount(ITextPara *me, LONG *pCount)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnAddTab(ITextPara *me, float tbPos, LONG tbAlign, LONG tbLeader)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnClearAllTabs(ITextPara *me)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnDeleteTab(ITextPara *me, float tbPos)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextPara_fnGetTab(ITextPara *me, LONG iTab, float *ptbPos,
+                                         LONG *ptbAlign, LONG *ptbLeader)
+{
+    ITextParaImpl *This = impl_from_ITextPara(me);
+    if (!This->reOle)
+         return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static const ITextParaVtbl tpvt = {
+    ITextPara_fnQueryInterface,
+    ITextPara_fnAddRef,
+    ITextPara_fnRelease,
+    ITextPara_fnGetTypeInfoCount,
+    ITextPara_fnGetTypeInfo,
+    ITextPara_fnGetIDsOfNames,
+    ITextPara_fnInvoke,
+    ITextPara_fnGetDuplicate,
+    ITextPara_fnSetDuplicate,
+    ITextPara_fnCanChange,
+    ITextPara_fnIsEqual,
+    ITextPara_fnReset,
+    ITextPara_fnGetStyle,
+    ITextPara_fnSetStyle,
+    ITextPara_fnGetAlignment,
+    ITextPara_fnSetAlignment,
+    ITextPara_fnGetHyphenation,
+    ITextPara_fnSetHyphenation,
+    ITextPara_fnGetFirstLineIndent,
+    ITextPara_fnGetKeepTogether,
+    ITextPara_fnSetKeepTogether,
+    ITextPara_fnGetKeepWithNext,
+    ITextPara_fnSetKeepWithNext,
+    ITextPara_fnGetLeftIndent,
+    ITextPara_fnGetLineSpacing,
+    ITextPara_fnGetLineSpacingRule,
+    ITextPara_fnGetListAlignment,
+    ITextPara_fnSetListAlignment,
+    ITextPara_fnGetListLevelIndex,
+    ITextPara_fnSetListLevelIndex,
+    ITextPara_fnGetListStart,
+    ITextPara_fnSetListStart,
+    ITextPara_fnGetListTab,
+    ITextPara_fnSetListTab,
+    ITextPara_fnGetListType,
+    ITextPara_fnSetListType,
+    ITextPara_fnGetNoLineNumber,
+    ITextPara_fnSetNoLineNumber,
+    ITextPara_fnGetPageBreakBefore,
+    ITextPara_fnSetPageBreakBefore,
+    ITextPara_fnGetRightIndent,
+    ITextPara_fnSetRightIndent,
+    ITextPara_fnSetIndents,
+    ITextPara_fnSetLineSpacing,
+    ITextPara_fnGetSpaceAfter,
+    ITextPara_fnSetSpaceAfter,
+    ITextPara_fnGetSpaceBefore,
+    ITextPara_fnSetSpaceBefore,
+    ITextPara_fnGetWindowControl,
+    ITextPara_fnSetWindowControl,
+    ITextPara_fnGetTabCount,
+    ITextPara_fnAddTab,
+    ITextPara_fnClearAllTabs,
+    ITextPara_fnDeleteTab,
+    ITextPara_fnGetTab
+};
+/* ITextPara interface */
+
+/* ITextFont interface */
+static inline ITextFontImpl *impl_from_ITextFont(ITextFont *iface)
+{
+    return CONTAINING_RECORD(iface, ITextFontImpl, ITextFont_iface);
+}
+
+static HRESULT WINAPI ITextFont_fnQueryInterface(ITextFont *me, REFIID riid, void **ppvObj)
+{
+    *ppvObj = NULL;
+    if (IsEqualGUID(riid, &IID_IUnknown)
+        || IsEqualGUID(riid, &IID_ITextFont)
+        || IsEqualGUID(riid, &IID_IDispatch))
+    {
+        *ppvObj = me;
+        ITextFont_AddRef(me);
+        return S_OK;
+    }
+
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI ITextFont_fnAddRef(ITextFont *me)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    return InterlockedIncrement(&This->ref);
+}
+
+static ULONG WINAPI ITextFont_fnRelease(ITextFont *me)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    ULONG ref = InterlockedDecrement(&This->ref);
+
+    TRACE ("%p ref=%u\n", This, ref);
+    if (ref == 0)
+    {
+        if (This->txtRge)
+            ITextRange_Release(&This->txtRge->ITextRange_iface);
+        else
+            ITextSelection_Release(&This->txtSel->ITextSelection_iface);
+        This->txtRge = NULL;
+        This->txtSel = NULL;
+        if (This->reOle)
+        {
+            list_remove(&This->entry);
+            This->reOle = NULL;
+        }
+        heap_free(This);
+    }
+    return ref;
+}
+
+static HRESULT WINAPI ITextFont_fnGetTypeInfoCount(ITextFont *me, UINT *pctinfo)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetTypeInfo(ITextFont *me, UINT iTInfo, LCID lcid,
+                                              ITypeInfo **ppTInfo)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetIDsOfNames(ITextFont *me, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnInvoke(ITextFont *me, DISPID dispIdMember, REFIID riid,
+                                         LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                                         VARIANT *pVarResult, EXCEPINFO *pExcepInfo,
+                                         UINT *puArgErr)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetDuplicate(ITextFont *me, ITextFont **ppFont)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetDuplicate(ITextFont *me, ITextFont *pFont)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnCanChange(ITextFont *me, LONG *pB)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnIsEqual(ITextFont *me, ITextFont *pFont, LONG *pB)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnReset(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetStyle(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetStyle(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetAllCaps(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetAllCaps(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetAnimation(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetAnimation(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetBackColor(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetBackColor(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetBold(ITextFont *me, LONG *pValue)
+{
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = tomFalse;
+    return S_OK;
+}
+
+static HRESULT WINAPI ITextFont_fnSetBold(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetEmboss(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetEmboss(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetForeColor(ITextFont *me, LONG *pValue)
+{
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = tomAutoColor;
+    return S_OK;
+}
+
+static HRESULT WINAPI ITextFont_fnSetForeColor(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetHidden(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetHidden(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetEngrave(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetEngrave(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetItalic(ITextFont *me, LONG *pValue)
+{
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = tomFalse;
+    return S_OK;
+}
+
+static HRESULT WINAPI ITextFont_fnSetItalic(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetKerning(ITextFont *me, float *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetKerning(ITextFont *me, float Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetLanguageID(ITextFont *me, LONG *pValue)
+{
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetLanguageID(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetName(ITextFont *me, BSTR *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    WCHAR font[] = {'S', 'y', 's', 't', 'e', 'm', 0};
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("Stub\n");
+    *pValue = SysAllocString(font);
+    return S_OK;
+}
+
+static HRESULT WINAPI ITextFont_fnSetName(ITextFont *me, BSTR Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetOutline(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetOutline(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetPosition(ITextFont *me, float *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetPosition(ITextFont *me, float Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetProtected(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetProtected(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetShadow(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetShadow(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetSize(ITextFont *me, float *pValue)
+{
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = 12.0;
+    return S_OK;
+}
+
+static HRESULT WINAPI ITextFont_fnSetSize(ITextFont *me, float Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetSmallCaps(ITextFont *me, LONG *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnSetSmallCaps(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI ITextFont_fnGetSpacing(ITextFont *me, float *pValue)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnGetObject(IRichEditOle *me, LONG iob,
-               REOBJECT *lpreobject, DWORD dwFlags)
+static HRESULT WINAPI ITextFont_fnSetSpacing(ITextFont *me, float Value)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static LONG WINAPI
-IRichEditOle_fnGetObjectCount(IRichEditOle *me)
+static HRESULT WINAPI ITextFont_fnGetStrikeThrough(ITextFont *me, LONG *pValue)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
-    return 0;
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = tomFalse;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnHandsOffStorage(IRichEditOle *me, LONG iob)
+static HRESULT WINAPI ITextFont_fnSetStrikeThrough(ITextFont *me, LONG Value)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnImportDataObject(IRichEditOle *me, LPDATAOBJECT lpdataobj,
-               CLIPFORMAT cf, HGLOBAL hMetaPict)
+static HRESULT WINAPI ITextFont_fnGetSubscript(ITextFont *me, LONG *pValue)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
-    return E_NOTIMPL;
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+      return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = tomFalse;
+    return S_OK;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnInPlaceDeactivate(IRichEditOle *me)
+static HRESULT WINAPI ITextFont_fnSetSubscript(ITextFont *me, LONG Value)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnInsertObject(IRichEditOle *me, REOBJECT *reo)
+static HRESULT WINAPI ITextFont_fnGetSuperscript(ITextFont *me, LONG *pValue)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    TRACE("(%p,%p)\n", This, reo);
-
-    if (reo->cbStruct < sizeof(*reo)) return STG_E_INVALIDPARAMETER;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
 
-    ME_InsertOLEFromCursor(This->editor, reo, 0);
-    ME_CommitUndo(This->editor);
-    ME_UpdateRepaint(This->editor, FALSE);
+    FIXME("Stub\n");
+    *pValue = tomFalse;
     return S_OK;
 }
 
-static HRESULT WINAPI IRichEditOle_fnSaveCompleted(IRichEditOle *me, LONG iob,
-               LPSTORAGE lpstg)
+static HRESULT WINAPI ITextFont_fnSetSuperscript(ITextFont *me, LONG Value)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnSetDvaspect(IRichEditOle *me, LONG iob, DWORD dvaspect)
+static HRESULT WINAPI ITextFont_fnGetUnderline(ITextFont *me, LONG *pValue)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
-    return E_NOTIMPL;
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!pValue)
+        return E_INVALIDARG;
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("Stub\n");
+    *pValue = tomNone;
+    return S_OK;
 }
 
-static HRESULT WINAPI IRichEditOle_fnSetHostNames(IRichEditOle *me,
-               LPCSTR lpstrContainerApp, LPCSTR lpstrContainerObj)
+static HRESULT WINAPI ITextFont_fnSetUnderline(ITextFont *me, LONG Value)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p %s %s\n",This, lpstrContainerApp, lpstrContainerObj);
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static HRESULT WINAPI
-IRichEditOle_fnSetLinkAvailable(IRichEditOle *me, LONG iob, BOOL fAvailable)
+static HRESULT WINAPI ITextFont_fnGetWeight(ITextFont *me, LONG *pValue)
 {
-    IRichEditOleImpl *This = impl_from_IRichEditOle(me);
-    FIXME("stub %p\n",This);
+    static int once;
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    if (!once++) FIXME("not implemented: %p\n", This);
     return E_NOTIMPL;
 }
 
-static const IRichEditOleVtbl revt = {
-    IRichEditOle_fnQueryInterface,
-    IRichEditOle_fnAddRef,
-    IRichEditOle_fnRelease,
-    IRichEditOle_fnGetClientSite,
-    IRichEditOle_fnGetObjectCount,
-    IRichEditOle_fnGetLinkCount,
-    IRichEditOle_fnGetObject,
-    IRichEditOle_fnInsertObject,
-    IRichEditOle_fnConvertObject,
-    IRichEditOle_fnActivateAs,
-    IRichEditOle_fnSetHostNames,
-    IRichEditOle_fnSetLinkAvailable,
-    IRichEditOle_fnSetDvaspect,
-    IRichEditOle_fnHandsOffStorage,
-    IRichEditOle_fnSaveCompleted,
-    IRichEditOle_fnInPlaceDeactivate,
-    IRichEditOle_fnContextSensitiveHelp,
-    IRichEditOle_fnGetClipboardData,
-    IRichEditOle_fnImportDataObject
+static HRESULT WINAPI ITextFont_fnSetWeight(ITextFont *me, LONG Value)
+{
+    ITextFontImpl *This = impl_from_ITextFont(me);
+    if (!This->reOle)
+        return CO_E_RELEASED;
+
+    FIXME("not implemented: %p\n", This);
+    return E_NOTIMPL;
+}
+
+static const ITextFontVtbl tfvt = {
+    ITextFont_fnQueryInterface,
+    ITextFont_fnAddRef,
+    ITextFont_fnRelease,
+    ITextFont_fnGetTypeInfoCount,
+    ITextFont_fnGetTypeInfo,
+    ITextFont_fnGetIDsOfNames,
+    ITextFont_fnInvoke,
+    ITextFont_fnGetDuplicate,
+    ITextFont_fnSetDuplicate,
+    ITextFont_fnCanChange,
+    ITextFont_fnIsEqual,
+    ITextFont_fnReset,
+    ITextFont_fnGetStyle,
+    ITextFont_fnSetStyle,
+    ITextFont_fnGetAllCaps,
+    ITextFont_fnSetAllCaps,
+    ITextFont_fnGetAnimation,
+    ITextFont_fnSetAnimation,
+    ITextFont_fnGetBackColor,
+    ITextFont_fnSetBackColor,
+    ITextFont_fnGetBold,
+    ITextFont_fnSetBold,
+    ITextFont_fnGetEmboss,
+    ITextFont_fnSetEmboss,
+    ITextFont_fnGetForeColor,
+    ITextFont_fnSetForeColor,
+    ITextFont_fnGetHidden,
+    ITextFont_fnSetHidden,
+    ITextFont_fnGetEngrave,
+    ITextFont_fnSetEngrave,
+    ITextFont_fnGetItalic,
+    ITextFont_fnSetItalic,
+    ITextFont_fnGetKerning,
+    ITextFont_fnSetKerning,
+    ITextFont_fnGetLanguageID,
+    ITextFont_fnSetLanguageID,
+    ITextFont_fnGetName,
+    ITextFont_fnSetName,
+    ITextFont_fnGetOutline,
+    ITextFont_fnSetOutline,
+    ITextFont_fnGetPosition,
+    ITextFont_fnSetPosition,
+    ITextFont_fnGetProtected,
+    ITextFont_fnSetProtected,
+    ITextFont_fnGetShadow,
+    ITextFont_fnSetShadow,
+    ITextFont_fnGetSize,
+    ITextFont_fnSetSize,
+    ITextFont_fnGetSmallCaps,
+    ITextFont_fnSetSmallCaps,
+    ITextFont_fnGetSpacing,
+    ITextFont_fnSetSpacing,
+    ITextFont_fnGetStrikeThrough,
+    ITextFont_fnSetStrikeThrough,
+    ITextFont_fnGetSubscript,
+    ITextFont_fnSetSubscript,
+    ITextFont_fnGetSuperscript,
+    ITextFont_fnSetSuperscript,
+    ITextFont_fnGetUnderline,
+    ITextFont_fnSetUnderline,
+    ITextFont_fnGetWeight,
+    ITextFont_fnSetWeight
 };
+/* ITextFont interface */
 
 /* ITextRange interface */
 static inline ITextRangeImpl *impl_from_ITextRange(ITextRange *iface)
@@ -768,14 +2197,40 @@ static HRESULT WINAPI ITextRange_fnInvoke(ITextRange *me, DISPID dispIdMember, R
     return E_NOTIMPL;
 }
 
+static HRESULT range_GetText(ME_TextEditor *editor, ME_Cursor *start, ME_Cursor *end, BSTR *pbstr)
+{
+    int nChars, endOfs;
+    BOOL bEOP;
+
+    endOfs = ME_GetCursorOfs(end);
+    nChars = endOfs - ME_GetCursorOfs(start);
+    if (!nChars)
+    {
+        *pbstr = NULL;
+        return S_OK;
+    }
+
+    *pbstr = SysAllocStringLen(NULL, nChars);
+    if (!*pbstr)
+        return E_OUTOFMEMORY;
+
+    bEOP = (end->pRun->next->type == diTextEnd && endOfs > ME_GetTextLength(editor));
+    ME_GetTextW(editor, *pbstr, nChars, start, nChars, FALSE, bEOP);
+    TRACE("%s\n", wine_dbgstr_w(*pbstr));
+
+    return S_OK;
+}
+
 static HRESULT WINAPI ITextRange_fnGetText(ITextRange *me, BSTR *pbstr)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
+    ME_Cursor start, end;
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    ME_CursorFromCharOfs(This->reOle->editor, This->start, &start);
+    ME_CursorFromCharOfs(This->reOle->editor, This->end, &end);
+    return range_GetText(This->reOle->editor, &start, &end, pbstr);
 }
 
 static HRESULT WINAPI ITextRange_fnSetText(ITextRange *me, BSTR bstr)
@@ -871,14 +2326,27 @@ static HRESULT WINAPI ITextRange_fnGetStart(ITextRange *me, LONG *pcpFirst)
     return S_OK;
 }
 
+static HRESULT range_SetStart(ME_TextEditor *editor, LONG cpFirst, LONG *start, LONG *end)
+{
+    int len = ME_GetTextLength(editor);
+
+    TRACE("%d\n", cpFirst);
+    if (cpFirst == *start)
+        return S_FALSE;
+    cpFirst = min(cpFirst, len);
+    cpFirst = max(cpFirst, 0);
+    *end = max(*end, cpFirst);
+    *start = cpFirst;
+    return S_OK;
+}
+
 static HRESULT WINAPI ITextRange_fnSetStart(ITextRange *me, LONG cpFirst)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    return range_SetStart(This->reOle->editor, cpFirst, &This->start, &This->end);
 }
 
 static HRESULT WINAPI ITextRange_fnGetEnd(ITextRange *me, LONG *pcpLim)
@@ -894,24 +2362,65 @@ static HRESULT WINAPI ITextRange_fnGetEnd(ITextRange *me, LONG *pcpLim)
     return S_OK;
 }
 
+static HRESULT range_SetEnd(ME_TextEditor *editor, LONG cpLim, LONG *start, LONG *end)
+{
+    int len = ME_GetTextLength(editor) + 1;
+
+    TRACE("%d\n", cpLim);
+    if (cpLim == *end)
+        return S_FALSE;
+    cpLim = min(cpLim, len);
+    cpLim = max(cpLim, 0);
+    *start = min(*start, cpLim);
+    *end = cpLim;
+    return S_OK;
+}
+
 static HRESULT WINAPI ITextRange_fnSetEnd(ITextRange *me, LONG cpLim)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    return range_SetEnd(This->reOle->editor, cpLim, &This->start, &This->end);
+}
+
+static HRESULT CreateITextFont(IRichEditOleImpl *reOle, ITextFontImpl **ptxtFont)
+{
+    ITextFontImpl *txtFont = NULL;
+    txtFont = heap_alloc(sizeof(ITextFontImpl));
+    if (!txtFont)
+        return E_OUTOFMEMORY;
+
+    txtFont->ITextFont_iface.lpVtbl = &tfvt;
+    txtFont->ref = 1;
+    txtFont->reOle = reOle;
+    list_add_head(&reOle->fontlist, &txtFont->entry);
+    *ptxtFont = txtFont;
+    return S_OK;
 }
 
 static HRESULT WINAPI ITextRange_fnGetFont(ITextRange *me, ITextFont **pFont)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
+    ITextFontImpl *txtFont = NULL;
+    HRESULT hres;
+
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    TRACE("%p\n", This);
+    if (!pFont)
+        return E_INVALIDARG;
+    hres = CreateITextFont(This->reOle, &txtFont);
+    if (!hres)
+    {
+        txtFont->txtSel = NULL;
+        txtFont->txtRge = This;
+        ITextRange_AddRef(me);
+        *pFont = &txtFont->ITextFont_iface;
+    }
+    return hres;
 }
 
 static HRESULT WINAPI ITextRange_fnSetFont(ITextRange *me, ITextFont *pFont)
@@ -924,14 +2433,42 @@ static HRESULT WINAPI ITextRange_fnSetFont(ITextRange *me, ITextFont *pFont)
     return E_NOTIMPL;
 }
 
+static HRESULT CreateITextPara(IRichEditOleImpl *reOle, ITextParaImpl **ptxtPara)
+{
+    ITextParaImpl *txtPara = NULL;
+    txtPara = heap_alloc(sizeof(ITextParaImpl));
+    if (!txtPara)
+        return E_OUTOFMEMORY;
+
+    txtPara->ITextPara_iface.lpVtbl = &tpvt;
+    txtPara->ref = 1;
+    txtPara->reOle = reOle;
+    list_add_head(&reOle->paralist, &txtPara->entry);
+    *ptxtPara = txtPara;
+    return S_OK;
+}
+
 static HRESULT WINAPI ITextRange_fnGetPara(ITextRange *me, ITextPara **ppPara)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
+    ITextParaImpl *txtPara = NULL;
+    HRESULT hres;
+
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    TRACE("%p\n", This);
+    if (!ppPara)
+        return E_INVALIDARG;
+    hres = CreateITextPara(This->reOle, &txtPara);
+    if (!hres)
+    {
+        txtPara->txtSel = NULL;
+        txtPara->txtRge = This;
+        ITextRange_AddRef(me);
+        *ppPara = &txtPara->ITextPara_iface;
+    }
+    return hres;
 }
 
 static HRESULT WINAPI ITextRange_fnSetPara(ITextRange *me, ITextPara *pPara)
@@ -950,8 +2487,10 @@ static HRESULT WINAPI ITextRange_fnGetStoryLength(ITextRange *me, LONG *pcch)
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    if (!pcch)
+        return E_INVALIDARG;
+    *pcch = ME_GetTextLength(This->reOle->editor) + 1;
+    return S_OK;
 }
 
 static HRESULT WINAPI ITextRange_fnGetStoryType(ITextRange *me, LONG *pValue)
@@ -1016,14 +2555,36 @@ static HRESULT WINAPI ITextRange_fnSetIndex(ITextRange *me, LONG Unit, LONG Inde
     return E_NOTIMPL;
 }
 
+static void cp2range(ME_TextEditor *editor, LONG *cp1, LONG *cp2)
+{
+    int len = ME_GetTextLength(editor) + 1;
+    *cp1 = max(*cp1, 0);
+    *cp2 = max(*cp2, 0);
+    *cp1 = min(*cp1, len);
+    *cp2 = min(*cp2, len);
+    if (*cp1 > *cp2)
+    {
+        int tmp = *cp1;
+        *cp1 = *cp2;
+        *cp2 = tmp;
+    }
+    if (*cp1 == len)
+        *cp1 = *cp2 = len - 1;
+}
+
 static HRESULT WINAPI ITextRange_fnSetRange(ITextRange *me, LONG cpActive, LONG cpOther)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    cp2range(This->reOle->editor, &cpActive, &cpOther);
+    if (cpActive == This->start && cpOther == This->end)
+        return S_FALSE;
+
+    This->start = cpActive;
+    This->end = cpOther;
+    return S_OK;
 }
 
 static HRESULT WINAPI ITextRange_fnInRange(ITextRange *me, ITextRange *pRange, LONG *pb)
@@ -1046,14 +2607,29 @@ static HRESULT WINAPI ITextRange_fnInStory(ITextRange *me, ITextRange *pRange, L
     return E_NOTIMPL;
 }
 
+static HRESULT range_IsEqual(LONG start, LONG end, ITextRange *pRange, LONG *pb)
+{
+    ITextRangeImpl *pRangeImpl = impl_from_ITextRange(pRange);
+    if (start == pRangeImpl->start && end == pRangeImpl->end)
+    {
+        if (pb)
+            *pb = tomTrue;
+        return S_OK;
+    }
+    if (pb)
+        *pb = tomFalse;
+    return S_FALSE;
+}
+
 static HRESULT WINAPI ITextRange_fnIsEqual(ITextRange *me, ITextRange *pRange, LONG *pb)
 {
     ITextRangeImpl *This = impl_from_ITextRange(me);
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented %p\n", This);
-    return E_NOTIMPL;
+    if (!pRange)
+        return S_FALSE;
+    return range_IsEqual(This->start, This->end, pRange, pb);
 }
 
 static HRESULT WINAPI ITextRange_fnSelect(ITextRange *me)
@@ -1618,26 +3194,12 @@ ITextDocument_fnRange(ITextDocument* me, LONG cp1, LONG cp2,
     ITextRange** ppRange)
 {
     IRichEditOleImpl *This = impl_from_ITextDocument(me);
-    const int len = ME_GetTextLength(This->editor) + 1;
 
     TRACE("%p %p %d %d\n", This, ppRange, cp1, cp2);
     if (!ppRange)
         return E_INVALIDARG;
 
-    cp1 = max(cp1, 0);
-    cp2 = max(cp2, 0);
-    cp1 = min(cp1, len);
-    cp2 = min(cp2, len);
-    if (cp1 > cp2)
-    {
-        LONG tmp;
-        tmp = cp1;
-        cp1 = cp2;
-        cp2 = tmp;
-    }
-    if (cp1 == len)
-        cp1 = cp2 = len - 1;
-
+    cp2range(This->editor, &cp1, &cp2);
     return CreateITextRange(This, cp1, cp2, ppRange);
 }
 
@@ -1770,8 +3332,6 @@ static HRESULT WINAPI ITextSelection_fnGetText(ITextSelection *me, BSTR *pbstr)
 {
     ITextSelectionImpl *This = impl_from_ITextSelection(me);
     ME_Cursor *start = NULL, *end = NULL;
-    int nChars, endOfs;
-    BOOL bEOP;
 
     if (!This->reOle)
         return CO_E_RELEASED;
@@ -1780,23 +3340,7 @@ static HRESULT WINAPI ITextSelection_fnGetText(ITextSelection *me, BSTR *pbstr)
         return E_INVALIDARG;
 
     ME_GetSelection(This->reOle->editor, &start, &end);
-    endOfs = ME_GetCursorOfs(end);
-    nChars = endOfs - ME_GetCursorOfs(start);
-    if (!nChars)
-    {
-        *pbstr = NULL;
-        return S_OK;
-    }
-
-    *pbstr = SysAllocStringLen(NULL, nChars);
-    if (!*pbstr)
-        return E_OUTOFMEMORY;
-
-    bEOP = (end->pRun->next->type == diTextEnd && endOfs > ME_GetTextLength(This->reOle->editor));
-    ME_GetTextW(This->reOle->editor, *pbstr, nChars, start, nChars, FALSE, bEOP);
-    TRACE("%s\n", wine_dbgstr_w(*pbstr));
-
-    return S_OK;
+    return range_GetText(This->reOle->editor, start, end, pbstr);
 }
 
 static HRESULT WINAPI ITextSelection_fnSetText(ITextSelection *me, BSTR bstr)
@@ -1837,11 +3381,17 @@ static HRESULT WINAPI ITextSelection_fnSetChar(ITextSelection *me, LONG ch)
 static HRESULT WINAPI ITextSelection_fnGetDuplicate(ITextSelection *me, ITextRange **ppRange)
 {
     ITextSelectionImpl *This = impl_from_ITextSelection(me);
+    int start, end;
+
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented\n");
-    return E_NOTIMPL;
+    TRACE("%p %p\n", This, ppRange);
+    if (!ppRange)
+        return E_INVALIDARG;
+
+    ME_GetSelectionOfs(This->reOle->editor, &start, &end);
+    return CreateITextRange(This->reOle, start, end, ppRange);
 }
 
 static HRESULT WINAPI ITextSelection_fnGetFormattedText(ITextSelection *me, ITextRange **ppRange)
@@ -1881,11 +3431,16 @@ static HRESULT WINAPI ITextSelection_fnGetStart(ITextSelection *me, LONG *pcpFir
 static HRESULT WINAPI ITextSelection_fnSetStart(ITextSelection *me, LONG cpFirst)
 {
     ITextSelectionImpl *This = impl_from_ITextSelection(me);
+    int start, end;
+    HRESULT hres;
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented\n");
-    return E_NOTIMPL;
+    ME_GetSelectionOfs(This->reOle->editor, &start, &end);
+    hres = range_SetStart(This->reOle->editor, cpFirst, &start, &end);
+    if (!hres)
+        ME_SetSelection(This->reOle->editor, start, end);
+    return hres;
 }
 
 static HRESULT WINAPI ITextSelection_fnGetEnd(ITextSelection *me, LONG *pcpLim)
@@ -1905,21 +3460,39 @@ static HRESULT WINAPI ITextSelection_fnGetEnd(ITextSelection *me, LONG *pcpLim)
 static HRESULT WINAPI ITextSelection_fnSetEnd(ITextSelection *me, LONG cpLim)
 {
     ITextSelectionImpl *This = impl_from_ITextSelection(me);
+    int start, end;
+    HRESULT hres;
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented\n");
-    return E_NOTIMPL;
+    ME_GetSelectionOfs(This->reOle->editor, &start, &end);
+    hres = range_SetEnd(This->reOle->editor, cpLim, &start, &end);
+    if (!hres)
+        ME_SetSelection(This->reOle->editor, start, end);
+    return hres;
 }
 
 static HRESULT WINAPI ITextSelection_fnGetFont(ITextSelection *me, ITextFont **pFont)
 {
     ITextSelectionImpl *This = impl_from_ITextSelection(me);
+    ITextFontImpl *txtFont = NULL;
+    HRESULT hres;
+
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented\n");
-    return E_NOTIMPL;
+    TRACE("%p\n", This);
+    if (!pFont)
+        return E_INVALIDARG;
+    hres = CreateITextFont(This->reOle, &txtFont);
+    if (!hres)
+    {
+        txtFont->txtSel = This;
+        txtFont->txtRge = NULL;
+        ITextSelection_AddRef(me);
+        *pFont = &txtFont->ITextFont_iface;
+    }
+    return hres;
 }
 
 static HRESULT WINAPI ITextSelection_fnSetFont(ITextSelection *me, ITextFont *pFont)
@@ -1958,8 +3531,10 @@ static HRESULT WINAPI ITextSelection_fnGetStoryLength(ITextSelection *me, LONG *
     if (!This->reOle)
         return CO_E_RELEASED;
 
-    FIXME("not implemented\n");
-    return E_NOTIMPL;
+    if (!pcch)
+        return E_INVALIDARG;
+    *pcch = ME_GetTextLength(This->reOle->editor) + 1;
+    return S_OK;
 }
 
 static HRESULT WINAPI ITextSelection_fnGetStoryType(ITextSelection *me, LONG *pValue)
@@ -2553,6 +4128,8 @@ LRESULT CreateIRichEditOle(IUnknown *outer_unk, ME_TextEditor *editor, LPVOID *p
     }
     TRACE("Created %p\n",reo);
     list_init(&reo->rangelist);
+    list_init(&reo->fontlist);
+    list_init(&reo->paralist);
     if (outer_unk)
         reo->outer_unk = outer_unk;
     else
diff --git a/dlls/riched20/run.c b/dlls/riched20/run.c
index 38d0270..ad08b82 100644
--- a/dlls/riched20/run.c
+++ b/dlls/riched20/run.c
@@ -181,9 +181,10 @@ void ME_RunOfsFromCharOfs(ME_TextEditor *editor,
                           int *pOfs)
 {
   ME_DisplayItem *item, *next_item;
+  int endOfs = nCharOfs, len = ME_GetTextLength(editor);
 
   nCharOfs = max(nCharOfs, 0);
-  nCharOfs = min(nCharOfs, ME_GetTextLength(editor));
+  nCharOfs = min(nCharOfs, len);
 
   /* Find the paragraph at the offset. */
   next_item = editor->pBuffer->pFirst->member.para.next_para;
@@ -206,7 +207,11 @@ void ME_RunOfsFromCharOfs(ME_TextEditor *editor,
   nCharOfs -= item->member.run.nCharOfs;
 
   if (ppRun) *ppRun = item;
-  if (pOfs) *pOfs = nCharOfs;
+  if (pOfs) {
+    if (((*ppRun)->member.run.nFlags & MERF_ENDPARA) && endOfs > len)
+      *pOfs = (*ppRun)->member.run.len;
+    else *pOfs = nCharOfs;
+  }
 }
 
 /******************************************************************************
diff --git a/dlls/riched20/tests/richole.c b/dlls/riched20/tests/richole.c
index b4fbaa1..9cd003f 100644
--- a/dlls/riched20/tests/richole.c
+++ b/dlls/riched20/tests/richole.c
@@ -1081,6 +1081,451 @@ static void test_IOleInPlaceSite_GetWindow(void)
   release_interfaces(&w, &reOle, &txtDoc, NULL);
 }
 
+static void test_ITextRange_SetStart(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  hres = ITextRange_SetStart(txtRge, first);
+  ok(hres == S_FALSE, "ITextRange_SetStart\n");
+
+#define TEST_TXTRGE_SETSTART(cp, expected_start, expected_end)  \
+  hres = ITextRange_SetStart(txtRge, cp);                       \
+  ok(hres == S_OK, "ITextRange_SetStart\n");                    \
+  ITextRange_GetStart(txtRge, &start);                          \
+  ITextRange_GetEnd(txtRge, &end);                              \
+  ok(start == expected_start, "got wrong start value: %d\n", start);  \
+  ok(end == expected_end, "got wrong end value: %d\n", end);
+
+  TEST_TXTRGE_SETSTART(2, 2, 8)
+  TEST_TXTRGE_SETSTART(-1, 0, 8)
+  TEST_TXTRGE_SETSTART(13, 12, 12)
+
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextRange_SetEnd(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  hres = ITextRange_SetEnd(txtRge, lim);
+  ok(hres == S_FALSE, "ITextRange_SetEnd\n");
+
+#define TEST_TXTRGE_SETEND(cp, expected_start, expected_end)    \
+  hres = ITextRange_SetEnd(txtRge, cp);                         \
+  ok(hres == S_OK, "ITextRange_SetEnd\n");                      \
+  ITextRange_GetStart(txtRge, &start);                          \
+  ITextRange_GetEnd(txtRge, &end);                              \
+  ok(start == expected_start, "got wrong start value: %d\n", start);  \
+  ok(end == expected_end, "got wrong end value: %d\n", end);
+
+  TEST_TXTRGE_SETEND(6, 4, 6)
+  TEST_TXTRGE_SETEND(14, 4, 13)
+  TEST_TXTRGE_SETEND(-1, 0, 0)
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextSelection_SetStart(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  hres = ITextSelection_SetStart(txtSel, first);
+  ok(hres == S_FALSE, "ITextSelection_SetStart\n");
+
+#define TEST_TXTSEL_SETSTART(cp, expected_start, expected_end)        \
+  hres = ITextSelection_SetStart(txtSel, cp);                         \
+  ok(hres == S_OK, "ITextSelection_SetStart\n");                      \
+  SendMessageA(w, EM_GETSEL, (LPARAM)&start, (WPARAM)&end);           \
+  ok(start == expected_start, "got wrong start value: %d\n", start);  \
+  ok(end == expected_end, "got wrong end value: %d\n", end);
+
+  TEST_TXTSEL_SETSTART(2, 2, 8)
+  TEST_TXTSEL_SETSTART(-1, 0, 8)
+  TEST_TXTSEL_SETSTART(13, 12, 12)
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
+static void test_ITextSelection_SetEnd(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG first, lim, start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 8;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  hres = ITextSelection_SetEnd(txtSel, lim);
+  ok(hres == S_FALSE, "ITextSelection_SetEnd\n");
+
+#define TEST_TXTSEL_SETEND(cp, expected_start, expected_end)          \
+  hres = ITextSelection_SetEnd(txtSel, cp);                           \
+  ok(hres == S_OK, "ITextSelection_SetEnd\n");                        \
+  SendMessageA(w, EM_GETSEL, (LPARAM)&start, (WPARAM)&end);           \
+  ok(start == expected_start, "got wrong start value: %d\n", start);  \
+  ok(end == expected_end, "got wrong end value: %d\n", end);
+
+  TEST_TXTSEL_SETEND(6, 4, 6)
+  TEST_TXTSEL_SETEND(14, 4, 13)
+  TEST_TXTSEL_SETEND(-1, 0, 0)
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
+static void test_ITextRange_GetFont(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  ITextFont *txtFont = NULL, *txtFont1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetFont(txtRge, &txtFont);
+  ok(hres == S_OK, "ITextRange_GetFont\n");
+  refcount = get_refcount((IUnknown *)txtFont);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetFont(txtRge, &txtFont1);
+  ok(hres == S_OK, "ITextRange_GetFont\n");
+  ok(txtFont1 != txtFont, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtFont1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextFont_Release(txtFont1);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  hres = ITextFont_GetOutline(txtFont, &value);
+  ok(hres == CO_E_RELEASED, "ITextFont after ITextDocument destroyed\n");
+
+  ITextFont_Release(txtFont);
+}
+
+static void test_ITextSelection_GetFont(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  ITextFont *txtFont = NULL, *txtFont1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  SendMessageA(w, EM_SETSEL, first, lim);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextSelection_GetFont(txtSel, &txtFont);
+  ok(hres == S_OK, "ITextSelection_GetFont\n");
+  refcount = get_refcount((IUnknown *)txtFont);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 3, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextSelection_GetFont(txtSel, &txtFont1);
+  ok(hres == S_OK, "ITextSelection_GetFont\n");
+  ok(txtFont1 != txtFont, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtFont1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextFont_Release(txtFont1);
+  refcount = get_refcount((IUnknown *)txtSel);
+  ok(refcount == 3, "got wrong ref count: %d\n", refcount);
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+
+  hres = ITextFont_GetOutline(txtFont, &value);
+  ok(hres == CO_E_RELEASED, "ITextFont after ITextDocument destroyed\n");
+
+  ITextFont_Release(txtFont);
+}
+
+static void test_ITextRange_GetPara(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  ITextPara *txtPara = NULL, *txtPara1 = NULL;
+  HRESULT hres;
+  int first, lim;
+  int refcount;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG value;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  first = 4, lim = 4;
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetPara(txtRge, &txtPara);
+  ok(hres == S_OK, "ITextRange_GetPara\n");
+  refcount = get_refcount((IUnknown *)txtPara);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  hres = ITextRange_GetPara(txtRge, &txtPara1);
+  ok(hres == S_OK, "ITextRange_GetPara\n");
+  ok(txtPara1 != txtPara, "A new pointer should be return\n");
+  refcount = get_refcount((IUnknown *)txtPara1);
+  ok(refcount == 1, "got wrong ref count: %d\n", refcount);
+  ITextPara_Release(txtPara1);
+  refcount = get_refcount((IUnknown *)txtRge);
+  ok(refcount == 2, "got wrong ref count: %d\n", refcount);
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  hres = ITextPara_GetStyle(txtPara, &value);
+  ok(hres == CO_E_RELEASED, "ITextPara after ITextDocument destroyed\n");
+
+  ITextPara_Release(txtPara);
+}
+
+static void test_ITextRange_GetText(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  BSTR bstr = NULL;
+  static const CHAR test_text1[] = "TestSomeText";
+  static const WCHAR bufW1[] = {'T', 'e', 's', 't', 0};
+  static const WCHAR bufW2[] = {'T', 'e', 'x', 't', '\r', 0};
+  static const WCHAR bufW3[] = {'T', 'e', 'x', 't', 0};
+  static const WCHAR bufW4[] = {'T', 'e', 's', 't', 'S', 'o', 'm',
+                                'e', 'T', 'e', 'x', 't', '\r', 0};
+  static const WCHAR bufW5[] = {'\r', 0};
+
+
+#define TEST_TXTRGE_GETTEXT(first, lim, expected_string)                \
+  create_interfaces(&w, &reOle, &txtDoc, NULL);                         \
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);                   \
+  ITextDocument_Range(txtDoc, first, lim, &txtRge);                     \
+  hres = ITextRange_GetText(txtRge, &bstr);                             \
+  ok(hres == S_OK, "ITextRange_GetText\n");                             \
+  ok(!lstrcmpW(bstr, expected_string), "got wrong text: %s\n", wine_dbgstr_w(bstr)); \
+  SysFreeString(bstr);                                                  \
+  ITextRange_Release(txtRge);                                           \
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+
+  TEST_TXTRGE_GETTEXT(0, 4, bufW1)
+  TEST_TXTRGE_GETTEXT(4, 0, bufW1)
+  TEST_TXTRGE_GETTEXT(8, 12, bufW3)
+  TEST_TXTRGE_GETTEXT(8, 13, bufW2)
+  TEST_TXTRGE_GETTEXT(12, 13, bufW5)
+  TEST_TXTRGE_GETTEXT(0, 13, bufW4)
+  TEST_TXTRGE_GETTEXT(1, 1, NULL)
+}
+
+static void test_ITextRange_SetRange(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  int start, end;
+  static const CHAR test_text1[] = "TestSomeText";
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+  ITextDocument_Range(txtDoc, 0, 0, &txtRge);
+
+#define TEST_TXTRGE_SETRANGE(first, lim, expected_start, expected_end, expected_return) \
+  hres = ITextRange_SetRange(txtRge, first, lim);                       \
+  ok(hres == expected_return, "ITextRange_SetRange\n");                 \
+  ITextRange_GetStart(txtRge, &start);                                  \
+  ITextRange_GetEnd(txtRge, &end);                                      \
+  ok(start == expected_start, "got wrong start value: %d\n", start);    \
+  ok(end == expected_end, "got wrong end value: %d\n", end);
+
+  TEST_TXTRGE_SETRANGE(2, 4, 2, 4, S_OK)
+  TEST_TXTRGE_SETRANGE(2, 4, 2, 4, S_FALSE)
+  TEST_TXTRGE_SETRANGE(4, 2, 2, 4, S_FALSE)
+  TEST_TXTRGE_SETRANGE(14, 14, 12, 12, S_OK)
+  TEST_TXTRGE_SETRANGE(15, 15, 12, 12, S_FALSE)
+  TEST_TXTRGE_SETRANGE(14, 1, 1, 13, S_OK)
+  TEST_TXTRGE_SETRANGE(-1, 4, 0, 4, S_OK)
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextRange_IsEqual(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge1 = NULL, *txtRge2 = NULL;
+  HRESULT hres;
+  static const CHAR test_text1[] = "TestSomeText";
+  LONG res;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+  ITextDocument_Range(txtDoc, 2, 4, &txtRge1);
+  ITextDocument_Range(txtDoc, 2, 4, &txtRge2);
+
+#define TEST_TXTRGE_ISEQUAL(expected_hres, expected_res)                \
+  hres = ITextRange_IsEqual(txtRge1, txtRge2, &res);                    \
+  ok(hres == expected_hres, "ITextRange_IsEqual\n");                    \
+  ok(res == expected_res, "got wrong return value: %d\n", res);
+
+  TEST_TXTRGE_ISEQUAL(S_OK, tomTrue)
+  ITextRange_SetRange(txtRge2, 1, 2);
+  TEST_TXTRGE_ISEQUAL(S_FALSE, tomFalse)
+
+  ITextRange_SetRange(txtRge1, 1, 1);
+  ITextRange_SetRange(txtRge2, 2, 2);
+  TEST_TXTRGE_ISEQUAL(S_FALSE, tomFalse)
+
+  ITextRange_SetRange(txtRge2, 1, 1);
+  TEST_TXTRGE_ISEQUAL(S_OK, tomTrue)
+
+  hres = ITextRange_IsEqual(txtRge1, txtRge1, &res);
+  ok(hres == S_OK, "ITextRange_IsEqual\n");
+  ok(res == tomTrue, "got wrong return value: %d\n", res);
+
+  hres = ITextRange_IsEqual(txtRge1, txtRge2, NULL);
+  ok(hres == S_OK, "ITextRange_IsEqual\n");
+
+  hres = ITextRange_IsEqual(txtRge1, NULL, NULL);
+  ok(hres == S_FALSE, "ITextRange_IsEqual\n");
+
+  ITextRange_Release(txtRge1);
+  ITextRange_Release(txtRge2);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextRange_GetStoryLength(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextRange *txtRge = NULL;
+  HRESULT hres;
+  LONG count;
+  static const CHAR test_text1[] = "TestSomeText";
+  int len = strlen(test_text1) + 1;
+
+  create_interfaces(&w, &reOle, &txtDoc, NULL);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+  ITextDocument_Range(txtDoc, 0, 0, &txtRge);
+
+  hres = ITextRange_GetStoryLength(txtRge, &count);
+  ok(hres == S_OK, "ITextRange_GetStoryLength\n");
+  ok(count == len, "got wrong length: %d\n", count);
+
+  ITextRange_SetRange(txtRge, 1, 2);
+  hres = ITextRange_GetStoryLength(txtRge, &count);
+  ok(hres == S_OK, "ITextRange_GetStoryLength\n");
+  ok(count == len, "got wrong length: %d\n", count);
+
+  hres = ITextRange_GetStoryLength(txtRge, NULL);
+  ok(hres == E_INVALIDARG, "ITextRange_GetStoryLength\n");
+
+  ITextRange_Release(txtRge);
+  release_interfaces(&w, &reOle, &txtDoc, NULL);
+}
+
+static void test_ITextSelection_GetStoryLength(void)
+{
+  HWND w;
+  IRichEditOle *reOle = NULL;
+  ITextDocument *txtDoc = NULL;
+  ITextSelection *txtSel = NULL;
+  HRESULT hres;
+  LONG count;
+  static const CHAR test_text1[] = "TestSomeText";
+  int len = strlen(test_text1) + 1;
+
+  create_interfaces(&w, &reOle, &txtDoc, &txtSel);
+  SendMessageA(w, WM_SETTEXT, 0, (LPARAM)test_text1);
+
+  hres = ITextSelection_GetStoryLength(txtSel, &count);
+  ok(hres == S_OK, "ITextSelection_GetStoryLength\n");
+  ok(count == len, "got wrong length: %d\n", count);
+
+  SendMessageA(w, EM_SETSEL, 1, 2);
+  hres = ITextSelection_GetStoryLength(txtSel, &count);
+  ok(hres == S_OK, "ITextSelection_GetStoryLength\n");
+  ok(count == len, "got wrong length: %d\n", count);
+
+  hres = ITextSelection_GetStoryLength(txtSel, NULL);
+  ok(hres == E_INVALIDARG, "ITextSelection_GetStoryLength\n");
+
+  release_interfaces(&w, &reOle, &txtDoc, &txtSel);
+}
+
 START_TEST(richole)
 {
   /* Must explicitly LoadLibrary(). The test has no references to functions in
@@ -1093,12 +1538,24 @@ START_TEST(richole)
   test_ITextSelection_GetText();
   test_ITextSelection_GetChar();
   test_ITextSelection_GetStart_GetEnd();
+  test_ITextSelection_SetStart();
+  test_ITextSelection_SetEnd();
   test_ITextSelection_Collapse();
+  test_ITextSelection_GetFont();
+  test_ITextSelection_GetStoryLength();
   test_ITextDocument_Range();
   test_ITextRange_GetChar();
   test_ITextRange_GetStart_GetEnd();
   test_ITextRange_GetDuplicate();
   test_ITextRange_Collapse();
+  test_ITextRange_SetStart();
+  test_ITextRange_SetEnd();
+  test_ITextRange_GetFont();
+  test_ITextRange_GetPara();
+  test_ITextRange_GetText();
+  test_ITextRange_SetRange();
+  test_ITextRange_IsEqual();
+  test_ITextRange_GetStoryLength();
   test_IOleClientSite_QueryInterface();
   test_IOleWindow_GetWindow();
   test_IOleInPlaceSite_GetWindow();
diff --git a/dlls/secur32/ntlm.c b/dlls/secur32/ntlm.c
index 0fe64ed..72e9706 100644
--- a/dlls/secur32/ntlm.c
+++ b/dlls/secur32/ntlm.c
@@ -174,27 +174,74 @@ SECURITY_STATUS SEC_ENTRY ntlm_AcquireCredentialsHandleW(
                 if(pAuthData != NULL)
                 {
                     PSEC_WINNT_AUTH_IDENTITY_W auth_data = pAuthData;
+                    LPWSTR domain = NULL, user = NULL, password = NULL;
+                    int domain_len = 0, user_len = 0, password_len = 0;
 
-                    TRACE("Username is %s\n", debugstr_wn(auth_data->User, auth_data->UserLength));
-                    TRACE("Domain name is %s\n", debugstr_wn(auth_data->Domain, auth_data->DomainLength));
+                    if (auth_data->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
+                    {
+                        if (auth_data->DomainLength)
+                        {
+                            domain_len = MultiByteToWideChar(CP_ACP, 0, (char *)auth_data->Domain,
+                                                             auth_data->DomainLength, NULL, 0);
+                            domain = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * domain_len);
+                            MultiByteToWideChar(CP_ACP, 0, (char *)auth_data->Domain, auth_data->DomainLength,
+                                                domain, domain_len);
+                        }
+
+                        if (auth_data->UserLength)
+                        {
+                            user_len = MultiByteToWideChar(CP_ACP, 0, (char *)auth_data->User,
+                                                           auth_data->UserLength, NULL, 0);
+                            user = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * user_len);
+                            MultiByteToWideChar(CP_ACP, 0, (char *)auth_data->User, auth_data->UserLength,
+                                                user, user_len);
+                        }
+
+                        if (auth_data->PasswordLength)
+                        {
+                            password_len = MultiByteToWideChar(CP_ACP, 0,(char *)auth_data->Password,
+                                                               auth_data->PasswordLength, NULL, 0);
+                            password = HeapAlloc(GetProcessHeap(), 0, sizeof(WCHAR) * password_len);
+                            MultiByteToWideChar(CP_ACP, 0, (char *)auth_data->Password, auth_data->PasswordLength,
+                                                password, password_len);
+                        }
+                    }
+                    else
+                    {
+                        domain = auth_data->Domain;
+                        domain_len = auth_data->DomainLength;
+
+                        user = auth_data->User;
+                        user_len = auth_data->UserLength;
+
+                        password = auth_data->Password;
+                        password_len = auth_data->PasswordLength;
+                    }
+
+                    TRACE("Username is %s\n", debugstr_wn(user, user_len));
+                    TRACE("Domain name is %s\n", debugstr_wn(domain, domain_len));
 
-                    ntlm_cred->username_arg = ntlm_GetUsernameArg(auth_data->User, auth_data->UserLength);
-                    ntlm_cred->domain_arg = ntlm_GetDomainArg(auth_data->Domain, auth_data->DomainLength);
+                    ntlm_cred->username_arg = ntlm_GetUsernameArg(user, user_len);
+                    ntlm_cred->domain_arg = ntlm_GetDomainArg(domain, domain_len);
 
-                    if(auth_data->PasswordLength != 0)
+                    if(password_len != 0)
                     {
-                        ntlm_cred->pwlen = WideCharToMultiByte(CP_UNIXCP,
-                                                               WC_NO_BEST_FIT_CHARS, auth_data->Password,
-                                                               auth_data->PasswordLength, NULL, 0, NULL,
-                                                               NULL);
+                        ntlm_cred->pwlen = WideCharToMultiByte(CP_UNIXCP, WC_NO_BEST_FIT_CHARS, password,
+                                                               password_len, NULL, 0, NULL, NULL);
 
                         ntlm_cred->password = HeapAlloc(GetProcessHeap(), 0,
                                                         ntlm_cred->pwlen);
 
-                        WideCharToMultiByte(CP_UNIXCP, WC_NO_BEST_FIT_CHARS,
-                                            auth_data->Password, auth_data->PasswordLength,
+                        WideCharToMultiByte(CP_UNIXCP, WC_NO_BEST_FIT_CHARS, password, password_len,
                                             ntlm_cred->password, ntlm_cred->pwlen, NULL, NULL);
                     }
+
+                    if (auth_data->Flags & SEC_WINNT_AUTH_IDENTITY_ANSI)
+                    {
+                        HeapFree(GetProcessHeap(), 0, domain);
+                        HeapFree(GetProcessHeap(), 0, user);
+                        HeapFree(GetProcessHeap(), 0, password);
+                    }
                 }
 
                 phCredential->dwUpper = fCredentialUse;
diff --git a/dlls/secur32/schannel_macosx.c b/dlls/secur32/schannel_macosx.c
index cfd2371..c71189c 100644
--- a/dlls/secur32/schannel_macosx.c
+++ b/dlls/secur32/schannel_macosx.c
@@ -1016,6 +1016,7 @@ BOOL schan_imp_init(void)
     supported_protocols = SP_PROT_SSL2_CLIENT | SP_PROT_SSL3_CLIENT | SP_PROT_TLS1_0_CLIENT;
 
 #if MAC_OS_X_VERSION_MAX_ALLOWED >= 1080
+#ifdef   SSLGetProtocolVersionMax
     if(SSLGetProtocolVersionMax != NULL) {
         SSLProtocol max_protocol;
         SSLContextRef ctx;
@@ -1036,6 +1037,7 @@ BOOL schan_imp_init(void)
         }
     }
 #endif
+#endif
 
     return TRUE;
 }
diff --git a/dlls/setupapi/devinst.c b/dlls/setupapi/devinst.c
index 966af75..eaaa40e 100644
--- a/dlls/setupapi/devinst.c
+++ b/dlls/setupapi/devinst.c
@@ -3710,6 +3710,19 @@ BOOL WINAPI SetupDiSetDeviceInstallParamsA(
     return TRUE;
 }
 
+/***********************************************************************
+ *              SetupDiSetDeviceInstallParamsW  (SETUPAPI.@)
+ */
+BOOL WINAPI SetupDiSetDeviceInstallParamsW(
+       HDEVINFO DeviceInfoSet,
+       PSP_DEVINFO_DATA DeviceInfoData,
+       PSP_DEVINSTALL_PARAMS_W DeviceInstallParams)
+{
+    FIXME("(%p, %p, %p) stub\n", DeviceInfoSet, DeviceInfoData, DeviceInstallParams);
+
+    return TRUE;
+}
+
 static HKEY SETUPDI_OpenDevKey(struct DeviceInfo *devInfo, REGSAM samDesired)
 {
     HKEY enumKey, key = INVALID_HANDLE_VALUE;
diff --git a/dlls/setupapi/dialog.c b/dlls/setupapi/dialog.c
index 24a46e8..daacaf5 100644
--- a/dlls/setupapi/dialog.c
+++ b/dlls/setupapi/dialog.c
@@ -248,6 +248,35 @@ UINT WINAPI SetupPromptForDiskW(HWND hwndParent, PCWSTR DialogTitle, PCWSTR Disk
         SetLastError(ERROR_INVALID_PARAMETER);
         return DPROMPT_CANCEL;
     }
+
+    if (PathToSource && (DiskPromptStyle & IDF_CHECKFIRST))
+    {
+        static const WCHAR format[] = {'%', 's', '\\', '%', 's', '\0'};
+        WCHAR filepath[MAX_PATH];
+
+        if (strlenW(PathToSource) + 1 + strlenW(FileSought) < sizeof(filepath))
+        {
+            snprintfW(filepath, MAX_PATH, format, PathToSource, FileSought);
+
+            if (GetFileAttributesW(filepath) != INVALID_FILE_ATTRIBUTES)
+            {
+                if (PathRequiredSize)
+                    *PathRequiredSize = strlenW(PathToSource) + 1;
+
+                if (!PathBuffer)
+                    return DPROMPT_SUCCESS;
+
+                if (PathBufferSize >= strlenW(PathToSource) + 1)
+                {
+                    strcpyW(PathBuffer, PathToSource);
+                    return DPROMPT_SUCCESS;
+                }
+                else
+                    return DPROMPT_BUFFERTOOSMALL;
+            }
+        }
+    }
+
     params.DialogTitle = DialogTitle;
     params.DiskName = DiskName;
     params.PathToSource = PathToSource;
diff --git a/dlls/setupapi/setupapi.spec b/dlls/setupapi/setupapi.spec
index c1dbed5..9bfaadd 100644
--- a/dlls/setupapi/setupapi.spec
+++ b/dlls/setupapi/setupapi.spec
@@ -381,12 +381,13 @@
 @ stdcall SetupDiRegisterDeviceInfo(ptr ptr long ptr ptr ptr)
 @ stdcall SetupDiRemoveDevice(ptr ptr)
 @ stub SetupDiRemoveDeviceInterface
+@ stdcall SetupDiSelectBestCompatDrv(ptr ptr)
 @ stub SetupDiSelectDevice
 @ stub SetupDiSelectOEMDrv
 @ stdcall SetupDiSetClassInstallParamsA(ptr ptr ptr long)
 @ stdcall SetupDiSetClassInstallParamsW(ptr ptr ptr long)
 @ stdcall SetupDiSetDeviceInstallParamsA(ptr ptr ptr)
-@ stub SetupDiSetDeviceInstallParamsW
+@ stdcall SetupDiSetDeviceInstallParamsW(ptr ptr ptr)
 @ stdcall SetupDiSetDeviceRegistryPropertyA(ptr ptr long ptr ptr)
 @ stdcall SetupDiSetDeviceRegistryPropertyW(ptr ptr long ptr ptr)
 @ stub SetupDiSetDriverInstallParamsA
diff --git a/dlls/setupapi/stubs.c b/dlls/setupapi/stubs.c
index a57f5fe..ffc766b 100644
--- a/dlls/setupapi/stubs.c
+++ b/dlls/setupapi/stubs.c
@@ -594,6 +594,17 @@ BOOL WINAPI SetupDiLoadClassIcon(const GUID *ClassGuid, HICON *LargeIcon, PINT M
 }
 
 /***********************************************************************
+ *              SetupDiSelectBestCompatDrv (SETUPAPI.@)
+ */
+BOOL WINAPI SetupDiSelectBestCompatDrv(HDEVINFO DeviceInfoSet, PSP_DEVINFO_DATA DeviceInfoData)
+{
+    FIXME(": stub %p, %p\n", DeviceInfoSet, DeviceInfoData);
+
+    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+    return FALSE;
+}
+
+/***********************************************************************
  *              SetupDiSetSelectedDevice  (SETUPAPI.@)
  */
 BOOL WINAPI SetupDiSetSelectedDevice(HDEVINFO SetupDiSetSelectedDevice, PSP_DEVINFO_DATA DeviceInfoData)
diff --git a/dlls/setupapi/tests/Makefile.in b/dlls/setupapi/tests/Makefile.in
index 30902e7..3531381 100644
--- a/dlls/setupapi/tests/Makefile.in
+++ b/dlls/setupapi/tests/Makefile.in
@@ -3,6 +3,7 @@ IMPORTS   = setupapi user32 advapi32
 
 C_SRCS = \
 	devinst.c \
+	dialog.c \
 	diskspace.c \
 	install.c \
 	misc.c \
diff --git a/dlls/shdocvw/shdocvw_main.c b/dlls/shdocvw/shdocvw_main.c
index 4ef2dd5..2ac943b 100644
--- a/dlls/shdocvw/shdocvw_main.c
+++ b/dlls/shdocvw/shdocvw_main.c
@@ -378,8 +378,7 @@ DWORD WINAPI ParseURLFromOutsideSourceW(LPCWSTR url, LPWSTR out, LPDWORD plen, L
     HRESULT hr;
     DWORD needed;
     DWORD len;
-    DWORD res = 0;
-
+    DWORD res;
 
     TRACE("(%s, %p, %p, %p) len: %d, unknown: 0x%x\n", debugstr_w(url), out, plen, unknown,
             plen ? *plen : 0, unknown ? *unknown : 0);
@@ -405,10 +404,12 @@ DWORD WINAPI ParseURLFromOutsideSourceW(LPCWSTR url, LPWSTR out, LPDWORD plen, L
     needed = lstrlenW(buffer_out)+1;
     TRACE("got 0x%x with %s (need %d)\n", hr, debugstr_w(buffer_out), needed);
 
+    res = 0;
     if (*plen >= needed) {
         if (out != NULL) {
             lstrcpyW(out, buffer_out);
-            res++;
+            /* On success, 1 is returned for unicode version */
+            res = 1;
         }
         needed--;
     }
@@ -451,6 +452,7 @@ DWORD WINAPI ParseURLFromOutsideSourceA(LPCSTR url, LPSTR out, LPDWORD plen, LPD
     if (*plen >= needed) {
         if (out != NULL) {
             WideCharToMultiByte(CP_ACP, 0, buffer, -1, out, *plen, NULL, NULL);
+            /* On success, string size including terminating 0 is returned for ansi version */
             res = needed;
         }
         needed--;
diff --git a/dlls/shdocvw/tests/shdocvw.c b/dlls/shdocvw/tests/shdocvw.c
index 7b4eccf..cdf1814 100644
--- a/dlls/shdocvw/tests/shdocvw.c
+++ b/dlls/shdocvw/tests/shdocvw.c
@@ -212,13 +212,13 @@ static void test_ParseURLFromOutsideSourceA(void)
         buffer[sizeof(buffer)-1] = '\0';
         len = sizeof(buffer);
         dummy = 0;
-        /* on success, len+1 is returned. No idea, if someone depend on this */
+        /* on success, string size including terminating 0 is returned for ansi version */
         res = pParseURLFromOutsideSourceA(ParseURL_table[i].url, buffer, &len, &dummy);
         /* len does not include the terminating 0, when buffer is large enough */
-        ok( res != 0 && len == ParseURL_table[i].len &&
+        ok( res == (ParseURL_table[i].len+1) && len == ParseURL_table[i].len &&
             !lstrcmpA(buffer, ParseURL_table[i].newurl),
-            "#%d: got %d and %d with '%s' (expected '!=0' and %d with '%s')\n",
-            i, res, len, buffer, ParseURL_table[i].len, ParseURL_table[i].newurl);
+            "#%d: got %d and %d with '%s' (expected %d and %d with '%s')\n",
+            i, res, len, buffer, ParseURL_table[i].len+1, ParseURL_table[i].len, ParseURL_table[i].newurl);
 
 
         /* use the size test only for the first examples */
@@ -308,11 +308,12 @@ static void test_ParseURLFromOutsideSourceW(void)
     /* len is in characters */
     len = sizeof(bufferW)/sizeof(bufferW[0]);
     dummy = 0;
+    /* on success, 1 is returned for unicode version */
     res = pParseURLFromOutsideSourceW(urlW, bufferW, &len, &dummy);
     WideCharToMultiByte(CP_ACP, 0, bufferW, -1, bufferA, sizeof(bufferA), NULL, NULL);
-    ok( res != 0 && len == ParseURL_table[0].len &&
+    ok( res == 1 && len == ParseURL_table[0].len &&
         !lstrcmpA(bufferA, ParseURL_table[0].newurl),
-        "got %d and %d with '%s' (expected '!=0' and %d with '%s')\n",
+        "got %d and %d with '%s' (expected 1 and %d with '%s')\n",
         res, len, bufferA, ParseURL_table[0].len, ParseURL_table[0].newurl);
 
 
diff --git a/dlls/shell32/control.c b/dlls/shell32/control.c
index b393154..2ddf8b0 100644
--- a/dlls/shell32/control.c
+++ b/dlls/shell32/control.c
@@ -883,3 +883,25 @@ DWORD WINAPI CallCPLEntry16(HMODULE hMod, FARPROC pFunc, DWORD dw3, DWORD dw4, D
     FIXME("(%p, %p, %08x, %08x, %08x, %08x): stub.\n", hMod, pFunc, dw3, dw4, dw5, dw6);
     return 0x0deadbee;
 }
+
+/*************************************************************************
+ * RunDLL_CallEntry16        [SHELL32.122]
+ * Manually relay this function to make Tages Protection v5 happy
+ */
+void WINAPI RunDLL_CallEntry16( DWORD proc, HWND hwnd, HINSTANCE inst,
+                                LPCSTR cmdline, INT cmdshow )
+{
+    static HMODULE shell16 = NULL;
+    static void (WINAPI *pRunDLL_CallEntry16)( DWORD proc, HWND hwnd, HINSTANCE inst,
+                                               LPCSTR cmdline, INT cmdshow ) = NULL;
+
+    if (!pRunDLL_CallEntry16)
+    {
+        if (!shell16 && !(shell16 = LoadLibraryA( "shell.dll16" )))
+            return;
+        if (!(pRunDLL_CallEntry16 = (void *)GetProcAddress( shell16, "RunDLL_CallEntry16" )))
+            return;
+    }
+
+    pRunDLL_CallEntry16( proc, hwnd, inst, cmdline, cmdshow );
+}
diff --git a/dlls/shell32/iconcache.c b/dlls/shell32/iconcache.c
index b294908..b9fef10 100644
--- a/dlls/shell32/iconcache.c
+++ b/dlls/shell32/iconcache.c
@@ -62,7 +62,9 @@ typedef struct
 static HDPA sic_hdpa;
 static INIT_ONCE sic_init_once = INIT_ONCE_STATIC_INIT;
 static HIMAGELIST ShellSmallIconList;
-static HIMAGELIST ShellBigIconList;
+static HIMAGELIST ShellLargeIconList;
+static HIMAGELIST ShellExtraLargeIconList;
+static HIMAGELIST ShellJumboIconList;
 
 static CRITICAL_SECTION SHELL32_SicCS;
 static CRITICAL_SECTION_DEBUG critsect_debug =
@@ -109,7 +111,7 @@ static int SIC_LoadOverlayIcon(int icon_idx);
  *  Creates a new icon as a copy of the passed-in icon, overlayed with a
  *  shortcut image. 
  */
-static HICON SIC_OverlayShortcutImage(HICON SourceIcon, BOOL large)
+static HICON SIC_OverlayShortcutImage(HICON SourceIcon, int type)
 {	ICONINFO SourceIconInfo, ShortcutIconInfo, TargetIconInfo;
 	HICON ShortcutIcon, TargetIcon;
 	BITMAP SourceBitmapInfo, ShortcutBitmapInfo;
@@ -139,10 +141,16 @@ static HICON SIC_OverlayShortcutImage(HICON SourceIcon, BOOL large)
 
 	if (s_imgListIdx != -1)
 	{
-	    if (large)
-	        ShortcutIcon = ImageList_GetIcon(ShellBigIconList, s_imgListIdx, ILD_TRANSPARENT);
-	    else
-	        ShortcutIcon = ImageList_GetIcon(ShellSmallIconList, s_imgListIdx, ILD_TRANSPARENT);
+        if (type == SHIL_SMALL)
+            ShortcutIcon = ImageList_GetIcon(ShellSmallIconList, s_imgListIdx, ILD_TRANSPARENT);
+        else if (type == SHIL_LARGE)
+            ShortcutIcon = ImageList_GetIcon(ShellLargeIconList, s_imgListIdx, ILD_TRANSPARENT);
+        else if (type == SHIL_EXTRALARGE)
+            ShortcutIcon = ImageList_GetIcon(ShellExtraLargeIconList, s_imgListIdx, ILD_TRANSPARENT);
+        else if (type == SHIL_JUMBO)
+            ShortcutIcon = ImageList_GetIcon(ShellJumboIconList, s_imgListIdx, ILD_TRANSPARENT);
+        else
+            ShortcutIcon = NULL;
 	} else
 	    ShortcutIcon = NULL;
 
@@ -258,11 +266,14 @@ fail:
  * NOTES
  *  appends an icon pair to the end of the cache
  */
-static INT SIC_IconAppend (LPCWSTR sSourceFile, INT dwSourceIndex, HICON hSmallIcon, HICON hBigIcon, DWORD dwFlags)
-{	LPSIC_ENTRY lpsice;
-	INT ret, index, index1;
+static INT SIC_IconAppend(LPCWSTR sSourceFile, INT dwSourceIndex, HICON hSmallIcon,
+                          HICON hLargeIcon, HICON hExtraLargeIcon, HICON hJumboIcon, DWORD dwFlags)
+{
+    LPSIC_ENTRY lpsice;
+    INT ret, index, index1, index2, index3;
 	WCHAR path[MAX_PATH];
-	TRACE("%s %i %p %p\n", debugstr_w(sSourceFile), dwSourceIndex, hSmallIcon ,hBigIcon);
+    TRACE("%s %i %p %p %p %p %d\n", debugstr_w(sSourceFile), dwSourceIndex, hSmallIcon,
+        hLargeIcon, hExtraLargeIcon, hJumboIcon, dwFlags);
 
 	lpsice = SHAlloc(sizeof(SIC_ENTRY));
 
@@ -284,13 +295,14 @@ static INT SIC_IconAppend (LPCWSTR sSourceFile, INT dwSourceIndex, HICON hSmallI
 	}
 	else
 	{
-	  index = ImageList_AddIcon (ShellSmallIconList, hSmallIcon);
-	  index1= ImageList_AddIcon (ShellBigIconList, hBigIcon);
+        index  = ImageList_AddIcon( ShellSmallIconList, hSmallIcon );
+        index1 = ImageList_AddIcon( ShellLargeIconList, hLargeIcon );
+        index2 = ImageList_AddIcon( ShellExtraLargeIconList, hExtraLargeIcon );
+        index3 = ImageList_AddIcon( ShellJumboIconList, hJumboIcon );
+
+        if (index != index1 || index != index2 || index != index3)
+            FIXME("iconlists out of sync 0x%x 0x%x 0x%x 0x%x\n", index, index1, index2, index3);
 
-	  if (index!=index1)
-	  {
-	    FIXME("iconlists out of sync 0x%x 0x%x\n", index, index1);
-	  }
 	  lpsice->dwListIndex = index;
 	  ret = lpsice->dwListIndex;
 	}
@@ -305,15 +317,22 @@ static INT SIC_IconAppend (LPCWSTR sSourceFile, INT dwSourceIndex, HICON hSmallI
  *  gets small/big icon by number from a file
  */
 static INT SIC_LoadIcon (LPCWSTR sSourceFile, INT dwSourceIndex, DWORD dwFlags)
-{	HICON	hiconLarge=0;
-	HICON	hiconSmall=0;
-	HICON 	hiconLargeShortcut;
-	HICON	hiconSmallShortcut;
-
-        PrivateExtractIconsW( sSourceFile, dwSourceIndex, 32, 32, &hiconLarge, 0, 1, 0 );
-        PrivateExtractIconsW( sSourceFile, dwSourceIndex, 16, 16, &hiconSmall, 0, 1, 0 );
-
-	if ( !hiconLarge ||  !hiconSmall)
+{
+    HICON   hiconSmall=0;
+    HICON   hiconLarge=0;
+    HICON   hiconExtraLarge=0;
+    HICON   hiconJumbo=0;
+    HICON   hiconSmallShortcut;
+    HICON   hiconLargeShortcut;
+    HICON   hiconExtraLargeShortcut;
+    HICON   hiconJumboShortcut;
+
+    PrivateExtractIconsW( sSourceFile, dwSourceIndex, 16, 16, &hiconSmall, 0, 1, 0 );
+    PrivateExtractIconsW( sSourceFile, dwSourceIndex, 32, 32, &hiconLarge, 0, 1, 0 );
+    PrivateExtractIconsW( sSourceFile, dwSourceIndex, 48, 48, &hiconExtraLarge, 0, 1, 0 );
+    PrivateExtractIconsW( sSourceFile, dwSourceIndex, 256, 256, &hiconJumbo, 0, 1, 0 );
+
+    if ( !hiconSmall || !hiconLarge || !hiconExtraLarge || !hiconJumbo )
 	{
 	  WARN("failure loading icon %i from %s (%p %p)\n", dwSourceIndex, debugstr_w(sSourceFile), hiconLarge, hiconSmall);
 	  return -1;
@@ -321,38 +340,59 @@ static INT SIC_LoadIcon (LPCWSTR sSourceFile, INT dwSourceIndex, DWORD dwFlags)
 
 	if (0 != (dwFlags & GIL_FORSHORTCUT))
 	{
-	  hiconLargeShortcut = SIC_OverlayShortcutImage(hiconLarge, TRUE);
-	  hiconSmallShortcut = SIC_OverlayShortcutImage(hiconSmall, FALSE);
-	  if (NULL != hiconLargeShortcut && NULL != hiconSmallShortcut)
-	  {
-	    hiconLarge = hiconLargeShortcut;
-	    hiconSmall = hiconSmallShortcut;
-	  }
-	  else
-	  {
-	    WARN("Failed to create shortcut overlayed icons\n");
-	    if (NULL != hiconLargeShortcut) DestroyIcon(hiconLargeShortcut);
-	    if (NULL != hiconSmallShortcut) DestroyIcon(hiconSmallShortcut);
-	    dwFlags &= ~ GIL_FORSHORTCUT;
-	  }
+        hiconSmallShortcut = SIC_OverlayShortcutImage( hiconSmall, SHIL_SMALL );
+        hiconLargeShortcut = SIC_OverlayShortcutImage( hiconLarge, SHIL_LARGE );
+        hiconExtraLargeShortcut = SIC_OverlayShortcutImage( hiconExtraLarge, SHIL_EXTRALARGE );
+        hiconJumboShortcut = SIC_OverlayShortcutImage( hiconJumbo, SHIL_JUMBO );
+
+        if (NULL != hiconLargeShortcut && NULL != hiconSmallShortcut &&
+            NULL != hiconExtraLargeShortcut && NULL != hiconJumboShortcut)
+        {
+            hiconSmall = hiconSmallShortcut;
+            hiconLarge = hiconLargeShortcut;
+            hiconExtraLarge = hiconExtraLargeShortcut;
+            hiconJumbo = hiconJumboShortcut;
+        }
+        else
+        {
+            WARN("Failed to create shortcut overlayed icons\n");
+            if (NULL != hiconSmallShortcut) DestroyIcon(hiconSmallShortcut);
+            if (NULL != hiconLargeShortcut) DestroyIcon(hiconLargeShortcut);
+            if (NULL != hiconExtraLargeShortcut) DestroyIcon(hiconExtraLargeShortcut);
+            if (NULL != hiconJumboShortcut) DestroyIcon(hiconJumboShortcut);
+            dwFlags &= ~ GIL_FORSHORTCUT;
+        }
 	}
 
-	return SIC_IconAppend (sSourceFile, dwSourceIndex, hiconSmall, hiconLarge, dwFlags);
+    return SIC_IconAppend( sSourceFile, dwSourceIndex, hiconSmall, hiconLarge,
+                           hiconExtraLarge, hiconJumbo, dwFlags );
 }
 /*****************************************************************************
  * SIC_Initialize			[internal]
  */
 static BOOL WINAPI SIC_Initialize( INIT_ONCE *once, void *param, void **context )
 {
-	HICON		hSm, hLg;
-	int		cx_small, cy_small;
-	int		cx_large, cy_large;
+    HICON   hSm, hLg, hELg, hJb;
+    int     cx_small, cy_small;
+    int     cx_large, cy_large;
+    int     cx_extralarge, cy_extralarge;
+    int     cx_jumbo, cy_jumbo;
 
 	cx_small = GetSystemMetrics(SM_CXSMICON);
 	cy_small = GetSystemMetrics(SM_CYSMICON);
 	cx_large = GetSystemMetrics(SM_CXICON);
 	cy_large = GetSystemMetrics(SM_CYICON);
 
+    /*
+     * TODO: according to
+     * http://msdn.microsoft.com/en-us/library/windows/desktop/bb762185(v=vs.85).aspx
+     * the size can be configured, but where is the value defined?
+     */
+    cx_extralarge = 48;
+    cy_extralarge = 48;
+    cx_jumbo = 256;
+    cy_jumbo = 256;
+
 	TRACE("\n");
 
 	sic_hdpa = DPA_Create(16);
@@ -362,28 +402,36 @@ static BOOL WINAPI SIC_Initialize( INIT_ONCE *once, void *param, void **context
 	  return(FALSE);
 	}
 
-        ShellSmallIconList = ImageList_Create(cx_small,cy_small,ILC_COLOR32|ILC_MASK,0,0x20);
-        ShellBigIconList = ImageList_Create(cx_large,cy_large,ILC_COLOR32|ILC_MASK,0,0x20);
+    ShellSmallIconList = ImageList_Create( cx_small,cy_small,ILC_COLOR32|ILC_MASK,0,0x20 );
+    ShellLargeIconList = ImageList_Create( cx_large,cy_large,ILC_COLOR32|ILC_MASK,0,0x20 );
+    ShellExtraLargeIconList = ImageList_Create( cx_extralarge,cy_extralarge,ILC_COLOR32|ILC_MASK,0,0x20 );
+    ShellJumboIconList = ImageList_Create( cx_jumbo,cy_jumbo,ILC_COLOR32|ILC_MASK,0,0x20 );
+
+    ImageList_SetBkColor( ShellSmallIconList, CLR_NONE );
+    ImageList_SetBkColor( ShellLargeIconList, CLR_NONE );
+    ImageList_SetBkColor( ShellExtraLargeIconList, CLR_NONE );
+    ImageList_SetBkColor( ShellJumboIconList, CLR_NONE );
+
+    /* Load the document icon, which is used as the default if an icon isn't found. */
+    hSm = LoadImageA(shell32_hInstance, MAKEINTRESOURCEA(IDI_SHELL_DOCUMENT),
+                            IMAGE_ICON, cx_small, cy_small, LR_SHARED);
+    hLg = LoadImageA(shell32_hInstance, MAKEINTRESOURCEA(IDI_SHELL_DOCUMENT),
+                            IMAGE_ICON, cx_large, cy_large, LR_SHARED);
+    hELg = LoadImageA(shell32_hInstance, MAKEINTRESOURCEA(IDI_SHELL_DOCUMENT),
+                            IMAGE_ICON, cx_extralarge, cy_extralarge, LR_SHARED);
+    hJb = LoadImageA(shell32_hInstance, MAKEINTRESOURCEA(IDI_SHELL_DOCUMENT),
+                            IMAGE_ICON, cx_jumbo, cy_jumbo, LR_SHARED);
+    if (!hSm || !hLg || !hELg || !hJb)
+    {
+      FIXME("Failed to load IDI_SHELL_DOCUMENT icon!\n");
+      return FALSE;
+    }
 
-        ImageList_SetBkColor(ShellSmallIconList, CLR_NONE);
-        ImageList_SetBkColor(ShellBigIconList, CLR_NONE);
+    SIC_IconAppend( swShell32Name, IDI_SHELL_DOCUMENT-1, hSm, hLg, hELg, hJb, 0 );
+    SIC_IconAppend( swShell32Name, -IDI_SHELL_DOCUMENT, hSm, hLg, hELg, hJb, 0 );
 
-        /* Load the document icon, which is used as the default if an icon isn't found. */
-        hSm = LoadImageA(shell32_hInstance, MAKEINTRESOURCEA(IDI_SHELL_DOCUMENT),
-                                IMAGE_ICON, cx_small, cy_small, LR_SHARED);
-        hLg = LoadImageA(shell32_hInstance, MAKEINTRESOURCEA(IDI_SHELL_DOCUMENT),
-                                IMAGE_ICON, cx_large, cy_large, LR_SHARED);
-
-        if (!hSm || !hLg) 
-        {
-          FIXME("Failed to load IDI_SHELL_DOCUMENT icon!\n");
-          return FALSE;
-        }
-
-        SIC_IconAppend (swShell32Name, IDI_SHELL_DOCUMENT-1, hSm, hLg, 0);
-        SIC_IconAppend (swShell32Name, -IDI_SHELL_DOCUMENT, hSm, hLg, 0);
-   
-	TRACE("hIconSmall=%p hIconBig=%p\n",ShellSmallIconList, ShellBigIconList);
+    TRACE("hIconSmall=%p hIconLarge=%p hExtraLargeIcon=%p hJumboIcon=%p\n",
+        ShellSmallIconList, ShellLargeIconList, ShellExtraLargeIconList, ShellJumboIconList);
 
 	return TRUE;
 }
@@ -407,10 +455,14 @@ void SIC_Destroy(void)
 
 	if (sic_hdpa) DPA_DestroyCallback(sic_hdpa, sic_free, NULL );
 
-	if (ShellSmallIconList)
-	    ImageList_Destroy(ShellSmallIconList);
-	if (ShellBigIconList)
-	    ImageList_Destroy(ShellBigIconList);
+    if (ShellSmallIconList)
+        ImageList_Destroy( ShellSmallIconList );
+    if (ShellLargeIconList)
+        ImageList_Destroy( ShellLargeIconList );
+    if (ShellExtraLargeIconList)
+        ImageList_Destroy( ShellExtraLargeIconList );
+    if (ShellJumboIconList)
+        ImageList_Destroy( ShellJumboIconList );
 
 	LeaveCriticalSection(&SHELL32_SicCS);
 	DeleteCriticalSection(&SHELL32_SicCS);
@@ -527,10 +579,20 @@ BOOL WINAPI Shell_GetImageLists(HIMAGELIST * lpBigList, HIMAGELIST * lpSmallList
 {
     TRACE("(%p,%p)\n",lpBigList,lpSmallList);
     InitOnceExecuteOnce( &sic_init_once, SIC_Initialize, NULL, NULL );
-    if (lpBigList) *lpBigList = ShellBigIconList;
+    if (lpBigList) *lpBigList = ShellLargeIconList;
     if (lpSmallList) *lpSmallList = ShellSmallIconList;
     return TRUE;
 }
+
+void SHELL_GetInternalImageLists(HIMAGELIST *lpSmallList, HIMAGELIST *lpLargeList,
+    HIMAGELIST *lpExtraLargeList, HIMAGELIST *lpJumboList)
+{
+    if (lpSmallList) *lpSmallList = ShellSmallIconList;
+    if (lpLargeList) *lpLargeList = ShellLargeIconList;
+    if (lpExtraLargeList) *lpExtraLargeList = ShellExtraLargeIconList;
+    if (lpJumboList) *lpJumboList = ShellJumboIconList;
+}
+
 /*************************************************************************
  * PidlToSicIndex			[INTERNAL]
  *
diff --git a/dlls/shell32/shell32.rc b/dlls/shell32/shell32.rc
index 847d2ce..2f0095f 100644
--- a/dlls/shell32/shell32.rc
+++ b/dlls/shell32/shell32.rc
@@ -184,6 +184,13 @@ If the files in the destination folder have the same names as files in the\n\
 selected folder they will be replaced. Do you still want to move or copy\n\
 the folder?"
 
+        IDS_FILEOP_COPYING   "Copying"
+        IDS_FILEOP_MOVING    "Moving"
+        IDS_FILEOP_DELETING  "Deleting"
+        IDS_FILEOP_FROM_TO   "From %1 to %2"
+        IDS_FILEOP_FROM      "From %1"
+        IDS_FILEOP_PREFLIGHT "Preflight"
+
         /* message box strings */
         IDS_RESTART_TITLE       "Restart"
         IDS_RESTART_PROMPT      "Do you want to simulate a Windows reboot?"
diff --git a/dlls/shell32/shell32.spec b/dlls/shell32/shell32.spec
index f168ed7..65d6c36 100644
--- a/dlls/shell32/shell32.spec
+++ b/dlls/shell32/shell32.spec
@@ -114,7 +114,7 @@
  119 stdcall -ordinal IsLFNDrive(ptr) IsLFNDriveAW
  120 stdcall -noname FileMenu_AbortInitMenu()
  121 stdcall -noname SHFlushClipboard()
- 122 stdcall -private @(long long ptr str long) shell.dll16.RunDLL_CallEntry16
+ 122 stdcall -noname RunDLL_CallEntry16(long long ptr str long)
  123 stdcall -noname SHFreeUnusedLibraries()
  124 stdcall -noname FileMenu_AppendFilesForPidl(long ptr long)
  125 stdcall -noname FileMenu_AddFilesForPidl(long long long ptr long long ptr)
@@ -261,6 +261,7 @@
  704 stdcall -noname GUIDFromStringW(wstr ptr)
  709 stdcall SHGetSetFolderCustomSettings(ptr str long)
  714 stdcall @(ptr) SHELL32_714 # PathIsTemporaryW
+ 723 stdcall SHCreateSessionKey(long ptr)
  727 stdcall SHGetImageList(long ptr ptr)
  730 stdcall -noname RestartDialogEx(long wstr long long)
  743 stdcall SHCreateFileExtractIconW(wstr long ptr ptr)
diff --git a/dlls/shell32/shell32_main.h b/dlls/shell32/shell32_main.h
index 954f1e4..e1e77f1 100644
--- a/dlls/shell32/shell32_main.h
+++ b/dlls/shell32/shell32_main.h
@@ -232,4 +232,7 @@ BOOL CreateFolderEnumList(IEnumIDListImpl *list, LPCWSTR lpszPath, DWORD dwFlags
 void release_typelib(void) DECLSPEC_HIDDEN;
 void release_desktop_folder(void) DECLSPEC_HIDDEN;
 
+void SHELL_GetInternalImageLists(HIMAGELIST *lpSmallList, HIMAGELIST *lpLargeList,
+    HIMAGELIST *lpExtraLargeList, HIMAGELIST *lpJumboList) DECLSPEC_HIDDEN;
+
 #endif
diff --git a/dlls/shell32/shellord.c b/dlls/shell32/shellord.c
index 914dc5a..75e5d645a 100644
--- a/dlls/shell32/shellord.c
+++ b/dlls/shell32/shellord.c
@@ -2182,20 +2182,32 @@ void WINAPI SHFlushSFCache(void)
  */
 HRESULT WINAPI SHGetImageList(int iImageList, REFIID riid, void **ppv)
 {
-    HIMAGELIST hLarge, hSmall;
+    HIMAGELIST hSmall, hLarge, hExtraLarge, hJumbo;
     HIMAGELIST hNew;
     HRESULT ret = E_FAIL;
 
-    /* Wine currently only maintains large and small image lists */
-    if ((iImageList != SHIL_LARGE) && (iImageList != SHIL_SMALL) && (iImageList != SHIL_SYSSMALL))
+    SHELL_GetInternalImageLists( &hSmall, &hLarge, &hExtraLarge, &hJumbo );
+
+    switch (iImageList)
     {
-        FIXME("Unsupported image list %i requested\n", iImageList);
-        return E_FAIL;
+        case SHIL_SMALL:
+        case SHIL_SYSSMALL:
+            hNew = ImageList_Duplicate( hSmall );
+            break;
+        case SHIL_LARGE:
+            hNew = ImageList_Duplicate( hLarge );
+            break;
+        case SHIL_EXTRALARGE:
+            hNew = ImageList_Duplicate( hExtraLarge );
+            break;
+        case SHIL_JUMBO:
+            hNew = ImageList_Duplicate( hJumbo );
+            break;
+        default:
+            FIXME("Unsupported image list %i requested\n", iImageList);
+            return E_FAIL;
     }
 
-    Shell_GetImageLists(&hLarge, &hSmall);
-    hNew = ImageList_Duplicate(iImageList == SHIL_LARGE ? hLarge : hSmall);
-
     /* Get the interface for the new image list */
     if (hNew)
     {
diff --git a/dlls/shell32/shellpath.c b/dlls/shell32/shellpath.c
index 354b23a..5cee75b 100644
--- a/dlls/shell32/shellpath.c
+++ b/dlls/shell32/shellpath.c
@@ -3815,6 +3815,80 @@ cleanup:
     return hr;
 }
 
+static PSID get_user_sid( TOKEN_USER **user )
+{
+    DWORD user_size = 0;
+    HANDLE token;
+    if (OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &token) ||
+        (GetLastError() == ERROR_NO_TOKEN &&
+        OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &token)))
+    {
+        if (!GetTokenInformation(token, TokenUser, NULL, 0, &user_size) &&
+            GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
+            (*user = HeapAlloc(GetProcessHeap(), 0, user_size)))
+        {
+            if (GetTokenInformation(token, TokenUser, *user, user_size, &user_size))
+            {
+                CloseHandle(token);
+                return (*user)->User.Sid;
+            }
+            HeapFree(GetProcessHeap(), 0, *user);
+        }
+        CloseHandle(token);
+    }
+    return NULL;
+}
+
+static PSID get_admin_sid( void )
+{
+    DWORD sid_size = 0;
+    PSID admin_sid;
+    if (!CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, NULL, &sid_size) &&
+        GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
+        (admin_sid = HeapAlloc(GetProcessHeap(), 0, sid_size)))
+    {
+        if (CreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, admin_sid, &sid_size))
+            return admin_sid;
+        HeapFree(GetProcessHeap(), 0, admin_sid);
+    }
+    return NULL;
+}
+
+static PSECURITY_DESCRIPTOR _SHGetUserSecurityDescriptor( void )
+{
+    PSID user_sid, admin_sid = NULL;
+    SECURITY_DESCRIPTOR *sd = NULL;
+    TOKEN_USER *user = NULL;
+
+    if ((user_sid  = get_user_sid( &user )) &&
+        (admin_sid = get_admin_sid()))
+    {
+        DWORD dacl_size = sizeof(ACL) + 2 * sizeof(ACE_HEADER) + 2 * sizeof(DWORD) +
+                          GetLengthSid(user_sid) + GetLengthSid(admin_sid);
+        if ((sd = HeapAlloc(GetProcessHeap(), 0, sizeof(SECURITY_DESCRIPTOR) + dacl_size)))
+        {
+            PACL dacl = (ACL *)(sd + 1);
+            if (!InitializeSecurityDescriptor(sd, SECURITY_DESCRIPTOR_REVISION) ||
+                !InitializeAcl(dacl, dacl_size, ACL_REVISION) ||
+                !AddAccessAllowedAceEx(dacl, ACL_REVISION,
+                                       OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
+                                       GENERIC_ALL, user_sid) ||
+                !AddAccessAllowedAceEx(dacl, ACL_REVISION,
+                                       OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE,
+                                       GENERIC_ALL, admin_sid) ||
+                !SetSecurityDescriptorDacl(sd, TRUE, dacl, FALSE))
+            {
+                HeapFree(GetProcessHeap(), 0, sd);
+                sd = NULL;
+            }
+        }
+    }
+
+    HeapFree(GetProcessHeap(), 0, admin_sid);
+    HeapFree(GetProcessHeap(), 0, user);
+    return sd;
+}
+
 /*************************************************************************
  * SHGetFolderPathAndSubDirW		[SHELL32.@]
  */
@@ -3826,6 +3900,8 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
 	LPCWSTR pszSubPath,/* [I] sub directory of the specified folder */
 	LPWSTR pszPath)    /* [O] converted path */
 {
+    SECURITY_ATTRIBUTES sa, *sec = NULL;
+    PSECURITY_DESCRIPTOR sd = NULL;
     HRESULT    hr;
     WCHAR      szBuildPath[MAX_PATH], szTemp[MAX_PATH];
     DWORD      folder = nFolder & CSIDL_FOLDER_MASK;
@@ -3938,8 +4014,25 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
         goto end;
     }
 
+    /* build the appropriate security attributes for the directory */
+    switch (type)
+    {
+        case CSIDL_Type_User:
+            sd = _SHGetUserSecurityDescriptor();
+            break;
+        default:
+            break;
+    }
+    if (sd)
+    {
+        sa.nLength = sizeof(sa);
+        sa.lpSecurityDescriptor = sd;
+        sa.bInheritHandle = TRUE;
+        sec = &sa;
+    }
+
     /* create directory/directories */
-    ret = SHCreateDirectoryExW(hwndOwner, szBuildPath, NULL);
+    ret = SHCreateDirectoryExW(hwndOwner, szBuildPath, sec);
     if (ret && ret != ERROR_ALREADY_EXISTS)
     {
         ERR("Failed to create directory %s.\n", debugstr_w(szBuildPath));
@@ -3949,6 +4042,7 @@ HRESULT WINAPI SHGetFolderPathAndSubDirW(
 
     TRACE("Created missing system directory %s\n", debugstr_w(szBuildPath));
 end:
+    HeapFree(GetProcessHeap(), 0, sd);
     TRACE("returning 0x%08x (final path is %s)\n", hr, debugstr_w(szBuildPath));
     return hr;
 }
@@ -4729,13 +4823,15 @@ HRESULT WINAPI SHGetKnownFolderPath(REFKNOWNFOLDERID rfid, DWORD flags, HANDLE t
     if (flags & KF_FLAG_INIT)
         index |= CSIDL_FLAG_PER_USER_INIT;
 
-    if (flags & ~(KF_FLAG_CREATE|KF_FLAG_DONT_VERIFY|KF_FLAG_NO_ALIAS|KF_FLAG_INIT))
+    if (flags & ~(KF_FLAG_CREATE|KF_FLAG_DONT_VERIFY|KF_FLAG_NO_ALIAS|
+                  KF_FLAG_INIT|KF_FLAG_DEFAULT_PATH))
     {
         FIXME("flags 0x%08x not supported\n", flags);
         return E_INVALIDARG;
     }
 
-    hr = SHGetFolderPathW( NULL, index, token, 0, folder );
+    hr = SHGetFolderPathW( NULL, index, token, (flags & KF_FLAG_DEFAULT_PATH) ?
+                           SHGFP_TYPE_DEFAULT : SHGFP_TYPE_CURRENT, folder );
     if (SUCCEEDED(hr))
     {
         *path = CoTaskMemAlloc( (strlenW( folder ) + 1) * sizeof(WCHAR) );
diff --git a/dlls/shell32/shellreg.c b/dlls/shell32/shellreg.c
index 37f3d9e..96a450e 100644
--- a/dlls/shell32/shellreg.c
+++ b/dlls/shell32/shellreg.c
@@ -147,3 +147,44 @@ HRESULT WINAPI SHRegCloseKey (HKEY hkey)
 	TRACE("%p\n",hkey);
 	return RegCloseKey( hkey );
 }
+
+static const char session_reg_key[] = "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\SessionInfo\\";
+
+static BOOL WINAPI create_session_key(INIT_ONCE *once, void *param, void **context)
+{
+    static const char desktop_guid[] = "__wine_display_device_guid";
+    ATOM guid_atom;
+    HKEY hkey_session;
+    LPWSTR session_reg_str = param;
+
+    guid_atom = HandleToULong(GetPropA(GetDesktopWindow(), desktop_guid));
+    if (!guid_atom) return FALSE;
+
+    MultiByteToWideChar(CP_ACP, 0, session_reg_key, sizeof(session_reg_key), session_reg_str, sizeof(session_reg_key));
+
+    if (!GlobalGetAtomNameW(guid_atom, session_reg_str + sizeof(session_reg_key) - 1, 39))
+        return FALSE;
+
+    if (RegCreateKeyExW(HKEY_CURRENT_USER, session_reg_str, 0, NULL,
+                        REG_OPTION_VOLATILE, KEY_WRITE, NULL, &hkey_session, NULL))
+        return FALSE;
+
+    RegCloseKey(hkey_session);
+    TRACE("session key %s\n", debugstr_w(session_reg_str));
+    return TRUE;
+}
+
+/*************************************************************************
+ * SHCreateSessionKey [SHELL32.723]
+ *
+ */
+HRESULT WINAPI SHCreateSessionKey(REGSAM access, HKEY *hkey)
+{
+    static INIT_ONCE init_once = INIT_ONCE_STATIC_INIT;
+    static WCHAR session_reg_str[sizeof(session_reg_key) + 39];
+
+    InitOnceExecuteOnce(&init_once, create_session_key, session_reg_str, NULL);
+
+    TRACE("using session key %s\n", debugstr_w(session_reg_str));
+    return RegOpenKeyExW(HKEY_CURRENT_USER, session_reg_str, 0, access, hkey);
+}
diff --git a/dlls/shell32/shlexec.c b/dlls/shell32/shlexec.c
index 2d9690a..df0f11c 100644
--- a/dlls/shell32/shlexec.c
+++ b/dlls/shell32/shlexec.c
@@ -1558,6 +1558,7 @@ static void do_error_dialog( UINT_PTR retval, HWND hwnd )
  */
 static BOOL SHELL_execute( LPSHELLEXECUTEINFOW sei, SHELL_ExecuteW32 execfunc )
 {
+    static const WCHAR wQuote[] = {'\"',0};
     static const WCHAR wSpace[] = {' ',0};
     static const WCHAR wWww[] = {'w','w','w',0};
     static const WCHAR wHttp[] = {'h','t','t','p',':','/','/',0};
@@ -1580,6 +1581,7 @@ static BOOL SHELL_execute( LPSHELLEXECUTEINFOW sei, SHELL_ExecuteW32 execfunc )
     LPCWSTR lpFile;
     UINT_PTR retval = SE_ERR_NOASSOC;
     BOOL appKnownSingular = FALSE;
+    BOOL needs_quote;
 
     /* make a local copy of the LPSHELLEXECUTEINFO structure and work with this from now on */
     sei_tmp = *sei;
@@ -1802,32 +1804,35 @@ static BOOL SHELL_execute( LPSHELLEXECUTEINFOW sei, SHELL_ExecuteW32 execfunc )
 	}
 	else
 	{
-	    /* If the executable name is not quoted, we have to use this search loop here,
-	       that in CreateProcess() is not sufficient because it does not handle shell links. */
+            /* FIXME: what versions support this? Fails on 2000/XP
+             * If the executable name is not quoted, we have to use this search loop here,
+             * that in CreateProcess() is not sufficient because it does not handle shell links. */
 	    WCHAR buffer[MAX_PATH], xlpFile[MAX_PATH];
-	    LPWSTR space, s;
+            LPWSTR space;
 
-	    LPWSTR beg = wszApplicationName/*sei_tmp.lpFile*/;
-	    for(s=beg; (space=strchrW(s, ' ')); s=space+1) {
-		int idx = space-sei_tmp.lpFile;
-		memcpy(buffer, sei_tmp.lpFile, idx * sizeof(WCHAR));
+            lstrcpynW(buffer, wszApplicationName, sizeof(buffer)/sizeof(WCHAR));
+            space = buffer + strlenW(buffer);
+            do
+            {
+                int idx = space-buffer;
 		buffer[idx] = '\0';
 
 		/*FIXME This finds directory paths if the targeted file name contains spaces. */
 		if (SearchPathW(*sei_tmp.lpDirectory? sei_tmp.lpDirectory: NULL, buffer, wszExe, sizeof(xlpFile)/sizeof(xlpFile[0]), xlpFile, NULL))
 		{
 		    /* separate out command from parameter string */
-		    LPCWSTR p = space + 1;
+                    LPCWSTR p = wszApplicationName + idx;
 
 		    while(isspaceW(*p))
 			++p;
 
 		    strcpyW(wszParameters, p);
-		    *space = '\0';
+                    wszApplicationName[idx] = '\0';
 
 		    break;
 		}
 	    }
+            while((space=strrchrW(buffer, ' ')));
 
             lpFile = sei_tmp.lpFile;
 	}
@@ -1836,6 +1841,9 @@ static BOOL SHELL_execute( LPSHELLEXECUTEINFOW sei, SHELL_ExecuteW32 execfunc )
 
     wcmd = wcmdBuffer;
     len = lstrlenW(wszApplicationName) + 1;
+    needs_quote = NULL != strstrW(wszApplicationName,wSpace);
+    if (needs_quote)
+        len += 2;
     if (sei_tmp.lpParameters[0])
         len += 1 + lstrlenW(wszParameters);
     if (len > wcmdLen)
@@ -1843,7 +1851,12 @@ static BOOL SHELL_execute( LPSHELLEXECUTEINFOW sei, SHELL_ExecuteW32 execfunc )
         wcmd = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
         wcmdLen = len;
     }
-    strcpyW(wcmd, wszApplicationName);
+
+    wcmd[0] = 0;
+    if (needs_quote) strcatW(wcmd, wQuote);
+    strcatW(wcmd, wszApplicationName);
+    if (needs_quote) strcatW(wcmd, wQuote);
+
     if (sei_tmp.lpParameters[0]) {
         strcatW(wcmd, wSpace);
         strcatW(wcmd, wszParameters);
diff --git a/dlls/shell32/shlfileop.c b/dlls/shell32/shlfileop.c
index 0b096b1..cbaa9ac 100644
--- a/dlls/shell32/shlfileop.c
+++ b/dlls/shell32/shlfileop.c
@@ -59,24 +59,60 @@ WINE_DEFAULT_DEBUG_CHANNEL(shell);
 static const WCHAR wWildcardFile[] = {'*',0};
 static const WCHAR wWildcardChars[] = {'*','?',0};
 
-static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec);
-static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec);
-static DWORD SHNotifyRemoveDirectoryA(LPCSTR path);
-static DWORD SHNotifyRemoveDirectoryW(LPCWSTR path);
-static DWORD SHNotifyDeleteFileA(LPCSTR path);
-static DWORD SHNotifyDeleteFileW(LPCWSTR path);
-static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest);
-static DWORD SHNotifyCopyFileW(LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists);
-static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly);
-
 typedef struct
 {
     SHFILEOPSTRUCTW *req;
     DWORD dwYesToAllMask;
     BOOL bManyItems;
     BOOL bCancelled;
+    IProgressDialog *progress;
+    ULARGE_INTEGER completedSize;
+    ULARGE_INTEGER totalSize;
+    WCHAR szBuilderString[64];
 } FILE_OPERATION;
 
+typedef struct
+{
+    DWORD attributes;
+    LPWSTR szDirectory;
+    LPWSTR szFilename;
+    LPWSTR szFullPath;
+    BOOL bFromWildcard;
+    BOOL bFromRelative;
+    BOOL bExists;
+} FILE_ENTRY;
+
+typedef struct
+{
+    FILE_ENTRY *feFiles;
+    DWORD num_alloc;
+    DWORD dwNumFiles;
+    BOOL bAnyFromWildcard;
+    BOOL bAnyDirectories;
+    BOOL bAnyDontExist;
+} FILE_LIST;
+
+#define ERROR_SHELL_INTERNAL_FILE_NOT_FOUND 1026
+
+static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec);
+static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec);
+static DWORD SHNotifyRemoveDirectoryA(LPCSTR path);
+static DWORD SHNotifyRemoveDirectoryW(LPCWSTR path);
+static DWORD SHNotifyDeleteFileA(FILE_OPERATION *op, LPCSTR path);
+static DWORD SHNotifyDeleteFileW(FILE_OPERATION *op, LPCWSTR path);
+static DWORD SHNotifyMoveFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest);
+static DWORD SHNotifyCopyFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists);
+static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly);
+
+static DWORD copy_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, FILE_LIST *flTo);
+static DWORD move_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, const FILE_LIST *flTo);
+
+static void progressbar_calc_totalsize(FILE_OPERATION *op, const FILE_LIST *from);
+static void progressbar_update_title(FILE_OPERATION *op);
+static void progressbar_update_files(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dst);
+static DWORD CALLBACK progressbar_copy_routine(LARGE_INTEGER total_size, LARGE_INTEGER total_transferred, LARGE_INTEGER stream_size,
+        LARGE_INTEGER stream_transferred, DWORD stream_number, DWORD reason, HANDLE src_file, HANDLE dst_file, LPVOID user);
+
 /* Confirm dialogs with an optional "Yes To All" as used in file operations confirmations
  */
 static const WCHAR CONFIRM_MSG_PROP[] = {'W','I','N','E','_','C','O','N','F','I','R','M',0};
@@ -164,7 +200,7 @@ static INT_PTR ConfirmMsgBox_Init(HWND hDlg, LPARAM lParam)
     width = r.right - r.left;
     height = r.bottom - r.top - yOffset;
     MoveWindow(hDlg, (GetSystemMetrics(SM_CXSCREEN) - width)/2,
-        (GetSystemMetrics(SM_CYSCREEN) - height)/2, width, height, FALSE);
+               (GetSystemMetrics(SM_CYSCREEN) - height)/2, width, height, FALSE);
 
     confirm_msg_move_button(hDlg, IDCANCEL,     &xPos, yOffset, info->bYesToAll);
     confirm_msg_move_button(hDlg, IDNO,         &xPos, yOffset, TRUE);
@@ -206,107 +242,107 @@ static int SHELL_ConfirmMsgBox(HWND hWnd, LPWSTR lpszText, LPWSTR lpszCaption, H
 /* confirmation dialogs content */
 typedef struct
 {
-        HINSTANCE hIconInstance;
-        UINT icon_resource_id;
-	UINT caption_resource_id, text_resource_id;
+    HINSTANCE hIconInstance;
+    UINT icon_resource_id;
+    UINT caption_resource_id, text_resource_id;
 } SHELL_ConfirmIDstruc;
 
 static BOOL SHELL_ConfirmIDs(int nKindOfDialog, SHELL_ConfirmIDstruc *ids)
 {
-        ids->hIconInstance = shell32_hInstance;
-	switch (nKindOfDialog) {
-	  case ASK_DELETE_FILE:
+    ids->hIconInstance = shell32_hInstance;
+    switch (nKindOfDialog) {
+        case ASK_DELETE_FILE:
             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-	    ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
-	    ids->text_resource_id  = IDS_DELETEITEM_TEXT;
-	    return TRUE;
-	  case ASK_DELETE_FOLDER:
+            ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
+            ids->text_resource_id  = IDS_DELETEITEM_TEXT;
+            return TRUE;
+        case ASK_DELETE_FOLDER:
             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-	    ids->caption_resource_id  = IDS_DELETEFOLDER_CAPTION;
-	    ids->text_resource_id  = IDS_DELETEITEM_TEXT;
-	    return TRUE;
-	  case ASK_DELETE_MULTIPLE_ITEM:
+            ids->caption_resource_id  = IDS_DELETEFOLDER_CAPTION;
+            ids->text_resource_id  = IDS_DELETEITEM_TEXT;
+            return TRUE;
+        case ASK_DELETE_MULTIPLE_ITEM:
             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
-	    ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
-	    ids->text_resource_id  = IDS_DELETEMULTIPLE_TEXT;
-	    return TRUE;
-          case ASK_TRASH_FILE:
+            ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
+            ids->text_resource_id  = IDS_DELETEMULTIPLE_TEXT;
+            return TRUE;
+        case ASK_TRASH_FILE:
             ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
             ids->caption_resource_id = IDS_DELETEITEM_CAPTION;
             ids->text_resource_id = IDS_TRASHITEM_TEXT;
             return TRUE;
-          case ASK_TRASH_FOLDER:
+        case ASK_TRASH_FOLDER:
             ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
             ids->caption_resource_id = IDS_DELETEFOLDER_CAPTION;
             ids->text_resource_id = IDS_TRASHFOLDER_TEXT;
             return TRUE;
-          case ASK_TRASH_MULTIPLE_ITEM:
+        case ASK_TRASH_MULTIPLE_ITEM:
             ids->icon_resource_id = IDI_SHELL_TRASH_FILE;
             ids->caption_resource_id = IDS_DELETEITEM_CAPTION;
             ids->text_resource_id = IDS_TRASHMULTIPLE_TEXT;
             return TRUE;
-          case ASK_CANT_TRASH_ITEM:
+        case ASK_CANT_TRASH_ITEM:
             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
             ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
             ids->text_resource_id  = IDS_CANTTRASH_TEXT;
             return TRUE;
-	  case ASK_DELETE_SELECTED:
+        case ASK_DELETE_SELECTED:
             ids->icon_resource_id = IDI_SHELL_CONFIRM_DELETE;
             ids->caption_resource_id  = IDS_DELETEITEM_CAPTION;
             ids->text_resource_id  = IDS_DELETESELECTED_TEXT;
             return TRUE;
-	  case ASK_OVERWRITE_FILE:
+        case ASK_OVERWRITE_FILE:
             ids->hIconInstance = NULL;
             ids->icon_resource_id = IDI_WARNING;
-	    ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
-	    ids->text_resource_id  = IDS_OVERWRITEFILE_TEXT;
+            ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
+            ids->text_resource_id  = IDS_OVERWRITEFILE_TEXT;
             return TRUE;
-	  case ASK_OVERWRITE_FOLDER:
+        case ASK_OVERWRITE_FOLDER:
             ids->hIconInstance = NULL;
             ids->icon_resource_id = IDI_WARNING;
             ids->caption_resource_id  = IDS_OVERWRITEFILE_CAPTION;
             ids->text_resource_id  = IDS_OVERWRITEFOLDER_TEXT;
             return TRUE;
-	  default:
-	    FIXME(" Unhandled nKindOfDialog %d stub\n", nKindOfDialog);
-	}
-	return FALSE;
+        default:
+            FIXME(" Unhandled nKindOfDialog %d stub\n", nKindOfDialog);
+   }
+   return FALSE;
 }
 
 static BOOL SHELL_ConfirmDialogW(HWND hWnd, int nKindOfDialog, LPCWSTR szDir, FILE_OPERATION *op)
 {
-	WCHAR szCaption[255], szText[255], szBuffer[MAX_PATH + 256];
-	SHELL_ConfirmIDstruc ids;
-	DWORD_PTR args[1];
-	HICON hIcon;
-	int ret;
+    WCHAR szCaption[255], szText[255], szBuffer[MAX_PATH + 256];
+    SHELL_ConfirmIDstruc ids;
+    DWORD_PTR args[1];
+    HICON hIcon;
+    int ret;
 
-        assert(nKindOfDialog >= 0 && nKindOfDialog < 32);
-        if (op && (op->dwYesToAllMask & (1 << nKindOfDialog)))
-            return TRUE;
+    assert(nKindOfDialog >= 0 && nKindOfDialog < 32);
+    if (op && (op->dwYesToAllMask & (1 << nKindOfDialog)))
+        return TRUE;
 
-        if (!SHELL_ConfirmIDs(nKindOfDialog, &ids)) return FALSE;
+    if (!SHELL_ConfirmIDs(nKindOfDialog, &ids)) return FALSE;
 
-	LoadStringW(shell32_hInstance, ids.caption_resource_id, szCaption, sizeof(szCaption)/sizeof(WCHAR));
-	LoadStringW(shell32_hInstance, ids.text_resource_id, szText, sizeof(szText)/sizeof(WCHAR));
+    LoadStringW(shell32_hInstance, ids.caption_resource_id, szCaption, sizeof(szCaption)/sizeof(WCHAR));
+    LoadStringW(shell32_hInstance, ids.text_resource_id, szText, sizeof(szText)/sizeof(WCHAR));
 
-	args[0] = (DWORD_PTR)szDir;
-	FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
-	               szText, 0, 0, szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), (__ms_va_list*)args);
-        hIcon = LoadIconW(ids.hIconInstance, (LPWSTR)MAKEINTRESOURCE(ids.icon_resource_id));
+    args[0] = (DWORD_PTR)szDir;
+    FormatMessageW(FORMAT_MESSAGE_FROM_STRING|FORMAT_MESSAGE_ARGUMENT_ARRAY,
+     szText, 0, 0, szBuffer, sizeof(szBuffer)/sizeof(szBuffer[0]), (__ms_va_list*)args);
+    hIcon = LoadIconW(ids.hIconInstance, (LPWSTR)MAKEINTRESOURCE(ids.icon_resource_id));
 
-        ret = SHELL_ConfirmMsgBox(hWnd, szBuffer, szCaption, hIcon, op && op->bManyItems);
-        if (op) {
-            if (ret == IDD_YESTOALL) {
-                op->dwYesToAllMask |= (1 << nKindOfDialog);
-                ret = IDYES;
-            }
-            if (ret == IDCANCEL)
-                op->bCancelled = TRUE;
-            if (ret != IDYES)
-                op->req->fAnyOperationsAborted = TRUE;
+    ret = SHELL_ConfirmMsgBox(hWnd, szBuffer, szCaption, hIcon, op && op->bManyItems);
+    if (op) {
+        if (ret == IDD_YESTOALL) {
+            op->dwYesToAllMask |= (1 << nKindOfDialog);
+            ret = IDYES;
         }
-        return ret == IDYES;
+        if (ret == IDCANCEL)
+            op->bCancelled = TRUE;
+        if (ret != IDYES)
+            op->req->fAnyOperationsAborted = TRUE;
+    }
+    return ret == IDYES;
 }
 
 BOOL SHELL_ConfirmYesNoW(HWND hWnd, int nKindOfDialog, LPCWSTR szDir)
@@ -316,23 +352,23 @@ BOOL SHELL_ConfirmYesNoW(HWND hWnd, int nKindOfDialog, LPCWSTR szDir)
 
 static DWORD SHELL32_AnsiToUnicodeBuf(LPCSTR aPath, LPWSTR *wPath, DWORD minChars)
 {
-	DWORD len = MultiByteToWideChar(CP_ACP, 0, aPath, -1, NULL, 0);
+    DWORD len = MultiByteToWideChar(CP_ACP, 0, aPath, -1, NULL, 0);
 
-	if (len < minChars)
-	  len = minChars;
+    if (len < minChars)
+      len = minChars;
 
-	*wPath = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
-	if (*wPath)
-	{
-	  MultiByteToWideChar(CP_ACP, 0, aPath, -1, *wPath, len);
-	  return NO_ERROR;
-	}
-	return E_OUTOFMEMORY;
+    *wPath = HeapAlloc(GetProcessHeap(), 0, len * sizeof(WCHAR));
+    if (*wPath)
+    {
+        MultiByteToWideChar(CP_ACP, 0, aPath, -1, *wPath, len);
+        return NO_ERROR;
+    }
+    return E_OUTOFMEMORY;
 }
 
 static void SHELL32_FreeUnicodeBuf(LPWSTR wPath)
 {
-	HeapFree(GetProcessHeap(), 0, wPath);
+    HeapFree(GetProcessHeap(), 0, wPath);
 }
 
 HRESULT WINAPI SHIsFileAvailableOffline(LPCWSTR path, LPDWORD status)
@@ -347,7 +383,7 @@ HRESULT WINAPI SHIsFileAvailableOffline(LPCWSTR path, LPDWORD status)
  * Asks for confirmation when bShowUI is true and deletes the directory and
  * all its subdirectories and files if necessary.
  */
-static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
+static DWORD SHELL_DeleteDirectoryW(FILE_OPERATION *op, LPCWSTR pszDir, BOOL bShowUI)
 {
     DWORD    ret = 0;
     HANDLE  hFind;
@@ -357,16 +393,25 @@ static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
     PathCombineW(szTemp, pszDir, wWildcardFile);
     hFind = FindFirstFileW(szTemp, &wfd);
 
-    if (hFind != INVALID_HANDLE_VALUE) {
-        if (!bShowUI || SHELL_ConfirmDialogW(hwnd, ASK_DELETE_FOLDER, pszDir, NULL)) {
+    if (hFind != INVALID_HANDLE_VALUE)
+    {
+        if (!bShowUI || SHELL_ConfirmDialogW(op->req->hwnd, ASK_DELETE_FOLDER, pszDir, NULL))
+        {
             do {
                 if (IsDotDir(wfd.cFileName))
                     continue;
                 PathCombineW(szTemp, pszDir, wfd.cFileName);
                 if (FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
-                    ret = SHELL_DeleteDirectoryW(hwnd, szTemp, FALSE);
+                    ret = SHELL_DeleteDirectoryW(op, szTemp, FALSE);
                 else
-                    ret = SHNotifyDeleteFileW(szTemp);
+                    ret = SHNotifyDeleteFileW(op, szTemp);
+
+                /* Check if dialog was cancelled in the meantime */
+                if (op->progress != NULL)
+                    op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+                if (op->bCancelled)
+                    break;
+
             } while (!ret && FindNextFileW(hFind, &wfd));
         }
         FindClose(hFind);
@@ -375,8 +420,8 @@ static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
         ret = SHNotifyRemoveDirectoryW(pszDir);
 
     return ret == ERROR_PATH_NOT_FOUND ?
-        0x7C: /* DE_INVALIDFILES (legacy Windows error) */
-        ret;
+                  0x7C: /* DE_INVALIDFILES (legacy Windows error) */
+                  ret;
 }
 
 /**************************************************************************
@@ -396,41 +441,41 @@ static DWORD SHELL_DeleteDirectoryW(HWND hwnd, LPCWSTR pszDir, BOOL bShowUI)
  */
 static DWORD SHNotifyCreateDirectoryA(LPCSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s, %p)\n", debugstr_a(path), sec);
+    TRACE("(%s, %p)\n", debugstr_a(path), sec);
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHNotifyCreateDirectoryW(wPath, sec);
-	  SHELL32_FreeUnicodeBuf(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHNotifyCreateDirectoryW(wPath, sec);
+        SHELL32_FreeUnicodeBuf(wPath);
+    }
+    return retCode;
 }
 
 /**********************************************************************/
 
 static DWORD SHNotifyCreateDirectoryW(LPCWSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	TRACE("(%s, %p)\n", debugstr_w(path), sec);
+    TRACE("(%s, %p)\n", debugstr_w(path), sec);
 
-	if (CreateDirectoryW(path, sec))
-	{
-	  SHChangeNotify(SHCNE_MKDIR, SHCNF_PATHW, path, NULL);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+    if (CreateDirectoryW(path, sec))
+    {
+        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATHW, path, NULL);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /**********************************************************************/
 
 BOOL WINAPI Win32CreateDirectoryAW(LPCVOID path, LPSECURITY_ATTRIBUTES sec)
 {
-	if (SHELL_OsIsUnicode())
-	  return (SHNotifyCreateDirectoryW(path, sec) == ERROR_SUCCESS);
-	return (SHNotifyCreateDirectoryA(path, sec) == ERROR_SUCCESS);
+    if (SHELL_OsIsUnicode())
+        return (SHNotifyCreateDirectoryW(path, sec) == ERROR_SUCCESS);
+    return (SHNotifyCreateDirectoryA(path, sec) == ERROR_SUCCESS);
 }
 
 /************************************************************************
@@ -450,116 +495,125 @@ BOOL WINAPI Win32CreateDirectoryAW(LPCVOID path, LPSECURITY_ATTRIBUTES sec)
  */
 static DWORD SHNotifyRemoveDirectoryA(LPCSTR path)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s)\n", debugstr_a(path));
+    TRACE("(%s)\n", debugstr_a(path));
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHNotifyRemoveDirectoryW(wPath);
-	  SHELL32_FreeUnicodeBuf(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHNotifyRemoveDirectoryW(wPath);
+        SHELL32_FreeUnicodeBuf(wPath);
+    }
+    return retCode;
 }
 
 /***********************************************************************/
 
 static DWORD SHNotifyRemoveDirectoryW(LPCWSTR path)
 {
-	BOOL ret;
-	TRACE("(%s)\n", debugstr_w(path));
-
-	ret = RemoveDirectoryW(path);
-	if (!ret)
-	{
-	  /* Directory may be write protected */
-	  DWORD dwAttr = GetFileAttributesW(path);
-	  if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY))
-	    if (SetFileAttributesW(path, dwAttr & ~FILE_ATTRIBUTE_READONLY))
-	      ret = RemoveDirectoryW(path);
-	}
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_RMDIR, SHCNF_PATHW, path, NULL);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+    BOOL ret;
+    TRACE("(%s)\n", debugstr_w(path));
+
+    ret = RemoveDirectoryW(path);
+    if (!ret)
+    {
+        /* Directory may be write protected */
+        DWORD dwAttr = GetFileAttributesW(path);
+        if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY))
+            if (SetFileAttributesW(path, dwAttr & ~FILE_ATTRIBUTE_READONLY))
+                ret = RemoveDirectoryW(path);
+    }
+    if (ret)
+    {
+        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATHW, path, NULL);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /***********************************************************************/
 
 BOOL WINAPI Win32RemoveDirectoryAW(LPCVOID path)
 {
-	if (SHELL_OsIsUnicode())
-	  return (SHNotifyRemoveDirectoryW(path) == ERROR_SUCCESS);
-	return (SHNotifyRemoveDirectoryA(path) == ERROR_SUCCESS);
+    if (SHELL_OsIsUnicode())
+        return (SHNotifyRemoveDirectoryW(path) == ERROR_SUCCESS);
+    return (SHNotifyRemoveDirectoryA(path) == ERROR_SUCCESS);
 }
 
-/************************************************************************
- * Win32DeleteFile           [SHELL32.164]
- *
- * Deletes a file. Also triggers a change notify if one exists.
- *
- * PARAMS
- *  path       [I]   path to file to delete
- *
- * RETURNS
- *  TRUE if successful, FALSE otherwise
- *
- * NOTES
- *  Verified on Win98 / IE 5 (SHELL32 4.72, March 1999 build) to be ANSI.
- *  This is Unicode on NT/2000
- */
-static DWORD SHNotifyDeleteFileA(LPCSTR path)
+/***********************************************************************/
+
+static DWORD SHNotifyDeleteFileA(FILE_OPERATION *op, LPCSTR path)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s)\n", debugstr_a(path));
+    TRACE("(%s)\n", debugstr_a(path));
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHNotifyDeleteFileW(wPath);
-	  SHELL32_FreeUnicodeBuf(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHNotifyDeleteFileW(op, wPath);
+        SHELL32_FreeUnicodeBuf(wPath);
+    }
+    return retCode;
 }
 
 /***********************************************************************/
 
-static DWORD SHNotifyDeleteFileW(LPCWSTR path)
-{
-	BOOL ret;
-
-	TRACE("(%s)\n", debugstr_w(path));
-
-	ret = DeleteFileW(path);
-	if (!ret)
-	{
-	  /* File may be write protected or a system file */
-	  DWORD dwAttr = GetFileAttributesW(path);
-	  if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
-	    if (SetFileAttributesW(path, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
-	      ret = DeleteFileW(path);
-	}
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_DELETE, SHCNF_PATHW, path, NULL);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+static DWORD SHNotifyDeleteFileW(FILE_OPERATION *op, LPCWSTR path)
+{
+    BOOL ret;
+    LARGE_INTEGER filesize;
+    filesize.QuadPart = 0;
+
+    TRACE("(%s)\n", debugstr_w(path));
+
+    /* Warning: can also be called with empty op */
+    if (op)
+    {
+        WIN32_FILE_ATTRIBUTE_DATA info;
+        progressbar_update_files(op, path, NULL);
+        if (GetFileAttributesExW(path, GetFileExInfoStandard, &info))
+        {
+            filesize.u.HighPart = info.nFileSizeHigh;
+            filesize.u.LowPart  = info.nFileSizeLow;
+        }
+    }
+
+    ret = DeleteFileW(path);
+    if (!ret)
+    {
+        /* File may be write protected or a system file */
+        DWORD dwAttr = GetFileAttributesW(path);
+        if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
+            if (SetFileAttributesW(path, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
+                ret = DeleteFileW(path);
+    }
+    if (ret)
+    {
+        if (op)
+        {
+            /* There is no progress while deleting a file,
+             * simply report full file size when we are done. */
+            progressbar_copy_routine(filesize, filesize, filesize, filesize, 0,
+                                     CALLBACK_STREAM_SWITCH, NULL, NULL, op);
+        }
+
+        SHChangeNotify(SHCNE_DELETE, SHCNF_PATHW, path, NULL);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /***********************************************************************/
 
 DWORD WINAPI Win32DeleteFileAW(LPCVOID path)
 {
-	if (SHELL_OsIsUnicode())
-	  return (SHNotifyDeleteFileW(path) == ERROR_SUCCESS);
-	return (SHNotifyDeleteFileA(path) == ERROR_SUCCESS);
+    if (SHELL_OsIsUnicode())
+        return (SHNotifyDeleteFileW(NULL, path) == ERROR_SUCCESS);
+    return (SHNotifyDeleteFileA(NULL, path) == ERROR_SUCCESS);
 }
 
 /************************************************************************
@@ -568,44 +622,48 @@ DWORD WINAPI Win32DeleteFileAW(LPCVOID path)
  * Moves a file. Also triggers a change notify if one exists.
  *
  * PARAMS
+ *  op         [I]   file operation context
  *  src        [I]   path to source file to move
  *  dest       [I]   path to target file to move to
  *
  * RETURNS
  *  ERORR_SUCCESS if successful
  */
-static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest)
-{
-	BOOL ret;
-
-	TRACE("(%s %s)\n", debugstr_w(src), debugstr_w(dest));
-
-        ret = MoveFileExW(src, dest, MOVEFILE_REPLACE_EXISTING);
-
-        /* MOVEFILE_REPLACE_EXISTING fails with dirs, so try MoveFile */
-        if (!ret)
-            ret = MoveFileW(src, dest);
-
-	if (!ret)
-	{
-	  DWORD dwAttr;
-
-	  dwAttr = SHFindAttrW(dest, FALSE);
-	  if (INVALID_FILE_ATTRIBUTES == dwAttr)
-	  {
-	    /* Source file may be write protected or a system file */
-	    dwAttr = GetFileAttributesW(src);
-	    if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
-	      if (SetFileAttributesW(src, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
-	        ret = MoveFileW(src, dest);
-	  }
-	}
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATHW, src, dest);
-	  return ERROR_SUCCESS;
-	}
-	return GetLastError();
+static DWORD SHNotifyMoveFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest)
+{
+    BOOL ret;
+
+    TRACE("(%s %s)\n", debugstr_w(src), debugstr_w(dest));
+
+    progressbar_update_files(op, src, dest);
+
+    ret = MoveFileWithProgressW(src, dest, progressbar_copy_routine,
+                                op, MOVEFILE_REPLACE_EXISTING);
+
+    /* MOVEFILE_REPLACE_EXISTING fails with dirs, so try MoveFile */
+    if (!ret)
+        ret = MoveFileW(src, dest);
+
+    if (!ret)
+    {
+        DWORD dwAttr;
+
+        dwAttr = SHFindAttrW(dest, FALSE);
+        if (INVALID_FILE_ATTRIBUTES == dwAttr)
+        {
+            /* Source file may be write protected or a system file */
+            dwAttr = GetFileAttributesW(src);
+            if (IsAttrib(dwAttr, FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM))
+                if (SetFileAttributesW(src, dwAttr & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
+                    ret = MoveFileW(src, dest);
+        }
+    }
+    if (ret)
+    {
+        SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_PATHW, src, dest);
+        return ERROR_SUCCESS;
+    }
+    return GetLastError();
 }
 
 /************************************************************************
@@ -614,6 +672,7 @@ static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest)
  * Copies a file. Also triggers a change notify if one exists.
  *
  * PARAMS
+ *  op            [I]   file operation context
  *  src           [I]   path to source file to move
  *  dest          [I]   path to target file to move to
  *  bFailIfExists [I]   if TRUE, the target file will not be overwritten if
@@ -622,26 +681,29 @@ static DWORD SHNotifyMoveFileW(LPCWSTR src, LPCWSTR dest)
  * RETURNS
  *  ERROR_SUCCESS if successful
  */
-static DWORD SHNotifyCopyFileW(LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists)
+static DWORD SHNotifyCopyFileW(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists)
 {
-	BOOL ret;
-	DWORD attribs;
+    BOOL ret;
+    DWORD attribs;
+
+    TRACE("(%s %s %s)\n", debugstr_w(src), debugstr_w(dest), bFailIfExists ? "failIfExists" : "");
 
-	TRACE("(%s %s %s)\n", debugstr_w(src), debugstr_w(dest), bFailIfExists ? "failIfExists" : "");
+    progressbar_update_files(op, src, dest);
 
-        /* Destination file may already exist with read only attribute */
-        attribs = GetFileAttributesW(dest);
-        if (IsAttrib(attribs, FILE_ATTRIBUTE_READONLY))
-          SetFileAttributesW(dest, attribs & ~FILE_ATTRIBUTE_READONLY);
+    /* Destination file may already exist with read only attribute */
+    attribs = GetFileAttributesW(dest);
+    if (IsAttrib(attribs, FILE_ATTRIBUTE_READONLY))
+        SetFileAttributesW(dest, attribs & ~FILE_ATTRIBUTE_READONLY);
 
-	ret = CopyFileW(src, dest, bFailIfExists);
-	if (ret)
-	{
-	  SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, dest, NULL);
-	  return ERROR_SUCCESS;
-	}
+    ret = CopyFileExW(src, dest, progressbar_copy_routine, op,
+                      &op->bCancelled, bFailIfExists);
+    if (ret)
+    {
+        SHChangeNotify(SHCNE_CREATE, SHCNF_PATHW, dest, NULL);
+        return ERROR_SUCCESS;
+    }
 
-	return GetLastError();
+    return GetLastError();
 }
 
 /*************************************************************************
@@ -671,9 +733,9 @@ static DWORD SHNotifyCopyFileW(LPCWSTR src, LPCWSTR dest, BOOL bFailIfExists)
  */
 DWORD WINAPI SHCreateDirectory(HWND hWnd, LPCVOID path)
 {
-	if (SHELL_OsIsUnicode())
-	  return SHCreateDirectoryExW(hWnd, path, NULL);
-	return SHCreateDirectoryExA(hWnd, path, NULL);
+    if (SHELL_OsIsUnicode())
+        return SHCreateDirectoryExW(hWnd, path, NULL);
+    return SHCreateDirectoryExA(hWnd, path, NULL);
 }
 
 /*************************************************************************
@@ -710,18 +772,18 @@ DWORD WINAPI SHCreateDirectory(HWND hWnd, LPCVOID path)
  */
 int WINAPI SHCreateDirectoryExA(HWND hWnd, LPCSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	LPWSTR wPath;
-	DWORD retCode;
+    LPWSTR wPath;
+    DWORD retCode;
 
-	TRACE("(%s, %p)\n", debugstr_a(path), sec);
+    TRACE("(%s, %p)\n", debugstr_a(path), sec);
 
-	retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
-	if (!retCode)
-	{
-	  retCode = SHCreateDirectoryExW(hWnd, wPath, sec);
-	  SHELL32_FreeUnicodeBuf(wPath);
-	}
-	return retCode;
+    retCode = SHELL32_AnsiToUnicodeBuf(path, &wPath, 0);
+    if (!retCode)
+    {
+        retCode = SHCreateDirectoryExW(hWnd, wPath, sec);
+        SHELL32_FreeUnicodeBuf(wPath);
+    }
+    return retCode;
 }
 
 /*************************************************************************
@@ -731,49 +793,49 @@ int WINAPI SHCreateDirectoryExA(HWND hWnd, LPCSTR path, LPSECURITY_ATTRIBUTES se
  */
 int WINAPI SHCreateDirectoryExW(HWND hWnd, LPCWSTR path, LPSECURITY_ATTRIBUTES sec)
 {
-	int ret = ERROR_BAD_PATHNAME;
-	TRACE("(%p, %s, %p)\n", hWnd, debugstr_w(path), sec);
-
-	if (PathIsRelativeW(path))
-	{
-	  SetLastError(ret);
-	}
-	else
-	{
-	  ret = SHNotifyCreateDirectoryW(path, sec);
-	  /* Refuse to work on certain error codes before trying to create directories recursively */
-	  if (ret != ERROR_SUCCESS &&
-	      ret != ERROR_FILE_EXISTS &&
-	      ret != ERROR_ALREADY_EXISTS &&
-	      ret != ERROR_FILENAME_EXCED_RANGE)
-	  {
-	    WCHAR *pEnd, *pSlash, szTemp[MAX_PATH + 1];  /* extra for PathAddBackslash() */
-
-	    lstrcpynW(szTemp, path, MAX_PATH);
-	    pEnd = PathAddBackslashW(szTemp);
-	    pSlash = szTemp + 3;
-
-	    while (*pSlash)
-	    {
-              while (*pSlash && *pSlash != '\\') pSlash++;
-	      if (*pSlash)
-	      {
-	        *pSlash = 0;    /* terminate path at separator */
-
-	        ret = SHNotifyCreateDirectoryW(szTemp, pSlash + 1 == pEnd ? sec : NULL);
-	      }
-	      *pSlash++ = '\\'; /* put the separator back */
-	    }
-	  }
-
-	  if (ret && hWnd && (ERROR_CANCELLED != ret))
-	  {
-	    /* We failed and should show a dialog box */
-	    FIXME("Show system error message, creating path %s, failed with error %d\n", debugstr_w(path), ret);
-	    ret = ERROR_CANCELLED; /* Error has been already presented to user (not really yet!) */
-	  }
-	}
-	return ret;
+    int ret = ERROR_BAD_PATHNAME;
+    TRACE("(%p, %s, %p)\n", hWnd, debugstr_w(path), sec);
+
+    if (PathIsRelativeW(path))
+    {
+        SetLastError(ret);
+    }
+    else
+    {
+        ret = SHNotifyCreateDirectoryW(path, sec);
+        /* Refuse to work on certain error codes before trying to create directories recursively */
+        if (ret != ERROR_SUCCESS &&
+            ret != ERROR_FILE_EXISTS &&
+            ret != ERROR_ALREADY_EXISTS &&
+            ret != ERROR_FILENAME_EXCED_RANGE)
+        {
+            WCHAR *pEnd, *pSlash, szTemp[MAX_PATH + 1];  /* extra for PathAddBackslash() */
+
+            lstrcpynW(szTemp, path, MAX_PATH);
+            pEnd = PathAddBackslashW(szTemp);
+            pSlash = szTemp + 3;
+
+            while (*pSlash)
+            {
+                while (*pSlash && *pSlash != '\\') pSlash++;
+                if (*pSlash)
+                {
+                    *pSlash = 0;    /* terminate path at separator */
+
+                    ret = SHNotifyCreateDirectoryW(szTemp, pSlash + 1 == pEnd ? sec : NULL);
+                }
+                *pSlash++ = '\\'; /* put the separator back */
+            }
+        }
+
+        if (ret && hWnd && (ERROR_CANCELLED != ret))
+        {
+            /* We failed and should show a dialog box */
+            FIXME("Show system error message, creating path %s, failed with error %d\n", debugstr_w(path), ret);
+            ret = ERROR_CANCELLED; /* Error has been already presented to user (not really yet!) */
+        }
+    }
+    return ret;
 }
 
 /*************************************************************************
@@ -793,25 +855,25 @@ int WINAPI SHCreateDirectoryExW(HWND hWnd, LPCWSTR path, LPSECURITY_ATTRIBUTES s
  */
 static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly)
 {
-	WIN32_FIND_DATAW wfd;
-	BOOL b_FileMask = fileOnly && (NULL != StrPBrkW(pName, wWildcardChars));
-	DWORD dwAttr = INVALID_FILE_ATTRIBUTES;
-	HANDLE hFind = FindFirstFileW(pName, &wfd);
-
-	TRACE("%s %d\n", debugstr_w(pName), fileOnly);
-	if (INVALID_HANDLE_VALUE != hFind)
-	{
-	  do
-	  {
-	    if (b_FileMask && IsAttribDir(wfd.dwFileAttributes))
-	       continue;
-	    dwAttr = wfd.dwFileAttributes;
-	    break;
-	  }
-	  while (FindNextFileW(hFind, &wfd));
-	  FindClose(hFind);
-	}
-	return dwAttr;
+    WIN32_FIND_DATAW wfd;
+    BOOL b_FileMask = fileOnly && (NULL != StrPBrkW(pName, wWildcardChars));
+    DWORD dwAttr = INVALID_FILE_ATTRIBUTES;
+    HANDLE hFind = FindFirstFileW(pName, &wfd);
+
+    TRACE("%s %d\n", debugstr_w(pName), fileOnly);
+    if (INVALID_HANDLE_VALUE != hFind)
+    {
+        do
+        {
+            if (b_FileMask && IsAttribDir(wfd.dwFileAttributes))
+                continue;
+            dwAttr = wfd.dwFileAttributes;
+            break;
+        }
+        while (FindNextFileW(hFind, &wfd));
+        FindClose(hFind);
+    }
+    return dwAttr;
 }
 
 /*************************************************************************
@@ -825,27 +887,27 @@ static DWORD SHFindAttrW(LPCWSTR pName, BOOL fileOnly)
  */
 static DWORD SHNameTranslate(LPWSTR* wString, LPCWSTR* pWToFrom, BOOL more)
 {
-	DWORD size = 0, aSize = 0;
-	LPCSTR aString = (LPCSTR)*pWToFrom;
-
-	if (aString)
-	{
-	  do
-	  {
-	    size = lstrlenA(aString) + 1;
-	    aSize += size;
-	    aString += size;
-	  } while ((size != 1) && more);
-	  /* The two sizes might be different in the case of multibyte chars */
-	  size = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, 0);
-	  if (*wString) /* only in the second loop */
-	  {
-	    MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, size);
-	    *pWToFrom = *wString;
-	    *wString += size;
-	  }
-	}
-	return size;
+    DWORD size = 0, aSize = 0;
+    LPCSTR aString = (LPCSTR)*pWToFrom;
+
+    if (aString)
+    {
+        do
+        {
+            size = lstrlenA(aString) + 1;
+            aSize += size;
+            aString += size;
+        } while ((size != 1) && more);
+        /* The two sizes might be different in the case of multibyte chars */
+        size = MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, 0);
+        if (*wString) /* only in the second loop */
+        {
+            MultiByteToWideChar(CP_ACP, 0, (LPCSTR)*pWToFrom, aSize, *wString, size);
+            *pWToFrom = *wString;
+            *wString += size;
+        }
+    }
+    return size;
 }
 /*************************************************************************
  * SHFileOperationA          [SHELL32.@]
@@ -865,73 +927,49 @@ static DWORD SHNameTranslate(LPWSTR* wString, LPCWSTR* pWToFrom, BOOL more)
  */
 int WINAPI SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp)
 {
-	SHFILEOPSTRUCTW nFileOp = *((LPSHFILEOPSTRUCTW)lpFileOp);
-	int retCode = 0;
-	DWORD size;
-	LPWSTR ForFree = NULL, /* we change wString in SHNameTranslate and can't use it for freeing */
-	       wString = NULL; /* we change this in SHNameTranslate */
-
-	TRACE("\n");
-	if (FO_DELETE == (nFileOp.wFunc & FO_MASK))
-	  nFileOp.pTo = NULL; /* we need a NULL or a valid pointer for translation */
-	if (!(nFileOp.fFlags & FOF_SIMPLEPROGRESS))
-	  nFileOp.lpszProgressTitle = NULL; /* we need a NULL or a valid pointer for translation */
-	while (1) /* every loop calculate size, second translate also, if we have storage for this */
-	{
-	  size = SHNameTranslate(&wString, &nFileOp.lpszProgressTitle, FALSE); /* no loop */
-	  size += SHNameTranslate(&wString, &nFileOp.pFrom, TRUE); /* internal loop */
-	  size += SHNameTranslate(&wString, &nFileOp.pTo, TRUE); /* internal loop */
-
-	  if (ForFree)
-	  {
-	    retCode = SHFileOperationW(&nFileOp);
-	    HeapFree(GetProcessHeap(), 0, ForFree); /* we cannot use wString, it was changed */
-	    break;
-	  }
-	  else
-	  {
-	    wString = ForFree = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
-	    if (ForFree) continue;
-	    retCode = ERROR_OUTOFMEMORY;
-	    nFileOp.fAnyOperationsAborted = TRUE;
-	    SetLastError(retCode);
-	    return retCode;
-	  }
-	}
-
-	lpFileOp->hNameMappings = nFileOp.hNameMappings;
-	lpFileOp->fAnyOperationsAborted = nFileOp.fAnyOperationsAborted;
-	return retCode;
-}
-
-#define ERROR_SHELL_INTERNAL_FILE_NOT_FOUND 1026
-
-typedef struct
-{
-    DWORD attributes;
-    LPWSTR szDirectory;
-    LPWSTR szFilename;
-    LPWSTR szFullPath;
-    BOOL bFromWildcard;
-    BOOL bFromRelative;
-    BOOL bExists;
-} FILE_ENTRY;
+    SHFILEOPSTRUCTW nFileOp = *((LPSHFILEOPSTRUCTW)lpFileOp);
+    int retCode = 0;
+    DWORD size;
+    LPWSTR ForFree = NULL, /* we change wString in SHNameTranslate and can't use it for freeing */
+           wString = NULL; /* we change this in SHNameTranslate */
+
+    TRACE("\n");
+    if (FO_DELETE == (nFileOp.wFunc & FO_MASK))
+        nFileOp.pTo = NULL; /* we need a NULL or a valid pointer for translation */
+    if (!(nFileOp.fFlags & FOF_SIMPLEPROGRESS))
+        nFileOp.lpszProgressTitle = NULL; /* we need a NULL or a valid pointer for translation */
+    while (1) /* every loop calculate size, second translate also, if we have storage for this */
+    {
+        size = SHNameTranslate(&wString, &nFileOp.lpszProgressTitle, FALSE); /* no loop */
+        size += SHNameTranslate(&wString, &nFileOp.pFrom, TRUE); /* internal loop */
+        size += SHNameTranslate(&wString, &nFileOp.pTo, TRUE); /* internal loop */
 
-typedef struct
-{
-    FILE_ENTRY *feFiles;
-    DWORD num_alloc;
-    DWORD dwNumFiles;
-    BOOL bAnyFromWildcard;
-    BOOL bAnyDirectories;
-    BOOL bAnyDontExist;
-} FILE_LIST;
+        if (ForFree)
+        {
+            retCode = SHFileOperationW(&nFileOp);
+            HeapFree(GetProcessHeap(), 0, ForFree); /* we cannot use wString, it was changed */
+            break;
+        }
+        else
+        {
+            wString = ForFree = HeapAlloc(GetProcessHeap(), 0, size * sizeof(WCHAR));
+            if (ForFree) continue;
+            retCode = ERROR_OUTOFMEMORY;
+            nFileOp.fAnyOperationsAborted = TRUE;
+            SetLastError(retCode);
+            return retCode;
+        }
+    }
 
+    lpFileOp->hNameMappings = nFileOp.hNameMappings;
+    lpFileOp->fAnyOperationsAborted = nFileOp.fAnyOperationsAborted;
+    return retCode;
+}
 
 static inline void grow_list(FILE_LIST *list)
 {
     FILE_ENTRY *new = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, list->feFiles,
-                                  list->num_alloc * 2 * sizeof(*new) );
+    list->num_alloc * 2 * sizeof(*new) );
     list->feFiles = new;
     list->num_alloc *= 2;
 }
@@ -1022,8 +1060,8 @@ static HRESULT parse_file_list(FILE_LIST *flList, LPCWSTR szFiles)
 
     /* empty list */
     if (!szFiles[0])
-        return ERROR_ACCESS_DENIED;
-        
+        return ERROR_ACCESS_DENIED; /* S_OK for Windows 95/98 */
+
     flList->feFiles = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
                                 flList->num_alloc * sizeof(FILE_ENTRY));
 
@@ -1091,7 +1129,7 @@ static void destroy_file_list(FILE_LIST *flList)
 static void copy_dir_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, LPCWSTR szDestPath)
 {
     WCHAR szFrom[MAX_PATH], szTo[MAX_PATH];
-    SHFILEOPSTRUCTW fileOp;
+    FILE_LIST flFromNew, flToNew;
 
     static const WCHAR wildCardFiles[] = {'*','.','*',0};
 
@@ -1119,17 +1157,16 @@ static void copy_dir_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, LPCWST
     PathCombineW(szFrom, feFrom->szFullPath, wildCardFiles);
     szFrom[lstrlenW(szFrom) + 1] = '\0';
 
-    fileOp = *op->req;
-    fileOp.pFrom = szFrom;
-    fileOp.pTo = szTo;
-    fileOp.fFlags &= ~FOF_MULTIDESTFILES; /* we know we're copying to one dir */
+    ZeroMemory(&flFromNew, sizeof(FILE_LIST));
+    ZeroMemory(&flToNew, sizeof(FILE_LIST));
+    parse_file_list(&flFromNew, szFrom);
+    parse_file_list(&flToNew, szTo);
 
-    /* Don't ask the user about overwriting files when he accepted to overwrite the
-       folder. FIXME: this is not exactly what Windows does - e.g. there would be
-       an additional confirmation for a nested folder */
-    fileOp.fFlags |= FOF_NOCONFIRMATION;  
+    /* we know we're copying to one dir */
+    copy_files(op, FALSE, &flFromNew, &flToNew);
 
-    SHFileOperationW(&fileOp);
+    destroy_file_list(&flFromNew);
+    destroy_file_list(&flToNew);
 }
 
 static BOOL copy_file_to_file(FILE_OPERATION *op, const WCHAR *szFrom, const WCHAR *szTo)
@@ -1140,7 +1177,7 @@ static BOOL copy_file_to_file(FILE_OPERATION *op, const WCHAR *szFrom, const WCH
             return FALSE;
     }
 
-    return SHNotifyCopyFileW(szFrom, szTo, FALSE) == 0;
+    return SHNotifyCopyFileW(op, szFrom, szTo, FALSE) == 0;
 }
 
 /* copy a file or directory to another directory */
@@ -1180,7 +1217,7 @@ static void create_dest_dirs(LPCWSTR szDestDir)
 }
 
 /* the FO_COPY operation */
-static DWORD copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *flTo)
+static DWORD copy_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, FILE_LIST *flTo)
 {
     DWORD i;
     const FILE_ENTRY *entryToCopy;
@@ -1203,7 +1240,7 @@ static DWORD copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *
         fileDest = &flTo->feFiles[0];
     }
 
-    if (op->req->fFlags & FOF_MULTIDESTFILES)
+    if (multidest)
     {
         if (flFrom->bAnyFromWildcard)
             return ERROR_CANCELLED;
@@ -1255,8 +1292,7 @@ static DWORD copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *
     {
         entryToCopy = &flFrom->feFiles[i];
 
-        if ((op->req->fFlags & FOF_MULTIDESTFILES) &&
-            flTo->dwNumFiles > 1)
+        if (multidest && flTo->dwNumFiles > 1)
         {
             fileDest = &flTo->feFiles[i];
         }
@@ -1296,6 +1332,8 @@ static DWORD copy_files(FILE_OPERATION *op, const FILE_LIST *flFrom, FILE_LIST *
         }
 
         /* Vista return code. XP would return e.g. ERROR_FILE_NOT_FOUND, ERROR_ALREADY_EXISTS */
+        if (op->progress != NULL)
+            op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
         if (op->bCancelled)
             return ERROR_CANCELLED;
     }
@@ -1328,7 +1366,7 @@ static BOOL confirm_delete_list(HWND hWnd, DWORD fFlags, BOOL fTrash, const FILE
 }
 
 /* the FO_DELETE operation */
-static DWORD delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
+static DWORD delete_files(FILE_OPERATION *op, const FILE_LIST *flFrom)
 {
     const FILE_ENTRY *fileEntry;
     DWORD i, ret;
@@ -1338,13 +1376,13 @@ static DWORD delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
         return ERROR_SUCCESS;
 
     /* Windows also checks only the first item */
-    bTrash = (lpFileOp->fFlags & FOF_ALLOWUNDO)
-        && TRASH_CanTrashFile(flFrom->feFiles[0].szFullPath);
+    bTrash = (op->req->fFlags & FOF_ALLOWUNDO)
+             && TRASH_CanTrashFile(flFrom->feFiles[0].szFullPath);
 
-    if (!(lpFileOp->fFlags & FOF_NOCONFIRMATION) || (!bTrash && lpFileOp->fFlags & FOF_WANTNUKEWARNING))
-        if (!confirm_delete_list(lpFileOp->hwnd, lpFileOp->fFlags, bTrash, flFrom))
+    if (!(op->req->fFlags & FOF_NOCONFIRMATION) || (!bTrash && op->req->fFlags & FOF_WANTNUKEWARNING))
+        if (!confirm_delete_list(op->req->hwnd, op->req->fFlags, bTrash, flFrom))
         {
-            lpFileOp->fAnyOperationsAborted = TRUE;
+            op->req->fAnyOperationsAborted = TRUE;
             return 0;
         }
 
@@ -1353,7 +1391,7 @@ static DWORD delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
         fileEntry = &flFrom->feFiles[i];
 
         if (!IsAttribFile(fileEntry->attributes) &&
-            (lpFileOp->fFlags & FOF_FILESONLY && fileEntry->bFromWildcard))
+            (op->req->fFlags & FOF_FILESONLY && fileEntry->bFromWildcard))
             continue;
 
         if (bTrash)
@@ -1363,43 +1401,47 @@ static DWORD delete_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom)
                 continue;
 
             /* Note: Windows silently deletes the file in such a situation, we show a dialog */
-            if (!(lpFileOp->fFlags & FOF_NOCONFIRMATION) || (lpFileOp->fFlags & FOF_WANTNUKEWARNING))
-                bDelete = SHELL_ConfirmDialogW(lpFileOp->hwnd, ASK_CANT_TRASH_ITEM, fileEntry->szFullPath, NULL);
+            if (!(op->req->fFlags & FOF_NOCONFIRMATION) || (op->req->fFlags & FOF_WANTNUKEWARNING))
+                bDelete = SHELL_ConfirmDialogW(op->req->hwnd, ASK_CANT_TRASH_ITEM, fileEntry->szFullPath, NULL);
             else
                 bDelete = TRUE;
 
             if (!bDelete)
             {
-                lpFileOp->fAnyOperationsAborted = TRUE;
+                op->req->fAnyOperationsAborted = TRUE;
                 break;
             }
         }
-        
+
         /* delete the file or directory */
         if (IsAttribFile(fileEntry->attributes))
-            ret = DeleteFileW(fileEntry->szFullPath) ?
-                    ERROR_SUCCESS : GetLastError();
+            ret = SHNotifyDeleteFileW(op, fileEntry->szFullPath);
         else
-            ret = SHELL_DeleteDirectoryW(lpFileOp->hwnd, fileEntry->szFullPath, FALSE);
+            ret = SHELL_DeleteDirectoryW(op, fileEntry->szFullPath, FALSE);
 
         if (ret)
             return ret;
+
+        if (op->progress != NULL)
+            op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+        if (op->bCancelled)
+            return ERROR_CANCELLED;
     }
 
     return ERROR_SUCCESS;
 }
 
 /* moves a file or directory to another directory */
-static void move_to_dir(LPSHFILEOPSTRUCTW lpFileOp, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
+static void move_to_dir(FILE_OPERATION *op, const FILE_ENTRY *feFrom, const FILE_ENTRY *feTo)
 {
     WCHAR szDestPath[MAX_PATH];
 
     PathCombineW(szDestPath, feTo->szFullPath, feFrom->szFilename);
-    SHNotifyMoveFileW(feFrom->szFullPath, szDestPath);
+    SHNotifyMoveFileW(op, feFrom->szFullPath, szDestPath);
 }
 
 /* the FO_MOVE operation */
-static DWORD move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const FILE_LIST *flTo)
+static DWORD move_files(FILE_OPERATION *op, BOOL multidest, const FILE_LIST *flFrom, const FILE_LIST *flTo)
 {
     DWORD i;
     INT mismatched = 0;
@@ -1412,14 +1454,12 @@ static DWORD move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, con
     if (!flTo->dwNumFiles)
         return ERROR_FILE_NOT_FOUND;
 
-    if (!(lpFileOp->fFlags & FOF_MULTIDESTFILES) &&
-        flTo->dwNumFiles > 1 && flFrom->dwNumFiles > 1)
+    if (!multidest && flTo->dwNumFiles > 1 && flFrom->dwNumFiles > 1)
     {
         return ERROR_CANCELLED;
     }
 
-    if (!(lpFileOp->fFlags & FOF_MULTIDESTFILES) &&
-        !flFrom->bAnyDirectories &&
+    if (!multidest && !flFrom->bAnyDirectories &&
         flFrom->dwNumFiles > flTo->dwNumFiles)
     {
         return ERROR_CANCELLED;
@@ -1428,7 +1468,7 @@ static DWORD move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, con
     if (!PathFileExistsW(flTo->feFiles[0].szDirectory))
         return ERROR_CANCELLED;
 
-    if (lpFileOp->fFlags & FOF_MULTIDESTFILES)
+    if (multidest)
         mismatched = flFrom->dwNumFiles - flTo->dwNumFiles;
 
     fileDest = &flTo->feFiles[0];
@@ -1439,7 +1479,7 @@ static DWORD move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, con
         if (!PathFileExistsW(fileDest->szDirectory))
             return ERROR_CANCELLED;
 
-        if (lpFileOp->fFlags & FOF_MULTIDESTFILES)
+        if (multidest)
         {
             if (i >= flTo->dwNumFiles)
                 break;
@@ -1453,9 +1493,14 @@ static DWORD move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, con
         }
 
         if (fileDest->bExists && IsAttribDir(fileDest->attributes))
-            move_to_dir(lpFileOp, entryToMove, fileDest);
+            move_to_dir(op, entryToMove, fileDest);
         else
-            SHNotifyMoveFileW(entryToMove->szFullPath, fileDest->szFullPath);
+            SHNotifyMoveFileW(op, entryToMove->szFullPath, fileDest->szFullPath);
+
+        if (op->progress != NULL)
+            op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+        if (op->bCancelled)
+            return ERROR_CANCELLED;
     }
 
     if (mismatched > 0)
@@ -1470,7 +1515,7 @@ static DWORD move_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, con
 }
 
 /* the FO_RENAME files */
-static DWORD rename_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, const FILE_LIST *flTo)
+static DWORD rename_files(FILE_OPERATION *op, const FILE_LIST *flFrom, const FILE_LIST *flTo)
 {
     const FILE_ENTRY *feFrom;
     const FILE_ENTRY *feTo;
@@ -1492,15 +1537,15 @@ static DWORD rename_files(LPSHFILEOPSTRUCTW lpFileOp, const FILE_LIST *flFrom, c
     if (feTo->bExists)
         return ERROR_ALREADY_EXISTS;
 
-    return SHNotifyMoveFileW(feFrom->szFullPath, feTo->szFullPath);
+    return SHNotifyMoveFileW(op, feFrom->szFullPath, feTo->szFullPath);
 }
 
 /* alert the user if an unsupported flag is used */
 static void check_flags(FILEOP_FLAGS fFlags)
 {
     WORD wUnsupportedFlags = FOF_NO_CONNECTED_ELEMENTS |
-        FOF_NOCOPYSECURITYATTRIBS | FOF_NORECURSEREPARSE |
-        FOF_RENAMEONCOLLISION | FOF_WANTMAPPINGHANDLE;
+                             FOF_NOCOPYSECURITYATTRIBS | FOF_NORECURSEREPARSE |
+                             FOF_RENAMEONCOLLISION | FOF_WANTMAPPINGHANDLE;
 
     if (fFlags & wUnsupportedFlags)
         FIXME("Unsupported flags: %04x\n", fFlags);
@@ -1515,6 +1560,7 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
 {
     FILE_OPERATION op;
     FILE_LIST flFrom, flTo;
+    HRESULT co_ret = E_FAIL;
     int ret = 0;
 
     if (!lpFileOp)
@@ -1526,35 +1572,75 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
     ZeroMemory(&flTo, sizeof(FILE_LIST));
 
     if ((ret = parse_file_list(&flFrom, lpFileOp->pFrom)))
+    {
+        if (ret != ERROR_ACCESS_DENIED)
+            return ret;
+
+        /* Win 9X */
+        if (GetVersion() & 0x80000000)
+            return S_OK;
+
+        FIXME("The return value of this function call depends on the windows version.\n");
+        FIXME("For old software it might be necessary to set the windows version to 95/98 using winecfg.\n");
+
         return ret;
+    }
 
     if (lpFileOp->wFunc != FO_DELETE)
         parse_file_list(&flTo, lpFileOp->pTo);
 
     ZeroMemory(&op, sizeof(op));
     op.req = lpFileOp;
+    op.totalSize.QuadPart = 0;
+    op.completedSize.QuadPart = 0;
     op.bManyItems = (flFrom.dwNumFiles > 1);
     lpFileOp->fAnyOperationsAborted = FALSE;
 
+    if (lpFileOp->wFunc != FO_RENAME && !(lpFileOp->fFlags & FOF_SILENT))
+    {
+        co_ret = CoInitialize(NULL);
+        ret = CoCreateInstance(&CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER,
+                               &IID_IProgressDialog, (void**)&op.progress);
+        if (SUCCEEDED(ret))
+        {
+            IProgressDialog_StartProgressDialog(op.progress, op.req->hwnd, NULL,
+                                                PROGDLG_NORMAL | PROGDLG_AUTOTIME, NULL);
+
+            progressbar_update_title(&op);
+            progressbar_calc_totalsize(&op, &flFrom);
+        }
+        else
+        {
+            FIXME("Failed to create progress dialog\n");
+            op.progress = NULL;
+        }
+    }
+
     switch (lpFileOp->wFunc)
     {
         case FO_COPY:
-            ret = copy_files(&op, &flFrom, &flTo);
+            ret = copy_files(&op, op.req->fFlags & FOF_MULTIDESTFILES, &flFrom, &flTo);
             break;
         case FO_DELETE:
-            ret = delete_files(lpFileOp, &flFrom);
+            ret = delete_files(&op, &flFrom);
             break;
         case FO_MOVE:
-            ret = move_files(lpFileOp, &flFrom, &flTo);
+            ret = move_files(&op, op.req->fFlags & FOF_MULTIDESTFILES, &flFrom, &flTo);
             break;
         case FO_RENAME:
-            ret = rename_files(lpFileOp, &flFrom, &flTo);
+            ret = rename_files(&op, &flFrom, &flTo);
             break;
         default:
             ret = ERROR_INVALID_PARAMETER;
             break;
     }
 
+    if (op.progress)
+    {
+        IProgressDialog_StopProgressDialog(op.progress);
+        IProgressDialog_Release(op.progress);
+    }
+
     destroy_file_list(&flFrom);
 
     if (lpFileOp->wFunc != FO_DELETE)
@@ -1563,6 +1649,9 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
     if (ret == ERROR_CANCELLED)
         lpFileOp->fAnyOperationsAborted = TRUE;
 
+    if (SUCCEEDED(co_ret))
+        CoUninitialize();
+
     return ret;
 }
 
@@ -1582,19 +1671,19 @@ int WINAPI SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp)
  */
 void WINAPI SHFreeNameMappings(HANDLE hNameMapping)
 {
-	if (hNameMapping)
-	{
-	  int i = SHDSA_GetItemCount((HDSA)hNameMapping) - 1;
+    if (hNameMapping)
+    {
+        int i = SHDSA_GetItemCount((HDSA)hNameMapping) - 1;
 
-	  for (; i>= 0; i--)
-	  {
+        for (; i>= 0; i--)
+        {
             LPSHNAMEMAPPINGW lp = DSA_GetItemPtr(hNameMapping, i);
 
-	    SHFree(lp->pszOldPath);
-	    SHFree(lp->pszNewPath);
-	  }
-          DSA_Destroy(hNameMapping);
-	}
+            SHFree(lp->pszOldPath);
+            SHFree(lp->pszNewPath);
+        }
+        DSA_Destroy(hNameMapping);
+    }
 }
 
 /*************************************************************************
@@ -1700,14 +1789,14 @@ DWORD WINAPI SheChangeDirW(LPWSTR path)
 }
 
 /*************************************************************************
- * IsNetDrive			[SHELL32.66]
+ * IsNetDrive                   [SHELL32.66]
  */
 int WINAPI IsNetDrive(int drive)
 {
-	char root[4];
-	strcpy(root, "A:\\");
-	root[0] += (char)drive;
-	return (GetDriveTypeA(root) == DRIVE_REMOTE);
+    char root[4];
+    strcpy(root, "A:\\");
+    root[0] += (char)drive;
+    return (GetDriveTypeA(root) == DRIVE_REMOTE);
 }
 
 
@@ -1793,3 +1882,189 @@ HRESULT WINAPI SHPathPrepareForWriteW(HWND hwnd, IUnknown *modless, LPCWSTR path
     else
         return HRESULT_FROM_WIN32(ERROR_DIRECTORY);
 }
+
+static BOOL progressbar_calc_size(FILE_OPERATION *op, LPWSTR buf, BOOL is_folder, DWORD *ticks)
+{
+    WIN32_FIND_DATAW wfd;
+    HANDLE find;
+    UINT i = strlenW(buf);
+    WCHAR *file = buf + i;
+    size_t size = MAX_PATH - i;
+
+    if (size < 3)
+        return FALSE;
+
+    if (is_folder)
+    {
+        *file++ = '\\';
+        size--;
+
+        file[0] = '*';
+        file[1] = 0;
+    }
+    else
+    {
+        file[0] = 0;
+    }
+
+    find = FindFirstFileW(buf, &wfd);
+    if (find == INVALID_HANDLE_VALUE)
+    {
+        WARN("FindFirstFileW %s failed\n", debugstr_w(buf));
+        return FALSE;
+    }
+
+    do
+    {
+        if (wfd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+        {
+            if (wfd.cFileName[0] == '.')
+            {
+                if (wfd.cFileName[1] == 0) continue;
+                if (wfd.cFileName[1] == '.' && wfd.cFileName[2] == 0) continue;
+            }
+
+            if (!lstrcpynW(file, wfd.cFileName, size)) continue;
+            progressbar_calc_size(op, buf, TRUE, ticks);
+        }
+        else
+        {
+            LARGE_INTEGER filesize;
+            filesize.u.LowPart  = wfd.nFileSizeLow;
+            filesize.u.HighPart = wfd.nFileSizeHigh;
+            op->totalSize.QuadPart += filesize.QuadPart;
+        }
+
+        if (GetTickCount() - *ticks > 500)
+        {
+            if (op->progress != NULL)
+                op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+            if (op->bCancelled)
+                break;
+            *ticks = GetTickCount();
+        }
+
+    }
+    while (FindNextFileW(find, &wfd));
+
+    FindClose(find);
+    return TRUE;
+}
+
+static void progressbar_calc_totalsize(FILE_OPERATION *op, const FILE_LIST *from)
+{
+    WCHAR filename[MAX_PATH];
+    DWORD ticks = GetTickCount();
+    UINT i;
+
+    op->totalSize.QuadPart = 0;
+
+    for (i = 0; i < from->dwNumFiles && !op->bCancelled; i++)
+    {
+        if (!lstrcpynW(filename, from->feFiles[i].szFullPath, sizeof(filename)/sizeof(filename[0])))
+            continue;
+        progressbar_calc_size(op, filename, IsAttribDir(from->feFiles[i].attributes), &ticks);
+    }
+}
+
+static void progressbar_update_title(FILE_OPERATION *op)
+{
+    WCHAR buf[64];
+    UINT title_id, builder_id, animation_id;
+
+    if (op->progress == NULL)
+        return;
+
+    switch (op->req->wFunc)
+    {
+        case FO_COPY:
+            title_id      = IDS_FILEOP_COPYING;
+            builder_id    = IDS_FILEOP_FROM_TO;
+            animation_id  = IDR_AVI_FILECOPY;
+            break;
+
+        case FO_DELETE:
+            title_id      = IDS_FILEOP_DELETING;
+            builder_id    = IDS_FILEOP_FROM;
+            animation_id  = IDR_AVI_FILEDELETE;
+            break;
+
+        case FO_MOVE:
+            title_id      = IDS_FILEOP_MOVING;
+            builder_id    = IDS_FILEOP_FROM_TO;
+            animation_id  = IDR_AVI_FILEMOVE;
+            break;
+
+        default:
+            return;
+    }
+
+    LoadStringW(shell32_hInstance, title_id, buf, sizeof(buf)/sizeof(WCHAR));
+    IProgressDialog_SetTitle(op->progress, buf);
+
+    LoadStringW(shell32_hInstance, builder_id,  op->szBuilderString,
+                sizeof(op->szBuilderString)/sizeof(WCHAR));
+
+    LoadStringW(shell32_hInstance, IDS_FILEOP_PREFLIGHT, buf, sizeof(buf)/sizeof(WCHAR));
+    IProgressDialog_SetLine(op->progress, 1, buf, FALSE, NULL);
+
+    IProgressDialog_SetAnimation(op->progress, shell32_hInstance, animation_id);
+}
+
+static void progressbar_update_files(FILE_OPERATION *op, LPCWSTR src, LPCWSTR dst)
+{
+    LPWSTR src_file, dst_file;
+    WCHAR src_dir[64], dst_dir[64], final[260];
+    DWORD_PTR args[2] = {0, 0};
+
+    if (!op->progress || !src || (op->req->wFunc == FO_MOVE && !dst))
+        return;
+
+    if (op->req->wFunc != FO_COPY &&
+        op->req->wFunc != FO_MOVE &&
+        op->req->wFunc != FO_DELETE)
+    {
+        return;
+    }
+
+    src_file = PathFindFileNameW(src);
+    lstrcpynW(src_dir, src, min(sizeof(src_dir) / sizeof(WCHAR) - 1, src_file - src));
+    args[0] = (DWORD_PTR)&src_dir;
+
+    if (op->req->wFunc == FO_MOVE ||
+        op->req->wFunc == FO_COPY)
+    {
+        if (PathIsDirectoryW(dst))
+            args[1] = (DWORD_PTR)&dst;
+        else
+        {
+            dst_file = PathFindFileNameW(dst);
+            lstrcpynW(dst_dir, dst, min(sizeof(dst_dir) / sizeof(WCHAR) - 1, dst_file - dst));
+            args[1] = (DWORD_PTR)&dst_dir;
+        }
+    }
+
+    FormatMessageW(FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_ARGUMENT_ARRAY, op->szBuilderString,
+                   0, 0, final, sizeof(final)/sizeof(final[0]), (__ms_va_list *)&args);
+
+    IProgressDialog_SetLine(op->progress, 1, src_file, FALSE, NULL);
+    IProgressDialog_SetLine(op->progress, 2, final, FALSE, NULL);
+}
+
+static DWORD CALLBACK progressbar_copy_routine(LARGE_INTEGER total_size, LARGE_INTEGER total_transferred, LARGE_INTEGER stream_size,
+        LARGE_INTEGER stream_transferred, DWORD stream_number, DWORD reason, HANDLE src_file, HANDLE dst_file, LPVOID user)
+{
+    FILE_OPERATION *op = (FILE_OPERATION *)user;
+
+    if (!op->progress)
+        return PROGRESS_CONTINUE;
+
+    if (reason == CALLBACK_STREAM_SWITCH)
+        op->completedSize.QuadPart += total_size.QuadPart;
+
+    IProgressDialog_SetProgress64(op->progress, op->completedSize.QuadPart - total_size.QuadPart +
+                                  total_transferred.QuadPart, op->totalSize.QuadPart);
+
+    op->bCancelled |= IProgressDialog_HasUserCancelled(op->progress);
+    return op->bCancelled ? PROGRESS_CANCEL : PROGRESS_CONTINUE;
+}
diff --git a/dlls/shell32/shresdef.h b/dlls/shell32/shresdef.h
index 183a75e..8ee525a 100644
--- a/dlls/shell32/shresdef.h
+++ b/dlls/shell32/shresdef.h
@@ -149,6 +149,14 @@
 #define IDM_RECYCLEBIN_RESTORE      301
 #define IDM_RECYCLEBIN_ERASE        302
 
+/* Strings for file operations */
+#define IDS_FILEOP_COPYING          333
+#define IDS_FILEOP_MOVING           334
+#define IDS_FILEOP_DELETING         335
+#define IDS_FILEOP_FROM_TO          336
+#define IDS_FILEOP_FROM             337
+#define IDS_FILEOP_PREFLIGHT        338
+
 /* Note: this string is referenced from the registry*/
 #define IDS_RECYCLEBIN_FOLDER_NAME   8964
 
diff --git a/dlls/shell32/tests/shellpath.c b/dlls/shell32/tests/shellpath.c
index c2ce198..81ba924 100644
--- a/dlls/shell32/tests/shellpath.c
+++ b/dlls/shell32/tests/shellpath.c
@@ -862,6 +862,11 @@ if (0) { /* crashes */
     ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
     ok(path != NULL, "expected path != NULL\n");
 
+    path = NULL;
+    hr = pSHGetKnownFolderPath(&FOLDERID_Desktop, KF_FLAG_DEFAULT_PATH, NULL, &path);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(path != NULL, "expected path != NULL\n");
+
     hr = pSHGetFolderPathEx(&FOLDERID_Desktop, 0, NULL, buffer, MAX_PATH);
     ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
     ok(!lstrcmpiW(path, buffer), "expected equal paths\n");
diff --git a/dlls/shell32/tests/shlexec.c b/dlls/shell32/tests/shlexec.c
index f81794e..2b3947e 100644
--- a/dlls/shell32/tests/shlexec.c
+++ b/dlls/shell32/tests/shlexec.c
@@ -857,6 +857,7 @@ static const char* testfiles[]=
     "%s\\masked",
     "%s\\test file.sde",
     "%s\\test file.exe",
+    "%s\\test file two.exe",
     "%s\\test2.exe",
     "%s\\simple.shlexec",
     "%s\\drawback_file.noassoc",
@@ -931,7 +932,7 @@ static void test_lpFile_parsed(void)
     /* existing "drawback_file.noassoc" prevents finding "drawback_file.noassoc foo.shlexec" on wine */
     sprintf(fileA, "%s\\drawback_file.noassoc foo.shlexec", tmpdir);
     rc=shell_execute(NULL, fileA, NULL, NULL);
-    todo_wine ok(rc > 32, "%s failed: rc=%lu\n", shell_call, rc);
+    ok(rc > 32, "%s failed: rc=%lu\n", shell_call, rc);
 
     /* if quoted, existing "drawback_file.noassoc" not prevents finding "drawback_file.noassoc foo.shlexec" on wine */
     sprintf(fileA, "\"%s\\drawback_file.noassoc foo.shlexec\"", tmpdir);
@@ -1547,7 +1548,7 @@ static void test_filename(void)
                "%s failed: rc=%ld err=%u\n", shell_call,
                rc, GetLastError());
         }
-        else todo_wine
+        else
         {
             ok(rc==test->rc, "%s failed: rc=%ld err=%u\n", shell_call,
                rc, GetLastError());
@@ -2094,6 +2095,7 @@ static void test_exes(void)
 {
     char filename[MAX_PATH];
     char params[1024];
+    DWORD retval;
     INT_PTR rc;
 
     sprintf(params, "shlexec \"%s\" Exec", child_file);
@@ -2120,6 +2122,32 @@ static void test_exes(void)
     {
         win_skip("Skipping shellexecute of file with unassociated extension\n");
     }
+
+    /* the directory with the test programs contain "test file.exe"
+     * and "test file two.exe". Check we do not start the first
+     * when we specify to start the second (see bug 19666)
+     */
+    sprintf(filename, "%s\\test file.exe", tmpdir);
+    retval = CopyFileA(argv0, filename, FALSE);
+    ok(retval, "CopyFile(\"%s\",\"%s\",FALSE) failed\n", argv0, filename);
+    sprintf(filename, "%s\\test file two.exe", tmpdir);
+    retval = CopyFileA(argv0, filename, FALSE);
+    ok(retval, "CopyFile(\"%s\",\"%s\",FALSE) failed\n", argv0, filename);
+    rc=shell_execute_ex(SEE_MASK_NOZONECHECKS, NULL, filename, params, NULL, NULL);
+    ok(rc > 32, "%s returned %lu\n", shell_call, rc);
+    okChildInt("argcA", 4);
+    okChildString("argvA0", filename);
+    okChildString("argvA3", "Exec");
+
+    /* check quoted filename */
+    sprintf(filename, "\"%s\\test file two.exe\"", tmpdir);
+    rc=shell_execute_ex(SEE_MASK_NOZONECHECKS, NULL, filename, params, NULL, NULL);
+    ok(rc > 32, "%s returned %lu\n", shell_call, rc);
+    okChildInt("argcA", 4);
+    /* strip the quotes for the compare */
+    sprintf(filename, "%s\\test file two.exe", tmpdir);
+    okChildString("argvA0", filename);
+    okChildString("argvA3", "Exec");
 }
 
 typedef struct
diff --git a/dlls/shlwapi/tests/url.c b/dlls/shlwapi/tests/url.c
index 857ed15..fa294d4 100644
--- a/dlls/shlwapi/tests/url.c
+++ b/dlls/shlwapi/tests/url.c
@@ -195,7 +195,15 @@ static const TEST_URL_CANONICALIZE TEST_CANONICALIZE[] = {
     {"res://c:\\tests/res\\foo%20bar/strange\\sth", URL_UNESCAPE, S_OK, "res://c:\\tests/res\\foo bar/strange\\sth", FALSE},
     {"A", 0, S_OK, "A", FALSE},
     {"../A", 0, S_OK, "../A", FALSE},
+    {".\\A", 0, S_OK, ".\\A", FALSE},
+    {"A\\.\\B", 0, S_OK, "A\\.\\B", FALSE},
     {"A/../B", 0, S_OK, "B", TRUE},
+    {"A/../B/./../C", 0, S_OK, "C", TRUE},
+    {"A/../B/./../C", URL_DONT_SIMPLIFY, S_OK, "A/../B/./../C", FALSE},
+    {".", 0, S_OK, "/", TRUE},
+    {"./A", 0, S_OK, "A", TRUE},
+    {"A/./B", 0, S_OK, "A/B", TRUE},
+    {"/:test\\", 0, S_OK, "/:test\\", TRUE},
     {"/uri-res/N2R?urn:sha1:B3K", URL_DONT_ESCAPE_EXTRA_INFO | URL_WININET_COMPATIBILITY /*0x82000000*/, S_OK, "/uri-res/N2R?urn:sha1:B3K", FALSE} /*LimeWire online installer calls this*/,
     {"http:www.winehq.org/dir/../index.html", 0, S_OK, "http:www.winehq.org/index.html"},
     {"http://localhost/test.html", URL_FILE_USE_PATHURL, S_OK, "http://localhost/test.html"},
@@ -310,6 +318,7 @@ typedef struct _TEST_URL_COMBINE {
     DWORD flags;
     HRESULT expectret;
     const char *expecturl;
+    BOOL todo;
 } TEST_URL_COMBINE;
 
 static const TEST_URL_COMBINE TEST_COMBINE[] = {
@@ -331,6 +340,15 @@ static const TEST_URL_COMBINE TEST_COMBINE[] = {
     {"http://www.winehq.org/test14#aaa/bbb#ccc", "#", 0, S_OK, "http://www.winehq.org/test14#"},
     {"http://www.winehq.org/tests/?query=x/y/z", "tests15", 0, S_OK, "http://www.winehq.org/tests/tests15"},
     {"http://www.winehq.org/tests/?query=x/y/z#example", "tests16", 0, S_OK, "http://www.winehq.org/tests/tests16"},
+    {"http://www.winehq.org/tests17", ".", 0, S_OK, "http://www.winehq.org/"},
+    {"http://www.winehq.org/tests18/test", ".", 0, S_OK, "http://www.winehq.org/tests18/"},
+    {"http://www.winehq.org/tests19/test", "./", 0, S_OK, "http://www.winehq.org/tests19/", FALSE},
+    {"http://www.winehq.org/tests20/test", "/", 0, S_OK, "http://www.winehq.org/", FALSE},
+    {"http://www.winehq.org/tests/test", "./test21", 0, S_OK, "http://www.winehq.org/tests/test21", FALSE},
+    {"http://www.winehq.org/tests/test", "./test22/../test", 0, S_OK, "http://www.winehq.org/tests/test", FALSE},
+    {"http://www.winehq.org/tests/", "http://www.winehq.org:80/tests23", 0, S_OK, "http://www.winehq.org/tests23", TRUE},
+    {"http://www.winehq.org/tests/", "tests24/./test/../test", 0, S_OK, "http://www.winehq.org/tests/tests24/test", FALSE},
+    {"http://www.winehq.org/tests/./tests25", "./", 0, S_OK, "http://www.winehq.org/tests/", FALSE},
     {"file:///C:\\dir\\file.txt", "test.txt", 0, S_OK, "file:///C:/dir/test.txt"},
     {"file:///C:\\dir\\file.txt#hash\\hash", "test.txt", 0, S_OK, "file:///C:/dir/file.txt#hash/test.txt"},
     {"file:///C:\\dir\\file.html#hash\\hash", "test.html", 0, S_OK, "file:///C:/dir/test.html"},
@@ -1090,7 +1108,7 @@ static void test_UrlCanonicalizeW(void)
 
 /* ########################### */
 
-static void test_url_combine(const char *szUrl1, const char *szUrl2, DWORD dwFlags, HRESULT dwExpectReturn, const char *szExpectUrl)
+static void test_url_combine(const char *szUrl1, const char *szUrl2, DWORD dwFlags, HRESULT dwExpectReturn, const char *szExpectUrl, BOOL todo)
 {
     HRESULT hr;
     CHAR szReturnUrl[INTERNET_MAX_URL_LENGTH];
@@ -1115,34 +1133,42 @@ static void test_url_combine(const char *szUrl1, const char *szUrl2, DWORD dwFla
     dwSize = 0;
     hr = pUrlCombineA(szUrl1, szUrl2, NULL, &dwSize, dwFlags);
     ok(hr == E_POINTER, "Checking length of string, return was 0x%08x, expected 0x%08x\n", hr, E_POINTER);
-    ok(dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
+    ok(todo || dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
 
     dwSize--;
     hr = pUrlCombineA(szUrl1, szUrl2, szReturnUrl, &dwSize, dwFlags);
     ok(hr == E_POINTER, "UrlCombineA returned 0x%08x, expected 0x%08x\n", hr, E_POINTER);
-    ok(dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
+    ok(todo || dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
 
     hr = pUrlCombineA(szUrl1, szUrl2, szReturnUrl, &dwSize, dwFlags);
     ok(hr == dwExpectReturn, "UrlCombineA returned 0x%08x, expected 0x%08x\n", hr, dwExpectReturn);
-    ok(dwSize == dwExpectLen, "Got length %d, expected %d\n", dwSize, dwExpectLen);
-    if(SUCCEEDED(hr)) {
-        ok(strcmp(szReturnUrl,szExpectUrl)==0, "Expected %s, but got %s\n", szExpectUrl, szReturnUrl);
+
+    if (todo)
+    {
+        todo_wine ok(dwSize == dwExpectLen && (FAILED(hr) || strcmp(szReturnUrl, szExpectUrl)==0),
+                "Expected %s (len=%d), but got %s (len=%d)\n", szExpectUrl, dwExpectLen, SUCCEEDED(hr) ? szReturnUrl : "(null)", dwSize);
+    }
+    else
+    {
+        ok(dwSize == dwExpectLen, "Got length %d, expected %d\n", dwSize, dwExpectLen);
+        if (SUCCEEDED(hr))
+            ok(strcmp(szReturnUrl, szExpectUrl)==0, "Expected %s, but got %s\n", szExpectUrl, szReturnUrl);
     }
 
     if (pUrlCombineW) {
         dwSize = 0;
         hr = pUrlCombineW(wszUrl1, wszUrl2, NULL, &dwSize, dwFlags);
         ok(hr == E_POINTER, "Checking length of string, return was 0x%08x, expected 0x%08x\n", hr, E_POINTER);
-        ok(dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
+        ok(todo || dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
 
         dwSize--;
         hr = pUrlCombineW(wszUrl1, wszUrl2, wszReturnUrl, &dwSize, dwFlags);
         ok(hr == E_POINTER, "UrlCombineW returned 0x%08x, expected 0x%08x\n", hr, E_POINTER);
-        ok(dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
+        ok(todo || dwSize == dwExpectLen+1, "Got length %d, expected %d\n", dwSize, dwExpectLen+1);
 
         hr = pUrlCombineW(wszUrl1, wszUrl2, wszReturnUrl, &dwSize, dwFlags);
         ok(hr == dwExpectReturn, "UrlCombineW returned 0x%08x, expected 0x%08x\n", hr, dwExpectReturn);
-        ok(dwSize == dwExpectLen, "Got length %d, expected %d\n", dwSize, dwExpectLen);
+        ok(todo || dwSize == dwExpectLen, "Got length %d, expected %d\n", dwSize, dwExpectLen);
         if(SUCCEEDED(hr)) {
             wszConvertedUrl = GetWideString(szReturnUrl);
             ok(lstrcmpW(wszReturnUrl, wszConvertedUrl)==0, "Strings didn't match between ascii and unicode UrlCombine!\n");
@@ -1162,7 +1188,7 @@ static void test_UrlCombine(void)
     unsigned int i;
     for(i=0; i<sizeof(TEST_COMBINE)/sizeof(TEST_COMBINE[0]); i++) {
         test_url_combine(TEST_COMBINE[i].url1, TEST_COMBINE[i].url2, TEST_COMBINE[i].flags,
-                         TEST_COMBINE[i].expectret, TEST_COMBINE[i].expecturl);
+                         TEST_COMBINE[i].expectret, TEST_COMBINE[i].expecturl, TEST_COMBINE[i].todo);
     }
 }
 
diff --git a/dlls/shlwapi/url.c b/dlls/shlwapi/url.c
index 1a53252..dd80cc3 100644
--- a/dlls/shlwapi/url.c
+++ b/dlls/shlwapi/url.c
@@ -914,7 +914,10 @@ HRESULT WINAPI UrlCombineW(LPCWSTR pszBase, LPCWSTR pszRelative,
 	work = preliminary + base.cchProtocol+1+base.cchSuffix - 1;
         if (*work++ != '/')
             *(work++) = '/';
-	strcpyW(work, relative.pszSuffix);
+        if (relative.pszSuffix[0] == '.' && relative.pszSuffix[1] == 0)
+            *work = 0;
+        else
+            strcpyW(work, relative.pszSuffix);
 	break;
 
     default:
diff --git a/dlls/strmbase/pospass.c b/dlls/strmbase/pospass.c
index e547328..424853a 100644
--- a/dlls/strmbase/pospass.c
+++ b/dlls/strmbase/pospass.c
@@ -526,9 +526,11 @@ static HRESULT WINAPI MediaSeekingPassThru_GetPositions(IMediaSeeking * iface, L
     if (SUCCEEDED(hr)) {
         hr = IMediaSeeking_GetPositions(seek, pCurrent, pStop);
         IMediaSeeking_Release(seek);
+    } else if (hr == VFW_E_NOT_CONNECTED) {
+        *pCurrent = 0;
+        *pStop = 0;
+        hr = S_OK;
     }
-    else
-        return E_NOTIMPL;
     return hr;
 }
 
diff --git a/dlls/urlmon/internet.c b/dlls/urlmon/internet.c
index e5d41b6..d7deccc 100644
--- a/dlls/urlmon/internet.c
+++ b/dlls/urlmon/internet.c
@@ -536,10 +536,8 @@ static HRESULT set_internet_feature(INTERNETFEATURELIST feature, DWORD flags, BO
     if(feature >= FEATURE_ENTRY_COUNT)
         return E_FAIL;
 
-    if(flags & ~supported_flags) {
+    if(flags & ~supported_flags)
         FIXME("Unsupported flags: %08x\n", flags & ~supported_flags);
-        return E_NOTIMPL;
-    }
 
     if(flags & SET_FEATURE_ON_PROCESS)
         set_feature_on_process(feature, enable);
diff --git a/dlls/user.exe16/message.c b/dlls/user.exe16/message.c
index 935b025..965da59 100644
--- a/dlls/user.exe16/message.c
+++ b/dlls/user.exe16/message.c
@@ -108,7 +108,7 @@ typedef struct
 #include "poppack.h"
 
 #define WINPROC_HANDLE (~0u >> 16)
-#define MAX_WINPROCS32 4096
+#define MAX_WINPROCS32 16384
 #define MAX_WINPROCS16 1024
 
 static WNDPROC16 winproc16_array[MAX_WINPROCS16];
diff --git a/dlls/user32/caret.c b/dlls/user32/caret.c
index 53bb5b4..fff9e3e 100644
--- a/dlls/user32/caret.c
+++ b/dlls/user32/caret.c
@@ -30,6 +30,8 @@
 #include "winbase.h"
 #include "wingdi.h"
 #include "winuser.h"
+#include "user_private.h"
+
 #include "wine/server.h"
 #include "wine/debug.h"
 
@@ -277,6 +279,7 @@ BOOL WINAPI SetCaretPos( INT x, INT y )
         r.left = x;
         r.top = y;
         CARET_DisplayCaret( hwnd, &r );
+        USER_Driver->pUpdateCandidatePos( hwnd, &r );
         SetSystemTimer( hwnd, TIMERID, Caret.timeout, CARET_Callback );
     }
     return ret;
@@ -355,6 +358,7 @@ BOOL WINAPI ShowCaret( HWND hwnd )
     if (ret && (hidden == 1))  /* hidden was 1 so it's now 0 */
     {
         CARET_DisplayCaret( hwnd, &r );
+        USER_Driver->pUpdateCandidatePos( hwnd, &r );
         SetSystemTimer( hwnd, TIMERID, Caret.timeout, CARET_Callback );
     }
     return ret;
diff --git a/dlls/user32/dialog.c b/dlls/user32/dialog.c
index 3b48fbb..d39a1bc 100644
--- a/dlls/user32/dialog.c
+++ b/dlls/user32/dialog.c
@@ -714,6 +714,7 @@ static HWND DIALOG_CreateIndirect( HINSTANCE hInst, LPCVOID dlgTemplate,
         if (template.style & WS_VISIBLE && !(GetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE))
         {
            ShowWindow( hwnd, SW_SHOWNORMAL );   /* SW_SHOW doesn't always work */
+            UpdateWindow( hwnd );
         }
         return hwnd;
     }
diff --git a/dlls/user32/driver.c b/dlls/user32/driver.c
index e0bc38c..0e8b007 100644
--- a/dlls/user32/driver.c
+++ b/dlls/user32/driver.c
@@ -154,6 +154,7 @@ static const USER_DRIVER *load_driver(void)
         GET_USER_FUNC(WindowPosChanging);
         GET_USER_FUNC(WindowPosChanged);
         GET_USER_FUNC(SystemParametersInfo);
+        GET_USER_FUNC(UpdateCandidatePos);
 #undef GET_USER_FUNC
     }
 
@@ -512,6 +513,10 @@ static BOOL CDECL nulldrv_SystemParametersInfo( UINT action, UINT int_param, voi
     return FALSE;
 }
 
+static void CDECL nulldrv_UpdateCandidatePos( HWND hwnd, const RECT *caret_rect )
+{
+}
+
 static USER_DRIVER null_driver =
 {
     /* keyboard functions */
@@ -572,7 +577,9 @@ static USER_DRIVER null_driver =
     nulldrv_WindowPosChanging,
     nulldrv_WindowPosChanged,
     /* system parameters */
-    nulldrv_SystemParametersInfo
+    nulldrv_SystemParametersInfo,
+    /* candidate pos functions */
+    nulldrv_UpdateCandidatePos
 };
 
 
@@ -767,6 +774,12 @@ static BOOL CDECL loaderdrv_UpdateLayeredWindow( HWND hwnd, const UPDATELAYEREDW
     return load_driver()->pUpdateLayeredWindow( hwnd, info, window_rect );
 }
 
+static void CDECL loaderdrv_UpdateCandidatePos( HWND hwnd, const RECT *caret_rect )
+{
+    load_driver()->pUpdateCandidatePos( hwnd, caret_rect );
+}
+
+
 static USER_DRIVER lazy_load_driver =
 {
     /* keyboard functions */
@@ -827,5 +840,7 @@ static USER_DRIVER lazy_load_driver =
     nulldrv_WindowPosChanging,
     nulldrv_WindowPosChanged,
     /* system parameters */
-    nulldrv_SystemParametersInfo
+    nulldrv_SystemParametersInfo,
+    /* candidate pos functions */
+    loaderdrv_UpdateCandidatePos
 };
diff --git a/dlls/user32/focus.c b/dlls/user32/focus.c
index c47a82d..8b17d1f 100644
--- a/dlls/user32/focus.c
+++ b/dlls/user32/focus.c
@@ -329,8 +329,10 @@ BOOL WINAPI SetForegroundWindow( HWND hwnd )
  */
 HWND WINAPI GetActiveWindow(void)
 {
+    shmlocal_t *shm = wine_get_shmlocal();
     HWND ret = 0;
 
+    if (shm) return wine_server_ptr_handle( shm->input_active );
     SERVER_START_REQ( get_thread_input )
     {
         req->tid = GetCurrentThreadId();
@@ -346,8 +348,10 @@ HWND WINAPI GetActiveWindow(void)
  */
 HWND WINAPI GetFocus(void)
 {
+    shmlocal_t *shm = wine_get_shmlocal();
     HWND ret = 0;
 
+    if (shm) return wine_server_ptr_handle( shm->input_focus );
     SERVER_START_REQ( get_thread_input )
     {
         req->tid = GetCurrentThreadId();
@@ -363,12 +367,31 @@ HWND WINAPI GetFocus(void)
  */
 HWND WINAPI GetForegroundWindow(void)
 {
+    struct user_thread_info *thread_info = get_user_thread_info();
+    shmglobal_t *shm = wine_get_shmglobal();
     HWND ret = 0;
+    DWORD epoch;
+
+    if (shm)
+    {
+        epoch = shm->foreground_wnd_epoch;
+
+        if (epoch == thread_info->foreground_wnd_epoch)
+            return thread_info->foreground_wnd;
+    }
 
     SERVER_START_REQ( get_thread_input )
     {
         req->tid = 0;
-        if (!wine_server_call_err( req )) ret = wine_server_ptr_handle( reply->foreground );
+        if (!wine_server_call_err( req ))
+        {
+            ret = wine_server_ptr_handle( reply->foreground );
+            if (shm)
+            {
+                thread_info->foreground_wnd         = ret;
+                thread_info->foreground_wnd_epoch   = epoch;
+            }
+        }
     }
     SERVER_END_REQ;
     return ret;
diff --git a/dlls/user32/input.c b/dlls/user32/input.c
index 57594a7..81b0e3c 100644
--- a/dlls/user32/input.c
+++ b/dlls/user32/input.c
@@ -342,8 +342,10 @@ BOOL WINAPI DECLSPEC_HOTPATCH ReleaseCapture(void)
  */
 HWND WINAPI GetCapture(void)
 {
+    shmlocal_t *shm = wine_get_shmlocal();
     HWND ret = 0;
 
+    if (shm) return wine_server_ptr_handle( shm->input_capture );
     SERVER_START_REQ( get_thread_input )
     {
         req->tid = GetCurrentThreadId();
@@ -354,12 +356,18 @@ HWND WINAPI GetCapture(void)
 }
 
 
-static void check_for_events( UINT flags )
+/***********************************************************************
+ *      __wine_check_for_events  (USER32.@)
+ *
+ * Internal function to check for pending X11 events.
+ */
+void CDECL __wine_check_for_events( UINT flags )
 {
     if (USER_Driver->pMsgWaitForMultipleObjectsEx( 0, NULL, 0, flags, 0 ) == WAIT_TIMEOUT)
         flush_window_surfaces( TRUE );
 }
 
+
 /**********************************************************************
  *		GetAsyncKeyState (USER32.@)
  *
@@ -375,7 +383,7 @@ SHORT WINAPI DECLSPEC_HOTPATCH GetAsyncKeyState( INT key )
 
     if (key < 0 || key >= 256) return 0;
 
-    check_for_events( QS_INPUT );
+    __wine_check_for_events( QS_INPUT );
 
     if ((ret = USER_Driver->pGetAsyncKeyState( key )) == -1)
     {
@@ -430,7 +438,7 @@ DWORD WINAPI GetQueueStatus( UINT flags )
         return 0;
     }
 
-    check_for_events( flags );
+    __wine_check_for_events( flags );
 
     SERVER_START_REQ( get_queue_status )
     {
@@ -448,17 +456,29 @@ DWORD WINAPI GetQueueStatus( UINT flags )
  */
 BOOL WINAPI GetInputState(void)
 {
+    shmlocal_t *shm = wine_get_shmlocal();
     DWORD ret;
 
-    check_for_events( QS_INPUT );
+    __wine_check_for_events( QS_INPUT );
+
+    /* req->clear is not set, so we can safely get the
+     * wineserver status without an additional call. */
+    if (shm)
+    {
+        ret = shm->queue_bits;
+        goto done;
+    }
 
     SERVER_START_REQ( get_queue_status )
     {
         req->clear = 0;
         wine_server_call( req );
-        ret = reply->wake_bits & (QS_KEY | QS_MOUSEBUTTON);
+        ret = reply->wake_bits;
     }
     SERVER_END_REQ;
+
+done:
+    ret &= (QS_KEY | QS_MOUSEBUTTON);
     return ret;
 }
 
@@ -469,6 +489,7 @@ BOOL WINAPI GetInputState(void)
 BOOL WINAPI GetLastInputInfo(PLASTINPUTINFO plii)
 {
     BOOL ret;
+    shmglobal_t *shm = wine_get_shmglobal();
 
     TRACE("%p\n", plii);
 
@@ -478,6 +499,12 @@ BOOL WINAPI GetLastInputInfo(PLASTINPUTINFO plii)
         return FALSE;
     }
 
+    if (shm)
+    {
+        plii->dwTime = shm->last_input_time;
+        return TRUE;
+    }
+
     SERVER_START_REQ( get_last_input_time )
     {
         ret = !wine_server_call_err( req );
@@ -507,6 +534,7 @@ UINT WINAPI GetRawInputDeviceList(RAWINPUTDEVICELIST *devices, UINT *device_coun
     if (*device_count < 2)
     {
         *device_count = 2;
+        SetLastError(ERROR_INSUFFICIENT_BUFFER);
         return ~0U;
     }
 
diff --git a/dlls/user32/message.c b/dlls/user32/message.c
index 2b544de..3531c4f 100644
--- a/dlls/user32/message.c
+++ b/dlls/user32/message.c
@@ -1881,6 +1881,12 @@ static LRESULT handle_internal_message( HWND hwnd, UINT msg, WPARAM wparam, LPAR
         return call_current_hook( h_extra->handle, HC_ACTION, wparam, h_extra->lparam );
     }
     case WM_WINE_CLIPCURSOR:
+        if (!lparam)
+        {
+            /* This is just a notification, nothing to do. Clipping will be
+             * done by the process that issues the set_cursor wineserver call. */
+            return 0;
+        }
         if (wparam)
         {
             RECT rect;
@@ -2501,7 +2507,7 @@ static BOOL process_mouse_message( MSG *msg, UINT hw_id, ULONG_PTR extra_info, H
     }
     else
     {
-        msg->hwnd = WINPOS_WindowFromPoint( msg->hwnd, msg->pt, &hittest );
+        msg->hwnd = WINPOS_WindowFromPoint( 0, msg->pt, &hittest );
     }
 
     if (!msg->hwnd || !WIN_IsCurrentThread( msg->hwnd ))
@@ -2734,6 +2740,18 @@ static BOOL peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags
     unsigned int hw_id = 0;  /* id of previous hardware message */
     void *buffer;
     size_t buffer_size = 256;
+    shmlocal_t *shm = wine_get_shmlocal();
+
+    /* From time to time we are forced to do a wineserver call in
+     * order to update last_msg_time stored for each server thread. */
+    if (shm && GetTickCount() - thread_info->last_get_msg < 500)
+    {
+        int filter = flags >> 16;
+        if (!filter) filter = QS_ALLINPUT;
+        filter |= QS_SENDMESSAGE;
+        if (filter & QS_INPUT) filter |= QS_INPUT;
+        if (!(shm->queue_bits & filter)) return FALSE;
+    }
 
     if (!(buffer = HeapAlloc( GetProcessHeap(), 0, buffer_size ))) return FALSE;
 
@@ -2746,6 +2764,7 @@ static BOOL peek_message( MSG *msg, HWND hwnd, UINT first, UINT last, UINT flags
         size_t size = 0;
         const message_data_t *msg_data = buffer;
 
+        if (shm) thread_info->last_get_msg = GetTickCount();
         SERVER_START_REQ( get_message )
         {
             req->flags     = flags;
@@ -4447,7 +4466,7 @@ UINT_PTR WINAPI SetTimer( HWND hwnd, UINT_PTR id, UINT timeout, TIMERPROC proc )
 
     if (proc) winproc = WINPROC_AllocProc( (WNDPROC)proc, FALSE );
 
-    timeout = min( max( USER_TIMER_MINIMUM, timeout ), USER_TIMER_MAXIMUM );
+    timeout = min( max( 5, timeout ), USER_TIMER_MAXIMUM );
 
     SERVER_START_REQ( set_win_timer )
     {
diff --git a/dlls/user32/misc.c b/dlls/user32/misc.c
index b3615e8..eb151bf 100644
--- a/dlls/user32/misc.c
+++ b/dlls/user32/misc.c
@@ -239,11 +239,74 @@ DWORD WINAPI SetLogonNotifyWindow(HWINSTA hwinsta,HWND hwnd)
     return 1;
 }
 
-static const WCHAR primary_device_name[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y','1',0};
-static const WCHAR primary_device_string[] = {'X','1','1',' ','W','i','n','d','o','w','i','n','g',' ',
-                                              'S','y','s','t','e','m',0};
-static const WCHAR primary_device_deviceid[] = {'P','C','I','\\','V','E','N','_','0','0','0','0','&',
+static const WCHAR adapter_device_string[] = {'W','i','n','e',' ','D','i','s','p','l','a','y',' ',
+                                              'A','d','a','p','t','e','r',0};
+static const WCHAR adapter_device_deviceid[] = {'P','C','I','\\','V','E','N','_','0','0','0','0','&',
                                                 'D','E','V','_','0','0','0','0',0};
+static const WCHAR display_device_name[] = {'%','s','\\','M','o','n','i','t','o','r','0',0};
+static const WCHAR display_device_string[] = {'W','i','n','e',' ','D','i','s','p','l','a','y',0};
+static const WCHAR display_device_deviceid[] = {'M','O','N','I','T','O','R','\\','W','I','N','E','%','0','4','d',0};
+
+struct display_devices_enum_info
+{
+    LPCWSTR adapter;
+    DWORD target;
+    DWORD non_primary_seen;
+    LPDISPLAY_DEVICEW device;
+};
+
+/***********************************************************************
+ *		display_devices_enum
+ *
+ * Helper callback for EnumDisplayDevicesW()
+ */
+static BOOL CALLBACK display_devices_enum( HMONITOR monitor, HDC hdc, LPRECT rect, LPARAM lp )
+{
+    struct display_devices_enum_info *info = (struct display_devices_enum_info *)lp;
+    MONITORINFOEXW mon_info;
+    BOOL match;
+
+    mon_info.cbSize = sizeof(mon_info);
+    GetMonitorInfoW( monitor, (MONITORINFO*)&mon_info );
+
+    if (!(mon_info.dwFlags & MONITORINFOF_PRIMARY))
+        info->non_primary_seen++;
+
+    if (info->adapter)
+    {
+        match = !strcmpiW( info->adapter, mon_info.szDevice );
+        if (match)
+        {
+            snprintfW( info->device->DeviceName, sizeof(info->device->DeviceName) / sizeof(WCHAR),
+                       display_device_name, mon_info.szDevice );
+            lstrcpynW( info->device->DeviceString, display_device_string, sizeof(info->device->DeviceString) / sizeof(WCHAR) );
+
+            if (info->device->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->device->DeviceID))
+            {
+                snprintfW( info->device->DeviceID, sizeof(info->device->DeviceID) / sizeof(WCHAR),
+                           display_device_deviceid, (mon_info.dwFlags & MONITORINFOF_PRIMARY) ? 0 : info->non_primary_seen );
+            }
+        }
+    }
+    else
+    {
+        if (mon_info.dwFlags & MONITORINFOF_PRIMARY)
+            match = (info->target == 0);
+        else
+            match = (info->target == info->non_primary_seen);
+
+        if (match)
+        {
+            lstrcpynW( info->device->DeviceName, mon_info.szDevice, sizeof(info->device->DeviceName) / sizeof(WCHAR) );
+            lstrcpynW( info->device->DeviceString, adapter_device_string, sizeof(info->device->DeviceString) / sizeof(WCHAR) );
+
+            if (info->device->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(info->device->DeviceID))
+                lstrcpynW( info->device->DeviceID, adapter_device_deviceid, sizeof(info->device->DeviceID) / sizeof(WCHAR) );
+        }
+    }
+
+    return !match;
+}
 
 /***********************************************************************
  *		EnumDisplayDevicesA (USER32.@)
@@ -284,24 +347,37 @@ BOOL WINAPI EnumDisplayDevicesA( LPCSTR lpDevice, DWORD i, LPDISPLAY_DEVICEA lpD
 BOOL WINAPI EnumDisplayDevicesW( LPCWSTR lpDevice, DWORD i, LPDISPLAY_DEVICEW lpDisplayDevice,
                                  DWORD dwFlags )
 {
-    FIXME("(%s,%d,%p,0x%08x), stub!\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
+  if (!lpDisplayDevice) {
+    return FALSE;
+  }
+
+    struct display_devices_enum_info info;
 
-    if (i)
+    TRACE("(%s,%d,%p,0x%08x)\n",debugstr_w(lpDevice),i,lpDisplayDevice,dwFlags);
+
+    if (lpDevice && i)
         return FALSE;
 
-    memcpy(lpDisplayDevice->DeviceName, primary_device_name, sizeof(primary_device_name));
-    memcpy(lpDisplayDevice->DeviceString, primary_device_string, sizeof(primary_device_string));
-  
     lpDisplayDevice->StateFlags =
         DISPLAY_DEVICE_ATTACHED_TO_DESKTOP |
-        DISPLAY_DEVICE_PRIMARY_DEVICE |
         DISPLAY_DEVICE_VGA_COMPATIBLE;
 
-    if(lpDisplayDevice->cb >= offsetof(DISPLAY_DEVICEW, DeviceID) + sizeof(lpDisplayDevice->DeviceID))
-        memcpy(lpDisplayDevice->DeviceID, primary_device_deviceid, sizeof(primary_device_deviceid));
+    if (!lpDevice && i == 0)
+        lpDisplayDevice->StateFlags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    info.adapter = lpDevice;
+    info.target = i;
+    info.non_primary_seen = 0;
+    info.device = lpDisplayDevice;
+    if (EnumDisplayMonitors( 0, NULL, display_devices_enum, (LPARAM)&info ))
+        return FALSE;
+
     if(lpDisplayDevice->cb >= offsetof(DISPLAY_DEVICEW, DeviceKey) + sizeof(lpDisplayDevice->DeviceKey))
         lpDisplayDevice->DeviceKey[0] = 0;
 
+    TRACE("DeviceName %s DeviceString %s DeviceID %s DeviceKey %s\n", debugstr_w(lpDisplayDevice->DeviceName),
+          debugstr_w(lpDisplayDevice->DeviceString), debugstr_w(lpDisplayDevice->DeviceID), debugstr_w(lpDisplayDevice->DeviceKey));
+
     return TRUE;
 }
 
diff --git a/dlls/user32/painting.c b/dlls/user32/painting.c
index 5c1dc69..dbe2efc 100644
--- a/dlls/user32/painting.c
+++ b/dlls/user32/painting.c
@@ -1116,6 +1116,7 @@ HDC WINAPI GetWindowDC( HWND hwnd )
  */
 INT WINAPI ReleaseDC( HWND hwnd, HDC hdc )
 {
+    flush_window_surfaces( FALSE );
     return release_dc( hwnd, hdc, FALSE );
 }
 
@@ -1430,10 +1431,10 @@ static INT scroll_window( HWND hwnd, INT dx, INT dy, const RECT *rect, const REC
     rdw_flags = (flags & SW_ERASE) && (flags & SW_INVALIDATE) ?
                                 RDW_INVALIDATE | RDW_ERASE  : RDW_INVALIDATE ;
 
-    if (!WIN_IsWindowDrawable( hwnd, TRUE )) return ERROR;
     hwnd = WIN_GetFullHandle( hwnd );
 
-    GetClientRect(hwnd, &rc);
+    if (!WIN_IsWindowDrawable( hwnd, TRUE )) SetRectEmpty(&rc);
+    else GetClientRect(hwnd, &rc);
 
     if (clipRect) IntersectRect(&cliprc,&rc,clipRect);
     else cliprc = rc;
diff --git a/dlls/user32/sysparams.c b/dlls/user32/sysparams.c
index 79396ae..bc4d36b 100644
--- a/dlls/user32/sysparams.c
+++ b/dlls/user32/sysparams.c
@@ -2343,6 +2343,49 @@ BOOL WINAPI SystemParametersInfoA( UINT uiAction, UINT uiParam,
     return ret;
 }
 
+/******************************************************************************
+ * Get the default and the app-specific config keys.
+ */
+BOOL get_app_key(HKEY *defkey, HKEY *appkey)
+{
+    char buffer[MAX_PATH+16];
+    DWORD len;
+
+    *appkey = 0;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\System */
+    if (RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\System", defkey))
+        *defkey = 0;
+
+    len = GetModuleFileNameA(0, buffer, MAX_PATH);
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\System */
+        if (!RegOpenKeyA(HKEY_CURRENT_USER, "Software\\Wine\\AppDefaults", &tmpkey))
+        {
+            char *p, *appname = buffer;
+            if ((p = strrchr(appname, '/'))) appname = p + 1;
+            if ((p = strrchr(appname, '\\'))) appname = p + 1;
+            strcat(appname, "\\System");
+
+            if (RegOpenKeyA(tmpkey, appname, appkey)) *appkey = 0;
+            RegCloseKey(tmpkey);
+        }
+    }
+
+    return *defkey || *appkey;
+}
+
+static DWORD get_config_key_dword(HKEY defkey, HKEY appkey, const char *name, DWORD *data)
+{
+    DWORD type;
+    DWORD size = sizeof(DWORD);
+    if (appkey && !RegQueryValueExA(appkey, name, 0, &type, (BYTE *)data, &size) && (type == REG_DWORD)) return 0;
+    if (defkey && !RegQueryValueExA(defkey, name, 0, &type, (BYTE *)data, &size) && (type == REG_DWORD)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
 
 /***********************************************************************
  *		GetSystemMetrics (USER32.@)
@@ -2570,7 +2613,21 @@ INT WINAPI GetSystemMetrics( INT index )
         return 1;
     case SM_TABLETPC:
     case SM_MEDIACENTER:
-        return 0;
+    {
+        const char *name = (index == SM_TABLETPC) ? "TabletPC" : "MediaCenter";
+        HKEY defkey, appkey;
+        DWORD value;
+
+        if (!get_app_key(&defkey, &appkey))
+            return 0;
+
+        if (get_config_key_dword(defkey, appkey, name, &value))
+            value = 0;
+
+        if (appkey) RegCloseKey( appkey );
+        if (defkey) RegCloseKey( defkey );
+        return value;
+    }
     case SM_CMETRICS:
         return SM_CMETRICS;
     default:
diff --git a/dlls/user32/tests/input.c b/dlls/user32/tests/input.c
index faf9c8c..a3be7fd 100644
--- a/dlls/user32/tests/input.c
+++ b/dlls/user32/tests/input.c
@@ -1909,8 +1909,8 @@ static void test_Input_mouse(void)
         }
     }
     ok(hittest_no && hittest_no<50, "expected WM_NCHITTEST message\n");
-    todo_wine ok(got_button_down, "expected WM_LBUTTONDOWN message\n");
-    todo_wine ok(got_button_up, "expected WM_LBUTTONUP message\n");
+    ok(got_button_down, "expected WM_LBUTTONDOWN message\n");
+    ok(got_button_up, "expected WM_LBUTTONUP message\n");
     DestroyWindow(static_win);
 
     /* click on HTTRANSPARENT top-level window that belongs to other thread */
diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 5f10a89..dfb002e 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -10459,13 +10459,10 @@ static void test_PeekMessage3(void)
     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     PostMessageA(hwnd, WM_USER, 0, 0);
     ret = PeekMessageA(&msg, NULL, 0, 0, PM_NOREMOVE);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, NULL, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, NULL, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = PeekMessageA(&msg, NULL, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
@@ -10475,10 +10472,8 @@ static void test_PeekMessage3(void)
     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     PostMessageA(hwnd, WM_USER, 0, 0);
     ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = PeekMessageA(&msg, NULL, 0, 0, PM_REMOVE);
-    todo_wine
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = PeekMessageA(&msg, NULL, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
@@ -10490,10 +10485,8 @@ static void test_PeekMessage3(void)
     ok(msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     PostMessageA(hwnd, WM_USER, 0, 0);
     ret = GetMessageA(&msg, NULL, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, NULL, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = PeekMessageA(&msg, NULL, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
@@ -10521,10 +10514,8 @@ static void test_PeekMessage3(void)
     ret = GetMessageA(&msg, NULL, 0, 0);
     ok(ret && msg.message == WM_USER, "msg.message = %u instead of WM_USER\n", msg.message);
     ret = GetMessageA(&msg, NULL, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_TIMER, "msg.message = %u instead of WM_TIMER\n", msg.message);
     ret = GetMessageA(&msg, NULL, 0, 0);
-    todo_wine
     ok(ret && msg.message == WM_USER + 1, "msg.message = %u instead of WM_USER + 1\n", msg.message);
     ret = PeekMessageA(&msg, NULL, 0, 0, 0);
     ok(!ret, "expected PeekMessage to return FALSE, got %u\n", ret);
diff --git a/dlls/user32/text.c b/dlls/user32/text.c
index 66a35d2..2aa127a 100644
--- a/dlls/user32/text.c
+++ b/dlls/user32/text.c
@@ -911,6 +911,15 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
     if (dtp && dtp->cbSize != sizeof(DRAWTEXTPARAMS))
         return 0;
 
+    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
+    {
+        SIZE window_ext, viewport_ext;
+        GetWindowExtEx(hdc, &window_ext);
+        GetViewportExtEx(hdc, &viewport_ext);
+        if ((window_ext.cy > 0) != (viewport_ext.cy > 0))
+            invert_y = TRUE;
+    }
+
     if (count == -1)
     {
         count = strlenW(str);
@@ -920,7 +929,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
             {
                 rect->right = rect->left;
                 if( flags & DT_SINGLELINE)
-                    rect->bottom = rect->top + lh;
+                    rect->bottom = rect->top + (invert_y ? -lh : lh);
                 else
                     rect->bottom = rect->top;
             }
@@ -928,15 +937,6 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
         }
     }
 
-    if (GetGraphicsMode(hdc) == GM_COMPATIBLE)
-    {
-        SIZE window_ext, viewport_ext;
-        GetWindowExtEx(hdc, &window_ext);
-        GetViewportExtEx(hdc, &viewport_ext);
-        if ((window_ext.cy > 0) != (viewport_ext.cy > 0))
-            invert_y = TRUE;
-    }
-
     if (dtp)
     {
         lmargin = dtp->iLeftMargin;
@@ -983,9 +983,10 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
 
 	if (flags & DT_SINGLELINE)
 	{
-	    if (flags & DT_VCENTER) y = rect->top +
-	    	(rect->bottom - rect->top) / 2 - size.cy / 2;
-	    else if (flags & DT_BOTTOM) y = rect->bottom - size.cy;
+            if (flags & DT_VCENTER)
+                y = rect->top + (rect->bottom - rect->top) / 2 + (invert_y ? (size.cy / 2) : (-size.cy / 2));
+            else if (flags & DT_BOTTOM)
+                y = rect->bottom + (invert_y ? 0 : -size.cy);
         }
 
 	if (!(flags & DT_CALCRECT))
@@ -1050,10 +1051,7 @@ INT WINAPI DrawTextExW( HDC hdc, LPWSTR str, INT i_count,
 	else if (size.cx > max_width)
 	    max_width = size.cx;
 
-        if (invert_y)
-	    y -= lh;
-        else
-	    y += lh;
+        y += invert_y ? -lh : lh;
         if (dtp)
             dtp->uiLengthDrawn += len;
     }
diff --git a/dlls/user32/user32.spec b/dlls/user32/user32.spec
index a8bbe83..b314b27 100644
--- a/dlls/user32/user32.spec
+++ b/dlls/user32/user32.spec
@@ -785,5 +785,6 @@
 # All functions must be prefixed with '__wine_' (for internal functions)
 # or 'wine_' (for user-visible functions) to avoid namespace conflicts.
 #
+@ cdecl __wine_check_for_events(long)
 @ cdecl __wine_send_input(long ptr)
 @ cdecl __wine_set_pixel_format(long long)
diff --git a/dlls/user32/user_private.h b/dlls/user32/user_private.h
index 445fd40..e2d53d7 100644
--- a/dlls/user32/user_private.h
+++ b/dlls/user32/user_private.h
@@ -117,6 +117,8 @@ typedef struct tagUSER_DRIVER {
     void   (CDECL *pWindowPosChanged)(HWND,HWND,UINT,const RECT *,const RECT *,const RECT *,const RECT *,struct window_surface*);
     /* system parameters */
     BOOL   (CDECL *pSystemParametersInfo)(UINT,UINT,void*,UINT);
+    /* candidate pos functions */
+    void   (CDECL *pUpdateCandidatePos)(HWND,const RECT *);
 } USER_DRIVER;
 
 extern const USER_DRIVER *USER_Driver DECLSPEC_HIDDEN;
@@ -184,10 +186,13 @@ struct user_thread_info
     DWORD                         GetMessagePosVal;       /* Value for GetMessagePos */
     ULONG_PTR                     GetMessageExtraInfoVal; /* Value for GetMessageExtraInfo */
     UINT                          active_hooks;           /* Bitmap of active hooks */
+    DWORD                         last_get_msg;           /* Last time of Get/PeekMessage call */
     struct user_key_state_info   *key_state;              /* Cache of global key state */
     HWND                          top_window;             /* Desktop window */
     HWND                          msg_window;             /* HWND_MESSAGE parent window */
     RAWINPUT                     *rawinput;
+    HWND                          foreground_wnd;         /* Cache of the foreground window */
+    DWORD                         foreground_wnd_epoch;   /* Counter to invalidate foreground window */
 };
 
 C_ASSERT( sizeof(struct user_thread_info) <= sizeof(((TEB *)0)->Win32ClientInfo) );
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 8ff3ebd..b6e90cc 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -55,6 +55,17 @@ static CRITICAL_SECTION_DEBUG critsect_debug =
 };
 static CRITICAL_SECTION surfaces_section = { &critsect_debug, -1, 0, 0, 0, 0 };
 
+/* from dlls/ntdll/actctx.c */
+struct wndclass_redirect_data
+{
+    ULONG size;
+    DWORD res;
+    ULONG name_len;
+    ULONG name_offset;
+    ULONG module_len;
+    ULONG module_offset;
+};
+
 /**********************************************************************/
 
 /* helper for Get/SetWindowLong */
@@ -598,7 +609,7 @@ void flush_window_surfaces( BOOL idle )
     now = GetTickCount();
     if (idle) last_idle = now;
     /* if not idle, we only flush if there's evidence that the app never goes idle */
-    else if ((int)(now - last_idle) < 1000) goto done;
+    else if ((int)(now - last_idle) < 100) goto done;
 
     LIST_FOR_EACH_ENTRY( surface, &window_surfaces, struct window_surface, entry )
         surface->funcs->flush( surface );
@@ -1292,6 +1303,39 @@ static void dump_window_styles( DWORD style, DWORD exstyle )
 #undef DUMPED_EX_STYLES
 }
 
+static BOOL get_redir_class_name(LPCWSTR className, LPWSTR redirClassName, int len)
+{
+    ATOM classatom;
+    ACTCTX_SECTION_KEYED_DATA askd;
+    WCHAR classNameStr[256];
+    struct wndclass_redirect_data* wcrd;
+
+    classatom = get_int_atom_value(className);
+    if (classatom)
+        GlobalGetAtomNameW(classatom, classNameStr, sizeof(classNameStr) / sizeof(*classNameStr));
+    else
+        strcpyW(classNameStr, className);
+
+    askd.cbSize = sizeof(askd);
+    if (FindActCtxSectionStringW(0, NULL, ACTIVATION_CONTEXT_SECTION_WINDOW_CLASS_REDIRECTION, classNameStr, &askd)) {
+        wcrd = askd.lpData;
+
+        if (wcrd->name_len == 0)
+            return FALSE;
+
+        if (wcrd->name_len > len) {
+            WARN("Redirected class name too long for buffer\n");
+            return FALSE;
+        }
+
+        memcpy(redirClassName, (unsigned char*)askd.lpData + wcrd->name_offset, wcrd->name_len);
+        redirClassName[wcrd->name_len / sizeof(WCHAR)] = 0;
+
+        return TRUE;
+    }
+
+    return FALSE;
+}
 
 /***********************************************************************
  *           WIN_CreateWindowEx
@@ -1308,6 +1352,7 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
     MDICREATESTRUCTW mdi_cs;
     CBT_CREATEWNDW cbtc;
     CREATESTRUCTW cbcs;
+    WCHAR redirClassName[256];
 
     TRACE("%s %s ex=%08x style=%08x %d,%d %dx%d parent=%p menu=%p inst=%p params=%p\n",
           unicode ? debugstr_w(cs->lpszName) : debugstr_a((LPCSTR)cs->lpszName),
@@ -1444,6 +1489,23 @@ HWND WIN_CreateWindowEx( CREATESTRUCTW *cs, LPCWSTR className, HINSTANCE module,
 
     /* Create the window structure */
 
+    wndPtr = NULL;
+
+    if (get_redir_class_name(className, redirClassName, sizeof(redirClassName)))
+    {
+        WNDCLASSW wc;
+
+        TRACE("Redirecting %s to %s\n", debugstr_w(className), debugstr_w(redirClassName));
+
+        wndPtr = create_window_handle( parent, owner, redirClassName, module, unicode );
+
+        if (GetLastError() == ERROR_INVALID_HANDLE && GetClassInfoW( 0, redirClassName, &wc ))
+            wndPtr = create_window_handle( parent, owner, redirClassName, module, unicode );
+
+        if (!wndPtr)
+            WARN("Could not create window of class %s\n", debugstr_w(redirClassName));
+    }
+
     if (!(wndPtr = create_window_handle( parent, owner, className, module, unicode )))
     {
         WNDCLASSW wc;
diff --git a/dlls/user32/winproc.c b/dlls/user32/winproc.c
index 3642109..828729b 100644
--- a/dlls/user32/winproc.c
+++ b/dlls/user32/winproc.c
@@ -45,7 +45,7 @@ typedef struct tagWINDOWPROC
     WNDPROC        procW;    /* Unicode window proc */
 } WINDOWPROC;
 
-#define MAX_WINPROCS  4096
+#define MAX_WINPROCS  16384
 #define MAX_WINPROC_RECURSION  64
 #define WINPROC_PROC16  ((WINDOWPROC *)1)  /* placeholder for 16-bit window procs */
 
diff --git a/dlls/vcomp/Makefile.in b/dlls/vcomp/Makefile.in
index a54a86f..dfff21a 100644
--- a/dlls/vcomp/Makefile.in
+++ b/dlls/vcomp/Makefile.in
@@ -1,4 +1,6 @@
 MODULE = vcomp.dll
 
 C_SRCS = \
-	main.c
+	fork.c \
+	main.c \
+	work.c
diff --git a/dlls/vcomp/main.c b/dlls/vcomp/main.c
index ab2a372..0194011 100644
--- a/dlls/vcomp/main.c
+++ b/dlls/vcomp/main.c
@@ -26,9 +26,12 @@
 #include "windef.h"
 #include "winbase.h"
 #include "wine/debug.h"
+#include "vcomp_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(vcomp);
 
+DWORD vcomp_context_tls;
+
 int CDECL omp_get_dynamic(void)
 {
     TRACE("stub\n");
@@ -117,6 +120,17 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
             return FALSE;    /* prefer native version */
         case DLL_PROCESS_ATTACH:
             DisableThreadLibraryCalls(hinstDLL);
+
+            if ((vcomp_context_tls = TlsAlloc()) == TLS_OUT_OF_INDEXES)
+            {
+                ERR("Failed to allocate TLS index\n");
+                return FALSE;
+            }
+
+            FIXME("Builtin vcomp doesn't support multithreading, use native library for better performance.\n");
+            break;
+        case DLL_PROCESS_DETACH:
+            TlsFree(vcomp_context_tls);
             break;
     }
 
diff --git a/dlls/vcomp/vcomp.spec b/dlls/vcomp/vcomp.spec
index 306dd15..1b02a65 100644
--- a/dlls/vcomp/vcomp.spec
+++ b/dlls/vcomp/vcomp.spec
@@ -55,16 +55,16 @@
 @ stub _vcomp_copyprivate_receive
 @ stub _vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long)
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr ptr)
 @ stub _vcomp_for_dynamic_next_i8
-@ stub _vcomp_for_static_end
-@ stub _vcomp_for_static_init
+@ cdecl _vcomp_for_static_end()
+@ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr)
 @ stub _vcomp_for_static_init_i8
-@ stub _vcomp_for_static_simple_init
+@ cdecl _vcomp_for_static_simple_init(long long long long ptr ptr)
 @ stub _vcomp_for_static_simple_init_i8
-@ stub _vcomp_fork
+@ varargs _vcomp_fork(long long ptr)
 @ stub _vcomp_get_thread_num
 @ stub _vcomp_leave_critsect
 @ stub _vcomp_master_barrier
@@ -83,8 +83,8 @@
 @ stub _vcomp_reduction_u2
 @ stub _vcomp_reduction_u4
 @ stub _vcomp_reduction_u8
-@ stub _vcomp_sections_init
-@ stub _vcomp_sections_next
+@ cdecl _vcomp_sections_init(long)
+@ cdecl _vcomp_sections_next()
 @ cdecl _vcomp_set_num_threads(long)
 @ cdecl _vcomp_single_begin(long)
 @ cdecl _vcomp_single_end()
@@ -98,7 +98,7 @@
 @ cdecl omp_get_thread_num()
 @ stub omp_get_wtick
 @ cdecl omp_get_wtime()
-@ stub omp_in_parallel
+@ cdecl omp_in_parallel()
 @ stub omp_init_lock
 @ stub omp_init_nest_lock
 @ cdecl omp_set_dynamic(long)
diff --git a/dlls/vcomp100/vcomp100.spec b/dlls/vcomp100/vcomp100.spec
index 39cf91c..ab93ec2 100644
--- a/dlls/vcomp100/vcomp100.spec
+++ b/dlls/vcomp100/vcomp100.spec
@@ -55,16 +55,16 @@
 @ stub _vcomp_copyprivate_receive
 @ stub _vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr ptr) vcomp._vcomp_for_dynamic_next
 @ stub _vcomp_for_dynamic_next_i8
-@ stub _vcomp_for_static_end
-@ stub _vcomp_for_static_init
+@ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
+@ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init
 @ stub _vcomp_for_static_init_i8
-@ stub _vcomp_for_static_simple_init
+@ cdecl _vcomp_for_static_simple_init(long long long long ptr ptr) vcomp._vcomp_for_static_simple_init
 @ stub _vcomp_for_static_simple_init_i8
-@ stub _vcomp_fork
+@ varargs _vcomp_fork(long long ptr) vcomp._vcomp_fork
 @ stub _vcomp_get_thread_num
 @ stub _vcomp_leave_critsect
 @ stub _vcomp_master_barrier
@@ -83,8 +83,8 @@
 @ stub _vcomp_reduction_u2
 @ stub _vcomp_reduction_u4
 @ stub _vcomp_reduction_u8
-@ stub _vcomp_sections_init
-@ stub _vcomp_sections_next
+@ cdecl _vcomp_sections_init(long) vcomp._vcomp_sections_init
+@ cdecl _vcomp_sections_next() vcomp._vcomp_sections_next
 @ cdecl _vcomp_set_num_threads(long) vcomp._vcomp_set_num_threads
 @ cdecl _vcomp_single_begin(long) vcomp._vcomp_single_begin
 @ cdecl _vcomp_single_end() vcomp._vcomp_single_end
@@ -98,7 +98,7 @@
 @ cdecl omp_get_thread_num() vcomp.omp_get_thread_num
 @ stub omp_get_wtick
 @ cdecl omp_get_wtime() vcomp.omp_get_wtime
-@ stub omp_in_parallel
+@ cdecl omp_in_parallel() vcomp.omp_in_parallel
 @ stub omp_init_lock
 @ stub omp_init_nest_lock
 @ cdecl omp_set_dynamic(long) vcomp.omp_set_dynamic
diff --git a/dlls/vcomp90/vcomp90.spec b/dlls/vcomp90/vcomp90.spec
index 39cf91c..ab93ec2 100644
--- a/dlls/vcomp90/vcomp90.spec
+++ b/dlls/vcomp90/vcomp90.spec
@@ -55,16 +55,16 @@
 @ stub _vcomp_copyprivate_receive
 @ stub _vcomp_enter_critsect
 @ stub _vcomp_flush
-@ stub _vcomp_for_dynamic_init
+@ cdecl _vcomp_for_dynamic_init(long long long long long) vcomp._vcomp_for_dynamic_init
 @ stub _vcomp_for_dynamic_init_i8
-@ stub _vcomp_for_dynamic_next
+@ cdecl _vcomp_for_dynamic_next(ptr ptr) vcomp._vcomp_for_dynamic_next
 @ stub _vcomp_for_dynamic_next_i8
-@ stub _vcomp_for_static_end
-@ stub _vcomp_for_static_init
+@ cdecl _vcomp_for_static_end() vcomp._vcomp_for_static_end
+@ cdecl _vcomp_for_static_init(long long long long ptr ptr ptr ptr ptr) vcomp._vcomp_for_static_init
 @ stub _vcomp_for_static_init_i8
-@ stub _vcomp_for_static_simple_init
+@ cdecl _vcomp_for_static_simple_init(long long long long ptr ptr) vcomp._vcomp_for_static_simple_init
 @ stub _vcomp_for_static_simple_init_i8
-@ stub _vcomp_fork
+@ varargs _vcomp_fork(long long ptr) vcomp._vcomp_fork
 @ stub _vcomp_get_thread_num
 @ stub _vcomp_leave_critsect
 @ stub _vcomp_master_barrier
@@ -83,8 +83,8 @@
 @ stub _vcomp_reduction_u2
 @ stub _vcomp_reduction_u4
 @ stub _vcomp_reduction_u8
-@ stub _vcomp_sections_init
-@ stub _vcomp_sections_next
+@ cdecl _vcomp_sections_init(long) vcomp._vcomp_sections_init
+@ cdecl _vcomp_sections_next() vcomp._vcomp_sections_next
 @ cdecl _vcomp_set_num_threads(long) vcomp._vcomp_set_num_threads
 @ cdecl _vcomp_single_begin(long) vcomp._vcomp_single_begin
 @ cdecl _vcomp_single_end() vcomp._vcomp_single_end
@@ -98,7 +98,7 @@
 @ cdecl omp_get_thread_num() vcomp.omp_get_thread_num
 @ stub omp_get_wtick
 @ cdecl omp_get_wtime() vcomp.omp_get_wtime
-@ stub omp_in_parallel
+@ cdecl omp_in_parallel() vcomp.omp_in_parallel
 @ stub omp_init_lock
 @ stub omp_init_nest_lock
 @ cdecl omp_set_dynamic(long) vcomp.omp_set_dynamic
diff --git a/dlls/version/tests/info.c b/dlls/version/tests/info.c
index 107cfac..1c60cd6 100644
--- a/dlls/version/tests/info.c
+++ b/dlls/version/tests/info.c
@@ -574,6 +574,132 @@ static void test_VerQueryValueA(void)
     HeapFree(GetProcessHeap(), 0, ver);
 }
 
+static void test_VerQueryValue_InvalidLength(void)
+{
+    /* this buffer is created with the reactos resource compiler from this resource:
+#include "winver.h"
+
+VS_VERSION_INFO VERSIONINFO
+FILEVERSION    1,0,0,0
+PRODUCTVERSION 1,0,0,0
+FILEFLAGSMASK  63
+FILEFLAGS      0
+FILEOS         VOS_UNKNOWN
+FILETYPE       VFT_APP
+FILESUBTYPE    VFT2_UNKNOWN
+{
+    BLOCK "StringFileInfo"
+    {
+    }
+}
+*/
+    char preparedbuffer[] = {
+        /* VS_VERSION_INFO_STRUCT32 */
+        0x80, 0x00,     /* wLength */
+        0x34, 0x00,     /* wValueLength */
+        0x00, 0x00,     /* wType */
+        /* L"VS_VERSION_INFO" + DWORD alignment */
+        0x56, 0x00, 0x53, 0x00, 0x5f, 0x00, 0x56, 0x00, 0x45, 0x00, 0x52, 0x00, 0x53, 0x00, 0x49, 0x00, 0x4f,
+        0x00, 0x4e, 0x00, 0x5f, 0x00, 0x49, 0x00, 0x4e, 0x00, 0x46, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x00, 0x00,
+
+        /* VS_FIXEDFILEINFO */
+        0xbd, 0x04, 0xef, 0xfe,     /* dwSignature */
+        0x00, 0x00, 0x01, 0x00,     /* dwStrucVersion */
+        0x00, 0x00, 0x01, 0x00,     /* dwFileVersionMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileVersionLS */
+        0x00, 0x00, 0x01, 0x00,     /* dwProductVersionMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwProductVersionLS */
+        0x3f, 0x00, 0x00, 0x00,     /* dwFileFlagsMask */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileFlags */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileOS */
+        0x01, 0x00, 0x00, 0x00,     /* dwFileType */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileSubtype */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileDateMS */
+        0x00, 0x00, 0x00, 0x00,     /* dwFileDateLS */
+
+        /* first child: */
+            0x24, 0x00,     /* wLength */
+            0x00, 0x00,     /* wValueLength */
+            0x01, 0x00,     /* wType */
+            /* L"StringFileInfo" + DWORD alignment */
+            0x53, 0x00, 0x74, 0x00, 0x72, 0x00, 0x69, 0x00, 0x6e, 0x00, 0x67, 0x00, 0x46, 0x00, 0x69, 0x00,
+            0x6c, 0x00, 0x65, 0x00, 0x49, 0x00, 0x6e, 0x00, 0x66, 0x00, 0x6f, 0x00, 0x00, 0x00,
+            /* "FE2X" */
+            0x46, 0x45, 0x32, 0x58,
+
+            /* Extra bytes allocated for W->A conversions. */
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+            0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba, 0x0d, 0xf0, 0xad, 0xba,
+    };
+    char *p;
+    UINT len, ret;
+    WCHAR FileDescriptionW[] = { '\\', '\\', 'S', 't', 'r', 'i', 'n', 'g', 'F', 'i', 'l', 'e', 'I', 'n', 'f', 'o', 0 };
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %u\n", GetLastError());
+    todo_wine
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "\\StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %u\n", GetLastError());
+    todo_wine
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueA(preparedbuffer, "\\\\StringFileInfo", (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueA error %u\n", GetLastError());
+    todo_wine
+    ok(len == 0, "VerQueryValueA returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    /* also test the W versions. */
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW + 2, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %u\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW + 1, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %u\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+
+    p = (char *)0xdeadbeef;
+    len = 0xdeadbeef;
+    SetLastError(0xdeadbeef);
+    ret = VerQueryValueW(preparedbuffer, FileDescriptionW, (LPVOID *)&p, &len);
+    ok(ret, "VerQueryValueW error %u\n", GetLastError());
+    ok(len == 0, "VerQueryValueW returned %u, expected 0\n", len);
+    todo_wine
+    ok(p == preparedbuffer + 0x7e, "p was %p, expected %p\n", p, preparedbuffer + 0x7e);
+}
+
 static void test_extra_block(void)
 {
     WORD extra_block[] = {
@@ -630,5 +756,6 @@ START_TEST(info)
     test_info();
     test_32bit_win();
     test_VerQueryValueA();
+    test_VerQueryValue_InvalidLength();
     test_extra_block();
 }
diff --git a/dlls/version/version.c b/dlls/version/version.c
index 68dab66..57fbaec 100644
--- a/dlls/version/version.c
+++ b/dlls/version/version.c
@@ -1619,9 +1619,9 @@ DWORD WINAPI VerInstallFileW(
  */
 DWORD WINAPI GetFileVersionInfoSizeExA(DWORD flags, LPCSTR filename, LPDWORD handle)
 {
-    FIXME("stub: %u %s %p\n", flags, wine_dbgstr_a(filename), handle);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return 0;
+    FIXME("semi-stub: %u %s %p\n", flags, wine_dbgstr_a(filename), handle);
+    return GetFileVersionInfoSizeA(filename, handle);
+
 }
 
 /******************************************************************************
@@ -1629,9 +1629,8 @@ DWORD WINAPI GetFileVersionInfoSizeExA(DWORD flags, LPCSTR filename, LPDWORD han
  */
 DWORD WINAPI GetFileVersionInfoSizeExW(DWORD flags, LPCWSTR filename, LPDWORD handle)
 {
-    FIXME("stub: %u %s %p\n", flags, wine_dbgstr_w(filename), handle);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return 0;
+    FIXME("semi-stub: %u %s %p\n", flags, wine_dbgstr_w(filename), handle);
+    return GetFileVersionInfoSizeW(filename, handle);
 }
 
 /******************************************************************************
@@ -1639,9 +1638,8 @@ DWORD WINAPI GetFileVersionInfoSizeExW(DWORD flags, LPCWSTR filename, LPDWORD ha
  */
 BOOL WINAPI GetFileVersionInfoExA(DWORD flags, LPCSTR filename, DWORD handle, DWORD len, LPVOID data)
 {
-    FIXME("stub: %u %s %u %u %p\n", flags, wine_dbgstr_a(filename), handle, len, data);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return 0;
+    FIXME("semi-stub: %u %s %u %u %p\n", flags, wine_dbgstr_a(filename), handle, len, data);
+    return GetFileVersionInfoA(filename, handle, len, data);
 }
 
 /******************************************************************************
@@ -1649,7 +1647,6 @@ BOOL WINAPI GetFileVersionInfoExA(DWORD flags, LPCSTR filename, DWORD handle, DW
  */
 BOOL WINAPI GetFileVersionInfoExW(DWORD flags, LPCWSTR filename, DWORD handle, DWORD len, LPVOID data)
 {
-    FIXME("stub: %u %s %u %u %p\n", flags, wine_dbgstr_w(filename), handle, len, data);
-    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
-    return 0;
+    FIXME("semi-stub: %u %s %u %u %p\n", flags, wine_dbgstr_w(filename), handle, len, data);
+    return GetFileVersionInfoW(filename, handle, len, data);
 }
diff --git a/dlls/wbemprox/builtin.c b/dlls/wbemprox/builtin.c
index 8ba2642..206b344 100644
--- a/dlls/wbemprox/builtin.c
+++ b/dlls/wbemprox/builtin.c
@@ -98,6 +98,8 @@ static const WCHAR class_sidW[] =
     {'W','i','n','3','2','_','S','I','D',0};
 static const WCHAR class_sounddeviceW[] =
     {'W','i','n','3','2','_','S','o','u','n','d','D','e','v','i','c','e',0};
+static const WCHAR class_systemenclosureW[] =
+    {'W','i','n','3','2','_','S','y','s','t','e','m','E','n','c','l','o','s','u','r','e',0};
 static const WCHAR class_videocontrollerW[] =
     {'W','i','n','3','2','_','V','i','d','e','o','C','o','n','t','r','o','l','l','e','r',0};
 
@@ -133,6 +135,8 @@ static const WCHAR prop_capacityW[] =
     {'C','a','p','a','c','i','t','y',0};
 static const WCHAR prop_captionW[] =
     {'C','a','p','t','i','o','n',0};
+static const WCHAR prop_chassistypesW[] =
+    {'C','h','a','s','s','i','s','T','y','p','e','s',0};
 static const WCHAR prop_classW[] =
     {'C','l','a','s','s',0};
 static const WCHAR prop_codesetW[] =
@@ -225,6 +229,8 @@ static const WCHAR prop_localdatetimeW[] =
     {'L','o','c','a','l','D','a','t','e','T','i','m','e',0};
 static const WCHAR prop_localeW[] =
     {'L','o','c','a','l','e',0};
+static const WCHAR prop_lockpresentW[] =
+    {'L','o','c','k','P','r','e','s','e','n','t',0};
 static const WCHAR prop_macaddressW[] =
     {'M','A','C','A','d','d','r','e','s','s',0};
 static const WCHAR prop_manufacturerW[] =
@@ -590,6 +596,16 @@ static const struct column col_stdregprov[] =
     { method_enumvaluesW,     CIM_FLAG_ARRAY|COL_FLAG_METHOD },
     { method_getstringvalueW, CIM_FLAG_ARRAY|COL_FLAG_METHOD }
 };
+static const struct column col_systemenclosure[] =
+{
+    { prop_captionW,      CIM_STRING },
+    { prop_chassistypesW, CIM_UINT16|CIM_FLAG_ARRAY },
+    { prop_descriptionW,  CIM_STRING },
+    { prop_lockpresentW,  CIM_BOOLEAN },
+    { prop_manufacturerW, CIM_STRING },
+    { prop_nameW,         CIM_STRING },
+    { prop_tagW,          CIM_STRING },
+};
 static const struct column col_systemsecurity[] =
 {
     { method_getsdW,                    CIM_FLAG_ARRAY|COL_FLAG_METHOD },
@@ -702,6 +718,12 @@ static const WCHAR physicalmedia_tagW[] =
     {'\\','\\','.','\\','P','H','Y','S','I','C','A','L','D','R','I','V','E','0',0};
 static const WCHAR sounddevice_productnameW[] =
     {'W','i','n','e',' ','A','u','d','i','o',' ','D','e','v','i','c','e',0};
+static const WCHAR systemenclosure_systemenclosureW[] =
+    {'S','y','s','t','e','m',' ','E','n','c','l','o','s','u','r','e',0};
+static const WCHAR systemenclosure_tagW[] =
+    {'S','y','s','t','e','m',' ','E','n','c','l','o','s','u','r','e',' ','0',0};
+static const WCHAR systemenclosure_ManufacturerW[] =
+    {'W','i','n','e',0};
 static const WCHAR videocontroller_dactypeW[] =
     {'I','n','t','e','g','r','a','t','e','d',' ','R','A','M','D','A','C',0};
 static const WCHAR videocontroller_deviceidW[] =
@@ -938,7 +960,7 @@ struct record_service
 struct record_sid
 {
     const WCHAR *accountname;
-    const UINT8 *binaryrepresentation;
+    const struct array *binaryrepresentation;
     const WCHAR *referenceddomainname;
     const WCHAR *sid;
     UINT32       sidlength;
@@ -960,6 +982,16 @@ struct record_systemsecurity
     class_method *getsd;
     class_method *setsd;
 };
+struct record_systemenclosure
+{
+    const WCHAR *caption;
+    const struct array *chassistypes;
+    const WCHAR *description;
+    int         lockpresent;
+    const WCHAR *manufacturer;
+    const WCHAR *name;
+    const WCHAR *tag;
+};
 struct record_videocontroller
 {
     const WCHAR *adapter_dactype;
@@ -1044,6 +1076,30 @@ static const struct record_stdregprov data_stdregprov[] =
 {
     { reg_enum_key, reg_enum_values, reg_get_stringvalue }
 };
+
+static UINT16 chassistypes[] =
+{
+    1,
+};
+
+static const struct array chassistypes_array =
+{
+    sizeof(chassistypes)/sizeof(chassistypes[0]),
+    &chassistypes
+};
+
+static const struct record_systemenclosure data_systemenclosure[] =
+{
+    {
+        systemenclosure_systemenclosureW,
+        &chassistypes_array,
+        systemenclosure_systemenclosureW,
+        FALSE,
+        systemenclosure_ManufacturerW,
+        systemenclosure_systemenclosureW,
+        systemenclosure_tagW,
+    }
+};
 static const struct record_systemsecurity data_systemsecurity[] =
 {
     { security_get_sd, security_set_sd }
@@ -2614,12 +2670,22 @@ static WCHAR *get_accountname( LSA_TRANSLATED_NAME *name )
     if (!name || !name->Name.Buffer) return NULL;
     return heap_strdupW( name->Name.Buffer );
 }
-static UINT8 *get_binaryrepresentation( PSID sid, UINT len )
+static struct array *get_binaryrepresentation( PSID sid, UINT len )
 {
-    UINT8 *ret = heap_alloc( len );
-    if (!ret) return NULL;
-    memcpy( ret, sid, len );
-    return ret;
+    struct array *array = heap_alloc( sizeof(struct array) );
+    if (array)
+    {
+        UINT8 *ret = heap_alloc( len );
+        if (ret)
+        {
+            memcpy( ret, sid, len );
+            array->count = len;
+            array->ptr = ret;
+            return array;
+        }
+        heap_free( array );
+    }
+    return NULL;
 }
 static WCHAR *get_referenceddomainname( LSA_REFERENCED_DOMAIN_LIST *domain )
 {
@@ -2807,6 +2873,7 @@ static struct table builtin_classes[] =
     { class_sounddeviceW, SIZEOF(col_sounddevice), col_sounddevice, SIZEOF(data_sounddevice), 0, (BYTE *)data_sounddevice },
     { class_stdregprovW, SIZEOF(col_stdregprov), col_stdregprov, SIZEOF(data_stdregprov), 0, (BYTE *)data_stdregprov },
     { class_systemsecurityW, SIZEOF(col_systemsecurity), col_systemsecurity, SIZEOF(data_systemsecurity), 0, (BYTE *)data_systemsecurity },
+    { class_systemenclosureW, SIZEOF(col_systemenclosure), col_systemenclosure, SIZEOF(data_systemenclosure), 0, (BYTE *)data_systemenclosure },
     { class_videocontrollerW, SIZEOF(col_videocontroller), col_videocontroller, 0, 0, NULL, fill_videocontroller }
 };
 
diff --git a/dlls/wbemprox/table.c b/dlls/wbemprox/table.c
index 0c57f26..273b8cb 100644
--- a/dlls/wbemprox/table.c
+++ b/dlls/wbemprox/table.c
@@ -288,10 +288,15 @@ void free_row_values( const struct table *table, UINT row )
         if (!(table->columns[i].type & COL_FLAG_DYNAMIC)) continue;
 
         type = table->columns[i].type & COL_TYPE_MASK;
-        if (type == CIM_STRING || type == CIM_DATETIME || (type & CIM_FLAG_ARRAY))
+        if (type == CIM_STRING || type == CIM_DATETIME)
         {
             if (get_value( table, row, i, &val ) == S_OK) heap_free( (void *)(INT_PTR)val );
         }
+        else if (type & CIM_FLAG_ARRAY)
+        {
+            if (get_value( table, row, i, &val ) == S_OK)
+                destroy_array( (void *)(INT_PTR)val, type & CIM_TYPE_MASK );
+        }
     }
 }
 
diff --git a/dlls/wbemprox/tests/query.c b/dlls/wbemprox/tests/query.c
index 7e031d2..02774db 100644
--- a/dlls/wbemprox/tests/query.c
+++ b/dlls/wbemprox/tests/query.c
@@ -158,7 +158,7 @@ static void test_Win32_Service( IWbemServices *services )
     if (hr != S_OK)
     {
         win_skip( "Win32_Service not available\n" );
-        return;
+        goto out;
     }
     type = 0xdeadbeef;
     VariantInit( &state );
@@ -232,6 +232,7 @@ static void test_Win32_Service( IWbemServices *services )
     ok( hr == S_OK, "got %08x\n", hr );
     if (service) IWbemClassObject_Release( service );
 
+out:
     SysFreeString( empty );
     SysFreeString( class );
 }
@@ -372,17 +373,17 @@ static void test_Win32_ComputerSystem( IWbemServices *services )
     if (!compname[0] || !username[0])
     {
         skip( "Failed to get user or computer name\n" );
-        return;
+        goto out;
     }
 
     hr = IWbemServices_ExecQuery( services, wql, query, 0, NULL, &result );
     if (hr != S_OK)
     {
         win_skip( "Win32_ComputerSystem not available\n" );
-        return;
+        goto out;
     }
 
-    IEnumWbemClassObject_Next( result, 10000, 1, &service, &count );
+    hr = IEnumWbemClassObject_Next( result, 10000, 1, &service, &count );
     ok( hr == S_OK, "got %08x\n", hr );
 
     type = 0xdeadbeef;
@@ -405,6 +406,7 @@ static void test_Win32_ComputerSystem( IWbemServices *services )
 
     IWbemClassObject_Release( service );
     IEnumWbemClassObject_Release( result );
+out:
     SysFreeString( query );
     SysFreeString( wql );
 }
diff --git a/dlls/wbemprox/wbemlocator.c b/dlls/wbemprox/wbemlocator.c
index 463e6d4..b50d7cb 100644
--- a/dlls/wbemprox/wbemlocator.c
+++ b/dlls/wbemprox/wbemlocator.c
@@ -89,10 +89,11 @@ static HRESULT WINAPI wbem_locator_QueryInterface(
 static BOOL is_local_machine( const WCHAR *server )
 {
     static const WCHAR dotW[] = {'.',0};
+    static const WCHAR localhostW[] = {'l','o','c','a','l','h','o','s','t',0};
     WCHAR buffer[MAX_COMPUTERNAME_LENGTH + 1];
     DWORD len = sizeof(buffer) / sizeof(buffer[0]);
 
-    if (!server || !strcmpW( server, dotW )) return TRUE;
+    if (!server || !strcmpW( server, dotW ) || !strcmpW( server, localhostW )) return TRUE;
     if (GetComputerNameW( buffer, &len ) && !strcmpiW( server, buffer )) return TRUE;
     return FALSE;
 }
diff --git a/dlls/wiaservc/Makefile.in b/dlls/wiaservc/Makefile.in
index b40c8f0..0bdbff1 100644
--- a/dlls/wiaservc/Makefile.in
+++ b/dlls/wiaservc/Makefile.in
@@ -4,6 +4,7 @@ IMPORTS   = uuid ole32 advapi32
 C_SRCS = \
 	factory.c \
 	service.c \
+	enumwiadevinfo.c \
 	wiadevmgr.c \
 	wiaservc_main.c
 
diff --git a/dlls/wiaservc/wiadevmgr.c b/dlls/wiaservc/wiadevmgr.c
index 6eb82aa..8305ae2 100644
--- a/dlls/wiaservc/wiadevmgr.c
+++ b/dlls/wiaservc/wiadevmgr.c
@@ -72,8 +72,18 @@ static ULONG WINAPI wiadevmgr_Release(IWiaDevMgr *iface)
 static HRESULT WINAPI wiadevmgr_EnumDeviceInfo(IWiaDevMgr *iface, LONG lFlag, IEnumWIA_DEV_INFO **ppIEnum)
 {
     wiadevmgr *This = impl_from_IWiaDevMgr(iface);
-    FIXME("(%p, %d, %p): stub\n", This, lFlag, ppIEnum);
-    return E_NOTIMPL;
+    HRESULT res;
+    IEnumWIA_DEV_INFO *enumdevinfo = NULL;
+
+    FIXME("(%p, %d, %p): returning empty IEnumWIA_DEV_INFO\n", This, lFlag, ppIEnum);
+
+    res = enumwiadevinfo_Constructor(&enumdevinfo);
+    if (FAILED(res))
+        return res;
+
+    res = IEnumWIA_DEV_INFO_QueryInterface(enumdevinfo, &IID_IEnumWIA_DEV_INFO, (void **)ppIEnum);
+    IEnumWIA_DEV_INFO_Release(enumdevinfo);
+    return res;
 }
 
 static HRESULT WINAPI wiadevmgr_CreateDevice(IWiaDevMgr *iface, BSTR bstrDeviceID, IWiaItem **ppWiaItemRoot)
diff --git a/dlls/wiaservc/wiaservc_private.h b/dlls/wiaservc/wiaservc_private.h
index 33c9ba1..22ad553 100644
--- a/dlls/wiaservc/wiaservc_private.h
+++ b/dlls/wiaservc/wiaservc_private.h
@@ -36,6 +36,14 @@ typedef struct
 
 HRESULT wiadevmgr_Constructor(IWiaDevMgr **ppObj) DECLSPEC_HIDDEN;
 
+typedef struct
+{
+    IEnumWIA_DEV_INFO IEnumWIA_DEV_INFO_iface;
+    LONG ref;
+} enumwiadevinfo;
+
+HRESULT enumwiadevinfo_Constructor(IEnumWIA_DEV_INFO **ppObj) DECLSPEC_HIDDEN;
+
 /* Little helper functions */
 static inline char *
 wiaservc_strdup(const char *s)
diff --git a/dlls/windowscodecs/stream.c b/dlls/windowscodecs/stream.c
index f6bfedf..0af9d81 100644
--- a/dlls/windowscodecs/stream.c
+++ b/dlls/windowscodecs/stream.c
@@ -1021,7 +1021,7 @@ HRESULT stream_initialize_from_filehandle(IWICStream *iface, HANDLE file)
     StreamOnFileHandle *pObject;
     IWICStream *stream = NULL;
     HANDLE map;
-    void *mem;
+    void *mem = NULL;
     LARGE_INTEGER size;
     HRESULT hr;
     TRACE("(%p,%p)\n", iface, file);
diff --git a/dlls/windowscodecs/tests/tiffformat.c b/dlls/windowscodecs/tests/tiffformat.c
index cc1951e..d07caa3 100644
--- a/dlls/windowscodecs/tests/tiffformat.c
+++ b/dlls/windowscodecs/tests/tiffformat.c
@@ -92,6 +92,48 @@ static const struct tiff_1bpp_data
     { 900, 3 },
     { 0x11, 0x22, 0x33, 0 }
 };
+
+static const struct tiff_8bpp_alpha
+{
+    USHORT byte_order;
+    USHORT version;
+    ULONG  dir_offset;
+    USHORT number_of_entries;
+    struct IFD_entry entry[15];
+    ULONG next_IFD;
+    struct IFD_rational res;
+    BYTE pixel_data[8];
+} tiff_8bpp_alpha =
+{
+#ifdef WORDS_BIGENDIAN
+    'M' | 'M' << 8,
+#else
+    'I' | 'I' << 8,
+#endif
+    42,
+    FIELD_OFFSET(struct tiff_8bpp_alpha, number_of_entries),
+    15,
+    {
+        { 0xff, IFD_SHORT, 1, 0 }, /* SUBFILETYPE */
+        { 0x100, IFD_LONG, 1, 2 }, /* IMAGEWIDTH */
+        { 0x101, IFD_LONG, 1, 2 }, /* IMAGELENGTH */
+        { 0x102, IFD_SHORT, 2, MAKELONG(8, 8) }, /* BITSPERSAMPLE */
+        { 0x103, IFD_SHORT, 1, 1 }, /* COMPRESSION: XP doesn't accept IFD_LONG here */
+        { 0x106, IFD_SHORT, 1, 1 }, /* PHOTOMETRIC */
+        { 0x111, IFD_LONG, 1, FIELD_OFFSET(struct tiff_8bpp_alpha, pixel_data) }, /* STRIPOFFSETS */
+        { 0x115, IFD_SHORT, 1, 2 }, /* SAMPLESPERPIXEL */
+        { 0x116, IFD_LONG, 1, 2 }, /* ROWSPERSTRIP */
+        { 0x117, IFD_LONG, 1, 8 }, /* STRIPBYTECOUNT */
+        { 0x11a, IFD_RATIONAL, 1, FIELD_OFFSET(struct tiff_8bpp_alpha, res) },
+        { 0x11b, IFD_RATIONAL, 1, FIELD_OFFSET(struct tiff_8bpp_alpha, res) },
+        { 0x11c, IFD_SHORT, 1, 1 }, /* PLANARCONFIGURATION */
+        { 0x128, IFD_SHORT, 1, 2 }, /* RESOLUTIONUNIT */
+        { 0x152, IFD_SHORT, 1, 1 } /* EXTRASAMPLES: 1 - Associated alpha with pre-multiplied color */
+    },
+    0,
+    { 96, 1 },
+    { 0x11,0x22,0x33,0x44,0x55,0x66,0x77,0x88 }
+};
 #include "poppack.h"
 
 static IWICImagingFactory *factory;
@@ -264,6 +306,66 @@ todo_wine
     IStream_Release(stream);
 }
 
+static void test_tiff_8bpp_alpha(void)
+{
+    HRESULT hr;
+    IWICBitmapDecoder *decoder;
+    IWICBitmapFrameDecode *frame;
+    UINT frame_count, width, height, i;
+    double dpi_x, dpi_y;
+    IWICPalette *palette;
+    GUID format;
+    WICRect rc;
+    BYTE data[16];
+    static const BYTE expected_data[16] = { 0x11,0x11,0x11,0x22,0x33,0x33,0x33,0x44,
+                                            0x55,0x55,0x55,0x66,0x77,0x77,0x77,0x88 };
+
+    decoder = create_decoder(&tiff_8bpp_alpha, sizeof(tiff_8bpp_alpha));
+    ok(decoder != 0, "Failed to load TIFF image data\n");
+
+    hr = IWICBitmapDecoder_GetFrameCount(decoder, &frame_count);
+    ok(hr == S_OK, "GetFrameCount error %#x\n", hr);
+    ok(frame_count == 1, "expected 1, got %u\n", frame_count);
+
+    hr = IWICBitmapDecoder_GetFrame(decoder, 0, &frame);
+    ok(hr == S_OK, "GetFrame error %#x\n", hr);
+
+    hr = IWICBitmapFrameDecode_GetSize(frame, &width, &height);
+    ok(hr == S_OK, "GetSize error %#x\n", hr);
+    ok(width == 2, "expected 2, got %u\n", width);
+    ok(height == 2, "expected 2, got %u\n", height);
+
+    hr = IWICBitmapFrameDecode_GetResolution(frame, &dpi_x, &dpi_y);
+    ok(hr == S_OK, "GetResolution error %#x\n", hr);
+    ok(dpi_x == 96.0, "expected 96.0, got %f\n", dpi_x);
+    ok(dpi_y == 96.0, "expected 96.0, got %f\n", dpi_y);
+
+    hr = IWICBitmapFrameDecode_GetPixelFormat(frame, &format);
+    ok(hr == S_OK, "GetPixelFormat error %#x\n", hr);
+    ok(IsEqualGUID(&format, &GUID_WICPixelFormat32bppPBGRA),
+       "got wrong format %s\n", wine_dbgstr_guid(&format));
+
+    hr = IWICImagingFactory_CreatePalette(factory, &palette);
+    ok(hr == S_OK, "CreatePalette error %#x\n", hr);
+    hr = IWICBitmapFrameDecode_CopyPalette(frame, palette);
+    ok(hr == WINCODEC_ERR_PALETTEUNAVAILABLE,
+       "expected WINCODEC_ERR_PALETTEUNAVAILABLE, got %#x\n", hr);
+    IWICPalette_Release(palette);
+
+    rc.X = 0;
+    rc.Y = 0;
+    rc.Width = 2;
+    rc.Height = 2;
+    hr = IWICBitmapFrameDecode_CopyPixels(frame, &rc, 8, sizeof(data), data);
+    ok(hr == S_OK, "CopyPixels error %#x\n", hr);
+
+    for (i = 0; i < sizeof(data); i++)
+        ok(data[i] == expected_data[i], "%u: expected %02x, got %02x\n", i, expected_data[i], data[i]);
+
+    IWICBitmapFrameDecode_Release(frame);
+    IWICBitmapDecoder_Release(decoder);
+}
+
 START_TEST(tiffformat)
 {
     HRESULT hr;
@@ -277,6 +379,7 @@ START_TEST(tiffformat)
 
     test_tiff_palette();
     test_QueryCapability();
+    test_tiff_8bpp_alpha();
 
     IWICImagingFactory_Release(factory);
     CoUninitialize();
diff --git a/dlls/windowscodecs/tiffformat.c b/dlls/windowscodecs/tiffformat.c
index 7f987de..51e940f 100644
--- a/dlls/windowscodecs/tiffformat.c
+++ b/dlls/windowscodecs/tiffformat.c
@@ -236,7 +236,7 @@ typedef struct {
     const WICPixelFormatGUID *format;
     int bps;
     int samples;
-    int bpp;
+    int bpp, source_bpp;
     int planar;
     int indexed;
     int reverse_bgr;
@@ -326,23 +326,63 @@ static HRESULT tiff_get_decode_info(TIFF *tiff, tiff_decode_info *decode_info)
         decode_info->invert_grayscale = 1;
         /* fall through */
     case 1: /* BlackIsZero */
-        if (samples != 1)
+        if (samples == 2)
+        {
+            ret = pTIFFGetField(tiff, TIFFTAG_EXTRASAMPLES, &extra_sample_count, &extra_samples);
+            if (!ret)
+            {
+                extra_sample_count = 1;
+                extra_sample = 0;
+                extra_samples = &extra_sample;
+            }
+        }
+        else if (samples != 1)
         {
-            FIXME("unhandled grayscale sample count %u\n", samples);
+            FIXME("unhandled %dbpp sample count %u\n", bps, samples);
             return E_FAIL;
         }
 
-        decode_info->bpp = bps;
+        decode_info->bpp = bps * samples;
+        decode_info->source_bpp = decode_info->bpp;
         switch (bps)
         {
         case 1:
+            if (samples != 1)
+            {
+                FIXME("unhandled 1bpp sample count %u\n", samples);
+                return E_FAIL;
+            }
             decode_info->format = &GUID_WICPixelFormatBlackWhite;
             break;
         case 4:
+            if (samples != 1)
+            {
+                FIXME("unhandled 4bpp grayscale sample count %u\n", samples);
+                return E_FAIL;
+            }
             decode_info->format = &GUID_WICPixelFormat4bppGray;
             break;
         case 8:
-            decode_info->format = &GUID_WICPixelFormat8bppGray;
+            if (samples == 1)
+                decode_info->format = &GUID_WICPixelFormat8bppGray;
+            else
+            {
+                decode_info->bpp = 32;
+
+                switch(extra_samples[0])
+                {
+                case 1: /* Associated (pre-multiplied) alpha data */
+                    decode_info->format = &GUID_WICPixelFormat32bppPBGRA;
+                    break;
+                case 0: /* Unspecified data */
+                case 2: /* Unassociated alpha data */
+                    decode_info->format = &GUID_WICPixelFormat32bppBGRA;
+                    break;
+                default:
+                    FIXME("unhandled extra sample type %u\n", extra_samples[0]);
+                    return E_FAIL;
+                }
+            }
             break;
         default:
             FIXME("unhandled greyscale bit count %u\n", bps);
@@ -943,6 +983,22 @@ static HRESULT TiffFrameDecode_ReadTile(TiffFrameDecode *This, UINT tile_x, UINT
             hr = E_FAIL;
     }
 
+    /* 8bpp grayscale with extra alpha */
+    if (hr == S_OK && This->decode_info.source_bpp == 16 && This->decode_info.samples == 2 && This->decode_info.bpp == 32)
+    {
+        BYTE *src;
+        DWORD *dst, count = This->decode_info.tile_width * This->decode_info.tile_height;
+
+        src = This->cached_tile + This->decode_info.tile_width * This->decode_info.tile_height * 2 - 2;
+        dst = (DWORD *)(This->cached_tile + This->decode_info.tile_size - 4);
+
+        while (count--)
+        {
+            *dst-- = src[0] | (src[0] << 8) | (src[0] << 16) | (src[1] << 24);
+            src -= 2;
+        }
+    }
+
     if (hr == S_OK && This->decode_info.reverse_bgr)
     {
         if (This->decode_info.bps == 8)
diff --git a/dlls/winealsa.drv/mmdevdrv.c b/dlls/winealsa.drv/mmdevdrv.c
index 90894b6..ef0271c 100644
--- a/dlls/winealsa.drv/mmdevdrv.c
+++ b/dlls/winealsa.drv/mmdevdrv.c
@@ -359,7 +359,7 @@ static WCHAR *construct_device_id(EDataFlow flow, const WCHAR *chunk1, const cha
 {
     WCHAR *ret;
     const WCHAR *prefix;
-    DWORD len_wchars = 0, chunk1_len, copied = 0, prefix_len;
+    DWORD len_wchars = 0, chunk1_len = 0, copied = 0, prefix_len;
 
     static const WCHAR dashW[] = {' ','-',' ',0};
     static const size_t dashW_len = (sizeof(dashW) / sizeof(*dashW)) - 1;
diff --git a/dlls/wined3d/Makefile.in b/dlls/wined3d/Makefile.in
index 655800b..7e81975 100644
--- a/dlls/wined3d/Makefile.in
+++ b/dlls/wined3d/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	device.c \
 	directx.c \
 	drawprim.c \
+	dxtn.c \
 	gl_compat.c \
 	glsl_shader.c \
 	nvidia_texture_shader.c \
@@ -26,6 +27,8 @@ C_SRCS = \
 	surface.c \
 	swapchain.c \
 	texture.c \
+  txc_compress_dxtn.c \
+  txc_fetch_dxtn.c \
 	utils.c \
 	vertexdeclaration.c \
 	view.c \
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
index 797c204..59a335f 100644
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -706,7 +706,11 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
+#if defined(STAGING_CSMT)
+        UINT rt_height = state->fb.render_targets[0]->height;
+#else  /* STAGING_CSMT */
         UINT rt_height = state->fb->render_targets[0]->height;
+#endif /* STAGING_CSMT */
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constantsF(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -4711,7 +4715,11 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
+#if defined(STAGING_CSMT)
+            UINT rt_height = state->fb.render_targets[0]->height;
+#else  /* STAGING_CSMT */
             UINT rt_height = state->fb->render_targets[0]->height;
+#endif /* STAGING_CSMT */
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -5992,6 +6000,7 @@ static void tex_bumpenvlum_arbfp(struct wined3d_context *context,
     param[1] = *((float *)&state->texture_states[stage][WINED3D_TSS_BUMPENV_LOFFSET]);
     param[2] = 0.0f;
     param[3] = 0.0f;
+  TRACE("LumOffset=%d, stage=%d\n", param[1], stage);
 
     GL_EXTCALL(glProgramEnvParameter4fvARB(GL_FRAGMENT_PROGRAM_ARB, ARB_FFP_CONST_LUMINANCE(stage), param));
     checkGLcall("glProgramEnvParameter4fvARB(GL_FRAGMENT_PROGRAM_ARB, ARB_FFP_CONST_LUMINANCE(stage), param)");
@@ -6372,6 +6381,15 @@ static GLuint gen_arbfp_ffp_shader(const struct ffp_frag_settings *settings, con
     }
     lowest_disabled_stage = stage;
 
+    /* Shader header */
+    if (!shader_buffer_init(&buffer))
+    {
+        ERR("Failed to initialize shader buffer.\n");
+        return 0;
+    }
+
+    shader_addline(&buffer, "!!ARBfp1.0\n");
+
     switch (settings->fog)
     {
         case WINED3D_FFP_PS_FOG_OFF:                                                         break;
@@ -7682,6 +7700,14 @@ static HRESULT arbfp_blit_set(void *blit_priv, struct wined3d_context *context,
     struct arbfp_blit_desc *desc;
     struct wined3d_color float_color_key;
 
+    
+    if (surface->container->flags & WINED3D_TEXTURE_CONVERTED)
+    {
+        gl_info->gl_ops.gl.p_glEnable(gl_texture_type);
+        checkGLcall("glEnable(gl_texture_type)");
+        return WINED3D_OK;
+    }
+
     if (is_complex_fixup(surface->resource.format->color_fixup))
         fixup = get_complex_fixup(surface->resource.format->color_fixup);
     else
@@ -7714,6 +7740,7 @@ static HRESULT arbfp_blit_set(void *blit_priv, struct wined3d_context *context,
             type.res_type = WINED3D_GL_RES_TYPE_TEX_2D;
     }
     type.fixup = fixup;
+    type.padding = 0;
     type.use_color_key = !!color_key;
 
     entry = wine_rb_get(&priv->shaders, &type);
@@ -7747,6 +7774,8 @@ static HRESULT arbfp_blit_set(void *blit_priv, struct wined3d_context *context,
         if (!shader)
         {
             FIXME("Unsupported complex fixup %#x, not setting a shader\n", fixup);
+            gl_info->gl_ops.gl.p_glEnable(gl_texture_type);
+            checkGLcall("glEnable(gl_texture_type)");
             return E_NOTIMPL;
         }
 
@@ -7795,6 +7824,18 @@ static void arbfp_blit_unset(const struct wined3d_gl_info *gl_info)
 {
     gl_info->gl_ops.gl.p_glDisable(GL_FRAGMENT_PROGRAM_ARB);
     checkGLcall("glDisable(GL_FRAGMENT_PROGRAM_ARB)");
+    gl_info->gl_ops.gl.p_glDisable(GL_TEXTURE_2D);
+    checkGLcall("glDisable(GL_TEXTURE_2D)");
+    if (gl_info->supported[ARB_TEXTURE_CUBE_MAP])
+    {
+        gl_info->gl_ops.gl.p_glDisable(GL_TEXTURE_CUBE_MAP_ARB);
+        checkGLcall("glDisable(GL_TEXTURE_CUBE_MAP_ARB)");
+    }
+    if (gl_info->supported[ARB_TEXTURE_RECTANGLE])
+    {
+        gl_info->gl_ops.gl.p_glDisable(GL_TEXTURE_RECTANGLE_ARB);
+        checkGLcall("glDisable(GL_TEXTURE_RECTANGLE_ARB)");
+    }
 }
 
 static BOOL arbfp_blit_supported(const struct wined3d_gl_info *gl_info,
@@ -7884,7 +7925,11 @@ static void arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
 
     /* Now load the surface */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+#if defined(STAGING_CSMT)
+            && (src_surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
+#else  /* STAGING_CSMT */
             && (src_surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
+#endif /* STAGING_CSMT */
             == WINED3D_LOCATION_DRAWABLE
             && !wined3d_resource_is_offscreen(&src_surface->container->resource))
     {
@@ -7914,6 +7959,19 @@ static void arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        context->gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
+            || (dst_surface->container->swapchain
+            && (dst_surface->container->swapchain->front_buffer == dst_surface->container)))
+        context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
+
+    context_release(context);
+
+    wined3d_resource_validate_location(&dst_surface->resource, dst_surface->container->resource.draw_binding);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->container->resource.draw_binding);
+#else  /* STAGING_CSMT */
     if (wined3d_settings.strict_draw_ordering
             || (dst_surface->container->swapchain
             && (dst_surface->container->swapchain->front_buffer == dst_surface->container)))
@@ -7923,6 +7981,7 @@ static void arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
 
     surface_validate_location(dst_surface, dst_surface->container->resource.draw_binding);
     surface_invalidate_location(dst_surface, ~dst_surface->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT arbfp_blit_color_fill(struct wined3d_device *device, struct wined3d_surface *dst_surface,
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index f2a22b0..45436a2 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -32,6 +32,18 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_CREATEBO     0x02    /* Create a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
+#if defined(STAGING_CSMT)
+#define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
+#define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
+
+#define VB_MAXDECLCHANGES     100     /* After that number of decl changes we stop converting */
+#define VB_RESETDECLCHANGE    1000    /* Reset the decl changecount after that number of draws */
+#define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
+#define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
+
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
+#else  /* STAGING_CSMT */
 #define WINED3D_BUFFER_FLUSH        0x08    /* Manual unmap flushing. */
 #define WINED3D_BUFFER_DISCARD      0x10    /* A DISCARD lock has occurred since the last preload. */
 #define WINED3D_BUFFER_SYNC         0x20    /* There has been at least one synchronized map since the last preload. */
@@ -43,6 +55,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
 static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
+#endif /* STAGING_CSMT */
 {
     if (!offset && !size)
         goto invalidate_all;
@@ -118,7 +131,11 @@ static void delete_gl_buffer(struct wined3d_buffer *This, const struct wined3d_g
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
 static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -167,8 +184,10 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
         {
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE)");
+#if !defined(STAGING_CSMT)
             This->flags |= WINED3D_BUFFER_FLUSH;
 
+#endif /* STAGING_CSMT */
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE)");
             This->flags |= WINED3D_BUFFER_APPLESYNC;
@@ -194,7 +213,14 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
     if (This->flags & WINED3D_BUFFER_DOUBLEBUFFER)
         buffer_invalidate_bo_range(This, 0, 0);
     else
+#if defined(STAGING_CSMT)
+    {
+        wined3d_resource_free_sysmem(&This->resource);
+        This->resource.map_heap_memory = NULL;
+    }
+#else  /* STAGING_CSMT */
         wined3d_resource_free_sysmem(&This->resource);
+#endif /* STAGING_CSMT */
 
     return;
 
@@ -423,6 +449,16 @@ static inline void fixup_d3dcolor(DWORD *dst_color)
 {
     DWORD src_color = *dst_color;
 
+#if defined(STAGING_CSMT)
+    /* Color conversion like in draw_strided_slow. watch out for little endianity
+     * If we want that stuff to work on big endian machines too we have to consider more things
+     *
+     * 0xff000000: Alpha mask
+     * 0x00ff0000: Blue mask
+     * 0x0000ff00: Green mask
+     * 0x000000ff: Red mask
+     */
+#else  /* STAGING_CSMT */
     /* Color conversion like in drawStridedSlow. watch out for little endianity
      * If we want that stuff to work on big endian machines too we have to consider more things
      *
@@ -431,6 +467,7 @@ static inline void fixup_d3dcolor(DWORD *dst_color)
      * 0x0000ff00: Green mask
      * 0x000000ff: Red mask
      */
+#endif /* STAGING_CSMT */
     *dst_color = 0;
     *dst_color |= (src_color & 0xff00ff00);         /* Alpha Green */
     *dst_color |= (src_color & 0x00ff0000) >> 16;   /* Red */
@@ -457,7 +494,12 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
+#if defined(STAGING_CSMT)
+        if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+                && buffer->flags & WINED3D_BUFFER_CREATEBO)
+#else  /* STAGING_CSMT */
         if ((buffer->flags & WINED3D_BUFFER_CREATEBO) && !buffer->resource.map_count)
+#endif /* STAGING_CSMT */
         {
             buffer_create_buffer_object(buffer, context);
             buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
@@ -496,6 +538,9 @@ BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *con
 
     if (!wined3d_resource_allocate_sysmem(&This->resource))
         ERR("Failed to allocate system memory.\n");
+#if defined(STAGING_CSMT)
+    This->resource.heap_memory = This->resource.map_heap_memory;
+#endif /* STAGING_CSMT */
 
     if (This->buffer_type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
         context_invalidate_state(context, STATE_INDEXBUFFER);
@@ -543,6 +588,40 @@ static void buffer_unload(struct wined3d_resource *resource)
     resource_unload(resource);
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer)
+{
+    struct wined3d_context *context;
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        delete_gl_buffer(buffer, context->gl_info);
+        context_release(context);
+
+        HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
+    }
+
+    HeapFree(GetProcessHeap(), 0, buffer->maps);
+    HeapFree(GetProcessHeap(), 0, buffer);
+}
+
+ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
+{
+    ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
+
+    TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
+
+    if (!refcount)
+    {
+        struct wined3d_device *device = buffer->resource.device;
+
+        resource_cleanup(&buffer->resource);
+
+        buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
+        wined3d_cs_emit_buffer_cleanup(device->cs, buffer);
+#else  /* STAGING_CSMT */
 ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
 {
     ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
@@ -565,6 +644,7 @@ ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
         buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
         HeapFree(GetProcessHeap(), 0, buffer->maps);
         HeapFree(GetProcessHeap(), 0, buffer);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -649,6 +729,31 @@ drop_query:
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
+#if defined(STAGING_CSMT)
+    UINT start = 0, len = 0;
+
+    /* This potentially invalidates the element array buffer binding, but the
+     * caller always takes care of this. */
+    GL_EXTCALL(glBindBuffer(This->buffer_type_hint, This->buffer_object));
+    checkGLcall("glBindBuffer");
+
+    if (flags & WINED3D_BUFFER_DISCARD)
+    {
+        GL_EXTCALL(glBufferData(This->buffer_type_hint, This->resource.size, NULL, GL_STREAM_DRAW));
+        checkGLcall("glBufferData");
+    }
+    else if (flags & WINED3D_BUFFER_SYNC && This->flags & WINED3D_BUFFER_APPLESYNC)
+    {
+        /* OSX doesn't do non-blocking asynchonous glBufferSubData like Linux drivers do, so we want to set
+         * GL_BUFFER_SERIALIZED_MODIFY_APPLE to GL_FALSE. Unfortunately ARB_sync and APPLE_fence are pretty
+         * slow on OSX. Putting the buffer back into synchronized mode for future maps is a lot faster.
+         * (GeForce 650M, Mavericks). The difference between ARB_sync and normal buffer operation is small
+         * in the glMapBuffer codepath without CSMT. */
+        glFinish();
+        GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE));
+        checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE)");
+        This->flags &= ~WINED3D_BUFFER_APPLESYNC;
+#else  /* STAGING_CSMT */
     BYTE *map;
     UINT start = 0, len = 0;
 
@@ -686,6 +791,7 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
     {
         ERR("Failed to map opengl buffer\n");
         return;
+#endif /* STAGING_CSMT */
     }
 
     while (This->modified_areas)
@@ -694,6 +800,14 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
+#if defined(STAGING_CSMT)
+        GL_EXTCALL(glBufferSubData(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
+        checkGLcall("glBufferSubData");
+    }
+}
+
+static void buffer_mark_used(struct wined3d_buffer *buffer)
+#else  /* STAGING_CSMT */
         memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
 
         if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
@@ -712,6 +826,7 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
 }
 
 void buffer_mark_used(struct wined3d_buffer *buffer)
+#endif /* STAGING_CSMT */
 {
     buffer->flags &= ~(WINED3D_BUFFER_SYNC | WINED3D_BUFFER_DISCARD);
 }
@@ -730,12 +845,14 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
     TRACE("buffer %p.\n", buffer);
 
+#if !defined(STAGING_CSMT)
     if (buffer->resource.map_count)
     {
         WARN("Buffer is mapped, skipping preload.\n");
         return;
     }
 
+#endif /* STAGING_CSMT */
     buffer_mark_used(buffer);
 
     if (!buffer->buffer_object)
@@ -924,10 +1041,22 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+    wined3d_cs_emit_buffer_preload(device->cs, buffer);
+#else  /* STAGING_CSMT */
     struct wined3d_context *context;
     context = context_acquire(buffer->resource.device, NULL);
     buffer_internal_preload(buffer, context, NULL);
     context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -941,9 +1070,36 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
 {
     LONG count;
     BYTE *base;
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = buffer->resource.device;
+    struct wined3d_context *context;
 
     TRACE("buffer %p, offset %u, size %u, data %p, flags %#x\n", buffer, offset, size, data, flags);
 
+    /* FIXME: There is a race condition with the same code in
+     * buffer_internal_preload and buffer_get_memory.
+     *
+     * This deals with a race condition concering buffer creation and buffer maps.
+     * If a VBO is created by the worker thread while the buffer is mapped, outdated
+     * data may be uploaded, and the BO range is not properly invaliated. Keep in
+     * mind that a broken application might draw from a buffer before mapping it.
+     *
+     * Don't try to solve this by going back to always invalidating changed areas.
+     * This won't work if we ever want to support glMapBufferRange mapping with
+     * GL_buffer_storage in the CS.
+     *
+     * Also keep in mind that UnLoad can destroy the VBO, so simply creating it
+     * on buffer creation won't work either. */
+    if (buffer->flags & WINED3D_BUFFER_CREATEBO)
+    {
+        wined3d_cs_emit_create_vbo(device->cs, buffer);
+        buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
+    }
+#else  /* STAGING_CSMT */
+
+    TRACE("buffer %p, offset %u, size %u, data %p, flags %#x\n", buffer, offset, size, data, flags);
+#endif /* STAGING_CSMT */
+
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
      * fill rate test seems to depend on this. When we map a buffer with
@@ -951,7 +1107,11 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
+#if defined(STAGING_CSMT)
+    if (buffer->ignore_discard)
+#else  /* STAGING_CSMT */
     if (buffer->flags & WINED3D_BUFFER_DISCARD)
+#endif /* STAGING_CSMT */
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -962,6 +1122,25 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
+#if defined(STAGING_CSMT)
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
+        else if (!(flags & WINED3D_MAP_READONLY))
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
+
+        if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
+        {
+            if (count == 1)
+            {
+                struct wined3d_device *device = buffer->resource.device;
+                const struct wined3d_gl_info *gl_info;
+
+                if (wined3d_settings.cs_multithreaded)
+                {
+                    FIXME("waiting for cs\n");
+                    wined3d_cs_emit_glfinish(device->cs);
+                    device->cs->ops->finish(device->cs);
+                }
+#else  /* STAGING_CSMT */
             buffer_invalidate_bo_range(buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
             buffer_invalidate_bo_range(buffer, offset, size);
@@ -973,6 +1152,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                 struct wined3d_device *device = buffer->resource.device;
                 struct wined3d_context *context;
                 const struct wined3d_gl_info *gl_info;
+#endif /* STAGING_CSMT */
 
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
@@ -1023,6 +1203,44 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                         buffer_get_sysmem(buffer, context);
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
+#if defined(STAGING_CSMT)
+                }
+                context_release(context);
+            }
+        }
+        else if(!wined3d_settings.cs_multithreaded)
+        {
+            if (flags & WINED3D_MAP_DISCARD)
+            {
+                buffer->flags |= WINED3D_BUFFER_DISCARD;
+                buffer->ignore_discard = TRUE;
+            }
+            else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+                buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
+    }
+
+    if (wined3d_settings.cs_multithreaded && count == 1)
+    {
+        BOOL swvp = device->create_parms.flags & WINED3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        if (flags & WINED3D_MAP_DISCARD && !swvp)
+        {
+            buffer->ignore_discard = TRUE;
+            wined3d_resource_allocate_sysmem(&buffer->resource);
+            wined3d_cs_emit_buffer_swap_mem(device->cs, buffer, buffer->resource.map_heap_memory);
+        }
+        else if(!(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_READONLY)) && !buffer->ignore_discard)
+        {
+            wined3d_resource_wait_fence(&buffer->resource);
+            /* Writing to the (otherwise worker thread controlled)
+             * flags field is OK here since the wait_fence call made
+             * sure the buffer is idle. */
+            buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
+    }
+
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.map_heap_memory;
+#else  /* STAGING_CSMT */
                     buffer->map_ptr = NULL;
                 }
                 context_release(context);
@@ -1036,6 +1254,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
     }
 
     base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+#endif /* STAGING_CSMT */
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1089,7 +1308,11 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
                 checkGLcall("glFlushMappedBufferRange");
             }
         }
+#if defined(STAGING_CSMT)
+        else if (buffer->flags & WINED3D_BUFFER_APPLESYNC)
+#else  /* STAGING_CSMT */
         else if (buffer->flags & WINED3D_BUFFER_FLUSH)
+#endif /* STAGING_CSMT */
         {
             for (i = 0; i < buffer->modified_areas; ++i)
             {
@@ -1100,6 +1323,16 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
         }
 
         GL_EXTCALL(glUnmapBuffer(buffer->buffer_type_hint));
+#if defined(STAGING_CSMT)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
+            gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
+        context_release(context);
+
+        buffer_clear_dirty_areas(buffer);
+        buffer->map_ptr = NULL;
+#else  /* STAGING_CSMT */
         if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
         context_release(context);
@@ -1110,6 +1343,7 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
     else if (buffer->flags & WINED3D_BUFFER_HASDESC)
     {
         wined3d_buffer_preload(buffer);
+#endif /* STAGING_CSMT */
     }
 }
 
@@ -1123,11 +1357,33 @@ static ULONG buffer_resource_decref(struct wined3d_resource *resource)
     return wined3d_buffer_decref(buffer_from_resource(resource));
 }
 
+#if defined(STAGING_CSMT)
+static void wined3d_buffer_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    ERR("Not yet implemented.\n");
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_buffer_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Not yet implemented.\n");
+}
+
+static const struct wined3d_resource_ops buffer_resource_ops =
+{
+    buffer_resource_incref,
+    buffer_resource_decref,
+    buffer_unload,
+    wined3d_buffer_location_invalidated,
+    wined3d_buffer_load_location,
+#else  /* STAGING_CSMT */
 static const struct wined3d_resource_ops buffer_resource_ops =
 {
     buffer_resource_incref,
     buffer_resource_decref,
     buffer_unload,
+#endif /* STAGING_CSMT */
 };
 
 static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device *device,
@@ -1154,6 +1410,9 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+#if defined(STAGING_CSMT)
+    buffer->ignore_discard = TRUE;
+#endif /* STAGING_CSMT */
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.heap_memory, buffer);
@@ -1169,6 +1428,15 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
 
     dynamic_buffer_ok = gl_info->supported[APPLE_FLUSH_BUFFER_RANGE] || gl_info->supported[ARB_MAP_BUFFER_RANGE];
 
+#if defined(STAGING_CSMT)
+    /* Observations show that draw_strided_slow is faster on dynamic VBs than converting +
+     * drawStridedFast (half-life 2 and others).
+     *
+     * Basically converting the vertices in the buffer is quite expensive, and observations
+     * show that draw_strided_slow is faster than converting + uploading + drawStridedFast.
+     * Therefore do not create a VBO for WINED3DUSAGE_DYNAMIC buffers.
+     */
+#else  /* STAGING_CSMT */
     /* Observations show that drawStridedSlow is faster on dynamic VBs than converting +
      * drawStridedFast (half-life 2 and others).
      *
@@ -1176,6 +1444,7 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
      * show that drawStridedSlow is faster than converting + uploading + drawStridedFast.
      * Therefore do not create a VBO for WINED3DUSAGE_DYNAMIC buffers.
      */
+#endif /* STAGING_CSMT */
     if (!gl_info->supported[ARB_VERTEX_BUFFER_OBJECT])
     {
         TRACE("Not creating a vbo because GL_ARB_vertex_buffer is not supported\n");
@@ -1221,6 +1490,11 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
     }
     buffer->maps_size = 1;
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1326,3 +1600,12 @@ HRESULT CDECL wined3d_buffer_create_ib(struct wined3d_device *device, UINT size,
 
     return WINED3D_OK;
 }
+#if defined(STAGING_CSMT)
+
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
+{
+    wined3d_resource_free_sysmem(&buffer->resource);
+    buffer->resource.heap_memory = mem;
+    buffer->flags |= WINED3D_BUFFER_DISCARD;
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 1d7cf9c..420ebd8 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -766,47 +766,11 @@ void context_surface_update(struct wined3d_context *context, const struct wined3
     }
 }
 
-static BOOL context_restore_pixel_format(struct wined3d_context *ctx)
+static BOOL context_set_pixel_format(const struct wined3d_gl_info *gl_info, HDC dc, int format)
 {
-    const struct wined3d_gl_info *gl_info = ctx->gl_info;
-    BOOL ret = FALSE;
+    int current = GetPixelFormat(dc);
 
-    if (ctx->restore_pf && IsWindow(ctx->restore_pf_win))
-    {
-        if (ctx->gl_info->supported[WGL_WINE_PIXEL_FORMAT_PASSTHROUGH])
-        {
-            HDC dc = GetDC(ctx->restore_pf_win);
-            if (dc)
-            {
-                if (!(ret = GL_EXTCALL(wglSetPixelFormatWINE(dc, ctx->restore_pf))))
-                {
-                    ERR("wglSetPixelFormatWINE failed to restore pixel format %d on window %p.\n",
-                            ctx->restore_pf, ctx->restore_pf_win);
-                }
-                ReleaseDC(ctx->restore_pf_win, dc);
-            }
-        }
-        else
-        {
-            ERR("can't restore pixel format %d on window %p\n", ctx->restore_pf, ctx->restore_pf_win);
-        }
-    }
-
-    ctx->restore_pf = 0;
-    ctx->restore_pf_win = NULL;
-    return ret;
-}
-
-static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, BOOL private, int format)
-{
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-    int current;
-
-    if (dc == context->hdc && context->hdc_is_private && context->hdc_has_format)
-        return TRUE;
-
-    current = GetPixelFormat(dc);
-    if (current == format) goto success;
+    if (current == format) return TRUE;
 
     if (!current)
     {
@@ -817,10 +781,7 @@ static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, BO
                     format, dc, GetLastError());
             return FALSE;
         }
-
-        context->restore_pf = 0;
-        context->restore_pf_win = private ? NULL : WindowFromDC(dc);
-        goto success;
+        return TRUE;
     }
 
     /* By default WGL doesn't allow pixel format adjustments but we need it
@@ -829,25 +790,13 @@ static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, BO
      * when really needed. */
     if (gl_info->supported[WGL_WINE_PIXEL_FORMAT_PASSTHROUGH])
     {
-        HWND win;
-
         if (!GL_EXTCALL(wglSetPixelFormatWINE(dc, format)))
         {
             ERR("wglSetPixelFormatWINE failed to set pixel format %d on device context %p.\n",
                     format, dc);
             return FALSE;
         }
-
-        win = private ? NULL : WindowFromDC(dc);
-        if (win != context->restore_pf_win)
-        {
-            context_restore_pixel_format(context);
-
-            context->restore_pf = private ? 0 : current;
-            context->restore_pf_win = win;
-        }
-
-        goto success;
+        return TRUE;
     }
 
     /* OpenGL doesn't allow pixel format adjustments. Print an error and
@@ -857,11 +806,6 @@ static BOOL context_set_pixel_format(struct wined3d_context *context, HDC dc, BO
     ERR("Unable to set pixel format %d on device context %p. Already using format %d.\n",
             format, dc, current);
     return TRUE;
-
-success:
-    if (dc == context->hdc && context->hdc_is_private)
-        context->hdc_has_format = TRUE;
-    return TRUE;
 }
 
 static BOOL context_set_gl_context(struct wined3d_context *ctx)
@@ -869,7 +813,7 @@ static BOOL context_set_gl_context(struct wined3d_context *ctx)
     struct wined3d_swapchain *swapchain = ctx->swapchain;
     BOOL backup = FALSE;
 
-    if (!context_set_pixel_format(ctx, ctx->hdc, ctx->hdc_is_private, ctx->pixel_format))
+    if (!context_set_pixel_format(ctx->gl_info, ctx->hdc, ctx->pixel_format))
     {
         WARN("Failed to set pixel format %d on device context %p.\n",
                 ctx->pixel_format, ctx->hdc);
@@ -902,7 +846,7 @@ static BOOL context_set_gl_context(struct wined3d_context *ctx)
             return FALSE;
         }
 
-        if (!context_set_pixel_format(ctx, dc, TRUE, ctx->pixel_format))
+        if (!context_set_pixel_format(ctx->gl_info, dc, ctx->pixel_format))
         {
             ERR("Failed to set pixel format %d on device context %p.\n",
                     ctx->pixel_format, dc);
@@ -924,8 +868,15 @@ static BOOL context_set_gl_context(struct wined3d_context *ctx)
     return TRUE;
 }
 
-static void context_restore_gl_context(const struct wined3d_gl_info *gl_info, HDC dc, HGLRC gl_ctx)
+static void context_restore_gl_context(const struct wined3d_gl_info *gl_info, HDC dc, HGLRC gl_ctx, int pf)
 {
+    if (!context_set_pixel_format(gl_info, dc, pf))
+    {
+        ERR("Failed to restore pixel format %d on device context %p.\n", pf, dc);
+        context_set_current(NULL);
+        return;
+    }
+
     if (!wglMakeCurrent(dc, gl_ctx))
     {
         ERR("Failed to restore GL context %p on device context %p, last error %#x.\n",
@@ -946,8 +897,6 @@ static void context_update_window(struct wined3d_context *context)
         wined3d_release_dc(context->win_handle, context->hdc);
 
     context->win_handle = context->swapchain->win_handle;
-    context->hdc_is_private = FALSE;
-    context->hdc_has_format = FALSE;
     context->needs_set = 1;
     context->valid = 1;
 
@@ -968,9 +917,11 @@ static void context_destroy_gl_resources(struct wined3d_context *context)
     HGLRC restore_ctx;
     HDC restore_dc;
     unsigned int i;
+    int restore_pf;
 
     restore_ctx = wglGetCurrentContext();
     restore_dc = wglGetCurrentDC();
+    restore_pf = GetPixelFormat(restore_dc);
 
     if (restore_ctx == context->glCtx)
         restore_ctx = NULL;
@@ -1059,10 +1010,9 @@ static void context_destroy_gl_resources(struct wined3d_context *context)
     HeapFree(GetProcessHeap(), 0, context->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, context->free_event_queries);
 
-    context_restore_pixel_format(context);
     if (restore_ctx)
     {
-        context_restore_gl_context(gl_info, restore_dc, restore_ctx);
+        context_restore_gl_context(gl_info, restore_dc, restore_ctx, restore_pf);
     }
     else if (wglGetCurrentContext() && !wglMakeCurrent(NULL, NULL))
     {
@@ -1158,17 +1108,12 @@ void context_release(struct wined3d_context *context)
             WARN("Context %p is not the current context.\n", context);
     }
 
-    if (!--context->level)
+    if (!--context->level && context->restore_ctx)
     {
-        if (context_restore_pixel_format(context))
-            context->needs_set = 1;
-        if (context->restore_ctx)
-        {
-            TRACE("Restoring GL context %p on device context %p.\n", context->restore_ctx, context->restore_dc);
-            context_restore_gl_context(context->gl_info, context->restore_dc, context->restore_ctx);
-            context->restore_ctx = NULL;
-            context->restore_dc = NULL;
-        }
+        TRACE("Restoring GL context %p on device context %p.\n", context->restore_ctx, context->restore_dc);
+        context_restore_gl_context(context->gl_info, context->restore_dc, context->restore_ctx, context->restore_pf);
+        context->restore_ctx = NULL;
+        context->restore_dc = NULL;
     }
 }
 
@@ -1187,11 +1132,9 @@ static void context_enter(struct wined3d_context *context)
                     current_gl, wglGetCurrentDC());
             context->restore_ctx = current_gl;
             context->restore_dc = wglGetCurrentDC();
+            context->restore_pf = GetPixelFormat(context->restore_dc);
             context->needs_set = 1;
         }
-        else if (!context->needs_set && !(context->hdc_is_private && context->hdc_has_format)
-                    && context->pixel_format != GetPixelFormat(context->hdc))
-            context->needs_set = 1;
     }
 }
 
@@ -1399,7 +1342,6 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     int swap_interval;
     DWORD state;
     HDC hdc;
-    BOOL hdc_is_private = FALSE;
 
     TRACE("swapchain %p, target %p, window %p.\n", swapchain, target, swapchain->win_handle);
 
@@ -1453,6 +1395,16 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+#if defined(STAGING_CSMT)
+    ret->current_fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*ret->current_fb.render_targets) * gl_info->limits.buffers);
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!ret->current_fb.render_targets)
+        goto out;
+    if (device->context_count)
+        ret->offscreenBuffer = device->contexts[0]->offscreenBuffer;
+
+#endif /* STAGING_CSMT */
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -1472,9 +1424,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     {
         WARN("Failed to retrieve device context, trying swapchain backup.\n");
 
-        if ((hdc = swapchain_get_backup_dc(swapchain)))
-            hdc_is_private = TRUE;
-        else
+        if (!(hdc = swapchain_get_backup_dc(swapchain)))
         {
             ERR("Failed to retrieve a device context.\n");
             goto out;
@@ -1523,9 +1473,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
 
     context_enter(ret);
 
-    ret->gl_info = gl_info;
-
-    if (!context_set_pixel_format(ret, hdc, hdc_is_private, pixel_format))
+    if (!context_set_pixel_format(gl_info, hdc, pixel_format))
     {
         ERR("Failed to set pixel format %d on device context %p.\n", pixel_format, hdc);
         context_release(ret);
@@ -1580,6 +1528,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+    ret->gl_info = gl_info;
     ret->d3d_info = &device->adapter->d3d_info;
     ret->state_table = device->StateTable;
 
@@ -1602,8 +1551,6 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
     ret->glCtx = ctx;
     ret->win_handle = swapchain->win_handle;
     ret->hdc = hdc;
-    ret->hdc_is_private = hdc_is_private;
-    ret->hdc_has_format = TRUE;
     ret->pixel_format = pixel_format;
     ret->needs_set = 1;
 
@@ -1770,6 +1717,9 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
 out:
     device->shader_backend->shader_free_context_data(ret);
     device->adapter->fragment_pipe->free_context_data(ret);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_timestamp_queries);
@@ -1804,6 +1754,9 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
 
     device->shader_backend->shader_free_context_data(context);
     device->adapter->fragment_pipe->free_context_data(context);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2208,7 +2161,11 @@ static BOOL match_depth_stencil_format(const struct wined3d_format *existing,
     return TRUE;
 }
 
+#if defined(STAGING_CSMT)
+/* Context activation is done by the caller. */
+#else  /* STAGING_CSMT */
 /* The caller provides a context */
+#endif /* STAGING_CSMT */
 static void context_validate_onscreen_formats(struct wined3d_context *context,
         const struct wined3d_rendertarget_view *depth_stencil)
 {
@@ -2224,6 +2181,22 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
+#if defined(STAGING_CSMT)
+    wined3d_resource_load_location(&context->current_rt->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+    swapchain->render_to_fbo = TRUE;
+    swapchain_update_draw_bindings(swapchain);
+    context_set_render_offscreen(context, TRUE);
+}
+
+static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_context *context, const struct wined3d_surface *rt)
+{
+    if (!rt || rt->resource.format->id == WINED3DFMT_NULL)
+        return 0;
+    else if (rt->container->swapchain)
+        return context_generate_rt_mask_from_surface(rt);
+    else
+        return context_generate_rt_mask(context->offscreenBuffer);
+#else  /* STAGING_CSMT */
     surface_load_location(context->current_rt, WINED3D_LOCATION_TEXTURE_RGB);
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
@@ -2238,6 +2211,7 @@ static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_device *device
         return context_generate_rt_mask_from_surface(rt);
     else
         return context_generate_rt_mask(device->offscreenBuffer);
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -2269,7 +2243,11 @@ void context_apply_blit_state(struct wined3d_context *context, const struct wine
     }
     else
     {
+#if defined(STAGING_CSMT)
+        rt_mask = context_generate_rt_mask_no_fbo(context, rt);
+#else  /* STAGING_CSMT */
         rt_mask = context_generate_rt_mask_no_fbo(device, rt);
+#endif /* STAGING_CSMT */
     }
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
@@ -2315,7 +2293,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     DWORD rt_mask = 0, *cur_mask;
     UINT i;
 
+#if defined(STAGING_CSMT)
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || !wined3d_fb_equal(fb, &context->current_fb)
+#else  /* STAGING_CSMT */
     if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != &device->fb
+#endif /* STAGING_CSMT */
             || rt_count != context->gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, fb->depth_stencil))
@@ -2355,9 +2337,17 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
         }
         else
         {
+#if defined(STAGING_CSMT)
+            rt_mask = context_generate_rt_mask_no_fbo(context,
+                    rt_count ? wined3d_rendertarget_view_get_surface(rts[0]) : NULL);
+        }
+
+        wined3d_fb_copy(&context->current_fb, fb);
+#else  /* STAGING_CSMT */
             rt_mask = context_generate_rt_mask_no_fbo(device,
                     rt_count ? wined3d_rendertarget_view_get_surface(rts[0]) : NULL);
         }
+#endif /* STAGING_CSMT */
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || wined3d_resource_is_offscreen(rts[0]->resource)))
@@ -2370,7 +2360,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     }
     else
     {
+#if defined(STAGING_CSMT)
+        rt_mask = context_generate_rt_mask_no_fbo(context,
+#else  /* STAGING_CSMT */
         rt_mask = context_generate_rt_mask_no_fbo(device,
+#endif /* STAGING_CSMT */
                 rt_count ? wined3d_rendertarget_view_get_surface(rts[0]) : NULL);
     }
 
@@ -2405,6 +2399,17 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     return TRUE;
 }
 
+#if defined(STAGING_CSMT)
+static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
+{
+    struct wined3d_rendertarget_view **rts = state->fb.render_targets;
+    struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
+    DWORD rt_mask, rt_mask_bits;
+    unsigned int i;
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
+        return context_generate_rt_mask_no_fbo(context, wined3d_rendertarget_view_get_surface(rts[0]));
+#else  /* STAGING_CSMT */
 static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_device *device)
 {
     const struct wined3d_state *state = &device->state;
@@ -2415,6 +2420,7 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
         return context_generate_rt_mask_no_fbo(device, wined3d_rendertarget_view_get_surface(rts[0]));
+#endif /* STAGING_CSMT */
     else if (!context->render_offscreen)
         return context_generate_rt_mask_from_surface(wined3d_rendertarget_view_get_surface(rts[0]));
 
@@ -2437,9 +2443,14 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 /* Context activation is done by the caller. */
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_fb_state *fb = &state->fb;
+    DWORD rt_mask = find_draw_buffers_mask(context, state);
+#else  /* STAGING_CSMT */
     const struct wined3d_device *device = context->swapchain->device;
     const struct wined3d_fb_state *fb = state->fb;
     DWORD rt_mask = find_draw_buffers_mask(context, device);
+#endif /* STAGING_CSMT */
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -2468,6 +2479,10 @@ void context_state_fb(struct wined3d_context *context, const struct wined3d_stat
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+#if defined(STAGING_CSMT)
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
+#endif /* STAGING_CSMT */
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -2705,6 +2720,14 @@ static void context_update_tex_unit_map(struct wined3d_context *context, const s
 /* Context activation is done by the caller. */
 void context_state_drawbuf(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    DWORD rt_mask, *cur_mask;
+
+    if (isStateDirty(context, STATE_FRAMEBUFFER)) return;
+
+    cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
+    rt_mask = find_draw_buffers_mask(context, state);
+#else  /* STAGING_CSMT */
     const struct wined3d_device *device = context->swapchain->device;
     DWORD rt_mask, *cur_mask;
 
@@ -2712,6 +2735,7 @@ void context_state_drawbuf(struct wined3d_context *context, const struct wined3d
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
     rt_mask = find_draw_buffers_mask(context, device);
+#endif /* STAGING_CSMT */
     if (rt_mask != *cur_mask)
     {
         context_apply_draw_buffers(context, rt_mask);
@@ -2800,6 +2824,7 @@ void context_stream_info_from_declaration(struct wined3d_context *context,
         {
             if (!element->ffp_valid)
             {
+//warn:d3d:context_stream_info_from_declaration Skipping unsupported fixed function element of format WINED3DFMT_R32_FLOAT and usage WINED3D_DECL_USAGE_PSIZE.
                 WARN("Skipping unsupported fixed function element of format %s and usage %s.\n",
                         debug_d3dformat(element->format->id), debug_d3ddeclusage(element->usage));
                 stride_used = FALSE;
@@ -2912,7 +2937,11 @@ static void context_update_stream_info(struct wined3d_context *context, const st
     {
         if (state->vertex_declaration->half_float_conv_needed && !stream_info->all_vbo)
         {
+#if defined(STAGING_CSMT)
+            TRACE("Using draw_strided_slow with vertex shaders for FLOAT16 conversion.\n");
+#else  /* STAGING_CSMT */
             TRACE("Using drawStridedSlow with vertex shaders for FLOAT16 conversion.\n");
+#endif /* STAGING_CSMT */
             context->use_immediate_mode_draw = TRUE;
         }
         else
@@ -3052,11 +3081,19 @@ static void context_bind_shader_resources(struct wined3d_context *context, const
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state)
+{
+    const struct StateEntry *state_table = context->state_table;
+    const struct wined3d_fb_state *fb = &state->fb;
+#else  /* STAGING_CSMT */
 BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device)
 {
     const struct wined3d_state *state = &device->state;
     const struct StateEntry *state_table = context->state_table;
     const struct wined3d_fb_state *fb = state->fb;
+#endif /* STAGING_CSMT */
     unsigned int i, j;
     WORD map;
 
@@ -3088,8 +3125,17 @@ BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_de
         for (i = 0, map = context->stream_info.use_map; map; map >>= 1, ++i)
         {
             if (map & 1)
+#if defined(STAGING_CSMT)
+                buffer_internal_preload(state->streams[context->stream_info.elements[i].stream_idx].buffer,
+                        context, state);
+        }
+        /* PreLoad may kick buffers out of vram. */
+        if (isStateDirty(context, STATE_STREAMSRC))
+            context_update_stream_info(context, state);
+#else  /* STAGING_CSMT */
                 buffer_mark_used(state->streams[context->stream_info.elements[i].stream_idx].buffer);
         }
+#endif /* STAGING_CSMT */
     }
     if (state->index_buffer)
     {
@@ -3192,7 +3238,11 @@ static void context_setup_target(struct wined3d_context *context, struct wined3d
             if (texture->texture_srgb.name)
                 wined3d_texture_load(texture, context, TRUE);
             wined3d_texture_load(texture, context, FALSE);
+#if defined(STAGING_CSMT)
+            wined3d_resource_invalidate_location(&context->current_rt->resource, WINED3D_LOCATION_DRAWABLE);
+#else  /* STAGING_CSMT */
             surface_invalidate_location(context->current_rt, WINED3D_LOCATION_DRAWABLE);
+#endif /* STAGING_CSMT */
         }
     }
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index d66850a..ea4efcf 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -22,10 +22,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
+#if defined(STAGING_CSMT)
+enum wined3d_cs_op
+{
+    WINED3D_CS_OP_NOP,
+    WINED3D_CS_OP_SKIP,
+    WINED3D_CS_OP_FENCE,
+#else  /* STAGING_CSMT */
 #define WINED3D_INITIAL_CS_SIZE 4096
 
 enum wined3d_cs_op
 {
+#endif /* STAGING_CSMT */
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -52,6 +60,86 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_COLOR_KEY,
     WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_RESET_STATE,
+#if defined(STAGING_CSMT)
+    WINED3D_CS_OP_SET_VS_CONSTS_F,
+    WINED3D_CS_OP_SET_VS_CONSTS_B,
+    WINED3D_CS_OP_SET_VS_CONSTS_I,
+    WINED3D_CS_OP_SET_PS_CONSTS_F,
+    WINED3D_CS_OP_SET_PS_CONSTS_B,
+    WINED3D_CS_OP_SET_PS_CONSTS_I,
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_SET_BASE_VERTEX_INDEX,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_CLEAR_RTV,
+    WINED3D_CS_OP_RESOURCE_CHANGED,
+    WINED3D_CS_OP_RESOURCE_MAP,
+    WINED3D_CS_OP_RESOURCE_UNMAP,
+    WINED3D_CS_OP_BUFFER_SWAP_MEM,
+    WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE,
+    WINED3D_CS_OP_BUFFER_PRELOAD,
+    WINED3D_CS_OP_QUERY_ISSUE,
+    WINED3D_CS_OP_QUERY_DESTROY,
+    WINED3D_CS_OP_UPDATE_SURFACE,
+    WINED3D_CS_OP_TEXTURE_PRELOAD,
+    WINED3D_CS_OP_SURFACE_PRELOAD,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_EVICT_RESOURCE,
+    WINED3D_CS_OP_VIEW_DESTROY,
+    WINED3D_CS_OP_VDECL_DESTROY,
+    WINED3D_CS_OP_SHADER_CLEANUP,
+    WINED3D_CS_OP_CREATE_VBO,
+    WINED3D_CS_OP_RESOURCE_CLEANUP,
+    WINED3D_CS_OP_BUFFER_CLEANUP,
+    WINED3D_CS_OP_VOLUME_CLEANUP,
+    WINED3D_CS_OP_SURFACE_CLEANUP,
+    WINED3D_CS_OP_TEXTURE_CLEANUP,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_GETDC,
+    WINED3D_CS_OP_RELEASEDC,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    BOOL *signalled;
+};
+
+#define CS_PRESENT_SRC_RECT 1
+#define CS_PRESENT_DST_RECT 2
+#define CS_PRESENT_DIRTY_RGN 4
+struct wined3d_cs_present
+{
+    enum wined3d_cs_op opcode;
+    HWND dst_window_override;
+    struct wined3d_swapchain *swapchain;
+    RECT src_rect;
+    RECT dst_rect;
+    RGNDATA dirty_region;
+    DWORD flags;
+    DWORD set_data;
+};
+
+struct wined3d_cs_clear
+{
+    enum wined3d_cs_op opcode;
+    DWORD rect_count;
+    DWORD flags;
+    struct wined3d_color color;
+    float depth;
+    DWORD stencil;
+    RECT rects[1];
+#else  /* STAGING_CSMT */
 };
 
 struct wined3d_cs_present
@@ -74,6 +162,7 @@ struct wined3d_cs_clear
     const struct wined3d_color *color;
     float depth;
     DWORD stencil;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_draw
@@ -96,6 +185,15 @@ struct wined3d_cs_set_predication
 struct wined3d_cs_set_viewport
 {
     enum wined3d_cs_op opcode;
+#if defined(STAGING_CSMT)
+    struct wined3d_viewport viewport;
+};
+
+struct wined3d_cs_set_scissor_rect
+{
+    enum wined3d_cs_op opcode;
+    RECT rect;
+#else  /* STAGING_CSMT */
     const struct wined3d_viewport *viewport;
 };
 
@@ -103,6 +201,7 @@ struct wined3d_cs_set_scissor_rect
 {
     enum wined3d_cs_op opcode;
     const RECT *rect;
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_cs_set_rendertarget_view
@@ -180,77 +279,2548 @@ struct wined3d_cs_set_color_key
     struct wined3d_color_key color_key;
 };
 
-struct wined3d_cs_set_shader_resource_view
+struct wined3d_cs_set_shader_resource_view
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_shader_type type;
+    UINT view_idx;
+    struct wined3d_shader_resource_view *view;
+};
+
+struct wined3d_cs_set_sampler
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_shader_type type;
+    UINT sampler_idx;
+    struct wined3d_sampler *sampler;
+};
+
+struct wined3d_cs_set_shader
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_shader_type type;
+    struct wined3d_shader *shader;
+};
+
+struct wined3d_cs_set_render_state
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_render_state state;
+    DWORD value;
+};
+
+struct wined3d_cs_set_texture_state
+{
+    enum wined3d_cs_op opcode;
+    UINT stage;
+    enum wined3d_texture_stage_state state;
+    DWORD value;
+};
+
+struct wined3d_cs_set_sampler_state
+{
+    enum wined3d_cs_op opcode;
+    UINT sampler_idx;
+    enum wined3d_sampler_state state;
+    DWORD value;
+};
+
+struct wined3d_cs_set_transform
+{
+    enum wined3d_cs_op opcode;
+    enum wined3d_transform_state state;
+#if defined(STAGING_CSMT)
+    struct wined3d_matrix matrix;
+};
+
+struct wined3d_cs_set_clip_plane
+{
+    enum wined3d_cs_op opcode;
+    UINT plane_idx;
+    struct wined3d_vec4 plane;
+};
+
+struct wined3d_cs_set_material
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_material material;
+#else  /* STAGING_CSMT */
+    const struct wined3d_matrix *matrix;
+};
+
+struct wined3d_cs_set_clip_plane
+{
+    enum wined3d_cs_op opcode;
+    UINT plane_idx;
+    const struct wined3d_vec4 *plane;
+};
+
+struct wined3d_cs_set_material
+{
+    enum wined3d_cs_op opcode;
+    const struct wined3d_material *material;
+#endif /* STAGING_CSMT */
+};
+
+struct wined3d_cs_reset_state
+{
+    enum wined3d_cs_op opcode;
+};
+
+#if defined(STAGING_CSMT)
+struct wined3d_cs_set_consts_f
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4f_count;
+    float constants[4];
+};
+
+struct wined3d_cs_set_consts_b
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, bool_count;
+    BOOL constants[1];
+};
+
+struct wined3d_cs_set_consts_i
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4i_count;
+    int constants[4];
+};
+
+struct wined3d_cs_finish
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_set_base_vertex_index
+{
+    enum wined3d_cs_op opcode;
+    UINT base_vertex_index;
+};
+
+struct wined3d_cs_set_primitive_type
+{
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
+
+struct wined3d_cs_set_light
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
+
+struct wined3d_cs_set_light_enable
+{
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
+
+struct wined3d_cs_blt
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    WINEDDBLTFX fx;
+    enum wined3d_texture_filter_type filter;
+};
+
+struct wined3d_cs_clear_rtv
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+    RECT rect;
+    struct wined3d_color color;
+};
+
+struct wined3d_cs_resource_map
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    DWORD flags;
+    void **mem;
+};
+
+struct wined3d_cs_resource_unmap
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
+
+struct wined3d_cs_resource_changed
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    struct wined3d_gl_bo *swap_buffer;
+    void *swap_heap_memory;
+};
+
+struct wined3d_cs_buffer_swap_mem
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    BYTE *mem;
+};
+
+struct wined3d_cs_buffer_invalidate_bo_range
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    UINT offset, size;
+};
+
+struct wined3d_cs_skip
+{
+    enum wined3d_cs_op opcode;
+    DWORD size;
+};
+
+struct wined3d_cs_query_issue
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+};
+
+struct wined3d_cs_query_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+};
+
+struct wined3d_cs_update_surface
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *src, *dst;
+    RECT src_rect;
+    POINT dst_point;
+    BOOL has_src_rect, has_dst_point;
+};
+
+struct wined3d_cs_texture_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
+
+struct wined3d_cs_surface_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
+
+struct wined3d_cs_update_texture
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
+
+struct wined3d_cs_evict_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
+
+struct wined3d_cs_buffer_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
+
+struct wined3d_cs_view_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+};
+
+struct wined3d_cs_vertex_declaration_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_vertex_declaration *declaration;
+};
+
+struct wined3d_cs_shader_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_shader *shader;
+};
+
+struct wined3d_cs_create_vbo
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
+
+struct wined3d_cs_resource_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
+
+struct wined3d_cs_buffer_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
+
+struct wined3d_cs_volume_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_volume *volume;
+};
+
+struct wined3d_cs_surface_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
+
+struct wined3d_cs_texture_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
+
+struct wined3d_cs_create_dummy_textures
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *ret;
+};
+
+struct wined3d_cs_delete_gl_contexts
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
+
+struct wined3d_cs_getdc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
+
+struct wined3d_cs_releasedc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
+
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->queue.head, new_val);
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static void wined3d_cs_mt_submit_prio(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->prio_queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->prio_queue.head, new_val);
+
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
+
+static UINT wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
+{
+    return sizeof(enum wined3d_cs_op);
+}
+
+static UINT wined3d_cs_exec_skip(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_skip *op = data;
+
+    return op->size;
+}
+
+static UINT wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_fence *op = data;
+
+    InterlockedExchange(op->signalled, TRUE);
+
+    return sizeof(*op);
+}
+
+static void wined3d_cs_emit_fence(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_emit_fence_prio(struct wined3d_cs *cs, BOOL *signalled)
+{
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_present *op = data;
+    struct wined3d_swapchain *swapchain;
+    const RECT *src_rect = op->set_data & CS_PRESENT_SRC_RECT ? &op->src_rect : NULL;
+    const RECT *dst_rect = op->set_data & CS_PRESENT_DST_RECT ? &op->dst_rect : NULL;
+    const RGNDATA *dirty_region = op->set_data & CS_PRESENT_DIRTY_RGN ? &op->dirty_region : NULL;
+    unsigned int i;
+
+    swapchain = op->swapchain;
+    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+
+    swapchain->swapchain_ops->swapchain_present(swapchain,
+            src_rect, dst_rect, dirty_region, op->flags,
+            wined3d_rendertarget_view_get_surface(cs->state.fb.depth_stencil));
+
+    InterlockedDecrement(&cs->pending_presents);
+
+    wined3d_resource_dec_fence(&swapchain->front_buffer->resource);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_resource_dec_fence(&swapchain->back_buffers[i]->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
+        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
+        const RGNDATA *dirty_region, DWORD flags)
+{
+    struct wined3d_cs_present *op;
+    LONG pending;
+    unsigned int i;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_PRESENT;
+    op->dst_window_override = dst_window_override;
+    op->swapchain = swapchain;
+    op->set_data = 0;
+    if (src_rect)
+    {
+        op->src_rect = *src_rect;
+        op->set_data |= CS_PRESENT_SRC_RECT;
+    }
+    if (dst_rect)
+    {
+        op->dst_rect = *dst_rect;
+        op->set_data |= CS_PRESENT_DST_RECT;
+    }
+    if (dirty_region)
+    {
+        op->dirty_region = *dirty_region;
+        op->set_data = CS_PRESENT_DIRTY_RGN;
+    }
+    op->flags = flags;
+
+    wined3d_resource_inc_fence(&swapchain->front_buffer->resource);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_resource_inc_fence(&swapchain->back_buffers[i]->resource);
+
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs, sizeof(*op));
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear *op = data;
+    struct wined3d_device *device;
+    RECT draw_rect;
+    unsigned int extra_rects = op->rect_count ? op->rect_count - 1 : 0, i;
+
+    device = cs->device;
+    wined3d_get_draw_rect(&cs->state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &cs->state.fb, op->rect_count, op->rect_count ? op->rects : NULL, &draw_rect, op->flags,
+            &op->color, op->depth, op->stencil);
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+        {
+            if (cs->state.fb.render_targets[i])
+                wined3d_resource_dec_fence(cs->state.fb.render_targets[i]->resource);
+        }
+    }
+    if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_resource_dec_fence(cs->state.fb.depth_stencil->resource);
+
+    return sizeof(*op) + sizeof(*op->rects) * extra_rects;
+}
+
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+{
+    struct wined3d_cs_clear *op;
+    unsigned int extra_rects = rect_count ? rect_count - 1 : 0, i;
+    size_t size = sizeof(*op) + sizeof(*op->rects) * extra_rects;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, size);
+    op->opcode = WINED3D_CS_OP_CLEAR;
+    op->rect_count = rect_count;
+    if (rect_count)
+        memcpy(op->rects, rects, rect_count * sizeof(*rects));
+    op->flags = flags;
+    op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+
+    if (flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+        {
+            if (state->fb.render_targets[i])
+                wined3d_resource_inc_fence(state->fb.render_targets[i]->resource);
+        }
+    }
+    if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_resource_inc_fence(state->fb.depth_stencil->resource);
+
+    cs->ops->submit(cs, size);
+}
+
+static inline BOOL wined3d_cs_colorwrite_enabled(const struct wined3d_state *state, unsigned int i)
+{
+    switch (i)
+    {
+        case 0:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE];
+        case 1:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE1];
+        case 2:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE2];
+        case 3:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE3];
+        default:
+            ERR("Unexpected color target %u.\n", i);
+            return TRUE;
+    }
+}
+
+static inline BOOL wined3d_cs_depth_stencil_enabled(const struct wined3d_state *state)
+{
+    return state->render_states[WINED3D_RS_ZENABLE]
+            || state->render_states[WINED3D_RS_STENCILENABLE];
+}
+
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_draw *op = data;
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+    unsigned int i;
+
+    if (op->indexed && !gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
+    {
+        if (cs->state.load_base_vertex_index != cs->state.base_vertex_index)
+        {
+            cs->state.load_base_vertex_index = cs->state.base_vertex_index;
+            device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+        }
+    }
+    else if (cs->state.load_base_vertex_index)
+    {
+        cs->state.load_base_vertex_index = 0;
+        device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+    }
+
+    draw_primitive(cs->device, &cs->state, op->start_idx, op->index_count,
+            op->start_instance, op->instance_count, op->indexed);
+
+    if (op->indexed)
+        wined3d_resource_dec_fence(&cs->state.index_buffer->resource);
+    for (i = 0; i < sizeof(cs->state.streams) / sizeof(*cs->state.streams); i++)
+    {
+        if (cs->state.streams[i].buffer)
+            wined3d_resource_dec_fence(&cs->state.streams[i].buffer->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.textures) / sizeof(*cs->state.textures); i++)
+    {
+        if (cs->state.textures[i])
+            wined3d_resource_dec_fence(&cs->state.textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+    {
+        if (cs->state.fb.render_targets[i] && wined3d_cs_colorwrite_enabled(&cs->state, i))
+            wined3d_resource_dec_fence(cs->state.fb.render_targets[i]->resource);
+    }
+    if (cs->state.fb.depth_stencil && wined3d_cs_depth_stencil_enabled(&cs->state))
+        wined3d_resource_dec_fence(cs->state.fb.depth_stencil->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
+        UINT start_instance, UINT instance_count, BOOL indexed)
+{
+    struct wined3d_cs_draw *op;
+    unsigned int i;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DRAW;
+    op->start_idx = start_idx;
+    op->index_count = index_count;
+    op->start_instance = start_instance;
+    op->instance_count = instance_count;
+    op->indexed = indexed;
+
+    if (indexed)
+    {
+        wined3d_resource_inc_fence(&state->index_buffer->resource);
+        state->index_buffer->ignore_discard = FALSE;
+    }
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+    {
+        if (state->streams[i].buffer)
+        {
+            wined3d_resource_inc_fence(&state->streams[i].buffer->resource);
+            state->streams[i].buffer->ignore_discard = FALSE;
+        }
+    }
+    for (i = 0; i < sizeof(state->textures) / sizeof(*state->textures); i++)
+    {
+        if (state->textures[i])
+            wined3d_resource_inc_fence(&state->textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+    {
+        if (state->fb.render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
+            wined3d_resource_inc_fence(state->fb.render_targets[i]->resource);
+    }
+    if (state->fb.depth_stencil && wined3d_cs_depth_stencil_enabled(state))
+        wined3d_resource_inc_fence(state->fb.depth_stencil->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_predication *op = data;
+
+    cs->state.predicate = op->predicate;
+    cs->state.predicate_value = op->value;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
+{
+    struct wined3d_cs_set_predication *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PREDICATION;
+    op->predicate = predicate;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_viewport *op = data;
+    struct wined3d_device *device = cs->device;
+
+    cs->state.viewport = op->viewport;
+    device_invalidate_state(device, STATE_VIEWPORT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+{
+    struct wined3d_cs_set_viewport *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
+    op->viewport = *viewport;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_scissor_rect *op = data;
+
+    cs->state.scissor_rect = op->rect;
+    device_invalidate_state(cs->device, STATE_SCISSORRECT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+{
+    struct wined3d_cs_set_scissor_rect *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
+    op->rect = *rect;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_rendertarget_view *op = data;
+
+    cs->state.fb.render_targets[op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
+        struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_set_rendertarget_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
+    op->view_idx = view_idx;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_stencil_view *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_rendertarget_view *prev;
+
+    if ((prev = cs->state.fb.depth_stencil))
+    {
+        struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
+
+        if (prev_surface && (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || prev_surface->flags & SFLAG_DISCARD))
+        {
+            surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
+            if (prev_surface == cs->onscreen_depth_stencil)
+            {
+                wined3d_surface_decref(cs->onscreen_depth_stencil);
+                cs->onscreen_depth_stencil = NULL;
+            }
+        }
+    }
+
+    cs->state.fb.depth_stencil = op->view;
+
+    if (!prev != !op->view)
+    {
+        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+    else if (prev && prev->format->depth_size != op->view->format->depth_size)
+    {
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+
+    device_invalidate_state(device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_set_depth_stencil_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_vertex_declaration *op = data;
+
+    cs->state.vertex_declaration = op->declaration;
+    device_invalidate_state(cs->device, STATE_VDECL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_set_vertex_declaration *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source *op = data;
+    struct wined3d_stream_state *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.streams[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+    stream->stride = op->stride;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+{
+    struct wined3d_cs_set_stream_source *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->stride = stride;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source_freq *op = data;
+    struct wined3d_stream_state *stream;
+
+    stream = &cs->state.streams[op->stream_idx];
+    stream->frequency = op->frequency;
+    stream->flags = op->flags;
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+{
+    struct wined3d_cs_set_stream_source_freq *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
+    op->stream_idx = stream_idx;
+    op->frequency = frequency;
+    op->flags = flags;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_output *op = data;
+    struct wined3d_stream_output *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.stream_output[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset)
+{
+    struct wined3d_cs_set_stream_output *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_index_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.index_buffer;
+    cs->state.index_buffer = op->buffer;
+    cs->state.index_format = op->format_id;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        enum wined3d_format_id format_id)
+{
+    struct wined3d_cs_set_index_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
+    op->buffer = buffer;
+    op->format_id = format_id;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_constant_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.cb[op->type][op->cb_idx];
+    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT cb_idx, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_set_constant_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
+    op->type = type;
+    op->cb_idx = cb_idx;
+    op->buffer = buffer;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
+    const struct wined3d_cs_set_texture *op = data;
+    struct wined3d_texture *prev;
+    BOOL old_use_color_key = FALSE, new_use_color_key = FALSE;
+
+    prev = cs->state.textures[op->stage];
+    cs->state.textures[op->stage] = op->texture;
+
+    if (op->texture)
+    {
+        const struct wined3d_format *new_format = op->texture->resource.format;
+        const struct wined3d_format *old_format = prev ? prev->resource.format : NULL;
+
+        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
+            op->texture->sampler = op->stage;
+
+        if (!prev || op->texture->target != prev->target
+                || !is_same_fixup(new_format->color_fixup, old_format->color_fixup)
+                || (new_format->flags & WINED3DFMT_FLAG_SHADOW) != (old_format->flags & WINED3DFMT_FLAG_SHADOW))
+            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+
+        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            /* The source arguments for color and alpha ops have different
+             * meanings when a NULL texture is bound, so the COLOR_OP and
+             * ALPHA_OP have to be dirtified. */
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+
+        if (!op->stage && op->texture->async.color_key_flags & WINED3D_CKEY_SRC_BLT)
+            new_use_color_key = TRUE;
+    }
+
+    if (prev)
+    {
+        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
+        {
+            unsigned int i;
+
+            /* Search for other stages the texture is bound to. Shouldn't
+             * happen if applications bind textures to a single stage only. */
+            TRACE("Searching for other stages the texture is bound to.\n");
+            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
+            {
+                if (cs->state.textures[i] == prev)
+                {
+                    TRACE("Texture is also bound to stage %u.\n", i);
+                    prev->sampler = i;
+                    break;
+                }
+            }
+        }
+
+        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+
+        if (!op->stage && prev->async.color_key_flags & WINED3D_CKEY_SRC_BLT)
+            old_use_color_key = TRUE;
+    }
+
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+
+    if (new_use_color_key != old_use_color_key)
+        device_invalidate_state(cs->device, STATE_RENDER(WINED3D_RS_COLORKEYENABLE));
+
+    if (new_use_color_key)
+        device_invalidate_state(cs->device, STATE_COLOR_KEY);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_set_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
+    op->stage = stage;
+    op->texture = texture;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader_resource_view *op = data;
+
+    cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT view_idx, struct wined3d_shader_resource_view *view)
+{
+    struct wined3d_cs_set_shader_resource_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
+    op->type = type;
+    op->view_idx = view_idx;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler *op = data;
+
+    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT sampler_idx, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_set_sampler *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
+    op->type = type;
+    op->sampler_idx = sampler_idx;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader *op = data;
+
+    cs->state.shader[op->type] = op->shader;
+    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+    device_invalidate_state(cs->device, STATE_SHADER_RESOURCE_BINDING);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_set_shader *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER;
+    op->type = type;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.vs_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.vs_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_vertex_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.ps_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.ps_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_pixel_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register,
+        const float *constants, UINT vector4f_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_f *op;
+    UINT extra_space = vector4f_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4f_count = vector4f_count;
+    memcpy(op->constants, constants, sizeof(*constants) * 4 * vector4f_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_state *op = data;
+
+    cs->state.render_states[op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+{
+    struct wined3d_cs_set_render_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.vs_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.ps_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_b *op;
+    UINT extra_space = bool_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->bool_count = bool_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * bool_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_i[op->start_register * 4], op->constants,
+            sizeof(*cs->state.vs_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_i[op->start_register * 4], op->constants,
+            sizeof(*cs->state.ps_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_i *op;
+    UINT extra_space = vector4i_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            ERR("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4i_count = vector4i_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * vector4i_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
+        enum wined3d_texture_stage_state state, DWORD value)
+{
+    struct wined3d_cs_set_texture_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
+    op->stage = stage;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler_state *op = data;
+
+    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
+        enum wined3d_sampler_state state, DWORD value)
+{
+    struct wined3d_cs_set_sampler_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
+    op->sampler_idx = sampler_idx;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_transform *op = data;
+
+    cs->state.transforms[op->state] = op->matrix;
+    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
+        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
+        const struct wined3d_matrix *matrix)
+{
+    struct wined3d_cs_set_transform *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
+    op->state = state;
+    op->matrix = *matrix;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_clip_plane *op = data;
+
+    cs->state.clip_planes[op->plane_idx] = op->plane;
+    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+{
+    struct wined3d_cs_set_clip_plane *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
+    op->plane_idx = plane_idx;
+    op->plane = *plane;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_color_key(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_color_key *op = data;
+    struct wined3d_texture *texture = op->texture;
+
+    if (op->set)
+    {
+        switch (op->flags & ~WINED3D_CKEY_COLORSPACE)
+        {
+            case WINED3D_CKEY_DST_BLT:
+                texture->async.dst_blt_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_DST_BLT;
+                break;
+
+            case WINED3D_CKEY_DST_OVERLAY:
+                texture->async.dst_overlay_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_DST_OVERLAY;
+                break;
+
+            case WINED3D_CKEY_SRC_BLT:
+                if (texture == cs->state.textures[0])
+                {
+                    device_invalidate_state(cs->device, STATE_COLOR_KEY);
+                    if (!(texture->async.color_key_flags & WINED3D_CKEY_SRC_BLT))
+                        device_invalidate_state(cs->device, STATE_RENDER(WINED3D_RS_COLORKEYENABLE));
+                }
+
+                texture->async.src_blt_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_SRC_BLT;
+                break;
+
+            case WINED3D_CKEY_SRC_OVERLAY:
+                texture->async.src_overlay_color_key = op->color_key;
+                texture->async.color_key_flags |= WINED3D_CKEY_SRC_OVERLAY;
+                break;
+        }
+    }
+    else
+    {
+        switch (op->flags & ~WINED3D_CKEY_COLORSPACE)
+        {
+            case WINED3D_CKEY_DST_BLT:
+                texture->async.color_key_flags &= ~WINED3D_CKEY_DST_BLT;
+                break;
+
+            case WINED3D_CKEY_DST_OVERLAY:
+                texture->async.color_key_flags &= ~WINED3D_CKEY_DST_OVERLAY;
+                break;
+
+            case WINED3D_CKEY_SRC_BLT:
+                if (texture == cs->state.textures[0] && texture->async.color_key_flags & WINED3D_CKEY_SRC_BLT)
+                    device_invalidate_state(cs->device, STATE_RENDER(WINED3D_RS_COLORKEYENABLE));
+
+                texture->async.color_key_flags &= ~WINED3D_CKEY_SRC_BLT;
+                break;
+
+            case WINED3D_CKEY_SRC_OVERLAY:
+                texture->async.color_key_flags &= ~WINED3D_CKEY_SRC_OVERLAY;
+                break;
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_color_key(struct wined3d_cs *cs, struct wined3d_texture *texture,
+        WORD flags, const struct wined3d_color_key *color_key)
+{
+    struct wined3d_cs_set_color_key *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_COLOR_KEY;
+    op->texture = texture;
+    op->flags = flags;
+    if (color_key)
+    {
+        op->color_key = *color_key;
+        op->set = 1;
+    }
+    else
+        op->set = 0;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_material *op = data;
+
+    cs->state.material = op->material;
+    device_invalidate_state(cs->device, STATE_MATERIAL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+{
+    struct wined3d_cs_set_material *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
+    op->material = *material;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+    HRESULT hr;
+
+    state_cleanup(&cs->state);
+    memset(&cs->state, 0, sizeof(cs->state));
+    if (FAILED(hr = state_init(&cs->state, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+
+    return sizeof(struct wined3d_cs_reset_state);
+}
+
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_reset_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_finish *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_context *context;
+
+    if (!device->d3d_initialized)
+        return sizeof(*op);
+
+    context = context_acquire(device, NULL);
+    context->gl_info->gl_ops.gl.p_glFinish();
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_base_vertex_index(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_base_vertex_index *op = data;
+
+    cs->state.base_vertex_index = op->base_vertex_index;
+    device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index)
+{
+    struct wined3d_cs_set_base_vertex_index *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_BASE_VERTEX_INDEX;
+    op->base_vertex_index = base_vertex_index;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_SIZE_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light\n");
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+        if (!object)
+            return E_OUTOFMEMORY;
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    memcpy(object->lightPosn, op->light.lightPosn, sizeof(object->lightPosn));
+    memcpy(object->lightDirn, op->light.lightDirn, sizeof(object->lightDirn));
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Light enabled requested but light not defined in cs state!\n");
+        return sizeof(*op);
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled\n");
+        }
+        else
+        {
+            unsigned int i;
+            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+            /* Find a free GL light. */
+            for (i = 0; i < gl_info->limits.lights; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op */
+                ERR("Too many concurrently active lights in cs\n");
+                return sizeof(*op);
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable)
+{
+    struct wined3d_cs_set_light_enable *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_resource_dec_fence(&op->dst_surface->container->resource);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_resource_dec_fence(&op->src_surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_resource_inc_fence(&dst_surface->container->resource);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_resource_inc_fence(&src_surface->container->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_clear_rtv(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear_rtv *op = data;
+    struct wined3d_resource *resource = op->view->resource;
+
+    resource = wined3d_texture_get_sub_resource(wined3d_texture_from_resource(resource), op->view->sub_resource_idx);
+
+    surface_color_fill(surface_from_resource(resource), &op->rect, &op->color);
+
+    wined3d_resource_dec_fence(op->view->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, const struct wined3d_color *color)
+{
+    struct wined3d_cs_clear_rtv *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CLEAR_RTV;
+    op->view = view;
+    op->rect = *rect;
+    op->color = *color;
+
+    wined3d_resource_inc_fence(view->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_resource_changed(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_changed *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_changed(resource, op->swap_buffer, op->swap_heap_memory);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_cs_resource_changed *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_CHANGED;
+    op->resource = resource;
+    op->swap_buffer = swap_buffer;
+    op->swap_heap_memory = swap_heap_memory;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_resource_map(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_map *op = data;
+
+    *op->mem = wined3d_resource_map_internal(op->resource, op->flags);
+
+    return sizeof(*op);
+}
+
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags)
+{
+    struct wined3d_cs_resource_map *op;
+    void *ret;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_MAP;
+    op->resource = resource;
+    op->flags = flags;
+    op->mem = &ret;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+
+    cs->ops->finish_prio(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_resource_unmap(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_unmap *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_unmap_internal(resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_resource_unmap *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_UNMAP;
+    op->resource = resource;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_query_issue *op = data;
+    struct wined3d_query *query = op->query;
+    BOOL poll;
+
+    poll = query->query_ops->query_issue(query, op->flags);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        if (poll && list_empty(&query->poll_list_entry))
+        {
+            list_add_tail(&cs->query_poll_list, &query->poll_list_entry);
+        }
+        else if (!poll && !list_empty(&query->poll_list_entry))
+        {
+            /* Can happen if occlusion queries are restarted. This discards the old
+             * result, polling it could result in a GL error */
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+        }
+        else if (op->flags & WINED3DISSUE_END)
+        {
+            /* Can happen when an occlusion query is ended without being started,
+             * in which case we don't want to poll, but still have to counter-balance
+             * the increment of the main counter (!poll && list_empty).
+             *
+             * This can also happen if an event query is re-issued before the first
+             * fence was reached (poll && !list_empty). In this case the query is
+             * already in the list and the poll function will check the new fence.
+             * We have to counter-balance the discarded increment. */
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_cs_query_issue *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
+    op->query = query;
+    op->flags = flags;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_query_destroy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_query_destroy *op = data;
+
+    if (!list_empty(&op->query->poll_list_entry))
+        list_remove(&op->query->poll_list_entry);
+
+    wined3d_query_destroy(op->query);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query)
+{
+    struct wined3d_cs_query_destroy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_QUERY_DESTROY;
+    op->query = query;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_surface(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_surface *op = data;
+
+    surface_upload_from_surface(op->dst, op->has_dst_point ? &op->dst_point : NULL,
+            op->src, op->has_src_rect ? &op->src_rect : NULL);
+
+    if (op->src->container)
+        wined3d_resource_dec_fence(&op->src->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->src->resource);
+
+    if (op->dst->container)
+        wined3d_resource_dec_fence(&op->dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src, const RECT *src_rect,
+        struct wined3d_surface *dst, const POINT *dst_point)
+{
+    struct wined3d_cs_update_surface *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_SURFACE;
+    op->src = src;
+    op->dst = dst;
+    op->has_src_rect = FALSE;
+    op->has_dst_point = FALSE;
+
+    if (src_rect)
+    {
+        op->has_src_rect = TRUE;
+        op->src_rect = *src_rect;
+    }
+
+    if (dst_point)
+    {
+        op->has_dst_point = TRUE;
+        op->dst_point = *dst_point;
+    }
+
+    if (src->container)
+        wined3d_resource_inc_fence(&src->container->resource);
+    else
+        wined3d_resource_inc_fence(&src->resource);
+
+    if (dst->container)
+        wined3d_resource_inc_fence(&dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_preload *op = data;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture = op->texture;
+
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&texture->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_texture_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_PRELOAD;
+    op->texture = texture;
+
+    wined3d_resource_inc_fence(&texture->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_surface_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_surface_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_preload(op->surface->container);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface)
+{
+    struct wined3d_cs_surface_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SURFACE_PRELOAD;
+    op->surface = surface;
+
+    wined3d_resource_inc_fence(&op->surface->container->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->src->resource);
+    wined3d_resource_dec_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_inc_fence(&op->src->resource);
+    wined3d_resource_inc_fence(&op->dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_evict_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_evict_resource *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    resource->resource_ops->resource_unload(resource);
+
+    /* FIXME: Is this necessary? Bound buffers are preloaded anyway, and in theory
+     * PreLoad should take care of invalidating the state if the VBO changes */
+    if (resource->bind_count && resource->type == WINED3D_RTYPE_BUFFER)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_evict_resource *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_EVICT_RESOURCE;
+    op->resource = resource;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_swap_mem(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_swap_mem *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+
+    buffer_swap_mem(buffer, op->mem);
+
+    if (!buffer->buffer_object && buffer->resource.bind_count)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer, BYTE *mem)
+{
+    struct wined3d_cs_buffer_swap_mem *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_SWAP_MEM;
+    op->buffer = buffer;
+    op->mem = mem;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_invalidate_bo_range(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_invalidate_bo_range *op = data;
+
+    buffer_invalidate_bo_range(op->buffer, op->offset, op->size);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size)
+{
+    struct wined3d_cs_buffer_invalidate_bo_range *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->size = size;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    buffer_internal_preload(op->buffer, context, NULL);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->buffer->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_buffer_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_PRELOAD;
+    op->buffer = buffer;
+
+    wined3d_resource_inc_fence(&buffer->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_view_destroy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_view_destroy *op = data;
+
+    wined3d_rendertarget_view_destroy(op->view);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_view_destroy(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_view_destroy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_VIEW_DESTROY;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_vertex_declaration_destroy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_vertex_declaration_destroy *op = data;
+
+    wined3d_vertex_declaration_destroy(op->declaration);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_vertex_declaration_destroy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_VDECL_DESTROY;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_shader_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_shader_cleanup *op = data;
+
+    shader_cleanup(op->shader);
+    HeapFree(GetProcessHeap(), 0, op->shader);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_shader_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SHADER_CLEANUP;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_create_vbo(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_vbo *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
+
+    buffer_create_buffer_object(op->buffer, context);
+
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_create_vbo *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_VBO;
+    op->buffer = buffer;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+    cs->ops->finish_prio(cs);
+}
+
+static UINT wined3d_cs_exec_resource_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_cleanup *op = data;
+
+    wined3d_resource_cleanup_cs(op->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_resource_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_CLEANUP;
+    op->resource = resource;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_cleanup *op = data;
+
+    wined3d_buffer_cleanup_cs(op->buffer);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_buffer_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_CLEANUP;
+    op->buffer = buffer;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_volume_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_volume_cleanup *op = data;
+
+    wined3d_volume_cleanup_cs(op->volume);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume)
+{
+    struct wined3d_cs_volume_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_VOLUME_CLEANUP;
+    op->volume = volume;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_surface_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_surface_cleanup *op = data;
+
+    wined3d_surface_cleanup_cs(op->surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface)
+{
+    struct wined3d_cs_surface_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SURFACE_CLEANUP;
+    op->surface = surface;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_texture_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_texture_cleanup *op = data;
+
+    wined3d_texture_cleanup_cs(op->texture);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_texture_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_TEXTURE_CLEANUP;
+    op->texture = texture;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
 {
-    enum wined3d_cs_op opcode;
-    enum wined3d_shader_type type;
-    UINT view_idx;
-    struct wined3d_shader_resource_view *view;
-};
+    const struct wined3d_cs_create_dummy_textures *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
 
-struct wined3d_cs_set_sampler
+    device_create_dummy_textures(cs->device, context);
+
+    context_release(context);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
 {
-    enum wined3d_cs_op opcode;
-    enum wined3d_shader_type type;
-    UINT sampler_idx;
-    struct wined3d_sampler *sampler;
-};
+    struct wined3d_cs_create_dummy_textures *op;
 
-struct wined3d_cs_set_shader
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
 {
-    enum wined3d_cs_op opcode;
-    enum wined3d_shader_type type;
-    struct wined3d_shader *shader;
-};
+    const struct wined3d_cs_create_swapchain_context *op = data;
 
-struct wined3d_cs_set_render_state
+    *op->ret = swapchain_create_context_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
+}
+
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    enum wined3d_cs_op opcode;
-    enum wined3d_render_state state;
-    DWORD value;
-};
+    HRESULT ret;
+    struct wined3d_cs_create_swapchain_context *op;
 
-struct wined3d_cs_set_texture_state
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->ret = &ret;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
 {
-    enum wined3d_cs_op opcode;
-    UINT stage;
-    enum wined3d_texture_stage_state state;
-    DWORD value;
-};
+    const struct wined3d_cs_delete_gl_contexts *op = data;
 
-struct wined3d_cs_set_sampler_state
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    enum wined3d_cs_op opcode;
-    UINT sampler_idx;
-    enum wined3d_sampler_state state;
-    DWORD value;
-};
+    struct wined3d_cs_delete_gl_contexts *op;
 
-struct wined3d_cs_set_transform
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_getdc(struct wined3d_cs *cs, const void *data)
 {
-    enum wined3d_cs_op opcode;
-    enum wined3d_transform_state state;
-    const struct wined3d_matrix *matrix;
-};
+    const struct wined3d_cs_getdc *op = data;
 
-struct wined3d_cs_set_clip_plane
+    wined3d_surface_getdc_cs(op->surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_getdc(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    enum wined3d_cs_op opcode;
-    UINT plane_idx;
-    const struct wined3d_vec4 *plane;
-};
+    struct wined3d_cs_getdc *op;
 
-struct wined3d_cs_set_material
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GETDC;
+    op->surface = surface;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT wined3d_cs_exec_releasedc(struct wined3d_cs *cs, const void *data)
 {
-    enum wined3d_cs_op opcode;
-    const struct wined3d_material *material;
-};
+    const struct wined3d_cs_releasedc *op = data;
 
-struct wined3d_cs_reset_state
+    wined3d_surface_releasedc_cs(op->surface);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_releasedc(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    enum wined3d_cs_op opcode;
-};
+    struct wined3d_cs_releasedc *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RELEASEDC;
+    op->surface = surface;
 
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
+}
+
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+{
+    /* WINED3D_CS_OP_NOP                        */ wined3d_cs_exec_nop,
+    /* WINED3D_CS_OP_SKIP                       */ wined3d_cs_exec_skip,
+    /* WINED3D_CS_OP_FENCE                      */ wined3d_cs_exec_fence,
+#else  /* STAGING_CSMT */
 static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
 {
     const struct wined3d_cs_present *op = data;
@@ -1019,6 +3589,7 @@ void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
 
 static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+#endif /* STAGING_CSMT */
     /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
@@ -1045,6 +3616,393 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_SET_COLOR_KEY              */ wined3d_cs_exec_set_color_key,
     /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
     /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
+#if defined(STAGING_CSMT)
+    /* WINED3D_CS_OP_SET_VS_CONSTS_F            */ wined3d_cs_exec_set_vs_consts_f,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_B            */ wined3d_cs_exec_set_vs_consts_b,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_I            */ wined3d_cs_exec_set_vs_consts_i,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_F            */ wined3d_cs_exec_set_ps_consts_f,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_B            */ wined3d_cs_exec_set_ps_consts_b,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_I            */ wined3d_cs_exec_set_ps_consts_i,
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX      */ wined3d_cs_exec_set_base_vertex_index,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_RESOURCE_CHANGED           */ wined3d_cs_exec_resource_changed,
+    /* WINED3D_CS_OP_RESOURCE_MAP               */ wined3d_cs_exec_resource_map,
+    /* WINED3D_CS_OP_RESOURCE_UNMAP             */ wined3d_cs_exec_resource_unmap,
+    /* WINED3D_CS_OP_BUFFER_SWAP_MEM            */ wined3d_cs_exec_buffer_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE    */ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_BUFFER_PRELOAD             */ wined3d_cs_exec_buffer_preload,
+    /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
+    /* WINED3D_CS_OP_QUERY_DESTROY              */ wined3d_cs_exec_query_destroy,
+    /* WINED3D_CS_OP_UPDATE_SURFACE             */ wined3d_cs_exec_update_surface,
+    /* WINED3D_CS_OP_TEXTURE_PRELOAD            */ wined3d_cs_exec_texture_preload,
+    /* WINED3D_CS_OP_SURFACE_PRELOAD            */ wined3d_cs_exec_surface_preload,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_EVICT_RESOURCE             */ wined3d_cs_exec_evict_resource,
+    /* WINED3D_CS_OP_VIEW_DESTROY               */ wined3d_cs_exec_view_destroy,
+    /* WINED3D_CS_OP_VDECL_DESTROY              */ wined3d_cs_exec_vertex_declaration_destroy,
+    /* WINED3D_CS_OP_SHADER_CLEANUP             */ wined3d_cs_exec_shader_cleanup,
+    /* WINED3D_CS_OP_CREATE_VBO                 */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_RESOURCE_CLEANUP           */ wined3d_cs_exec_resource_cleanup,
+    /* WINED3D_CS_OP_BUFFER_CLEANUP             */ wined3d_cs_exec_buffer_cleanup,
+    /* WINED3D_CS_OP_VOLUME_CLEANUP             */ wined3d_cs_exec_volume_cleanup,
+    /* WINED3D_CS_OP_SURFACE_CLEANUP            */ wined3d_cs_exec_surface_cleanup,
+    /* WINED3D_CS_OP_TEXTURE_CLEANUP            */ wined3d_cs_exec_texture_cleanup,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_GETDC                      */ wined3d_cs_exec_getdc,
+    /* WINED3D_CS_OP_RELEASEDC                  */ wined3d_cs_exec_releasedc,
+};
+
+static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+{
+    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
+    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
+
+    if (queue_size - size < queue->head)
+    {
+        struct wined3d_cs_skip *skip;
+        size_t nop_size = queue_size - queue->head;
+
+        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
+        if (nop_size < sizeof(*skip))
+        {
+            skip->opcode = WINED3D_CS_OP_NOP;
+        }
+        else
+        {
+            skip->opcode = WINED3D_CS_OP_SKIP;
+            skip->size = nop_size;
+        }
+
+        if (prio)
+            cs->ops->submit_prio(cs, nop_size);
+        else
+            cs->ops->submit(cs, nop_size);
+
+        assert(!queue->head);
+    }
+
+    while(1)
+    {
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        /* Head ahead of tail, take care of wrap-around */
+        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        if (head > tail && (new_pos || tail))
+            break;
+        /* Tail ahead of head, but still enough space */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
+                (unsigned int) size);
+    }
+
+    return &queue->data[queue->head];
+}
+
+static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+}
+
+static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+}
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence_prio(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
+};
+
+static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
+    }
+
+    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
+}
+
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
+{
+}
+
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return cs->queue.data;
+}
+
+static const struct wined3d_cs_ops wined3d_cs_st_ops =
+{
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_submit,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
+};
+
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (cs->onscreen_depth_stencil)
+    {
+        surface_load_ds_location(cs->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(cs->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                cs->onscreen_depth_stencil->ds_current_size.cx,
+                cs->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_surface_decref(cs->onscreen_depth_stencil);
+    }
+    cs->onscreen_depth_stencil = depth_stencil;
+    wined3d_surface_incref(cs->onscreen_depth_stencil);
+}
+
+static inline void poll_queries(struct wined3d_cs *cs)
+{
+    struct wined3d_query *query, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(query, cursor, &cs->query_poll_list, struct wined3d_query, poll_list_entry)
+    {
+        BOOL ret;
+
+        ret = query->query_ops->query_poll(query);
+        if (ret)
+        {
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+}
+
+static inline BOOL queue_is_empty(const struct wined3d_cs_queue *queue)
+{
+    return *((volatile LONG *)&queue->head) == queue->tail;
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (!queue_is_empty(&cs->prio_queue) || !queue_is_empty(&cs->queue))
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, FALSE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+    enum wined3d_cs_op opcode;
+    LONG tail;
+    char poll = 0;
+    struct wined3d_cs_queue *queue;
+    unsigned int spin_count = 0;
+
+    TRACE("Started.\n");
+
+    list_init(&cs->query_poll_list);
+    cs->thread_id = GetCurrentThreadId();
+    for (;;)
+    {
+        if (poll == 10)
+        {
+            poll = 0;
+            poll_queries(cs);
+        }
+        else
+            poll++;
+
+        if (!queue_is_empty(&cs->prio_queue))
+        {
+            queue = &cs->prio_queue;
+        }
+        else if (!queue_is_empty(&cs->queue))
+        {
+            queue = &cs->queue;
+            if (!queue_is_empty(&cs->prio_queue))
+                queue = &cs->prio_queue;
+        }
+        else
+        {
+            spin_count++;
+            if (spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
+                wined3d_cs_wait_event(cs);
+
+            continue;
+        }
+
+        spin_count = 0;
+
+        tail = queue->tail;
+        opcode = *(const enum wined3d_cs_op *)&queue->data[tail];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            goto done;
+        }
+
+        tail += wined3d_cs_op_handlers[opcode](cs, &queue->data[tail]);
+        tail &= (WINED3D_CS_QUEUE_SIZE - 1);
+        InterlockedExchange(&queue->tail, tail);
+    }
+
+done:
+    TRACE("Stopped.\n");
+    return 0;
+}
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
+{
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_cs *cs = NULL;
+
+    if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
+        return NULL;
+
+    if (FAILED(state_init(&cs->state, gl_info, &device->adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+    {
+        goto err;
+    }
+
+    cs->ops = &wined3d_cs_st_ops;
+    cs->device = device;
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        cs->ops = &wined3d_cs_mt_ops;
+
+        cs->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, NULL)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            goto err;
+        }
+    }
+
+    return cs;
+
+err:
+    if (cs)
+        state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs);
+    return NULL;
+}
+
+void wined3d_cs_destroy(struct wined3d_cs *cs)
+{
+    DWORD ret;
+
+    state_cleanup(&cs->state);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+        if (!CloseHandle(cs->event))
+            ERR("Closing event failed.\n");
+    }
+
+#else  /* STAGING_CSMT */
 };
 
 static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
@@ -1118,5 +4076,6 @@ void wined3d_cs_destroy(struct wined3d_cs *cs)
     state_cleanup(&cs->state);
     HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, cs->data);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index 5f44a1a..8c5b285 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -198,6 +198,7 @@ void device_context_remove(struct wined3d_device *device, struct wined3d_context
     device->contexts = new_array;
 }
 
+#if !defined(STAGING_CSMT)
 void device_switch_onscreen_ds(struct wined3d_device *device,
         struct wined3d_context *context, struct wined3d_surface *depth_stencil)
 {
@@ -214,6 +215,7 @@ void device_switch_onscreen_ds(struct wined3d_device *device,
     wined3d_surface_incref(device->onscreen_depth_stencil);
 }
 
+#endif /* STAGING_CSMT */
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     /* partial draw rect */
@@ -236,7 +238,11 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
 {
     RECT current_rect, r;
 
+#if defined(STAGING_CSMT)
+    if (ds->resource.locations & WINED3D_LOCATION_DISCARDED)
+#else  /* STAGING_CSMT */
     if (ds->locations & WINED3D_LOCATION_DISCARDED)
+#endif /* STAGING_CSMT */
     {
         /* Depth buffer was discarded, make it entirely current in its new location since
          * there is no other place where we would get data anyway. */
@@ -244,7 +250,11 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
         return;
     }
 
+#if defined(STAGING_CSMT)
+    if (ds->resource.locations & location)
+#else  /* STAGING_CSMT */
     if (ds->locations & location)
+#endif /* STAGING_CSMT */
         SetRect(&current_rect, 0, 0,
                 ds->ds_current_size.cx,
                 ds->ds_current_size.cy);
@@ -300,6 +310,17 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     unsigned int i;
     RECT ds_rect;
 
+#if defined(STAGING_CSMT)
+    context = context_acquire(device, target);
+    if (!context->valid)
+    {
+        context_release(context);
+        WARN("Invalid context, skipping clear.\n");
+        return;
+    }
+    gl_info = context->gl_info;
+
+#endif /* STAGING_CSMT */
     /* When we're clearing parts of the drawable, make sure that the target surface is well up to date in the
      * drawable. After the clear we'll mark the drawable up to date, so we have to make sure that this is true
      * for the cleared parts, and the untouched parts.
@@ -314,6 +335,11 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
         {
             struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(fb->render_targets[i]);
             if (rt)
+#if defined(STAGING_CSMT)
+                wined3d_resource_load_location(&rt->resource, context, rt->container->resource.draw_binding);
+        }
+    }
+#else  /* STAGING_CSMT */
                 surface_load_location(rt, rt->container->resource.draw_binding);
         }
     }
@@ -326,6 +352,7 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
         return;
     }
     gl_info = context->gl_info;
+#endif /* STAGING_CSMT */
 
     if (target)
     {
@@ -343,8 +370,13 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     {
         DWORD location = render_offscreen ? fb->depth_stencil->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
+#if defined(STAGING_CSMT)
+        if (!render_offscreen && depth_stencil != device->cs->onscreen_depth_stencil)
+            wined3d_cs_switch_onscreen_ds(device->cs, context, depth_stencil);
+#else  /* STAGING_CSMT */
         if (!render_offscreen && depth_stencil != device->onscreen_depth_stencil)
             device_switch_onscreen_ds(device, context, depth_stencil);
+#endif /* STAGING_CSMT */
         prepare_ds_clear(depth_stencil, context, location,
                 draw_rect, rect_count, clear_rect, &ds_rect);
     }
@@ -392,8 +424,13 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
 
             if (rt)
             {
+#if defined(STAGING_CSMT)
+                wined3d_resource_validate_location(&rt->resource, rt->container->resource.draw_binding);
+                wined3d_resource_invalidate_location(&rt->resource, ~rt->container->resource.draw_binding);
+#else  /* STAGING_CSMT */
                 surface_validate_location(rt, rt->container->resource.draw_binding);
                 surface_invalidate_location(rt, ~rt->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
             }
         }
 
@@ -474,7 +511,7 @@ ULONG CDECL wined3d_device_incref(struct wined3d_device *device)
 {
     ULONG refcount = InterlockedIncrement(&device->ref);
 
-    TRACE("%p increasing refcount to %u.\n", device, refcount);
+//    TRACE("%p increasing refcount to %u.\n", device, refcount);
 
     return refcount;
 }
@@ -490,7 +527,7 @@ ULONG CDECL wined3d_device_decref(struct wined3d_device *device)
 {
     ULONG refcount = InterlockedDecrement(&device->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", device, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", device, refcount);
 
     if (!refcount)
     {
@@ -633,7 +670,11 @@ out:
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#else  /* STAGING_CSMT */
 static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+#endif /* STAGING_CSMT */
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     unsigned int i, j, count;
@@ -860,7 +901,11 @@ static void device_init_swapchain_state(struct wined3d_device *device, struct wi
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
+#if defined(STAGING_CSMT)
+    if (device->state.fb.render_targets)
+#else  /* STAGING_CSMT */
     if (device->fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -878,9 +923,13 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
+#if defined(STAGING_CSMT)
+    struct wined3d_swapchain *swapchain = NULL;
+#else  /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -891,9 +940,11 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
+#if !defined(STAGING_CSMT)
     device->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
             sizeof(*device->fb.render_targets) * gl_info->limits.buffers);
 
+#endif /* STAGING_CSMT */
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -934,10 +985,14 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_create_dummy_textures(device->cs);
+#else  /* STAGING_CSMT */
     context = context_acquire(device,
             surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0)));
 
     create_dummy_textures(device, context);
+#endif /* STAGING_CSMT */
 
     device->contexts[0]->last_was_rhw = 0;
 
@@ -949,7 +1004,11 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
 
         case ORM_BACKBUFFER:
         {
+#if defined(STAGING_CSMT)
+            if (device->contexts[0]->aux_buffers > 0)
+#else  /* STAGING_CSMT */
             if (context_get_current()->aux_buffers > 0)
+#endif /* STAGING_CSMT */
             {
                 TRACE("Using auxiliary buffer for offscreen rendering\n");
                 device->offscreenBuffer = GL_AUX0;
@@ -961,10 +1020,16 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
             }
         }
     }
+#if defined(STAGING_CSMT)
+    device->contexts[0]->offscreenBuffer = device->offscreenBuffer;
+
+    TRACE("All defaults now set up, leaving 3D init.\n");
+#else  /* STAGING_CSMT */
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
     context_release(context);
+#endif /* STAGING_CSMT */
 
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
@@ -981,7 +1046,9 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
+#if !defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
+#endif /* STAGING_CSMT */
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (device->back_buffer_view)
@@ -1039,8 +1106,10 @@ static void device_free_sampler(struct wine_rb_entry *entry, void *context)
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1049,6 +1118,43 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        device->cs->ops->finish(device->cs);
+
+    if (device->logo_texture)
+        wined3d_texture_decref(device->logo_texture);
+
+    /* Release the buffers (with sanity checks).
+     * FIXME: Move this move into a separate patch. I think the idea
+     * behind this is that those surfaces should be freed before unloading
+     * remaining resources below.
+     * FIXME 2: Shouldn't the cs take care of onscreen_depth_stencil? */
+    if (device->cs->onscreen_depth_stencil)
+    {
+        surface = device->cs->onscreen_depth_stencil;
+        device->cs->onscreen_depth_stencil = NULL;
+        wined3d_surface_decref(surface);
+    }
+
+    state_unbind_resources(&device->state);
+
+    if (device->auto_depth_stencil_view)
+    {
+        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
+        device->auto_depth_stencil_view = NULL;
+    }
+
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
+
+#else  /* STAGING_CSMT */
     /* I don't think that the interface guarantees that the device is destroyed from the same thread
      * it was created. Thus make sure a context is active for the glDelete* calls
      */
@@ -1086,6 +1192,12 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->shader_backend->shader_free_private(device);
     destroy_dummy_textures(device, gl_info);
 
+    /* Release the context again as soon as possible. In particular,
+     * releasing the render target views below may release the last reference
+     * to the swapchain associated with this context, which in turn will
+     * destroy the context. */
+    context_release(context);
+
     /* Release the buffers (with sanity checks)*/
     if (device->onscreen_depth_stencil)
     {
@@ -1117,14 +1229,13 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     {
         wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
     }
+#endif /* STAGING_CSMT */
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
         device->back_buffer_view = NULL;
     }
 
-    context_release(context);
-
     for (i = 0; i < device->swapchain_count; ++i)
     {
         TRACE("Releasing the implicit swapchain %u.\n", i);
@@ -1136,9 +1247,11 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
+#if !defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     device->fb.render_targets = NULL;
 
+#endif /* STAGING_CSMT */
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1451,7 +1564,6 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
     {
         case WINED3D_LIGHT_POINT:
         case WINED3D_LIGHT_SPOT:
-        case WINED3D_LIGHT_PARALLELPOINT:
         case WINED3D_LIGHT_GLSPOT:
             /* Incorrect attenuation values can cause the gl driver to crash.
              * Happens with Need for speed most wanted. */
@@ -1463,6 +1575,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             break;
 
         case WINED3D_LIGHT_DIRECTIONAL:
+        case WINED3D_LIGHT_PARALLELPOINT:
             /* Ignores attenuation */
             break;
 
@@ -1502,6 +1615,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
     TRACE("... Range(%f), Falloff(%f), Theta(%f), Phi(%f)\n",
             light->range, light->falloff, light->theta, light->phi);
 
+#if !defined(STAGING_CSMT)
     /* Update the live definitions if the light is currently assigned a glIndex. */
     if (object->glIndex != -1 && !device->recording)
     {
@@ -1510,6 +1624,7 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
         device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
     }
 
+#endif /* STAGING_CSMT */
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1582,6 +1697,11 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+#if defined(STAGING_CSMT)
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
+#endif /* STAGING_CSMT */
     return WINED3D_OK;
 }
 
@@ -1654,12 +1774,14 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
     {
         if (light_info->glIndex != -1)
         {
+#if !defined(STAGING_CSMT)
             if (!device->recording)
             {
                 device_invalidate_state(device, STATE_LIGHT_TYPE);
                 device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
             }
 
+#endif /* STAGING_CSMT */
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1701,6 +1823,13 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
+#if defined(STAGING_CSMT)
+        }
+    }
+
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+#else  /* STAGING_CSMT */
 
             /* i == light_info->glIndex */
             if (!device->recording)
@@ -1710,6 +1839,7 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
             }
         }
     }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -1884,6 +2014,11 @@ void CDECL wined3d_device_set_base_vertex_index(struct wined3d_device *device, I
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+#if defined(STAGING_CSMT)
+
+    if (!device->recording)
+        wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
+#endif /* STAGING_CSMT */
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -1928,7 +2063,11 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(texture->resource.format->flags & WINED3DFMT_FLAG_DEPTH))
         return;
     surface = surface_from_resource(texture->sub_resources[0]);
+#if defined(STAGING_CSMT)
+    if (!(depth_stencil = wined3d_rendertarget_view_get_surface(state->fb.depth_stencil)))
+#else  /* STAGING_CSMT */
     if (!(depth_stencil = wined3d_rendertarget_view_get_surface(state->fb->depth_stencil)))
+#endif /* STAGING_CSMT */
         return;
 
     wined3d_surface_blt(surface, NULL, depth_stencil, NULL, 0, NULL, WINED3D_TEXF_POINT);
@@ -2248,7 +2387,11 @@ struct wined3d_sampler * CDECL wined3d_device_get_vs_sampler(const struct wined3
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
+#if defined(STAGING_CSMT)
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
+#else  /* STAGING_CSMT */
 static void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
+#endif /* STAGING_CSMT */
 {
     UINT i;
 
@@ -2281,7 +2424,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
         device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2328,7 +2476,12 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
         device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2379,8 +2532,13 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(device->recording->changed.vertexShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.vertexShaderConstantsF) * vector4f_count);
     else
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_VERTEX);
+#else  /* STAGING_CSMT */
         device->shader_backend->shader_update_float_vertex_constants(device, start_register, vector4f_count);
 
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2515,7 +2673,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
         device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2562,7 +2725,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
         device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+#endif /* STAGING_CSMT */
     }
 
     return WINED3D_OK;
@@ -2614,7 +2782,12 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(device->recording->changed.pixelShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.pixelShaderConstantsF) * vector4f_count);
     else
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_PIXEL);
+#else  /* STAGING_CSMT */
         device->shader_backend->shader_update_float_pixel_constants(device, start_register, vector4f_count);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2774,6 +2947,15 @@ static HRESULT process_vertices_strided(const struct wined3d_device *device, DWO
         return hr;
     }
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
+#endif /* STAGING_CSMT */
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3275,8 +3457,10 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
+#if !defined(STAGING_CSMT)
     struct wined3d_context *context;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3285,6 +3469,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     context = context_acquire(device, NULL);
     /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
     context->gl_info->gl_ops.gl.p_glFlush();
@@ -3292,6 +3477,7 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
      * fails. */
     context_release(context);
 
+#endif /* STAGING_CSMT */
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3317,6 +3503,10 @@ HRESULT CDECL wined3d_device_present(const struct wined3d_device *device, const
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color {%.8e, %.8e, %.8e, %.8e}, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, color->r, color->g, color->b, color->a, depth, stencil);
 
@@ -3325,10 +3515,19 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         WARN("Rects is %p, but rect_count is 0, ignoring clear\n", rects);
         return WINED3D_OK;
     }
+#if defined(STAGING_CSMT)
+    if (rect_count && !rects)
+        rect_count = 0;
+
+    if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+    {
+        struct wined3d_rendertarget_view *ds = fb->depth_stencil;
+#else  /* STAGING_CSMT */
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
         struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#endif /* STAGING_CSMT */
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3337,8 +3536,13 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
+#if defined(STAGING_CSMT)
+            if (ds->width < fb->render_targets[0]->width
+                    || ds->height < fb->render_targets[0]->height)
+#else  /* STAGING_CSMT */
             if (ds->width < device->fb.render_targets[0]->width
                     || ds->height < device->fb.render_targets[0]->height)
+#endif /* STAGING_CSMT */
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3384,7 +3588,9 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
+#if !defined(STAGING_CSMT)
 
+#endif /* STAGING_CSMT */
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3392,8 +3598,13 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
+#if defined(STAGING_CSMT)
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#else  /* STAGING_CSMT */
     else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
         device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+#endif /* STAGING_CSMT */
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3416,12 +3627,14 @@ HRESULT CDECL wined3d_device_draw_primitive(struct wined3d_device *device, UINT
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (device->state.load_base_vertex_index)
     {
         device->state.load_base_vertex_index = 0;
         device_invalidate_state(device, STATE_BASEVERTEXINDEX);
     }
 
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_draw(device->cs, start_vertex, vertex_count, 0, 0, FALSE);
 
     return WINED3D_OK;
@@ -3438,8 +3651,10 @@ void CDECL wined3d_device_draw_primitive_instanced(struct wined3d_device *device
 
 HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count)
 {
+#if !defined(STAGING_CSMT)
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
 
+#endif /* STAGING_CSMT */
     TRACE("device %p, start_idx %u, index_count %u.\n", device, start_idx, index_count);
 
     if (!device->state.index_buffer)
@@ -3458,6 +3673,7 @@ HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *devic
         return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     if (!gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX] &&
         device->state.load_base_vertex_index != device->state.base_vertex_index)
     {
@@ -3465,6 +3681,7 @@ HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *devic
         device_invalidate_state(device, STATE_BASEVERTEXINDEX);
     }
 
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_draw(device->cs, start_idx, index_count, 0, 0, TRUE);
 
     return WINED3D_OK;
@@ -3480,6 +3697,47 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
 }
 
 /* This is a helper function for UpdateTexture, there is no UpdateVolume method in D3D. */
+#if defined(STAGING_CSMT)
+static void device_update_volume(struct wined3d_context *context,
+        struct wined3d_volume *src_volume, struct wined3d_volume *dst_volume)
+{
+    struct wined3d_bo_address data;
+
+    TRACE("src_volume %p, dst_volume %p.\n",
+            src_volume, dst_volume);
+
+    if (src_volume->resource.format != dst_volume->resource.format)
+    {
+        FIXME("Source and destination formats do not match.\n");
+        return;
+    }
+    if (src_volume->resource.width != dst_volume->resource.width
+            || src_volume->resource.height != dst_volume->resource.height
+            || src_volume->resource.depth != dst_volume->resource.depth)
+    {
+        FIXME("Source and destination sizes do not match.\n");
+        return;
+    }
+
+    /* Only a prepare, since we're uploading the entire volume. */
+    wined3d_texture_prepare_texture(dst_volume->container, context, FALSE);
+    wined3d_texture_bind_and_dirtify(dst_volume->container, context, FALSE);
+    wined3d_resource_get_memory(&src_volume->resource, src_volume->resource.map_binding, &data);
+    wined3d_volume_upload_data(dst_volume, context, wined3d_const_bo_address(&data));
+    wined3d_resource_invalidate_location(&dst_volume->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
+}
+
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
+{
+    enum wined3d_resource_type type = src_texture->resource.type;
+    unsigned int level_count = wined3d_texture_get_level_count(dst_texture);
+    unsigned int i;
+
+    /* Make sure that the destination texture is loaded. */
+    wined3d_texture_load(dst_texture, context, FALSE);
+#else  /* not STAGING_CSMT */
 static HRESULT device_update_volume(struct wined3d_device *device,
         struct wined3d_volume *src_volume, struct wined3d_volume *dst_volume)
 {
@@ -3491,21 +3749,26 @@ static HRESULT device_update_volume(struct wined3d_device *device,
     TRACE("device %p, src_volume %p, dst_volume %p.\n",
             device, src_volume, dst_volume);
 
-    if (src_volume->resource.format != dst_volume->resource.format)
+    if (src_volume->resource.format->id != dst_volume->resource.format->id)
     {
-        FIXME("Source and destination formats do not match.\n");
+        FIXME("Source %x and destination %x formats do not match.\n",
+              src_volume->resource.format->id, dst_volume->resource.format->id);
         return WINED3DERR_INVALIDCALL;
     }
     if (src_volume->resource.width != dst_volume->resource.width
             || src_volume->resource.height != dst_volume->resource.height
             || src_volume->resource.depth != dst_volume->resource.depth)
     {
-        FIXME("Source and destination sizes do not match.\n");
+        FIXME("Source (%d, %d, %d) and destination (%d, %d, %d) sizes do not match.\n",
+              src_volume->resource.width, src_volume->resource.height, src_volume->resource.depth, 
+              dst_volume->resource.width, dst_volume->resource.height, dst_volume->resource.depth);
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY)))
+  if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY))) {
+    FIXME("wined3d_volume_map failed\n");
         return hr;
+  }
 
     context = context_acquire(device, NULL);
 
@@ -3561,18 +3824,18 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    /* Check that both textures have the identical numbers of levels. */
-    level_count = wined3d_texture_get_level_count(src_texture);
-    if (wined3d_texture_get_level_count(dst_texture) != level_count)
+    /* Check that both textures have the compatible numbers of levels. */
+    level_count = wined3d_texture_get_level_count(dst_texture);
+    if (wined3d_texture_get_level_count(src_texture) < level_count)
     {
-        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
+        WARN("Source has fewer level counts then destination, returning WINED3DERR_INVALIDCALL.\n");
         return WINED3DERR_INVALIDCALL;
-    }
-
+    } 
     /* Make sure that the destination texture is loaded. */
     context = context_acquire(device, NULL);
     wined3d_texture_load(dst_texture, context, FALSE);
     context_release(context);
+#endif /* STAGING_CSMT */
 
     /* Update every surface level of the texture. */
     switch (type)
@@ -3586,12 +3849,16 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
+#if defined(STAGING_CSMT)
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
+#else  /* STAGING_CSMT */
                 hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
                 if (FAILED(hr))
                 {
                     WARN("Failed to update surface, hr %#x.\n", hr);
                     return hr;
                 }
+#endif /* STAGING_CSMT */
             }
             break;
         }
@@ -3605,12 +3872,16 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
+#if defined(STAGING_CSMT)
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
+#else  /* STAGING_CSMT */
                 hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
                 if (FAILED(hr))
                 {
                     WARN("Failed to update surface, hr %#x.\n", hr);
                     return hr;
                 }
+#endif /* STAGING_CSMT */
             }
             break;
         }
@@ -3619,12 +3890,70 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         {
             for (i = 0; i < level_count; ++i)
             {
+#if defined(STAGING_CSMT)
+                device_update_volume(context,
+                        volume_from_resource(wined3d_texture_get_sub_resource(src_texture, i)),
+                        volume_from_resource(wined3d_texture_get_sub_resource(dst_texture, i)));
+            }
+            break;
+        }
+
+        default:
+            FIXME("Unsupported texture type %#x.\n", type);
+            return;
+    }
+}
+
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    enum wined3d_resource_type type;
+    unsigned int level_count;
+
+    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
+
+    /* Verify that the source and destination textures are non-NULL. */
+    if (!src_texture || !dst_texture)
+    {
+        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
+    {
+        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
+    {
+        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Verify that the source and destination textures are the same type. */
+    type = src_texture->resource.type;
+    if (dst_texture->resource.type != type)
+    {
+        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Check that both textures have the identical numbers of levels. */
+    level_count = wined3d_texture_get_level_count(dst_texture);
+    if (wined3d_texture_get_level_count(src_texture) < level_count)
+    {
+        WARN("Source has fewer level counts then destination, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+#else  /* STAGING_CSMT */
                 hr = device_update_volume(device,
                         volume_from_resource(wined3d_texture_get_sub_resource(src_texture, i)),
                         volume_from_resource(wined3d_texture_get_sub_resource(dst_texture, i)));
                 if (FAILED(hr))
                 {
-                    WARN("Failed to update volume, hr %#x.\n", hr);
+                    FIXME("Failed to update volume, hr %#x.\n", hr);
                     return hr;
                 }
             }
@@ -3635,6 +3964,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             FIXME("Unsupported texture type %#x.\n", type);
             return WINED3DERR_INVALIDCALL;
     }
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -3697,8 +4027,13 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_rendertarget_view *rt = state->fb.render_targets[0];
+        struct wined3d_rendertarget_view *ds = state->fb.depth_stencil;
+#else  /* STAGING_CSMT */
         struct wined3d_rendertarget_view *rt = device->fb.render_targets[0];
         struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+#endif /* STAGING_CSMT */
 
         if (ds && rt && (ds->width < rt->width || ds->height < rt->height))
         {
@@ -3795,6 +4130,15 @@ HRESULT CDECL wined3d_device_update_surface(struct wined3d_device *device,
         struct wined3d_surface *src_surface, const RECT *src_rect,
         struct wined3d_surface *dst_surface, const POINT *dst_point)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_format *src_format = src_surface->resource.format;
+    const struct wined3d_format *dst_format = dst_surface->resource.format;
+    UINT update_w, update_h;
+    UINT dst_w, dst_h;
+    RECT r, dst_rect;
+    POINT p;
+
+#endif /* STAGING_CSMT */
     TRACE("device %p, src_surface %p, src_rect %s, dst_surface %p, dst_point %s.\n",
             device, src_surface, wine_dbgstr_rect(src_rect),
             dst_surface, wine_dbgstr_point(dst_point));
@@ -3806,7 +4150,72 @@ HRESULT CDECL wined3d_device_update_surface(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
+    if (src_format->id != dst_format->id)
+    {
+        WARN("Source and destination surfaces should have the same format.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!dst_point)
+    {
+        p.x = 0;
+        p.y = 0;
+        dst_point = &p;
+    }
+    else if (dst_point->x < 0 || dst_point->y < 0)
+    {
+        WARN("Invalid destination point.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!src_rect)
+    {
+        r.left = 0;
+        r.top = 0;
+        r.right = src_surface->resource.width;
+        r.bottom = src_surface->resource.height;
+        src_rect = &r;
+    }
+    else if (src_rect->left < 0 || src_rect->left >= src_rect->right
+            || src_rect->top < 0 || src_rect->top >= src_rect->bottom)
+    {
+        WARN("Invalid source rectangle.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    dst_w = dst_surface->resource.width;
+    dst_h = dst_surface->resource.height;
+
+    update_w = src_rect->right - src_rect->left;
+    update_h = src_rect->bottom - src_rect->top;
+
+    if (update_w > dst_w || dst_point->x > dst_w - update_w
+            || update_h > dst_h || dst_point->y > dst_h - update_h)
+    {
+        WARN("Destination out of bounds.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if ((src_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(src_surface, src_rect))
+    {
+        WARN("Source rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    SetRect(&dst_rect, dst_point->x, dst_point->y, dst_point->x + update_w, dst_point->y + update_h);
+    if ((dst_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(dst_surface, &dst_rect))
+    {
+        WARN("Destination rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_surface(device->cs, src_surface, src_rect, dst_surface, dst_point);
+
+    return WINED3D_OK;
+#else  /* STAGING_CSMT */
     return surface_upload_from_surface(dst_surface, dst_point, src_surface, src_rect);
+#endif /* STAGING_CSMT */
 }
 
 void CDECL wined3d_device_copy_resource(struct wined3d_device *device,
@@ -3885,6 +4294,10 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
 {
     struct wined3d_resource *resource;
     RECT r;
+  
+  if (!color || !view) {
+    return WINED3DERR_INVALIDCALL;
+  }
 
     TRACE("device %p, view %p, rect %s, color {%.8e, %.8e, %.8e, %.8e}.\n",
             device, view, wine_dbgstr_rect(rect), color->r, color->g, color->b, color->a);
@@ -3908,9 +4321,14 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
         rect = &r;
     }
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_clear_rtv(device->cs, view, rect, color);
+    return WINED3D_OK;
+#else  /* STAGING_CSMT */
     resource = wined3d_texture_get_sub_resource(wined3d_texture_from_resource(resource), view->sub_resource_idx);
 
     return surface_color_fill(surface_from_resource(resource), rect, color);
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -3924,6 +4342,23 @@ struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(co
         return NULL;
     }
 
+#if defined(STAGING_CSMT)
+    return device->state.fb.render_targets[view_idx];
+}
+
+struct wined3d_rendertarget_view * CDECL wined3d_device_get_depth_stencil_view(const struct wined3d_device *device)
+{
+    TRACE("device %p.\n", device);
+
+    return device->state.fb.depth_stencil;
+}
+
+HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device,
+        unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
+{
+    struct wined3d_rendertarget_view *prev;
+    struct wined3d_fb_state *fb = &device->state.fb;
+#else  /* STAGING_CSMT */
     return device->fb.render_targets[view_idx];
 }
 
@@ -3938,6 +4373,7 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
         unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
 {
     struct wined3d_rendertarget_view *prev;
+#endif /* STAGING_CSMT */
 
     TRACE("device %p, view_idx %u, view %p, set_viewport %#x.\n",
             device, view_idx, view, set_viewport);
@@ -3977,6 +4413,15 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     }
 
 
+#if defined(STAGING_CSMT)
+    prev = fb->render_targets[view_idx];
+    if (view == prev)
+        return WINED3D_OK;
+
+    if (view)
+        wined3d_rendertarget_view_incref(view);
+    fb->render_targets[view_idx] = view;
+#else  /* STAGING_CSMT */
     prev = device->fb.render_targets[view_idx];
     if (view == prev)
         return WINED3D_OK;
@@ -3984,6 +4429,7 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     if (view)
         wined3d_rendertarget_view_incref(view);
     device->fb.render_targets[view_idx] = view;
+#endif /* STAGING_CSMT */
     wined3d_cs_emit_set_rendertarget_view(device->cs, view_idx, view);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -3995,6 +4441,32 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
 
 void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device, struct wined3d_rendertarget_view *view)
 {
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state *fb = &device->state.fb;
+    struct wined3d_rendertarget_view *prev;
+
+    TRACE("device %p, view %p.\n", device, view);
+
+    prev = fb->depth_stencil;
+    if (prev == view)
+    {
+        TRACE("Trying to do a NOP SetRenderTarget operation.\n");
+        return;
+    }
+
+    if ((fb->depth_stencil = view))
+        wined3d_rendertarget_view_incref(view);
+    wined3d_cs_emit_set_depth_stencil_view(device->cs, view);
+    if (prev)
+        wined3d_rendertarget_view_decref(prev);
+}
+
+HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device,
+        UINT x_hotspot, UINT y_hotspot, struct wined3d_surface *cursor_image)
+{
+    TRACE("device %p, x_hotspot %u, y_hotspot %u, cursor_image %p.\n",
+            device, x_hotspot, y_hotspot, cursor_image);
+#else  /* STAGING_CSMT */
     struct wined3d_rendertarget_view *prev;
 
     TRACE("device %p, view %p.\n", device, view);
@@ -4066,6 +4538,7 @@ HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device
         wined3d_texture_decref(device->cursor_texture);
         device->cursor_texture = NULL;
     }
+#endif /* STAGING_CSMT */
 
     if (cursor_image)
     {
@@ -4101,11 +4574,16 @@ HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device
          * release it after setting the cursor image. Windows doesn't
          * addref the set surface, so we can't do this either without
          * creating circular refcount dependencies. */
+#if defined(STAGING_CSMT)
+        device->cursorWidth = cursor_image->resource.width;
+        device->cursorHeight = cursor_image->resource.height;
+#else  /* STAGING_CSMT */
         if (!(device->cursor_texture = wined3d_device_create_cursor_texture(device, cursor_image)))
         {
             ERR("Failed to create cursor texture.\n");
             return WINED3DERR_INVALIDCALL;
         }
+#endif /* STAGING_CSMT */
 
         device->cursorWidth = cursor_image->resource.width;
         device->cursorHeight = cursor_image->resource.height;
@@ -4205,10 +4683,12 @@ BOOL CDECL wined3d_device_show_cursor(struct wined3d_device *device, BOOL show)
         else
             SetCursor(NULL);
     }
+#if !defined(STAGING_CSMT)
     else if (device->cursor_texture)
     {
         device->bCursorVisible = show;
     }
+#endif /* STAGING_CSMT */
 
     return oldVisible;
 }
@@ -4219,6 +4699,10 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
 
     TRACE("device %p.\n", device);
 
+#if defined(STAGING_CSMT)
+    /* The resource list is manged by the main thread, iterate here and emit commands for
+     * each resource */
+#endif /* STAGING_CSMT */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -4226,6 +4710,28 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
+#if defined(STAGING_CSMT)
+            wined3d_cs_emit_evict_resource(device->cs, resource);
+        }
+    }
+}
+
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_shader *shader;
+
+    LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
+    {
+        device->shader_backend->shader_destroy(shader);
+    }
+
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    wine_rb_clear(&device->samplers, device_free_sampler, NULL);
+#else  /* STAGING_CSMT */
             resource->resource_ops->resource_unload(resource);
         }
     }
@@ -4255,6 +4761,7 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
     {
         device->shader_backend->shader_destroy(shader);
     }
+#endif /* STAGING_CSMT */
 
     if (device->depth_blt_texture)
     {
@@ -4275,12 +4782,34 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+#if defined(STAGING_CSMT)
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
+}
+
+static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+#else  /* STAGING_CSMT */
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
     struct wined3d_context *context;
     struct wined3d_surface *target;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4297,6 +4826,18 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
         return hr;
     }
 
+#if defined(STAGING_CSMT)
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
+    {
+        WARN("Failed to create context.\n");
+        device->blitter->free_private(device);
+        device->shader_backend->shader_free_private(device);
+        return hr;
+    }
+
+    wined3d_cs_emit_create_dummy_textures(device->cs);
+#else  /* STAGING_CSMT */
     /* Recreate the primary swapchain's context */
     swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
     if (!swapchain->context)
@@ -4323,6 +4864,7 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
     swapchain->num_contexts = 1;
     create_dummy_textures(device, context);
     context_release(context);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4343,6 +4885,10 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     unsigned int i;
 
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p.\n", device, swapchain_desc, mode, callback);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_glfinish(device->cs);
+    device->cs->ops->finish(device->cs);
+#endif /* STAGING_CSMT */
 
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
@@ -4358,6 +4904,11 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
             wined3d_texture_decref(device->logo_texture);
             device->logo_texture = NULL;
         }
+#if defined(STAGING_CSMT)
+    }
+
+    if (device->state.fb.render_targets)
+#else  /* STAGING_CSMT */
         if (device->cursor_texture)
         {
             wined3d_texture_decref(device->cursor_texture);
@@ -4367,6 +4918,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
 
     if (device->fb.render_targets)
+#endif /* STAGING_CSMT */
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -4375,10 +4927,22 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     wined3d_device_set_depth_stencil_view(device, NULL);
 
+#if defined(STAGING_CSMT)
+    if (reset_state)
+    {
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->cs->onscreen_depth_stencil)
+    {
+        wined3d_surface_decref(device->cs->onscreen_depth_stencil);
+        device->cs->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
     if (device->onscreen_depth_stencil)
     {
         wined3d_surface_decref(device->onscreen_depth_stencil);
         device->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
     }
 
     if (reset_state)
@@ -4391,6 +4955,29 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
     }
 
+#if defined(STAGING_CSMT)
+    /* Free implicit resources and wait for the command stream before modifying
+     * swapchain parameters. After modifying the swapchain parameters a new GL
+     * context may be acquired by the worker thread. This causes problems in the
+     * d3d8/9 test that passes a hidden window as the new device window.
+     * SetPixelFormat will call SetWindowPos inside the X11 driver, which sends
+     * a message to the window to query the icon. Since the worker thread is
+     * not the thread that created the window and the d3d8 test does not run
+     * an event loop this deadlocks. Set up the window first from the main thread
+     * before calling SetPixelFormat from the worker thread to avoid this. */
+    if (device->auto_depth_stencil_view)
+    {
+        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
+        device->auto_depth_stencil_view = NULL;
+    }
+    if (device->back_buffer_view)
+    {
+        wined3d_rendertarget_view_decref(device->back_buffer_view);
+        device->back_buffer_view = NULL;
+    }
+    device->cs->ops->finish(device->cs);
+
+#endif /* STAGING_CSMT */
     /* Is it necessary to recreate the gl context? Actually every setting can be changed
      * on an existing gl context, so there's no real need for recreation.
      *
@@ -4532,11 +5119,13 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
     }
 
+#if !defined(STAGING_CSMT)
     if (device->auto_depth_stencil_view)
     {
         wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
         device->auto_depth_stencil_view = NULL;
     }
+#endif /* STAGING_CSMT */
     if (swapchain->desc.enable_auto_depth_stencil)
     {
         struct wined3d_resource_desc surface_desc;
@@ -4574,11 +5163,13 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         wined3d_device_set_depth_stencil_view(device, device->auto_depth_stencil_view);
     }
 
+#if !defined(STAGING_CSMT)
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
         device->back_buffer_view = NULL;
     }
+#endif /* STAGING_CSMT */
     if (swapchain->desc.backbuffer_count && FAILED(hr = wined3d_rendertarget_view_create_from_surface(
             surface_from_resource(wined3d_texture_get_sub_resource(swapchain->back_buffers[0], 0)),
             NULL, &wined3d_null_parent_ops, &device->back_buffer_view)))
@@ -4661,11 +5252,20 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
         wined3d_cs_emit_reset_state(device->cs);
         state_cleanup(&device->state);
+#if defined(STAGING_CSMT)
+        memset(&device->state, 0, sizeof(device->state));
+
+        if (device->d3d_initialized)
+            delete_opengl_contexts(device, swapchain);
+
+        if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
+#else  /* STAGING_CSMT */
 
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
         if (FAILED(hr = state_init(&device->state, &device->fb, &device->adapter->gl_info,
+#endif /* STAGING_CSMT */
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
         device->update_state = &device->state;
@@ -4674,6 +5274,23 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     else if (device->back_buffer_view)
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_state *state = &device->state;
+
+        wined3d_device_set_rendertarget_view(device, 0, device->back_buffer_view, FALSE);
+
+        /* Note the min_z / max_z is not reset. */
+        state->viewport.x = 0;
+        state->viewport.y = 0;
+        state->viewport.width = swapchain->desc.backbuffer_width;
+        state->viewport.height = swapchain->desc.backbuffer_height;
+        wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
+
+        state->scissor_rect.top = 0;
+        state->scissor_rect.left = 0;
+        state->scissor_rect.right = swapchain->desc.backbuffer_width;
+        state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
+#else  /* STAGING_CSMT */
         struct wined3d_rendertarget_view *view = device->back_buffer_view;
         struct wined3d_state *state = &device->state;
 
@@ -4690,6 +5307,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         state->scissor_rect.left = 0;
         state->scissor_rect.right = view->width;
         state->scissor_rect.bottom = view->height;
+#endif /* STAGING_CSMT */
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
@@ -4768,8 +5386,10 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
     TRACE("device %p, resource %p, type %s.\n", device, resource, debug_d3dresourcetype(type));
 
+#if !defined(STAGING_CSMT)
     context_resource_released(device, resource, type);
 
+#endif /* STAGING_CSMT */
     switch (type)
     {
         case WINED3D_RTYPE_SURFACE:
@@ -4780,6 +5400,19 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
                 for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
                 {
+#if defined(STAGING_CSMT)
+                    if (wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[i]) == surface)
+                    {
+                        ERR("Surface %p is still in use as render target %u.\n", surface, i);
+                        device->state.fb.render_targets[i] = NULL;
+                    }
+                }
+
+                if (wined3d_rendertarget_view_get_surface(device->state.fb.depth_stencil) == surface)
+                {
+                    ERR("Surface %p is still in use as depth/stencil buffer.\n", surface);
+                    device->state.fb.depth_stencil = NULL;
+#else  /* STAGING_CSMT */
                     if (wined3d_rendertarget_view_get_surface(device->fb.render_targets[i]) == surface)
                     {
                         ERR("Surface %p is still in use as render target %u.\n", surface, i);
@@ -4791,6 +5424,7 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
                 {
                     ERR("Surface %p is still in use as depth/stencil buffer.\n", surface);
                     device->fb.depth_stencil = NULL;
+#endif /* STAGING_CSMT */
                 }
             }
             break;
@@ -4953,7 +5587,11 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
+#if defined(STAGING_CSMT)
+    if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
+#else  /* STAGING_CSMT */
     if (FAILED(hr = state_init(&device->state, &device->fb, &adapter->gl_info,
+#endif /* STAGING_CSMT */
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
@@ -5052,3 +5690,58 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+#if defined(STAGING_CSMT)
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffers(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBuffer(type_hint, ret->name));
+    GL_EXTCALL(glBufferData(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBuffer(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffers(1, &bo->name));
+    checkGLcall("glDeleteBuffers");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index 01048fd..db282c2 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -112,6 +112,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_color_buffer_float",           ARB_COLOR_BUFFER_FLOAT        },
     {"GL_ARB_debug_output",                 ARB_DEBUG_OUTPUT              },
     {"GL_ARB_depth_buffer_float",           ARB_DEPTH_BUFFER_FLOAT        },
+    {"GL_ARB_depth_clamp",                  ARB_DEPTH_CLAMP               },
     {"GL_ARB_depth_texture",                ARB_DEPTH_TEXTURE             },
     {"GL_ARB_draw_buffers",                 ARB_DRAW_BUFFERS              },
     {"GL_ARB_draw_elements_base_vertex",    ARB_DRAW_ELEMENTS_BASE_VERTEX },
@@ -145,6 +146,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_ARB_texture_compression",          ARB_TEXTURE_COMPRESSION       },
     {"GL_ARB_texture_compression_rgtc",     ARB_TEXTURE_COMPRESSION_RGTC  },
     {"GL_ARB_texture_cube_map",             ARB_TEXTURE_CUBE_MAP          },
+    {"GL_ARB_texture_env_add",              ARB_TEXTURE_ENV_ADD           },
     {"GL_ARB_texture_env_combine",          ARB_TEXTURE_ENV_COMBINE       },
     {"GL_ARB_texture_env_dot3",             ARB_TEXTURE_ENV_DOT3          },
     {"GL_ARB_texture_float",                ARB_TEXTURE_FLOAT             },
@@ -183,6 +185,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_gpu_program_parameters",       EXT_GPU_PROGRAM_PARAMETERS    },
     {"GL_EXT_gpu_shader4",                  EXT_GPU_SHADER4               },
     {"GL_EXT_packed_depth_stencil",         EXT_PACKED_DEPTH_STENCIL      },
+    {"GL_EXT_paletted_texture",             EXT_PALETTED_TEXTURE          },//ns
     {"GL_EXT_point_parameters",             EXT_POINT_PARAMETERS          },
     {"GL_EXT_provoking_vertex",             EXT_PROVOKING_VERTEX          },
     {"GL_EXT_secondary_color",              EXT_SECONDARY_COLOR           },
@@ -191,6 +194,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_texture3D",                    EXT_TEXTURE3D                 },
     {"GL_EXT_texture_compression_rgtc",     EXT_TEXTURE_COMPRESSION_RGTC  },
     {"GL_EXT_texture_compression_s3tc",     EXT_TEXTURE_COMPRESSION_S3TC  },
+    {"GL_EXT_texture_env_add",              EXT_TEXTURE_ENV_ADD           },
     {"GL_EXT_texture_env_combine",          EXT_TEXTURE_ENV_COMBINE       },
     {"GL_EXT_texture_env_dot3",             EXT_TEXTURE_ENV_DOT3          },
     {"GL_EXT_texture_filter_anisotropic",   EXT_TEXTURE_FILTER_ANISOTROPIC},
@@ -202,6 +206,7 @@ static const struct wined3d_extension_map gl_extension_map[] =
     {"GL_EXT_vertex_array_bgra",            EXT_VERTEX_ARRAY_BGRA         },
 
     /* NV */
+    {"GL_NV_depth_clamp",                   NV_DEPTH_CLAMP                },
     {"GL_NV_fence",                         NV_FENCE                      },
     {"GL_NV_fog_distance",                  NV_FOG_DISTANCE               },
     {"GL_NV_fragment_program",              NV_FRAGMENT_PROGRAM           },
@@ -612,6 +617,47 @@ static BOOL match_not_dx10_capable(const struct wined3d_gl_info *gl_info, const
     return !match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device);
 }
 
+
+static BOOL match_apple_broken_uniforms(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
+                                        enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
+{
+    const char *sysrelease;
+    unsigned int major, minor, ret;
+    void (CDECL *my_wine_get_host_version)(const char **sysname, const char **release);
+
+    /* MacOS dx9 GPU drivers more GLSL vertex shader uniforms than supported by the hardware, and if
+     * more are used it falls back to software. While the compiler can detect if the shader uses all
+     * declared uniforms, the optimization fails if the shader uses relative addressing. So any GLSL
+     * shader using relative addressing falls back to software.
+     *
+     * ARB vp gives the correct amount of uniforms, so use it instead of GLSL.
+     *
+     * In addition, AMD Radeon HD GPUs advertise > 256 constants and can support this in HW, but the
+     * driver nevertheless falls back to software if more than 256 are used. This is fixed in MacOS
+     * 10.8.3 */
+
+    /* Non-Apple GL vendors report uniforms correctly */
+    if (!match_apple(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return FALSE;
+    /* All dx9 cards are overreported on OSX */
+    if (!match_dx10_capable(gl_info, gl_renderer, gl_vendor, card_vendor, device)) return TRUE;
+    /* Nvidia and Intel DX10 cards support > 256 uniforms */
+    if (card_vendor != HW_VENDOR_AMD) return FALSE;
+
+    /* On OSX 10.8.3 and later, AMD GPUs support more than 256 constants. This OSX version reports
+     * uname -r "12.3.0" */
+    my_wine_get_host_version = (void *)GetProcAddress(GetModuleHandleA("ntdll.dll"), "wine_get_host_version");
+    if (!my_wine_get_host_version) return FALSE;
+
+    my_wine_get_host_version(NULL, &sysrelease);
+    ret = sscanf(sysrelease, "%u.%u", &major, &minor);
+  TRACE("host version %s\n", sysrelease);
+    if (ret != 2) return FALSE; /* String format changed, assume workaround not needed */
+    if (major > 12) return FALSE;
+    if (major == 12 && minor >= 3) return FALSE;
+
+    return TRUE;
+}
+
 /* A GL context is provided by the caller */
 static BOOL match_allows_spec_alpha(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
@@ -766,6 +812,18 @@ static BOOL match_fglrx(const struct wined3d_gl_info *gl_info, const char *gl_re
     return gl_vendor == GL_VENDOR_FGLRX;
 }
 
+static void quirk_arb_constants(struct wined3d_gl_info *gl_info)
+{
+    TRACE("Using ARB vs constant limit(%u->%u) for GLSL.\n", 
+    gl_info->limits.glsl_vs_float_constants,
+    gl_info->limits.arb_vs_native_constants);
+    gl_info->limits.glsl_vs_float_constants = gl_info->limits.arb_vs_native_constants;
+    TRACE("Using ARB ps constant limit(%u->%u) for GLSL.\n",
+    gl_info->limits.glsl_ps_float_constants,
+    gl_info->limits.arb_ps_native_constants);
+    gl_info->limits.glsl_ps_float_constants = gl_info->limits.arb_ps_native_constants;
+}
+
 static BOOL match_r200(const struct wined3d_gl_info *gl_info, const char *gl_renderer,
         enum wined3d_gl_vendor gl_vendor, enum wined3d_pci_vendor card_vendor, enum wined3d_pci_device device)
 {
@@ -874,8 +932,19 @@ static void quirk_apple_glsl_constants(struct wined3d_gl_info *gl_info)
     /* MacOS needs uniforms for relative addressing offsets. This can accumulate to quite a few uniforms.
      * Beyond that the general uniform isn't optimal, so reserve a number of uniforms. 12 vec4's should
      * allow 48 different offsets or other helper immediate values. */
-    TRACE("Reserving 12 GLSL constants for compiler private use.\n");
+    //other match_apple quirks
+  if ( wined3d_settings.user_quirks & 1) {
+    gl_info->quirks |= WINED3D_CX_QUIRK_BLIT;
+  }
+  if ( wined3d_settings.user_quirks & 2) {
+    gl_info->quirks |= WINED3D_QUIRK_NO_DXTN;
+  }
+  if ( wined3d_settings.user_quirks & 4) {
+    FIXME("Reserving 12 GLSL constants for compiler private use.\n");
     gl_info->reserved_glsl_constants = max(gl_info->reserved_glsl_constants, 12);
+  }
+  FIXME("There are %d GLSL constants reserved\n", gl_info->reserved_glsl_constants);
+
 }
 
 static void quirk_amd_dx9(struct wined3d_gl_info *gl_info)
@@ -935,8 +1004,10 @@ static void quirk_texcoord_w(struct wined3d_gl_info *gl_info)
      * all radeon cards on Macs and whitelist the good ones. That way we're prepared for the future. If
      * this workaround is activated on cards that do not need it, it won't break things, just affect
      * performance negatively. */
-    TRACE("Enabling vertex texture coord fixes in vertex shaders.\n");
+  if ( wined3d_settings.user_quirks & 8) {
+    FIXME("Enabling vertex texture coord fixes in vertex shaders.\n");
     gl_info->quirks |= WINED3D_QUIRK_SET_TEXCOORD_W;
+  }
 }
 
 static void quirk_clip_varying(struct wined3d_gl_info *gl_info)
@@ -1201,6 +1272,7 @@ static const struct gpu_description gpu_description_table[] =
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_6600GT,     "NVIDIA GeForce 6600 GT",           DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_6800,       "NVIDIA GeForce 6800",              DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7300,       "NVIDIA GeForce Go 7300",           DRIVER_NVIDIA_GEFORCE6,  256 },
+    {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7300LE,       "NVIDIA GeForce 7300LE",           DRIVER_NVIDIA_GEFORCE6,  128 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7400,       "NVIDIA GeForce Go 7400",           DRIVER_NVIDIA_GEFORCE6,  256 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7600,       "NVIDIA GeForce 7600 GT",           DRIVER_NVIDIA_GEFORCE6,  256 },
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_7800GT,     "NVIDIA GeForce 7800 GT",           DRIVER_NVIDIA_GEFORCE6,  256 },
@@ -1395,7 +1467,7 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
 {
     OSVERSIONINFOW os_version;
     WORD driver_os_version;
-    enum wined3d_display_driver driver;
+    enum wined3d_display_driver driver = DRIVER_UNKNOWN;
     enum wined3d_driver_model driver_model;
     const struct driver_version_information *version_info;
     const struct gpu_description *gpu_desc;
@@ -1427,6 +1499,10 @@ static void init_driver_info(struct wined3d_driver_info *driver_info,
     driver_info->vendor = vendor;
     driver_info->device = device;
 
+    /* Set a default amount of video memory (64MB). In general this code isn't used unless the user
+     * overrides the pci ids to a card which is not in our database. */
+    driver_info->vram_bytes = WINE_DEFAULT_VIDMEM;
+
     memset(&os_version, 0, sizeof(os_version));
     os_version.dwOSVersionInfoSize = sizeof(os_version);
     if (!GetVersionExW(&os_version))
@@ -1795,7 +1871,8 @@ cards_nvidia_binary[] =
     {"7700",                        CARD_NVIDIA_GEFORCE_7600},      /* Geforce 7 - midend */
     {"7600",                        CARD_NVIDIA_GEFORCE_7600},      /* Geforce 7 - midend */
     {"7400",                        CARD_NVIDIA_GEFORCE_7400},      /* Geforce 7 - lower medium */
-    {"7300",                        CARD_NVIDIA_GEFORCE_7300},      /* Geforce 7 - lowend */
+    {"7300 LE",      CARD_NVIDIA_GEFORCE_7300LE},    /* Geforce 7 - lowend */
+    {"7300",        CARD_NVIDIA_GEFORCE_7300},      /* Geforce 7 - go */
     {"6800",                        CARD_NVIDIA_GEFORCE_6800},      /* Geforce 6 - highend */
     {"6700",                        CARD_NVIDIA_GEFORCE_6600GT},    /* Geforce 6 - midend */
     {"6610",                        CARD_NVIDIA_GEFORCE_6600GT},    /* Geforce 6 - midend */
@@ -1832,6 +1909,28 @@ cards_nvidia_binary[] =
  * eg HD 4800 is returned for multiple cards, even for RV790 based ones. */
 cards_amd_binary[] =
 {
+    /* by family name */
+    {"Hawaii",                      CARD_AMD_RADEON_R9    },
+    {"Kaveri",                      CARD_AMD_RADEON_R7    },
+    {"Kabini",                      CARD_AMD_RADEON_R3    },
+    {"Bonair",                      CARD_AMD_RADEON_HD8770},
+    /* Southern Islands */
+    {"Oland",                       CARD_AMD_RADEON_HD8670},
+    {"Hainan",                      CARD_AMD_RADEON_HD8600M},
+    {"Tahiti",                      CARD_AMD_RADEON_HD7900},
+    {"Pitcairn",                    CARD_AMD_RADEON_HD7800},
+    {"Verde",                       CARD_AMD_RADEON_HD7700},
+    /* Northern Islands */
+    {"Cayman",                      CARD_AMD_RADEON_HD6900},
+    {"Barts",                       CARD_AMD_RADEON_HD6800},
+    {"Turks",                       CARD_AMD_RADEON_HD6600},
+    {"Caicos",                      CARD_AMD_RADEON_HD6400},
+    /* Evergreen */
+    {"Hemlock",                     CARD_AMD_RADEON_HD5900},
+    {"Cypress",                     CARD_AMD_RADEON_HD5800},
+    {"Juniper",                     CARD_AMD_RADEON_HD5700},
+    {"Redwood",                     CARD_AMD_RADEON_HD5600},
+    {"Cedar",                       CARD_AMD_RADEON_HD5400},
     /* Southern Islands */
     {"HD 7900",                     CARD_AMD_RADEON_HD7900},
     {"HD 7800",                     CARD_AMD_RADEON_HD7800},
@@ -1926,10 +2025,12 @@ cards_intel[] =
     {"Ivybridge Server",            CARD_INTEL_IVBS},
     {"Ivybridge Mobile",            CARD_INTEL_IVBM},
     {"Ivybridge Desktop",           CARD_INTEL_IVBD},
+    {"Intel HD Graphics 4000",      CARD_INTEL_IVBM},
     /* Sandybridge */
     {"Sandybridge Server",          CARD_INTEL_SNBS},
     {"Sandybridge Mobile",          CARD_INTEL_SNBM},
     {"Sandybridge Desktop",         CARD_INTEL_SNBD},
+    {"Intel HD Graphics 3000",      CARD_INTEL_SNBM},
     /* Ironlake */
     {"Ironlake Mobile",             CARD_INTEL_ILKM},
     {"Ironlake Desktop",            CARD_INTEL_ILKD},
@@ -3529,6 +3630,17 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
 
     wined3d_adapter_init_limits(gl_info);
 
+  gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
+  card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
+  TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
+  
+  device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version, gl_renderer_str, &gl_vendor, &card_vendor);
+  TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
+
+  if (match_apple_broken_uniforms(gl_info, gl_renderer_str, gl_vendor, card_vendor, device)) {
+    quirk_arb_constants(gl_info);
+  }
+
     if (gl_info->supported[ARB_VERTEX_PROGRAM] && test_arb_vs_offset_limit(gl_info))
         gl_info->quirks |= WINED3D_QUIRK_ARB_VS_OFFSET_LIMIT;
 
@@ -3630,12 +3742,6 @@ static BOOL wined3d_adapter_init_gl_caps(struct wined3d_adapter *adapter)
         }
     }
 
-    gl_vendor = wined3d_guess_gl_vendor(gl_info, gl_vendor_str, gl_renderer_str);
-    card_vendor = wined3d_guess_card_vendor(gl_vendor_str, gl_renderer_str);
-    TRACE("Found GL_VENDOR (%s)->(0x%04x/0x%04x).\n", debugstr_a(gl_vendor_str), gl_vendor, card_vendor);
-
-    device = wined3d_guess_card(&shader_caps, &fragment_caps, gl_info->glsl_version, gl_renderer_str, &gl_vendor, &card_vendor);
-    TRACE("Found (fake) card: 0x%x (vendor id), 0x%x (device id).\n", card_vendor, device);
 
     gl_info->wrap_lookup[WINED3D_TADDRESS_WRAP - WINED3D_TADDRESS_WRAP] = GL_REPEAT;
     gl_info->wrap_lookup[WINED3D_TADDRESS_MIRROR - WINED3D_TADDRESS_WRAP] =
@@ -4139,7 +4245,8 @@ static BOOL wined3d_check_pixel_format_depth(const struct wined3d_gl_info *gl_in
     /* Float formats need FBOs. If FBOs are used this function isn't called */
     if (format->flags & WINED3DFMT_FLAG_FLOAT) return FALSE;
 
-    if ((format->id == WINED3DFMT_D16_LOCKABLE) || (format->id == WINED3DFMT_D32_FLOAT))
+    if ((format->id == WINED3DFMT_D16_LOCKABLE) || (format->id == WINED3DFMT_D32_FLOAT) ||
+        (format->id == WINED3DFMT_D32_LOCKABLE) || (format->id == WINED3DFMT_S8_LOCKABLE))
         lockable = TRUE;
 
     /* On some modern cards like the Geforce8/9 GLX doesn't offer some dephthstencil formats which D3D9 reports.
@@ -4237,9 +4344,16 @@ HRESULT CDECL wined3d_check_device_multisample_type(const struct wined3d *wined3
 
     if (quality_levels)
     {
-        if (multisample_type == WINED3D_MULTISAMPLE_NON_MASKABLE)
-            /* FIXME: This is probably wrong. */
+        if (wined3d_settings.msaa_quality_levels)
+        {
+            *quality_levels = wined3d_settings.msaa_quality_levels;
+            TRACE("Overriding MSAA quality levels to %i\n", *quality_levels);
+        }
+        else if (multisample_type == WINED3D_MULTISAMPLE_NON_MASKABLE)
+        {
             *quality_levels = gl_info->limits.samples;
+            WARN("probably wrong, setting quality_levels to %d\n", *quality_levels);
+        }
         else
             *quality_levels = 1;
     }
@@ -4500,6 +4614,7 @@ HRESULT CDECL wined3d_check_device_format(const struct wined3d *wined3d, UINT ad
                 case WINED3DFMT_DXT4:
                 case WINED3DFMT_DXT5:
                     TRACE("[FAILED] - DXTn does not support 3D textures.\n");
+                if (gl_info->quirks & WINED3D_QUIRK_NO_DXTN)
                     return WINED3DERR_NOTAVAILABLE;
 
                 default:
@@ -5345,9 +5460,15 @@ static void WINE_GLAPI invalid_texcoord_func(GLenum unit, const void *data)
     DebugBreak();
 }
 
+#if defined(STAGING_CSMT)
+/* Helper functions for providing vertex data to opengl. The arrays are initialized based on
+ * the extension detection and are used in draw_strided_slow
+ */
+#else  /* STAGING_CSMT */
 /* Helper functions for providing vertex data to opengl. The arrays are initialized based on
  * the extension detection and are used in drawStridedSlow
  */
+#endif /* STAGING_CSMT */
 static void WINE_GLAPI position_d3dcolor(const void *data)
 {
     DWORD pos = *((const DWORD *)data);
@@ -5763,7 +5884,7 @@ static void wined3d_adapter_init_nogl(struct wined3d_adapter *adapter, UINT ordi
 {
     DISPLAY_DEVICEW display_device;
 
-    memset(adapter, 0, sizeof(*adapter));
+    memset(adapter, 0, sizeof(struct wined3d_adapter));
     adapter->ordinal = ordinal;
     adapter->monitorPoint.x = -1;
     adapter->monitorPoint.y = -1;
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
index c0654a6..238b051 100644
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -36,7 +36,11 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 #include <math.h>
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+static void draw_strided_fast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
+#else  /* STAGING_CSMT */
 static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
+#endif /* STAGING_CSMT */
         const void *idx_data, UINT start_idx, INT base_vertex_index, UINT start_instance, UINT instance_count)
 {
     if (idx_size)
@@ -95,7 +99,11 @@ static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primit
  */
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+static void draw_strided_slow(const struct wined3d_state *state, struct wined3d_context *context,
+#else  /* STAGING_CSMT */
 static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_context *context,
+#endif /* STAGING_CSMT */
         const struct wined3d_stream_info *si, UINT NumVertexes, GLenum glPrimType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -103,7 +111,9 @@ static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_
     const WORD                *pIdxBufS     = NULL;
     const DWORD               *pIdxBufL     = NULL;
     UINT vx_index;
+#if !defined(STAGING_CSMT)
     const struct wined3d_state *state = &device->state;
+#endif /* STAGING_CSMT */
     LONG SkipnStrides = startIdx;
     BOOL pixelShader = use_ps(state);
     BOOL specular_fog = FALSE;
@@ -453,7 +463,11 @@ static inline void send_attribute(const struct wined3d_gl_info *gl_info,
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+static void draw_strided_slow_vs(struct wined3d_context *context, const struct wined3d_state *state,
+#else  /* STAGING_CSMT */
 static void drawStridedSlowVs(struct wined3d_context *context, const struct wined3d_state *state,
+#endif /* STAGING_CSMT */
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -510,7 +524,11 @@ static void drawStridedSlowVs(struct wined3d_context *context, const struct wine
 }
 
 /* Context activation is done by the caller. */
+#if defined(STAGING_CSMT)
+static void draw_strided_instanced(struct wined3d_context *context, const struct wined3d_state *state,
+#else  /* STAGING_CSMT */
 static void drawStridedInstanced(struct wined3d_context *context, const struct wined3d_state *state,
+#endif /* STAGING_CSMT */
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx, UINT base_vertex_index, UINT instance_count)
 {
@@ -595,10 +613,17 @@ static void remove_vbos(struct wined3d_context *context,
 }
 
 /* Routine common to the draw primitive and draw indexed primitive routines */
+#if defined(STAGING_CSMT)
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed)
+{
+#else  /* STAGING_CSMT */
 void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
         UINT start_instance, UINT instance_count, BOOL indexed)
 {
     const struct wined3d_state *state = &device->state;
+#endif /* STAGING_CSMT */
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -611,6 +636,49 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
 
     if (!index_count) return;
 
+#if defined(STAGING_CSMT)
+    context = context_acquire(device, wined3d_rendertarget_view_get_surface(state->fb.render_targets[0]));
+    if (!context->valid)
+    {
+        context_release(context);
+        WARN("Invalid context, skipping draw.\n");
+        return;
+    }
+    gl_info = context->gl_info;
+
+    if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
+    {
+        /* Invalidate the back buffer memory so LockRect will read it the next time */
+        for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
+        {
+            struct wined3d_surface *target = wined3d_rendertarget_view_get_surface(state->fb.render_targets[i]);
+            if (target)
+            {
+                wined3d_resource_load_location(&target->resource, context, target->container->resource.draw_binding);
+                wined3d_resource_invalidate_location(&target->resource, ~target->container->resource.draw_binding);
+            }
+        }
+    }
+
+    if (state->fb.depth_stencil)
+    {
+        /* Note that this depends on the context_acquire() call above to set
+         * context->render_offscreen properly. We don't currently take the
+         * Z-compare function into account, but we could skip loading the
+         * depthstencil for D3DCMP_NEVER and D3DCMP_ALWAYS as well. Also note
+         * that we never copy the stencil data.*/
+        DWORD location = context->render_offscreen ? state->fb.depth_stencil->resource->draw_binding
+                : WINED3D_LOCATION_DRAWABLE;
+        if (state->render_states[WINED3D_RS_ZWRITEENABLE] || state->render_states[WINED3D_RS_ZENABLE])
+        {
+            struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(state->fb.depth_stencil);
+            RECT current_rect, draw_rect, r;
+
+            if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
+                wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
+
+            if (ds->resource.locations & location)
+#else  /* STAGING_CSMT */
     if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
     {
         /* Invalidate the back buffer memory so LockRect will read it the next time */
@@ -652,6 +720,7 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
                 device_switch_onscreen_ds(device, context, ds);
 
             if (ds->locations & location)
+#endif /* STAGING_CSMT */
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
             else
                 SetRectEmpty(&current_rect);
@@ -664,6 +733,18 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         }
     }
 
+#if defined(STAGING_CSMT)
+    if (!context_apply_draw_state(context, device, state))
+    {
+        context_release(context);
+        WARN("Unable to apply draw state, skipping draw.\n");
+        return;
+    }
+
+    if (state->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
+    {
+        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(state->fb.depth_stencil);
+#else  /* STAGING_CSMT */
     if (!context_apply_draw_state(context, device))
     {
         context_release(context);
@@ -674,6 +755,7 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
     if (device->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
     {
         struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(device->fb.depth_stencil);
+#endif /* STAGING_CSMT */
         DWORD location = context->render_offscreen ? ds->container->resource.draw_binding : WINED3D_LOCATION_DRAWABLE;
 
         surface_modify_ds_location(ds, location, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -756,6 +838,26 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
             else
                 WARN_(d3d_perf)("Using immediate mode with vertex shaders for half float emulation.\n");
 
+#if defined(STAGING_CSMT)
+            draw_strided_slow_vs(context, state, stream_info, index_count,
+                    state->gl_primitive_type, idx_data, idx_size, start_idx);
+        }
+        else
+        {
+            draw_strided_slow(state, context, stream_info, index_count,
+                    state->gl_primitive_type, idx_data, idx_size, start_idx);
+        }
+    }
+    else if (!gl_info->supported[ARB_INSTANCED_ARRAYS] && instance_count)
+    {
+        /* Instancing emulation by mixing immediate mode and arrays. */
+        draw_strided_instanced(context, state, stream_info, index_count, state->gl_primitive_type,
+                idx_data, idx_size, start_idx, state->base_vertex_index, instance_count);
+    }
+    else
+    {
+        draw_strided_fast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
+#else  /* STAGING_CSMT */
             drawStridedSlowVs(context, state, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
@@ -774,6 +876,7 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
     else
     {
         drawStridedFast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
+#endif /* STAGING_CSMT */
                 start_idx, state->base_vertex_index, start_instance, instance_count);
     }
 
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index b1a0f85..7aaf4e9 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -1085,10 +1085,15 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
         const struct wined3d_shader_reg_maps *reg_maps, const struct shader_glsl_ctx_priv *ctx_priv)
 {
     const struct wined3d_shader_version *version = &reg_maps->shader_version;
+#if defined(STAGING_CSMT)
+    const struct ps_compile_args *ps_args = ctx_priv->cur_ps_args;
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+#else  /* STAGING_CSMT */
     const struct wined3d_state *state = &shader->device->state;
     const struct ps_compile_args *ps_args = ctx_priv->cur_ps_args;
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_fb_state *fb = &shader->device->fb;
+#endif /* STAGING_CSMT */
     unsigned int i, extra_constants_needed = 0;
     const struct wined3d_shader_lconst *lconst;
     const char *prefix;
@@ -1329,11 +1334,15 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
         {
             UINT in_count = min(vec4_varyings(version->major, gl_info), shader->limits->packed_input);
 
+#if defined(STAGING_CSMT)
+            if (ps_args->vp_mode == vertexshader)
+#else  /* STAGING_CSMT */
             if (use_vs(state))
+#endif /* STAGING_CSMT */
                 shader_addline(buffer, "varying vec4 %s_link[%u];\n", prefix, in_count);
             shader_addline(buffer, "vec4 %s_in[%u];\n", prefix, in_count);
         }
-
+      TRACE("luminance =%d; extra_constant=%d\n", reg_maps->luminanceparams, extra_constants_needed);
         for (i = 0, map = reg_maps->bumpmat; map; map >>= 1, ++i)
         {
             if (!(map & 1))
@@ -1370,6 +1379,16 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
             }
             else
             {
+#if defined(STAGING_CSMT)
+                /* This happens because we do not have proper tracking of the
+                 * constant registers that are actually used, only the max
+                 * limit of the shader version.
+                 *
+                 * FIXME 2: This is wrong, there's no need to do this. Get rid of
+                 * it and just create the uniform.
+                 */
+                FIXME("Cannot find a free uniform for vpos correction params\n");
+#else  /* STAGING_CSMT */
                 float ycorrection[] =
                 {
                     context->render_offscreen ? 0.0f : fb->render_targets[0]->height,
@@ -1385,6 +1404,7 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
                 shader_addline(buffer, "const vec4 ycorrection = ");
                 shader_glsl_append_imm_vec4(buffer, ycorrection);
                 shader_addline(buffer, ";\n");
+#endif /* STAGING_CSMT */
             }
             shader_addline(buffer, "vec4 vpos;\n");
         }
@@ -5101,7 +5121,12 @@ static void shader_glsl_ffp_vertex_lighting(struct wined3d_shader_buffer *buffer
                 shader_addline(buffer, "dir = normalize(gl_LightSource[%u].position.xyz);\n", i);
                 shader_addline(buffer, "diffuse += clamp(dot(dir, normal), 0.0, 1.0)"
                         " * gl_LightSource[%u].diffuse.xyz;\n", i);
-                shader_addline(buffer, "t = dot(normal, gl_LightSource[%u].halfVector.xyz);\n", i);
+                /* TODO: In the non-local viewer case the halfvector is constant and
+                 * could be precomputed and stored in a uniform. */
+                if (settings->localviewer)
+                    shader_addline(buffer, "t = dot(normal, normalize(dir - normalize(ec_pos.xyz)));\n");
+                else
+                    shader_addline(buffer, "t = dot(normal, normalize(dir + vec3(0.0, 0.0, -1.0)));\n");
                 shader_addline(buffer, "if (t > 0.0) specular += pow(t, gl_FrontMaterial.shininess)"
                         " * gl_LightSource[%u].specular;\n", i);
                 break;
@@ -6009,7 +6034,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
     GLuint vs_id = 0;
     GLuint gs_id = 0;
     GLuint ps_id = 0;
-    struct list *ps_list, *vs_list;
+    struct list *ps_list = NULL, *vs_list = NULL;
 
     if (!(context->shader_update_mask & (1 << WINED3D_SHADER_TYPE_VERTEX)))
     {
@@ -7222,7 +7247,7 @@ void glsl_vertex_pipe_view(struct wined3d_context *context, const struct wined3d
         gl_info->gl_ops.gl.p_glLightfv(GL_LIGHT0 + light->glIndex, GL_SPOT_DIRECTION, light->lightDirn);
         checkGLcall("glLightfv dirn");
     }
-
+  
     gl_info->gl_ops.gl.p_glPopMatrix();
 
     for (k = 0; k < gl_info->limits.clipplanes; ++k)
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
index 0ec578d..074d8aa 100644
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -233,6 +233,38 @@ ULONG CDECL wined3d_query_incref(struct wined3d_query *query)
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_query_destroy(struct wined3d_query *query)
+{
+    /* Queries are specific to the GL context that created them. Not
+     * deleting the query will obviously leak it, but that's still better
+     * than potentially deleting a different query with the same id in this
+     * context, and (still) leaking the actual query. */
+    if (query->type == WINED3D_QUERY_TYPE_EVENT)
+    {
+        struct wined3d_event_query *event_query = query->extendedData;
+        if (event_query) wined3d_event_query_destroy(event_query);
+    }
+    else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
+    {
+        struct wined3d_occlusion_query *oq = query->extendedData;
+
+        if (oq->context) context_free_occlusion_query(oq);
+        HeapFree(GetProcessHeap(), 0, query->extendedData);
+    }
+    else if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP)
+    {
+        struct wined3d_timestamp_query *tq = query->extendedData;
+
+        if (tq->context)
+            context_free_timestamp_query(tq);
+        HeapFree(GetProcessHeap(), 0, query->extendedData);
+    }
+
+    HeapFree(GetProcessHeap(), 0, query);
+}
+
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
 {
     ULONG refcount = InterlockedDecrement(&query->ref);
@@ -240,6 +272,9 @@ ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
     TRACE("%p decreasing refcount to %u.\n", query, refcount);
 
     if (!refcount)
+#if defined(STAGING_CSMT)
+        wined3d_cs_emit_query_destroy(query->device->cs, query);
+#else  /* STAGING_CSMT */
     {
         /* Queries are specific to the GL context that created them. Not
          * deleting the query will obviously leak it, but that's still better
@@ -268,6 +303,7 @@ ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
 
         HeapFree(GetProcessHeap(), 0, query);
     }
+#endif /* STAGING_CSMT */
 
     return refcount;
 }
@@ -292,7 +328,21 @@ HRESULT CDECL wined3d_query_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
+#if defined(STAGING_CSMT)
+    if (flags & WINED3DISSUE_END)
+        query->counter_main++;
+
+    wined3d_cs_emit_query_issue(query->device->cs, query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
+#else  /* STAGING_CSMT */
     return query->query_ops->query_issue(query, flags);
+#endif /* STAGING_CSMT */
 }
 
 static void fill_query_data(void *out, unsigned int out_size, const void *result, unsigned int result_size)
@@ -303,6 +353,12 @@ static void fill_query_data(void *out, unsigned int out_size, const void *result
 static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
+#if defined(STAGING_CSMT)
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    GLuint samples;
+#else  /* STAGING_CSMT */
     struct wined3d_occlusion_query *oq = query->extendedData;
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -315,6 +371,7 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
 
     if (!oq->context)
         query->state = QUERY_CREATED;
+#endif /* STAGING_CSMT */
 
     if (query->state == QUERY_CREATED)
     {
@@ -325,6 +382,10 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
+    TRACE("(%p) : type D3DQUERY_OCCLUSION, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+#endif /* STAGING_CSMT */
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -340,12 +401,46 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+#if defined(STAGING_CSMT)
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        fill_query_data(data, size, &oq->samples, sizeof(oq->samples));
+
+    return S_OK;
+}
+
+static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    BOOL ret;
+
+    if (oq->context->tid != GetCurrentThreadId())
+    {
+        FIXME("%p Wrong thread, returning 1.\n", query);
+        oq->samples = 1;
+        return TRUE;
+#else  /* STAGING_CSMT */
     if (oq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
         samples = 1;
         fill_query_data(data, size, &samples, sizeof(samples));
         return S_OK;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(query->device, oq->context->current_rt);
@@ -356,6 +451,79 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
+#if defined(STAGING_CSMT)
+        GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
+        checkGLcall("glGetQueryObjectuiv(GL_QUERY_RESULT)");
+        TRACE("Returning %d samples.\n", samples);
+        oq->samples = samples;
+        ret = TRUE;
+    }
+    else
+    {
+        ret = FALSE;
+    }
+
+    context_release(context);
+
+    return ret;
+}
+
+static BOOL wined3d_event_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    enum wined3d_event_query_result ret;
+
+    ret = wined3d_event_query_test(event_query, query->device);
+    switch(ret)
+    {
+        case WINED3D_EVENT_QUERY_OK:
+        case WINED3D_EVENT_QUERY_NOT_STARTED:
+            return TRUE;
+
+        case WINED3D_EVENT_QUERY_WAITING:
+            return FALSE;
+
+        case WINED3D_EVENT_QUERY_WRONG_THREAD:
+            FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
+            return TRUE;
+
+        case WINED3D_EVENT_QUERY_ERROR:
+            ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
+            return TRUE;
+
+        default:
+            ERR("Unexpected wined3d_event_query_test result %u\n", ret);
+            return TRUE;
+    }
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *pData, DWORD dwSize, DWORD flags)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    BOOL *data = pData;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
+    if (!pData || !dwSize) return S_OK;
+    if (!event_query)
+    {
+        WARN("Event query not supported by GL, reporting GPU idle.\n");
+        *data = TRUE;
+        return S_OK;
+    }
+
+    if (!wined3d_settings.cs_multithreaded)
+        ret = query->query_ops->query_poll(query);
+    else if (query->counter_main != query->counter_retrieved)
+        ret = FALSE;
+    else
+        ret = TRUE;
+
+    if (data)
+        fill_query_data(data, dwSize, &ret, sizeof(ret));
+#else  /* STAGING_CSMT */
         if (size)
         {
             GL_EXTCALL(glGetQueryObjectuiv(oq->id, GL_QUERY_RESULT, &samples));
@@ -417,6 +585,7 @@ static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
             ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
             return WINED3DERR_INVALIDCALL;
     }
+#endif /* STAGING_CSMT */
 
     return S_OK;
 }
@@ -435,7 +604,11 @@ enum wined3d_query_type CDECL wined3d_query_get_type(const struct wined3d_query
     return query->type;
 }
 
+#if defined(STAGING_CSMT)
+static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
 static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -445,6 +618,26 @@ static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD
         struct wined3d_event_query *event_query = query->extendedData;
 
         /* Faked event query support */
+#if defined(STAGING_CSMT)
+        if (!event_query) return FALSE;
+
+        wined3d_event_query_issue(event_query, query->device);
+        return TRUE;
+    }
+    else if (flags & WINED3DISSUE_BEGIN)
+    {
+        /* Started implicitly at device creation */
+        ERR("Event query issued with START flag - what to do?\n");
+    }
+    return FALSE;
+}
+
+static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    BOOL poll = FALSE;
+#else  /* STAGING_CSMT */
         if (!event_query) return WINED3D_OK;
 
         wined3d_event_query_issue(event_query, query->device);
@@ -467,6 +660,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+#endif /* STAGING_CSMT */
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -478,7 +672,11 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         /* This is allowed according to msdn and our tests. Reset the query and restart */
         if (flags & WINED3DISSUE_BEGIN)
         {
+#if defined(STAGING_CSMT)
+            if (oq->started)
+#else  /* STAGING_CSMT */
             if (query->state == QUERY_BUILDING)
+#endif /* STAGING_CSMT */
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -507,6 +705,9 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
             checkGLcall("glBeginQuery()");
 
             context_release(context);
+#if defined(STAGING_CSMT)
+            oq->started = TRUE;
+#endif /* STAGING_CSMT */
         }
         if (flags & WINED3DISSUE_END)
         {
@@ -514,7 +715,11 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
              * our tests show that it returns OK. But OpenGL doesn't like it, so avoid
              * generating an error
              */
+#if defined(STAGING_CSMT)
+            if (oq->started)
+#else  /* STAGING_CSMT */
             if (query->state == QUERY_BUILDING)
+#endif /* STAGING_CSMT */
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -528,8 +733,15 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
                     checkGLcall("glEndQuery()");
 
                     context_release(context);
+#if defined(STAGING_CSMT)
+                    poll = TRUE;
                 }
             }
+            oq->started = FALSE;
+#else  /* STAGING_CSMT */
+                }
+            }
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -537,6 +749,66 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         FIXME("%p Occlusion queries not supported.\n", query);
     }
 
+#if defined(STAGING_CSMT)
+    return poll;
+}
+
+static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    struct wined3d_timestamp_query *tq = query->extendedData;
+
+    TRACE("(%p) : type D3DQUERY_TIMESTAMP, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (query->state == QUERY_CREATED)
+    {
+        UINT64 zero = 0;
+        /* D3D allows GetData on a new query, OpenGL doesn't. So just invent the data ourselves */
+        TRACE("Query wasn't yet started, returning S_OK.\n");
+        if (data)
+            fill_query_data(data, size, &zero, sizeof(zero));
+        return S_OK;
+    }
+
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        fill_query_data(data, size, &tq->timestamp, sizeof(tq->timestamp));
+
+    return S_OK;
+}
+
+static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_timestamp_query *tq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint64 timestamp;
+    BOOL ret;
+
+    if (!gl_info->supported[ARB_TIMER_QUERY])
+    {
+        TRACE("Faking timestamp.\n");
+        QueryPerformanceCounter((LARGE_INTEGER *)&tq->timestamp);
+        return TRUE;
+    }
+
+    if (tq->context->tid != GetCurrentThreadId())
+    {
+        FIXME("%p Wrong thread, returning 1.\n", query);
+        tq->timestamp = 1;
+        return TRUE;
+#else  /* STAGING_CSMT */
     if (flags & WINED3DISSUE_BEGIN)
         query->state = QUERY_BUILDING;
     else
@@ -576,6 +848,7 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
         timestamp = 1;
         fill_query_data(data, size, &timestamp, sizeof(timestamp));
         return S_OK;
+#endif /* STAGING_CSMT */
     }
 
     context = context_acquire(query->device, tq->context->current_rt);
@@ -586,6 +859,25 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
+#if defined(STAGING_CSMT)
+        GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
+        checkGLcall("glGetQueryObjectui64v(GL_QUERY_RESULT)");
+        TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
+        tq->timestamp = timestamp;
+        ret = TRUE;
+    }
+    else
+    {
+        ret = FALSE;
+    }
+
+    context_release(context);
+
+    return ret;
+}
+
+static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#else  /* STAGING_CSMT */
         if (size)
         {
             GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT, &timestamp));
@@ -606,6 +898,7 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
 }
 
 static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -638,6 +931,24 @@ static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DW
     }
 
     if (flags & WINED3DISSUE_END)
+#if defined(STAGING_CSMT)
+        return TRUE;
+    return FALSE;
+}
+
+static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_query *query,
+        void *data, DWORD size, DWORD flags)
+{
+    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+    if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP_DISJOINT)
+    {
+        static const struct wined3d_query_data_timestamp_disjoint disjoint_data = {FALSE, 1000 * 1000 * 1000};
+
+        if (query->state == QUERY_BUILDING)
+        {
+             TRACE("Query is building, returning S_FALSE.\n");
+             return S_FALSE;
+#else  /* STAGING_CSMT */
         query->state = QUERY_SIGNALLED;
 
     return WINED3D_OK;
@@ -656,6 +967,7 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_quer
         {
             TRACE("Query is building, returning S_FALSE.\n");
             return S_FALSE;
+#endif /* STAGING_CSMT */
         }
 
         fill_query_data(data, size, &disjoint_data, sizeof(disjoint_data));
@@ -669,6 +981,44 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_quer
     return S_OK;
 }
 
+#if defined(STAGING_CSMT)
+static BOOL wined3d_timestamp_disjoint_query_ops_poll(struct wined3d_query *query)
+{
+    return TRUE;
+}
+
+static BOOL wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    TRACE("query %p, flags %#x.\n", query, flags);
+    return FALSE;
+}
+
+static const struct wined3d_query_ops event_query_ops =
+{
+    wined3d_event_query_ops_get_data,
+    wined3d_event_query_ops_poll,
+    wined3d_event_query_ops_issue,
+};
+
+static const struct wined3d_query_ops occlusion_query_ops =
+{
+    wined3d_occlusion_query_ops_get_data,
+    wined3d_occlusion_query_ops_poll,
+    wined3d_occlusion_query_ops_issue,
+};
+
+static const struct wined3d_query_ops timestamp_query_ops =
+{
+    wined3d_timestamp_query_ops_get_data,
+    wined3d_timestamp_query_ops_poll,
+    wined3d_timestamp_query_ops_issue,
+};
+
+static const struct wined3d_query_ops timestamp_disjoint_query_ops =
+{
+    wined3d_timestamp_disjoint_query_ops_get_data,
+    wined3d_timestamp_disjoint_query_ops_poll,
+#else  /* STAGING_CSMT */
 static HRESULT wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
@@ -702,6 +1052,7 @@ static const struct wined3d_query_ops timestamp_query_ops =
 static const struct wined3d_query_ops timestamp_disjoint_query_ops =
 {
     wined3d_timestamp_disjoint_query_ops_get_data,
+#endif /* STAGING_CSMT */
     wined3d_timestamp_disjoint_query_ops_issue,
 };
 
@@ -723,6 +1074,15 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
             }
             query->query_ops = &occlusion_query_ops;
             query->data_size = sizeof(DWORD);
+#if defined(STAGING_CSMT)
+            query->extendedData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(struct wined3d_occlusion_query));
+            if (!query->extendedData)
+            {
+                ERR("Failed to allocate occlusion query extended data.\n");
+                return E_OUTOFMEMORY;
+            }
+#else  /* STAGING_CSMT */
             query->extendedData = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_occlusion_query));
             if (!query->extendedData)
             {
@@ -730,6 +1090,7 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
                 return E_OUTOFMEMORY;
             }
             ((struct wined3d_occlusion_query *)query->extendedData)->context = NULL;
+#endif /* STAGING_CSMT */
             break;
 
         case WINED3D_QUERY_TYPE_EVENT:
@@ -802,6 +1163,9 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
     query->state = QUERY_CREATED;
     query->device = device;
     query->ref = 1;
+#if defined(STAGING_CSMT)
+    list_init(&query->poll_list_entry);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
index 205f074..91042cb 100644
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -50,7 +50,7 @@ static DWORD resource_access_from_pool(enum wined3d_pool pool)
 
 static void resource_check_usage(DWORD usage)
 {
-    static const DWORD handled = WINED3DUSAGE_RENDERTARGET
+    static DWORD handled = WINED3DUSAGE_RENDERTARGET
             | WINED3DUSAGE_DEPTHSTENCIL
             | WINED3DUSAGE_WRITEONLY
             | WINED3DUSAGE_DYNAMIC
@@ -66,7 +66,15 @@ static void resource_check_usage(DWORD usage)
      * driver. */
 
     if (usage & ~handled)
+    {
         FIXME("Unhandled usage flags %#x.\n", usage & ~handled);
+        handled |= usage;
+    }
+
+//#define WINED3DUSAGE_SOFTWAREPROCESSING                         0x00000010
+//#define WINED3DUSAGE_DONOTCLIP                                  0x00000020
+//#define WINED3DUSAGE_POINTS                                     0x00000040
+
     if ((usage & (WINED3DUSAGE_DYNAMIC | WINED3DUSAGE_WRITEONLY)) == WINED3DUSAGE_DYNAMIC)
         WARN_(d3d_perf)("WINED3DUSAGE_DYNAMIC used without WINED3DUSAGE_WRITEONLY.\n");
 }
@@ -78,7 +86,12 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
         void *parent, const struct wined3d_parent_ops *parent_ops,
         const struct wined3d_resource_ops *resource_ops)
 {
-    const struct wined3d *d3d = device->wined3d;
+  const struct wined3d *d3d; // = device->wined3d;
+  TRACE(" device %p, resource %p\n", device, resource);
+  if (!device || !resource) {
+    return WINED3DERR_INVALIDCALL;
+  }
+  d3d = device->wined3d;
 
     resource_check_usage(usage);
     if (pool != WINED3D_POOL_SCRATCH && type != WINED3D_RTYPE_BUFFER)
@@ -128,6 +141,9 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+#if defined(STAGING_CSMT)
+        resource->heap_memory = resource->map_heap_memory;
+#endif /* STAGING_CSMT */
     }
     else
     {
@@ -151,6 +167,33 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_resource_free_bo(struct wined3d_resource *resource)
+{
+    struct wined3d_context *context = context_acquire(resource->device, NULL);
+
+    if (resource->buffer != resource->map_buffer)
+        ERR("Releasing resource buffer with buffer != map_buffer.\n");
+
+    wined3d_device_release_bo(resource->device, resource->buffer, context);
+    resource->buffer = NULL;
+    resource->map_buffer = NULL;
+
+    context_release(context);
+}
+
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
+{
+    context_resource_released(resource->device, resource, resource->type);
+
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
+    wined3d_resource_free_sysmem(resource);
+    resource->map_heap_memory = NULL;
+}
+
+#endif /* STAGING_CSMT */
 void resource_cleanup(struct wined3d_resource *resource)
 {
     const struct wined3d *d3d = resource->device->wined3d;
@@ -163,7 +206,11 @@ void resource_cleanup(struct wined3d_resource *resource)
         adapter_adjust_memory(resource->device->adapter, (INT64)0 - resource->size);
     }
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_resource_cleanup(resource->device->cs, resource);
+#else  /* STAGING_CSMT */
     wined3d_resource_free_sysmem(resource);
+#endif /* STAGING_CSMT */
 
     device_resource_released(resource->device, resource);
 }
@@ -173,6 +220,11 @@ void resource_unload(struct wined3d_resource *resource)
     if (resource->map_count)
         ERR("Resource %p is being unloaded while mapped.\n", resource);
 
+#if defined(STAGING_CSMT)
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
+#endif /* STAGING_CSMT */
     context_resource_unloaded(resource->device,
             resource, resource->type);
 }
@@ -235,7 +287,11 @@ BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
+#if defined(STAGING_CSMT)
+    resource->map_heap_memory = ++p;
+#else  /* STAGING_CSMT */
     resource->heap_memory = ++p;
+#endif /* STAGING_CSMT */
 
     return TRUE;
 }
@@ -301,7 +357,11 @@ GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags)
     return ret;
 }
 
+#if defined(STAGING_CSMT)
+static GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
+#else  /* STAGING_CSMT */
 GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
+#endif /* STAGING_CSMT */
 {
     if (d3d_flags & WINED3D_MAP_READONLY)
         return GL_READ_ONLY_ARB;
@@ -340,3 +400,588 @@ void wined3d_resource_update_draw_binding(struct wined3d_resource *resource)
     else
         resource->draw_binding = WINED3D_LOCATION_TEXTURE_RGB;
 }
+
+void CDECL wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch)
+{
+    unsigned int alignment;
+    const struct wined3d_format *format = resource->format;
+
+    if (resource->custom_row_pitch)
+    {
+        *row_pitch = resource->custom_row_pitch;
+        *slice_pitch = resource->custom_slice_pitch;
+        return;
+    }
+
+    alignment = resource->device->surface_alignment;
+    *row_pitch = wined3d_format_calculate_pitch(resource->format, resource->width);
+    *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
+    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        /* Since compressed formats are block based, pitch means the amount of
+         * bytes to the next row of block rather than the next row of pixels. */
+        UINT slice_block_count = (resource->height + format->block_height - 1) / format->block_height;
+        *slice_pitch = *row_pitch * slice_block_count;
+    }
+    else
+    {
+        *slice_pitch = *row_pitch * resource->height;
+    }
+
+    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
+}
+#if defined(STAGING_CSMT)
+
+void wined3d_resource_validate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations |= location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+}
+
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource, DWORD location)
+{
+//    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations &= ~location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+
+    resource->resource_ops->resource_location_invalidated(resource, location);
+}
+
+DWORD wined3d_resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_DISCARDED:
+            return 0;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_DIB:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data)
+{
+    if (location & WINED3D_LOCATION_BUFFER)
+    {
+        data->buffer_object = resource->buffer->name;
+        data->addr = NULL;
+        return;
+    }
+    if (location & WINED3D_LOCATION_USER_MEMORY)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->user_memory;
+        return;
+    }
+    if (location & WINED3D_LOCATION_DIB)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->bitmap_data;
+        return;
+    }
+    if (location & WINED3D_LOCATION_SYSMEM)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->heap_memory;
+        return;
+    }
+    ERR("Unexpected location %s.\n", wined3d_debug_location(location));
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+static void wined3d_resource_copy_simple_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+    UINT size = resource->size;
+
+    wined3d_resource_get_memory(resource, location, &dst);
+    wined3d_resource_get_memory(resource, resource->locations, &src);
+
+    if (dst.buffer_object)
+    {
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, dst.buffer_object));
+        GL_EXTCALL(glBufferSubData(GL_PIXEL_UNPACK_BUFFER, 0, size, src.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+        checkGLcall("Upload PBO");
+        return;
+    }
+    if (src.buffer_object)
+    {
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubData(GL_PIXEL_PACK_BUFFER, 0, size, dst.addr));
+        GL_EXTCALL(glBindBuffer(GL_PIXEL_PACK_BUFFER, 0));
+        checkGLcall("Download PBO");
+        return;
+    }
+    memcpy(dst.addr, src.addr, size);
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    DWORD required_access = wined3d_resource_access_from_location(location);
+    DWORD simple_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if ((resource->locations & location) == location)
+    {
+        TRACE("Location(s) already up to date.\n");
+        return;
+    }
+
+    /* Keep this a WARN for now until surfaces are cleaned up. */
+    if ((resource->access_flags & required_access) != required_access)
+        WARN("Operation requires %#x access, but resource only has %#x.\n",
+                required_access, resource->access_flags);
+
+    if (location & simple_locations)
+    {
+        if (resource->locations & WINED3D_LOCATION_DISCARDED)
+        {
+            TRACE("Resource was discarded, nothing to do.\n");
+            resource->locations |= location;
+            return;
+        }
+        if (resource->locations & simple_locations)
+        {
+            wined3d_resource_copy_simple_location(resource, context, location);
+            resource->locations |= location;
+            return;
+        }
+    }
+
+    /* Context is NULL in ddraw-only operation without OpenGL. */
+    if (!context)
+        ERR("A context is required for non-sysmem operation.\n");
+
+    resource->resource_ops->resource_load_location(resource, context, location);
+}
+
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags)
+{
+    const struct wined3d_gl_info *gl_info;
+    BYTE *ptr;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, resource->map_buffer->name));
+
+            if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+            {
+                GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
+                mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
+                ptr = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER,
+                        0, resource->size, mapflags));
+            }
+            else
+            {
+                GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
+                ptr = GL_EXTCALL(glMapBuffer(GL_PIXEL_UNPACK_BUFFER, access));
+            }
+
+            GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+            checkGLcall("Map GL buffer");
+            return ptr;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return resource->map_heap_memory;
+
+        case WINED3D_LOCATION_DIB:
+            return resource->bitmap_data;
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            return resource->user_memory;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return NULL;
+    }
+}
+
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, resource->map_buffer->name));
+            GL_EXTCALL(glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER));
+            GL_EXTCALL(glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0));
+            checkGLcall("Unmap GL buffer");
+            return;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_DIB:
+        case WINED3D_LOCATION_USER_MEMORY:
+            return;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return;
+    }
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_resource_prepare_bo(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    if (resource->buffer)
+        return;
+
+    resource->buffer = wined3d_device_get_bo(resource->device, resource->size,
+            GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+    resource->map_buffer = resource->buffer;
+    TRACE("Created GL buffer %u for resource %p.\n", resource->buffer->name, resource);
+    resource->map_heap_memory = NULL;
+}
+
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource)
+{
+    if (resource->heap_memory)
+        return TRUE;
+
+    if (!wined3d_resource_allocate_sysmem(resource))
+    {
+        ERR("Failed to allocate system memory.\n");
+        return FALSE;
+    }
+    resource->heap_memory = resource->map_heap_memory;
+    return TRUE;
+}
+
+/* Context activation is done by the caller. */
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            wined3d_resource_prepare_bo(resource, context);
+            return TRUE;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return wined3d_resource_prepare_system_memory(resource);
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            if (!resource->user_memory)
+                ERR("Map binding is set to WINED3D_LOCATION_USER_MEMORY but resource->user_memory is NULL.\n");
+            return TRUE;
+
+        case WINED3D_LOCATION_DIB:
+            if (!resource->bitmap_data)
+                ERR("Map binding is set to WINED3D_LOCATION_DIB but resource->bitmap_data is NULL.\n");
+            return TRUE;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return FALSE;
+    }
+}
+
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box)
+{
+    UINT width_mask, height_mask;
+    const struct wined3d_format *format = resource->format;
+
+    if (!box)
+        return TRUE;
+
+    /* This assumes power of two block sizes, but NPOT block sizes would be
+     * silly anyway.
+     *
+     * This also assumes that the format's block depth is 1. */
+    width_mask = format->block_width - 1;
+    if (!width_mask) {
+        return TRUE;
+    }
+    height_mask = format->block_height - 1;
+    if (!height_mask) {
+        return TRUE;
+    }
+
+    if (box->left & width_mask)
+        return FALSE;
+    if (box->top & height_mask)
+        return FALSE;
+    if (box->right & width_mask && box->right != resource->width)
+        return FALSE;
+    if (box->bottom & height_mask && box->bottom != resource->height)
+        return FALSE;
+
+    return TRUE;
+}
+
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+    void *mem;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(resource, context))
+    {
+        WARN("Out of memory.\n");
+        context_release(context);
+        return NULL;
+    }
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+                resource->map_buffer = wined3d_device_get_bo(device, resource->size,
+                        GL_STREAM_DRAW, GL_PIXEL_UNPACK_BUFFER, context);
+                break;
+
+            case WINED3D_LOCATION_SYSMEM:
+                wined3d_resource_allocate_sysmem(resource);
+                break;
+
+            default:
+                if (resource->access_fence)
+                    ERR("Location %s does not support DISCARD maps.\n",
+                            wined3d_debug_location(resource->map_binding));
+                if (resource->pool != WINED3D_POOL_DEFAULT)
+                    FIXME("Discard used on %s pool resource.\n", debug_d3dpool(resource->pool));
+        }
+        wined3d_resource_validate_location(resource, resource->map_binding);
+    }
+    else
+    {
+        wined3d_resource_load_location(resource, context, resource->map_binding);
+    }
+
+    mem = wined3d_resource_get_map_ptr(resource, context, flags);
+
+    if (context)
+        context_release(context);
+
+    return mem;
+}
+
+static void wined3d_resource_sync(struct wined3d_resource *resource)
+{
+    struct wined3d_resource *real_res = resource;
+    struct wined3d_surface *surface;
+    struct wined3d_volume *volume;
+
+    switch (resource->type)
+    {
+        case WINED3D_RTYPE_SURFACE:
+            surface = surface_from_resource(resource);
+            if (surface->container)
+                real_res = &surface->container->resource;
+            break;
+
+        case WINED3D_RTYPE_VOLUME:
+            volume = volume_from_resource(resource);
+            real_res = &volume->container->resource;
+            break;
+
+        default:
+            break;
+    }
+    wined3d_resource_wait_fence(real_res);
+}
+
+HRESULT wined3d_resource_map(struct wined3d_resource *resource,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    BYTE *base_memory;
+    const struct wined3d_format *format = resource->format;
+
+    TRACE("resource %p, map_desc %p, box %p, flags %#x.\n",
+            resource, map_desc, box, flags);
+
+    if (resource->usage & WINED3DUSAGE_RENDERTARGET && wined3d_settings.ignore_rt_map)
+    {
+        WARN("Ignoring render target map, only finishing CS.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        map_desc->row_pitch = 0;
+        map_desc->slice_pitch = 0;
+        map_desc->data = NULL;
+        device->cs->ops->finish(device->cs);
+        return WINED3D_OK;
+    }
+
+    if (resource->map_count)
+    {
+        WARN("Volume is already mapped.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    flags = wined3d_resource_sanitize_map_flags(resource, flags);
+
+    if (flags & WINED3D_MAP_NOOVERWRITE)
+        FIXME("WINED3D_MAP_NOOVERWRITE are not implemented yet.\n");
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+            case WINED3D_LOCATION_SYSMEM:
+                break;
+
+            default:
+                FIXME("Implement discard maps with %s map binding.\n",
+                        wined3d_debug_location(resource->map_binding));
+                wined3d_resource_sync(resource);
+        }
+    }
+    else
+        wined3d_resource_sync(resource);
+
+    base_memory = wined3d_cs_emit_resource_map(device->cs, resource, flags);
+    if (!base_memory)
+    {
+        WARN("Map failed.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    TRACE("Base memory pointer %p.\n", base_memory);
+
+    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
+    {
+        map_desc->row_pitch = resource->width * format->byte_count;
+        map_desc->slice_pitch = map_desc->row_pitch * resource->height;
+    }
+    else
+    {
+        wined3d_resource_get_pitch(resource, &map_desc->row_pitch, &map_desc->slice_pitch);
+    }
+
+    if (!box)
+    {
+        TRACE("No box supplied - all is ok\n");
+        map_desc->data = base_memory;
+    }
+    else
+    {
+        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
+                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
+
+        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
+        {
+            /* Compressed textures are block based, so calculate the offset of
+             * the block that contains the top-left pixel of the locked rectangle. */
+            map_desc->data = base_memory
+                    + (box->front * map_desc->slice_pitch)
+                    + ((box->top / format->block_height) * map_desc->row_pitch)
+                    + ((box->left / format->block_width) * format->block_byte_count);
+        }
+        else
+        {
+            map_desc->data = base_memory
+                    + (map_desc->slice_pitch * box->front)
+                    + (map_desc->row_pitch * box->top)
+                    + (box->left * format->byte_count);
+        }
+    }
+
+    if (!(flags & WINED3D_MAP_READONLY))
+        resource->unmap_dirtify = TRUE;
+
+    resource->map_count++;
+
+    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
+            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+    wined3d_resource_release_map_ptr(resource, context);
+    if (context)
+        context_release(context);
+}
+
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    TRACE("resource %p.\n", resource);
+
+    if (resource->usage & WINED3DUSAGE_RENDERTARGET && wined3d_settings.ignore_rt_map)
+    {
+        WARN("Ignoring render target unmap.\n");
+        return WINED3D_OK;
+    }
+
+    if (!resource->map_count)
+    {
+        WARN("Trying to unlock an unlocked resource %p.\n", resource);
+        return WINEDDERR_NOTLOCKED;
+    }
+
+    wined3d_cs_emit_resource_unmap(device->cs, resource);
+
+    if (resource->unmap_dirtify)
+    {
+        wined3d_cs_emit_resource_changed(device->cs, resource,
+                resource->map_buffer, resource->map_heap_memory);
+    }
+    resource->unmap_dirtify = FALSE;
+
+    resource->map_count--;
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_changed(struct wined3d_resource *resource, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory)
+{
+    struct wined3d_device *device = resource->device;
+
+    if (swap_buffer && swap_buffer != resource->buffer)
+    {
+        struct wined3d_context *context = context_acquire(device, NULL);
+        wined3d_device_release_bo(device, resource->buffer, context);
+        context_release(context);
+        resource->buffer = swap_buffer;
+    }
+    if (swap_heap_memory && swap_heap_memory != resource->heap_memory)
+    {
+        wined3d_resource_free_sysmem(resource);
+        resource->heap_memory = swap_heap_memory;
+    }
+
+    wined3d_resource_invalidate_location(resource, ~resource->map_binding);
+}
+#endif /* STAGING_CSMT */
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index 0bedf24..f660097 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -556,6 +556,8 @@ static BOOL shader_record_register_usage(struct wined3d_shader *shader, struct w
         default:
             TRACE("Not recording register of type %#x and [%#x][%#x].\n",
                     reg->type, reg->idx[0].offset, reg->idx[1].offset);
+//trace:d3d_shader:shader_record_register_usage Not recording register of type 0x6 and [0][0xffffffff].
+        //WINED3DSPR_OUTPUT = 6,
             break;
     }
     return TRUE;
@@ -1812,7 +1814,11 @@ static void shader_trace_init(const struct wined3d_shader_frontend *fe, void *fe
     }
 }
 
+#if defined(STAGING_CSMT)
+void shader_cleanup(struct wined3d_shader *shader)
+#else  /* STAGING_CSMT */
 static void shader_cleanup(struct wined3d_shader *shader)
+#endif /* STAGING_CSMT */
 {
     HeapFree(GetProcessHeap(), 0, shader->output_signature.elements);
     HeapFree(GetProcessHeap(), 0, shader->signature_strings);
@@ -2054,7 +2060,7 @@ ULONG CDECL wined3d_shader_incref(struct wined3d_shader *shader)
 {
     ULONG refcount = InterlockedIncrement(&shader->ref);
 
-    TRACE("%p increasing refcount to %u.\n", shader, refcount);
+//    TRACE("%p increasing refcount to %u.\n", shader, refcount);
 
     return refcount;
 }
@@ -2063,13 +2069,20 @@ ULONG CDECL wined3d_shader_decref(struct wined3d_shader *shader)
 {
     ULONG refcount = InterlockedDecrement(&shader->ref);
 
-    TRACE("%p decreasing refcount to %u.\n", shader, refcount);
+//    TRACE("%p decreasing refcount to %u.\n", shader, refcount);
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        const struct wined3d_device *device = shader->device;
+
+        shader->parent_ops->wined3d_object_destroyed(shader->parent);
+        wined3d_cs_emit_shader_cleanup(device->cs, shader);
+#else  /* STAGING_CSMT */
         shader_cleanup(shader);
         shader->parent_ops->wined3d_object_destroyed(shader->parent);
         HeapFree(GetProcessHeap(), 0, shader);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -2344,7 +2357,11 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && state->render_states[WINED3D_RS_SRGBWRITEENABLE])
     {
+#if defined(STAGING_CSMT)
+        const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
+#else  /* STAGING_CSMT */
         const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+#endif /* STAGING_CSMT */
         if (rt_format->flags & WINED3DFMT_FLAG_SRGB_WRITE)
         {
             static unsigned int warned = 0;
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index 7efbf3d..6e97ecd 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -105,7 +105,11 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     /* No z test without depth stencil buffers */
+#if defined(STAGING_CSMT)
+    if (!state->fb.depth_stencil)
+#else  /* STAGING_CSMT */
     if (!state->fb->depth_stencil)
+#endif /* STAGING_CSMT */
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -360,14 +364,21 @@ static GLenum gl_blend_factor(enum wined3d_blend factor, const struct wined3d_fo
         case WINED3D_BLEND_INVBLENDFACTOR:
             return GL_ONE_MINUS_CONSTANT_COLOR_EXT;
         default:
-            FIXME("Unhandled blend factor %#x.\n", factor);
+        {
+            static int once;
+            if (factor || !once++) FIXME("Unhandled blend factor %#x.\n", factor);
             return GL_NONE;
+        }
     }
 }
 
 static void state_blend(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
+#else  /* STAGING_CSMT */
     const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     GLenum srcBlend, dstBlend;
     enum wined3d_blend d3d_blend;
@@ -812,7 +823,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint depthFail_ccw;
 
     /* No stencil test without a stencil buffer. */
+#if defined(STAGING_CSMT)
+    if (!state->fb.depth_stencil)
+#else  /* STAGING_CSMT */
     if (!state->fb->depth_stencil)
+#endif /* STAGING_CSMT */
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -908,7 +923,11 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
     DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -922,7 +941,11 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#else  /* STAGING_CSMT */
     DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1163,10 +1186,17 @@ void state_fog_fragpart(struct wined3d_context *context, const struct wined3d_st
                     /* drop through */
 
                 case WINED3D_FOG_NONE:
+#if defined(STAGING_CSMT)
+                    /* Both are none? According to msdn the alpha channel of the specular
+                     * color contains a fog factor. Set it in draw_strided_slow.
+                     * Same happens with Vertexfog on transformed vertices
+                     */
+#else  /* STAGING_CSMT */
                     /* Both are none? According to msdn the alpha channel of the specular
                      * color contains a fog factor. Set it in drawStridedSlow.
                      * Same happens with Vertexfog on transformed vertices
                      */
+#endif /* STAGING_CSMT */
                     new_source = FOGSOURCE_COORD;
                     gl_info->gl_ops.gl.p_glFogi(GL_FOG_MODE, GL_LINEAR);
                     checkGLcall("glFogi(GL_FOG_MODE, GL_LINEAR)");
@@ -1762,7 +1792,11 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
+#if defined(STAGING_CSMT)
+        const struct wined3d_rendertarget_view *depth = state->fb.depth_stencil;
+#else  /* STAGING_CSMT */
         const struct wined3d_rendertarget_view *depth = state->fb->depth_stencil;
+#endif /* STAGING_CSMT */
         float scale;
 
         union
@@ -3898,10 +3932,9 @@ static void state_vertexblend_w(struct wined3d_context *context, const struct wi
 {
     enum wined3d_vertex_blend_flags f = state->render_states[WINED3D_RS_VERTEXBLEND];
     static unsigned int once;
-
+  
     if (f == WINED3D_VBF_DISABLE)
-        return;
-
+      return;
     if (!once++) FIXME("Vertex blend flags %#x not supported.\n", f);
     else WARN("Vertex blend flags %#x not supported.\n", f);
 }
@@ -4303,9 +4336,15 @@ static void load_vertex_data(struct wined3d_context *context,
                 }
             }
         } else {
+#if defined(STAGING_CSMT)
+            /* TODO: support blends in draw_strided_slow
+             * No need to write a FIXME here, this is done after the general vertex decl decoding
+             */
+#else  /* STAGING_CSMT */
             /* TODO: support blends in drawStridedSlow
              * No need to write a FIXME here, this is done after the general vertex decl decoding
              */
+#endif /* STAGING_CSMT */
             WARN("unsupported blending in openGl\n");
         }
     }
@@ -4657,7 +4696,11 @@ static void vertexdeclaration(struct wined3d_context *context, const struct wine
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#else  /* STAGING_CSMT */
     const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
 
@@ -4835,7 +4878,11 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
+#if defined(STAGING_CSMT)
+        const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
+#else  /* STAGING_CSMT */
         const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+#endif /* STAGING_CSMT */
         UINT height;
         UINT width;
 
@@ -4899,7 +4946,11 @@ static void psorigin(struct wined3d_context *context, const struct wined3d_state
 
 void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
+#else  /* STAGING_CSMT */
     const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 62b1841..f7682ec 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -464,6 +464,9 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view *view;
+#endif /* STAGING_CSMT */
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -540,6 +543,33 @@ void state_unbind_resources(struct wined3d_state *state)
             }
         }
     }
+#if defined(STAGING_CSMT)
+
+    if (state->fb.depth_stencil)
+    {
+        view = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", view);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_rendertarget_view_decref(view);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            view = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (view)
+            {
+                TRACE("Releasing the rendertarget view at %p\n", view);
+                wined3d_rendertarget_view_decref(view);
+            }
+        }
+    }
+#endif /* STAGING_CSMT */
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -567,6 +597,9 @@ void state_cleanup(struct wined3d_state *state)
 
     HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
     HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+#if defined(STAGING_CSMT)
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
+#endif /* STAGING_CSMT */
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -1048,8 +1081,13 @@ void CDECL wined3d_stateblock_apply(const struct wined3d_stateblock *stateblock)
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
+#if defined(STAGING_CSMT)
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
+#else  /* STAGING_CSMT */
         if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
             device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+#endif /* STAGING_CSMT */
     }
 
     if (stateblock->changed.indices)
@@ -1307,6 +1345,25 @@ static void state_init_default(struct wined3d_state *state, const struct wined3d
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+#if defined(STAGING_CSMT)
+        state->textures[i] = NULL;
+    }
+
+    state->index_buffer = NULL;
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        memset(&state->streams[i], 0, sizeof(state->streams[i]));
+
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    state->shader[WINED3D_SHADER_TYPE_PIXEL] = NULL;
+}
+
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags)
+{
+    unsigned int i;
+
+    state->flags = flags;
+#else  /* STAGING_CSMT */
     }
 }
 
@@ -1318,6 +1375,7 @@ HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
 
     state->flags = flags;
     state->fb = fb;
+#endif /* STAGING_CSMT */
 
     for (i = 0; i < LIGHTMAP_SIZE; i++)
     {
@@ -1335,6 +1393,17 @@ HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         return E_OUTOFMEMORY;
     }
 
+#if defined(STAGING_CSMT)
+    if (!(state->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*state->fb.render_targets) * gl_info->limits.buffers)))
+    {
+        HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+        HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
+        return E_OUTOFMEMORY;
+    }
+    state->fb.rt_size = gl_info->limits.buffers;
+
+#endif /* STAGING_CSMT */
     if (flags & WINED3D_STATE_INIT_DEFAULT)
         state_init_default(state, gl_info);
 
@@ -1345,12 +1414,22 @@ static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
     HRESULT hr;
+#if defined(STAGING_CSMT)
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
+
+    stateblock->ref = 1;
+    stateblock->device = device;
+
+    if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
+#else  /* STAGING_CSMT */
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
 
     stateblock->ref = 1;
     stateblock->device = device;
 
     if (FAILED(hr = state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0)))
+#endif /* STAGING_CSMT */
         return hr;
 
     if (FAILED(hr = stateblock_allocate_shader_constants(stateblock)))
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 77a0eae..10c6b86 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -36,6 +36,16 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d);
 
 #define MAXLOCKCOUNT 50 /* After this amount of locks do not free the sysmem copy. */
 
+#if defined(STAGING_CSMT)
+
+static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter);
+
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface)
+{
+    if (surface->rb_multisample || surface->rb_resolved || !list_empty(&surface->renderbuffers))
+#else  /* STAGING_CSMT */
 static const DWORD surface_simple_locations =
         WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
         | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
@@ -48,6 +58,7 @@ static void surface_cleanup(struct wined3d_surface *surface)
 
     if (surface->pbo || surface->rb_multisample
             || surface->rb_resolved || !list_empty(&surface->renderbuffers))
+#endif /* STAGING_CSMT */
     {
         struct wined3d_renderbuffer_entry *entry, *entry2;
         const struct wined3d_gl_info *gl_info;
@@ -56,12 +67,14 @@ static void surface_cleanup(struct wined3d_surface *surface)
         context = context_acquire(surface->resource.device, NULL);
         gl_info = context->gl_info;
 
+#if !defined(STAGING_CSMT)
         if (surface->pbo)
         {
             TRACE("Deleting PBO %u.\n", surface->pbo);
             GL_EXTCALL(glDeleteBuffers(1, &surface->pbo));
         }
 
+#endif /* STAGING_CSMT */
         if (surface->rb_multisample)
         {
             TRACE("Deleting multisample renderbuffer %u.\n", surface->rb_multisample);
@@ -88,8 +101,25 @@ static void surface_cleanup(struct wined3d_surface *surface)
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
+#if defined(STAGING_CSMT)
+        surface->resource.bitmap_data = NULL;
+    }
+
+    TRACE("Destroyed surface %p.\n", surface);
+    HeapFree(GetProcessHeap(), 0, surface);
+}
+
+static void surface_cleanup(struct wined3d_surface *surface)
+{
+    struct wined3d_surface *overlay, *cur;
+    struct wined3d_cs *cs = surface->resource.device->cs;
+    BOOL user_mem = surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY;
+
+    TRACE("surface %p.\n", surface);
+#else  /* STAGING_CSMT */
         surface->dib.bitmap_data = NULL;
     }
+#endif /* STAGING_CSMT */
 
     if (surface->overlay_dest)
         list_remove(&surface->overlay_entry);
@@ -101,6 +131,23 @@ static void surface_cleanup(struct wined3d_surface *surface)
     }
 
     resource_cleanup(&surface->resource);
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_surface_cleanup(cs, surface);
+
+    /* Wait for the CS to finish operations on this surface when user memory was in use.
+     * The application is allowed to free the memory after texture / surface destruction
+     * returns. */
+    if (user_mem)
+        wined3d_resource_wait_fence(&surface->container->resource);
+}
+
+void wined3d_surface_destroy(struct wined3d_surface *surface)
+{
+    TRACE("surface %p.\n", surface);
+
+    surface->resource.parent_ops->wined3d_object_destroyed(surface->resource.parent);
+    surface_cleanup(surface);
+#else  /* STAGING_CSMT */
 }
 
 void wined3d_surface_destroy(struct wined3d_surface *surface)
@@ -110,6 +157,7 @@ void wined3d_surface_destroy(struct wined3d_surface *surface)
     surface_cleanup(surface);
     surface->resource.parent_ops->wined3d_object_destroyed(surface->resource.parent);
     HeapFree(GetProcessHeap(), 0, surface);
+#endif /* STAGING_CSMT */
 }
 
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
@@ -363,6 +411,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     BITMAPINFO *b_info;
     int extraline = 0;
     DWORD *masks;
+    UINT row_pitch, slice_pitch;
 
     TRACE("surface %p.\n", surface);
 
@@ -408,10 +457,11 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
 
     b_info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     /* TODO: Is there a nicer way to force a specific alignment? (8 byte for ddraw) */
-    b_info->bmiHeader.biWidth = wined3d_surface_get_pitch(surface) / format->byte_count;
+    wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+    b_info->bmiHeader.biWidth = row_pitch / format->byte_count;
     b_info->bmiHeader.biHeight = 0 - surface->resource.height - extraline;
     b_info->bmiHeader.biSizeImage = (surface->resource.height + extraline)
-            * wined3d_surface_get_pitch(surface);
+            * row_pitch;
     b_info->bmiHeader.biPlanes = 1;
     b_info->bmiHeader.biBitCount = format->byte_count * 8;
 
@@ -453,7 +503,11 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     TRACE("Creating a DIB section with size %dx%dx%d, size=%d.\n",
             b_info->bmiHeader.biWidth, b_info->bmiHeader.biHeight,
             b_info->bmiHeader.biBitCount, b_info->bmiHeader.biSizeImage);
+#if defined(STAGING_CSMT)
+    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->resource.bitmap_data, 0, 0);
+#else  /* STAGING_CSMT */
     surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->dib.bitmap_data, 0, 0);
+#endif /* STAGING_CSMT */
 
     if (!surface->dib.DIBsection)
     {
@@ -462,7 +516,11 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
+#if defined(STAGING_CSMT)
+    TRACE("DIBSection at %p.\n", surface->resource.bitmap_data);
+#else  /* STAGING_CSMT */
     TRACE("DIBSection at %p.\n", surface->dib.bitmap_data);
+#endif /* STAGING_CSMT */
     surface->dib.bitmap_size = b_info->bmiHeader.biSizeImage;
 
     HeapFree(GetProcessHeap(), 0, b_info);
@@ -476,6 +534,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
+#if !defined(STAGING_CSMT)
 static void surface_get_memory(const struct wined3d_surface *surface, struct wined3d_bo_address *data,
         DWORD location)
 {
@@ -584,6 +643,7 @@ void surface_prepare_map_memory(struct wined3d_surface *surface)
     }
 }
 
+#endif /* STAGING_CSMT */
 static void surface_evict_sysmem(struct wined3d_surface *surface)
 {
     /* In some conditions the surface memory must not be freed:
@@ -596,6 +656,10 @@ static void surface_evict_sysmem(struct wined3d_surface *surface)
         return;
 
     wined3d_resource_free_sysmem(&surface->resource);
+#if defined(STAGING_CSMT)
+    surface->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
     surface_invalidate_location(surface, WINED3D_LOCATION_SYSMEM);
 }
 
@@ -619,6 +683,7 @@ static void surface_release_client_storage(struct wined3d_surface *surface)
     wined3d_texture_force_reload(surface->container);
 
     context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 static BOOL surface_use_pbo(const struct wined3d_surface *surface)
@@ -703,7 +768,11 @@ static HRESULT surface_private_setup(struct wined3d_surface *surface)
     }
 
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
+#if defined(STAGING_CSMT)
+        surface->resource.locations = WINED3D_LOCATION_DISCARDED;
+#else  /* STAGING_CSMT */
         surface->locations = WINED3D_LOCATION_DISCARDED;
+#endif /* STAGING_CSMT */
 
     if (surface_use_pbo(surface))
         surface->resource.map_binding = WINED3D_LOCATION_BUFFER;
@@ -711,6 +780,24 @@ static HRESULT surface_private_setup(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+static void surface_frontbuffer_updated(struct wined3d_surface *surface)
+{
+    struct wined3d_context *context = NULL;
+    struct wined3d_device *device = surface->resource.device;
+
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
+    {
+        TRACE("Not dirtified, nothing to do.\n");
+        return;
+    }
+
+    if (device->d3d_initialized)
+        context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_load_location(&surface->resource, context, surface->container->resource.draw_binding);
+    if (context)
+        context_release(context);
+#else  /* STAGING_CSMT */
 static void surface_unmap(struct wined3d_surface *surface)
 {
     struct wined3d_device *device = surface->resource.device;
@@ -753,6 +840,7 @@ static void surface_unmap(struct wined3d_surface *surface)
         surface_load_location(surface, surface->container->resource.draw_binding);
     else if (surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
         FIXME("Depth / stencil buffer locking is not implemented.\n");
+#endif /* STAGING_CSMT */
 }
 
 static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RECT *r)
@@ -764,6 +852,26 @@ static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RE
     return TRUE;
 }
 
+static void prepare_blit_quirks(const struct wined3d_device *device, const struct wined3d_gl_info *gl_info)
+{
+  /* ATI Macs blend blits even though GL_EXT_framebuffer_blit says that this
+   * operation does not blend. This sometimes even happens if GL_BLEND is
+   * disabled, although in my glut test case blending has to be enabled for
+   * the bug to occur. While we're at it, disable blending.
+   *
+   * Tracked by crossover hacks bug 5391. */
+  gl_info->gl_ops.gl.p_glDisable(GL_BLEND);
+  gl_info->gl_ops.gl.p_glBlendFunc(GL_ONE, GL_ZERO);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHABLENDENABLE));
+  
+  gl_info->gl_ops.gl.p_glDisable(GL_ALPHA_TEST);
+  gl_info->gl_ops.gl.p_glAlphaFunc(GL_ALWAYS, 0.0);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ALPHATESTENABLE));
+  gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
+  gl_info->gl_ops.gl.p_glStencilFunc(GL_ALWAYS, 0, 0);
+  device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+}
+
 static void surface_depth_blt_fbo(const struct wined3d_device *device,
         struct wined3d_surface *src_surface, DWORD src_location, const RECT *src_rect,
         struct wined3d_surface *dst_surface, DWORD dst_location, const RECT *dst_rect)
@@ -803,12 +911,14 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     if (src_mask & WINED3DFMT_FLAG_STENCIL)
         gl_mask |= GL_STENCIL_BUFFER_BIT;
 
+#if !defined(STAGING_CSMT)
     /* Make sure the locations are up-to-date. Loading the destination
      * surface isn't required if the entire surface is overwritten. */
     surface_load_location(src_surface, src_location);
     if (!surface_is_full_rect(dst_surface, dst_rect))
         surface_load_location(dst_surface, dst_location);
 
+#endif /* STAGING_CSMT */
     context = context_acquire(device, NULL);
     if (!context->valid)
     {
@@ -817,6 +927,14 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
         return;
     }
 
+#if defined(STAGING_CSMT)
+    /* Make sure the locations are up-to-date. Loading the destination
+     * surface isn't required if the entire surface is overwritten. */
+    wined3d_resource_load_location(&src_surface->resource, context, src_location);
+    if (!surface_is_full_rect(dst_surface, dst_rect))
+        wined3d_resource_load_location(&dst_surface->resource, context, dst_location);
+
+#endif /* STAGING_CSMT */
     gl_info = context->gl_info;
 
     context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, NULL, src_surface, src_location);
@@ -846,6 +964,9 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     gl_info->gl_ops.gl.p_glDisable(GL_SCISSOR_TEST);
     context_invalidate_state(context, STATE_RENDER(WINED3D_RS_SCISSORTESTENABLE));
 
+  if (gl_info->quirks & WINED3D_CX_QUIRK_BLIT)
+    prepare_blit_quirks(device, gl_info);
+
     gl_info->fbo_ops.glBlitFramebuffer(src_rect->left, src_rect->top, src_rect->right, src_rect->bottom,
             dst_rect->left, dst_rect->top, dst_rect->right, dst_rect->bottom, gl_mask, GL_NEAREST);
     checkGLcall("glBlitFramebuffer()");
@@ -856,6 +977,18 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     context_release(context);
 }
 
+#if defined(STAGING_CSMT)
+/* Blit between surface locations. Onscreen on different swapchains is not supported.
+ * Depth / stencil is not supported. Context activation is done by the caller. */
+static void surface_blt_fbo(const struct wined3d_device *device,
+        struct wined3d_context *old_ctx, enum wined3d_texture_filter_type filter,
+        struct wined3d_surface *src_surface, DWORD src_location, const RECT *src_rect_in,
+        struct wined3d_surface *dst_surface, DWORD dst_location, const RECT *dst_rect_in)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_surface *required_rt, *restore_rt;
+#else  /* STAGING_CSMT */
 /* Blit between surface locations. Onscreen on different swapchains is not supported.
  * Depth / stencil is not supported. */
 static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_texture_filter_type filter,
@@ -864,6 +997,7 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     RECT src_rect, dst_rect;
     GLenum gl_filter;
     GLenum buffer;
@@ -902,6 +1036,26 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
+#if defined(STAGING_CSMT)
+    wined3d_resource_load_location(&src_surface->resource, old_ctx, src_location);
+    if (!surface_is_full_rect(dst_surface, &dst_rect))
+        wined3d_resource_load_location(&dst_surface->resource, old_ctx, dst_location);
+
+    if (src_location == WINED3D_LOCATION_DRAWABLE) required_rt = src_surface;
+    else if (dst_location == WINED3D_LOCATION_DRAWABLE) required_rt = dst_surface;
+    else required_rt = NULL;
+
+    if (required_rt && required_rt != old_ctx->current_rt)
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, required_rt);
+    }
+    else
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+#else  /* STAGING_CSMT */
     surface_load_location(src_surface, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
         surface_load_location(dst_surface, dst_location);
@@ -909,6 +1063,7 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
     if (src_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, src_surface);
     else if (dst_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, dst_surface);
     else context = context_acquire(device, NULL);
+#endif /* STAGING_CSMT */
 
     if (!context->valid)
     {
@@ -971,7 +1126,16 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
             && dst_surface->container->swapchain->front_buffer == dst_surface->container))
         gl_info->gl_ops.gl.p_glFlush();
 
+#if defined(STAGING_CSMT)
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
+#else  /* STAGING_CSMT */
     context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 static BOOL fbo_blit_supported(const struct wined3d_gl_info *gl_info, enum wined3d_blit_op blit_op,
@@ -1092,6 +1256,7 @@ HRESULT CDECL wined3d_surface_get_render_target_data(struct wined3d_surface *sur
     return wined3d_surface_blt(surface, NULL, render_target, NULL, 0, NULL, WINED3D_TEXF_POINT);
 }
 
+#if !defined(STAGING_CSMT)
 /* Context activation is done by the caller. */
 static void surface_remove_pbo(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
 {
@@ -1102,6 +1267,7 @@ static void surface_remove_pbo(struct wined3d_surface *surface, const struct win
     surface_invalidate_location(surface, WINED3D_LOCATION_BUFFER);
 }
 
+#endif /* STAGING_CSMT */
 static ULONG surface_resource_incref(struct wined3d_resource *resource)
 {
     return wined3d_surface_incref(surface_from_resource(resource));
@@ -1122,6 +1288,19 @@ static void surface_unload(struct wined3d_resource *resource)
 
     TRACE("surface %p.\n", surface);
 
+#if defined(STAGING_CSMT)
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
+    if (resource->pool == WINED3D_POOL_DEFAULT)
+    {
+        /* Default pool resources are supposed to be destroyed before Reset is called.
+         * Implicit resources stay however. So this means we have an implicit render target
+         * or depth stencil. The content may be destroyed, but we still have to tear down
+         * opengl resources, so we cannot leave early. */
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DISCARDED);
+#else  /* STAGING_CSMT */
     if (resource->pool == WINED3D_POOL_DEFAULT)
     {
         /* Default pool resources are supposed to be destroyed before Reset is called.
@@ -1137,6 +1316,7 @@ static void surface_unload(struct wined3d_resource *resource)
         memset(surface->resource.heap_memory, 0, surface->resource.size);
         surface_validate_location(surface, WINED3D_LOCATION_SYSMEM);
         surface_invalidate_location(surface, ~WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
 
         /* We also get here when the ddraw swapchain is destroyed, for example
          * for a mode switch. In this case this surface won't necessarily be
@@ -1146,6 +1326,12 @@ static void surface_unload(struct wined3d_resource *resource)
     }
     else
     {
+#if defined(STAGING_CSMT)
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
+    }
+#else  /* STAGING_CSMT */
         surface_prepare_map_memory(surface);
         surface_load_location(surface, surface->resource.map_binding);
         surface_invalidate_location(surface, ~surface->resource.map_binding);
@@ -1157,6 +1343,7 @@ static void surface_unload(struct wined3d_resource *resource)
     /* Destroy PBOs, but load them into real sysmem before */
     if (surface->pbo)
         surface_remove_pbo(surface, gl_info);
+#endif /* STAGING_CSMT */
 
     /* Destroy fbo render buffers. This is needed for implicit render targets, for
      * all application-created targets the application has to release the surface
@@ -1187,6 +1374,23 @@ static void surface_unload(struct wined3d_resource *resource)
     resource_unload(resource);
 }
 
+#if defined(STAGING_CSMT)
+static void wined3d_surface_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    struct wined3d_surface *surface = surface_from_resource(resource);
+
+    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+        wined3d_texture_set_dirty(surface->container);
+
+    if (surface->container->swapchain && surface->container == surface->container->swapchain->front_buffer)
+        surface->surface_ops->surface_frontbuffer_updated(surface);
+}
+
+static const struct wined3d_surface_ops surface_ops =
+{
+    surface_private_setup,
+    surface_frontbuffer_updated,
+#else  /* STAGING_CSMT */
 static const struct wined3d_resource_ops surface_resource_ops =
 {
     surface_resource_incref,
@@ -1198,6 +1402,7 @@ static const struct wined3d_surface_ops surface_ops =
 {
     surface_private_setup,
     surface_unmap,
+#endif /* STAGING_CSMT */
 };
 
 /*****************************************************************************
@@ -1241,6 +1446,17 @@ static HRESULT gdi_surface_private_setup(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
+#if defined(STAGING_CSMT)
+static void gdi_surface_frontbuffer_updated(struct wined3d_surface *surface)
+{
+    x11_copy_to_screen(surface->container->swapchain, &surface->lockedRect);
+}
+
+static const struct wined3d_surface_ops gdi_surface_ops =
+{
+    gdi_surface_private_setup,
+    gdi_surface_frontbuffer_updated,
+#else  /* STAGING_CSMT */
 static void gdi_surface_unmap(struct wined3d_surface *surface)
 {
     TRACE("surface %p.\n", surface);
@@ -1256,6 +1472,7 @@ static const struct wined3d_surface_ops gdi_surface_ops =
 {
     gdi_surface_private_setup,
     gdi_surface_unmap,
+#endif /* STAGING_CSMT */
 };
 
 /* This call just downloads data, the caller is responsible for binding the
@@ -1274,7 +1491,11 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         return;
     }
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_get_memory(&surface->resource, dst_location, &data);
+#else  /* STAGING_CSMT */
     surface_get_memory(surface, &data, dst_location);
+#endif /* STAGING_CSMT */
 
     if (format->flags & WINED3DFMT_FLAG_COMPRESSED)
     {
@@ -1302,14 +1523,14 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         void *mem;
         GLenum gl_format = format->glFormat;
         GLenum gl_type = format->glType;
-        int src_pitch = 0;
-        int dst_pitch = 0;
+        UINT src_pitch = 0;
+        UINT dst_row_pitch, dst_slice_pitch;
 
         if (surface->flags & SFLAG_NONPOW2)
         {
             unsigned char alignment = surface->resource.device->surface_alignment;
             src_pitch = format->byte_count * surface->pow2Width;
-            dst_pitch = wined3d_surface_get_pitch(surface);
+            wined3d_resource_get_pitch(&surface->resource, &dst_row_pitch, &dst_slice_pitch);
             src_pitch = (src_pitch + alignment - 1) & ~(alignment - 1);
             mem = HeapAlloc(GetProcessHeap(), 0, src_pitch * surface->pow2Height);
         }
@@ -1396,12 +1617,12 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
              * won't be released, and doesn't have to be re-read. */
             src_data = mem;
             dst_data = data.addr;
-            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_pitch);
+            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_row_pitch);
             for (y = 0; y < surface->resource.height; ++y)
             {
-                memcpy(dst_data, src_data, dst_pitch);
+                memcpy(dst_data, src_data, dst_row_pitch);
                 src_data += src_pitch;
-                dst_data += dst_pitch;
+                dst_data += dst_row_pitch;
             }
 
             HeapFree(GetProcessHeap(), 0, mem);
@@ -1523,13 +1744,29 @@ void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct w
     }
 }
 
+#if defined(STAGING_CSMT)
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
+{
+    struct wined3d_box box;
+
+    if (!rect)
+        return wined3d_resource_check_block_align(&surface->resource, NULL);
+
+    box.left = rect->left;
+    box.top = rect->top;
+    box.front = 0;
+    box.right = rect->right;
+    box.bottom = rect->bottom;
+    box.back = 1;
+    return wined3d_resource_check_block_align(&surface->resource, &box);
+#else  /* STAGING_CSMT */
 static BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
 {
     UINT width_mask, height_mask;
 
-    if (!rect->left && !rect->top
+    if (!rect || (!rect->left && !rect->top
             && rect->right == surface->resource.width
-            && rect->bottom == surface->resource.height)
+            && rect->bottom == surface->resource.height))
         return TRUE;
 
     /* This assumes power of two block sizes, but NPOT block sizes would be
@@ -1542,6 +1779,7 @@ static BOOL surface_check_block_align(struct wined3d_surface *surface, const REC
         return TRUE;
 
     return FALSE;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
@@ -1555,7 +1793,7 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     UINT update_w, update_h;
     UINT dst_w, dst_h;
     RECT r, dst_rect;
-    UINT src_pitch;
+    UINT src_row_pitch, src_slice_pitch;
     POINT p;
 
     TRACE("dst_surface %p, dst_point %s, src_surface %p, src_rect %s.\n",
@@ -1624,9 +1862,17 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
         return WINED3DERR_INVALIDCALL;
     }
 
+#if defined(STAGING_CSMT)
+    /* Use surface_cpu_blt() instead of uploading directly if we need
+     * conversion. Avoid calling wined3d_surface_blt() since that goes
+     * through the CS. */
+    if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_surface->container, FALSE))
+        return surface_cpu_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+#else  /* STAGING_CSMT */
     /* Use wined3d_surface_blt() instead of uploading directly if we need conversion. */
     if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_surface->container, FALSE))
         return wined3d_surface_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+#endif /* STAGING_CSMT */
 
     context = context_acquire(dst_surface->resource.device, NULL);
     gl_info = context->gl_info;
@@ -1637,19 +1883,31 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     if (update_w == dst_w && update_h == dst_h)
         wined3d_texture_prepare_texture(dst_surface->container, context, FALSE);
     else
+#if defined(STAGING_CSMT)
+        wined3d_resource_load_location(&dst_surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_texture_bind_and_dirtify(dst_surface->container, context, FALSE);
+
+    wined3d_resource_get_memory(&src_surface->resource, src_surface->resource.locations, &data);
+#else  /* STAGING_CSMT */
         surface_load_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind_and_dirtify(dst_surface->container, context, FALSE);
 
     surface_get_memory(src_surface, &data, src_surface->locations);
-    src_pitch = wined3d_surface_get_pitch(src_surface);
+#endif /* STAGING_CSMT */
+    wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
 
     wined3d_surface_upload_data(dst_surface, gl_info, src_format, src_rect,
-            src_pitch, dst_point, FALSE, wined3d_const_bo_address(&data));
+            src_row_pitch, dst_point, FALSE, wined3d_const_bo_address(&data));
 
     context_release(context);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
     surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
     surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -1753,7 +2011,12 @@ GLenum surface_get_gl_buffer(const struct wined3d_surface *surface)
     return GL_BACK;
 }
 
+#if defined(STAGING_CSMT)
+/* Context activation is done by the caller. */
+void surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb)
+#else  /* STAGING_CSMT */
 void surface_load(struct wined3d_surface *surface, BOOL srgb)
+#endif /* STAGING_CSMT */
 {
     DWORD location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
 
@@ -1762,6 +2025,16 @@ void surface_load(struct wined3d_surface *surface, BOOL srgb)
     if (surface->resource.pool == WINED3D_POOL_SCRATCH)
         ERR("Not supported on scratch surfaces.\n");
 
+#if defined(STAGING_CSMT)
+    if (surface->resource.locations & location)
+    {
+        TRACE("surface is already in texture\n");
+        return;
+    }
+    TRACE("Reloading because surface is dirty.\n");
+
+    wined3d_resource_load_location(&surface->resource, context, location);
+#else  /* STAGING_CSMT */
     if (surface->locations & location)
     {
         TRACE("surface is already in texture\n");
@@ -1770,6 +2043,7 @@ void surface_load(struct wined3d_surface *surface, BOOL srgb)
     TRACE("Reloading because surface is dirty.\n");
 
     surface_load_location(surface, location);
+#endif /* STAGING_CSMT */
     surface_evict_sysmem(surface);
 }
 
@@ -1852,6 +2126,18 @@ ULONG CDECL wined3d_surface_decref(struct wined3d_surface *surface)
 
 void CDECL wined3d_surface_preload(struct wined3d_surface *surface)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_device *device = surface->resource.device;
+    TRACE("surface %p.\n", surface);
+
+    if (!device->d3d_initialized)
+    {
+        ERR("D3D not initialized.\n");
+        return;
+    }
+
+    wined3d_cs_emit_surface_preload(device->cs, surface);
+#else  /* STAGING_CSMT */
     TRACE("surface %p.\n", surface);
 
     if (!surface->resource.device->d3d_initialized)
@@ -1861,6 +2147,7 @@ void CDECL wined3d_surface_preload(struct wined3d_surface *surface)
     }
 
     wined3d_texture_preload(surface->container);
+#endif /* STAGING_CSMT */
 }
 
 void * CDECL wined3d_surface_get_parent(const struct wined3d_surface *surface)
@@ -1925,25 +2212,6 @@ HRESULT CDECL wined3d_surface_restore(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
-DWORD CDECL wined3d_surface_get_pitch(const struct wined3d_surface *surface)
-{
-    unsigned int alignment;
-    DWORD pitch;
-
-    TRACE("surface %p.\n", surface);
-
-    if (surface->pitch)
-        return surface->pitch;
-
-    alignment = surface->resource.device->surface_alignment;
-    pitch = wined3d_format_calculate_pitch(surface->resource.format, surface->resource.width);
-    pitch = (pitch + alignment - 1) & ~(alignment - 1);
-
-    TRACE("Returning %u.\n", pitch);
-
-    return pitch;
-}
-
 HRESULT CDECL wined3d_surface_set_overlay_position(struct wined3d_surface *surface, LONG x, LONG y)
 {
     LONG w, h;
@@ -2087,6 +2355,16 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
+#if defined(STAGING_CSMT)
+        surface->resource.bitmap_data = NULL;
+        surface->flags &= ~SFLAG_DIBSECTION;
+        create_dib = TRUE;
+    }
+
+    surface->resource.locations = 0;
+    wined3d_resource_free_sysmem(&surface->resource);
+    surface->resource.map_heap_memory = NULL;
+#else  /* STAGING_CSMT */
         surface->dib.bitmap_data = NULL;
         surface->flags &= ~SFLAG_DIBSECTION;
         create_dib = TRUE;
@@ -2094,6 +2372,7 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
 
     surface->locations = 0;
     wined3d_resource_free_sysmem(&surface->resource);
+#endif /* STAGING_CSMT */
 
     width = texture_resource->width;
     height = texture_resource->height;
@@ -2119,25 +2398,30 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
     else
         surface->flags &= ~SFLAG_NONPOW2;
 
+#if defined(STAGING_CSMT)
+    if ((surface->resource.user_memory = mem))
+#else  /* STAGING_CSMT */
     if ((surface->user_memory = mem))
+#endif /* STAGING_CSMT */
     {
         surface->resource.map_binding = WINED3D_LOCATION_USER_MEMORY;
         valid_location = WINED3D_LOCATION_USER_MEMORY;
     }
-    surface->pitch = pitch;
+    surface->resource.custom_row_pitch = pitch;
+    surface->resource.custom_slice_pitch = pitch * surface->resource.height;
     surface->resource.format = texture_resource->format;
     surface->resource.multisample_type = texture_resource->multisample_type;
     surface->resource.multisample_quality = texture_resource->multisample_quality;
-    if (surface->pitch)
+    if (surface->resource.custom_row_pitch)
     {
-        surface->resource.size = height * surface->pitch;
+        surface->resource.size = height * surface->resource.custom_row_pitch;
     }
     else
     {
         /* User memory surfaces don't have the regular surface alignment. */
-        surface->resource.size = wined3d_format_calculate_size(texture_resource->format,
-                1, width, height, 1);
-        surface->pitch = wined3d_format_calculate_pitch(texture_resource->format, width);
+        surface->resource.size = wined3d_format_calculate_size(texture_resource->format, 1, width, height, 1);
+        surface->resource.custom_row_pitch = wined3d_format_calculate_pitch(texture_resource->format, width);
+        surface->resource.custom_slice_pitch = surface->resource.custom_row_pitch * surface->resource.height; /* FIXME */
     }
 
     /* The format might be changed to a format that needs conversion.
@@ -2160,11 +2444,19 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
 
     if (!valid_location)
     {
+#if defined(STAGING_CSMT)
+        wined3d_resource_prepare_system_memory(&surface->resource);
+        valid_location = WINED3D_LOCATION_SYSMEM;
+    }
+
+    wined3d_resource_validate_location(&surface->resource, valid_location);
+#else  /* STAGING_CSMT */
         surface_prepare_system_memory(surface);
         valid_location = WINED3D_LOCATION_SYSMEM;
     }
 
     surface_validate_location(surface, valid_location);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -2338,6 +2630,126 @@ static void convert_yuy2_r5g6b5(const BYTE *src, BYTE *dst,
     }
 }
 
+static void convert_dxt1_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt1_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_dxt1_a4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4A4_UNORM, w, h);
+}
+
+static void convert_dxt1_x4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4X4_UNORM, w, h);
+}
+
+static void convert_dxt1_a1r5g5b5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5A1_UNORM, w, h);
+}
+
+static void convert_dxt1_x1r5g5b5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5X1_UNORM, w, h);
+}
+
+static void convert_dxt3_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt3_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_dxt3_a4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4A4_UNORM, w, h);
+}
+
+static void convert_dxt3_x4r4g4b4(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B4G4R4X4_UNORM, w, h);
+}
+
+static void convert_dxt5_a8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_dxt5_x8r8g8b8(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_decode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a1r5g5b5_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5A1_UNORM, w, h);
+}
+
+static void convert_x1r5g5b5_dxt1(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt1_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B5G5R5X1_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt3(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt3(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt3_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
+static void convert_a8r8g8b8_dxt5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8A8_UNORM, w, h);
+}
+
+static void convert_x8r8g8b8_dxt5(const BYTE *src, BYTE *dst,
+        DWORD pitch_in, DWORD pitch_out, unsigned int w, unsigned int h)
+{
+    wined3d_dxt5_encode(src, dst, pitch_in, pitch_out, WINED3DFMT_B8G8R8X8_UNORM, w, h);
+}
+
 struct d3dfmt_converter_desc
 {
     enum wined3d_format_id from, to;
@@ -2354,6 +2766,33 @@ static const struct d3dfmt_converter_desc converters[] =
     {WINED3DFMT_YUY2,           WINED3DFMT_B5G6R5_UNORM,    convert_yuy2_r5g6b5},
 };
 
+static const struct d3dfmt_converter_desc dxtn_converters[] =
+{
+    /* decode DXT */
+    {WINED3DFMT_DXT1,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt1_a8r8g8b8},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt1_x8r8g8b8},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B4G4R4A4_UNORM,  convert_dxt1_a4r4g4b4},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B4G4R4X4_UNORM,  convert_dxt1_x4r4g4b4},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B5G5R5A1_UNORM,  convert_dxt1_a1r5g5b5},
+    {WINED3DFMT_DXT1,           WINED3DFMT_B5G5R5X1_UNORM,  convert_dxt1_x1r5g5b5},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt3_a8r8g8b8},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt3_x8r8g8b8},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B4G4R4A4_UNORM,  convert_dxt3_a4r4g4b4},
+    {WINED3DFMT_DXT3,           WINED3DFMT_B4G4R4X4_UNORM,  convert_dxt3_x4r4g4b4},
+    {WINED3DFMT_DXT5,           WINED3DFMT_B8G8R8A8_UNORM,  convert_dxt5_a8r8g8b8},
+    {WINED3DFMT_DXT5,           WINED3DFMT_B8G8R8X8_UNORM,  convert_dxt5_x8r8g8b8},
+
+    /* encode DXT */
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT1,            convert_a8r8g8b8_dxt1},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT1,            convert_x8r8g8b8_dxt1},
+    {WINED3DFMT_B5G5R5A1_UNORM, WINED3DFMT_DXT1,            convert_a1r5g5b5_dxt1},
+    {WINED3DFMT_B5G5R5X1_UNORM, WINED3DFMT_DXT1,            convert_x1r5g5b5_dxt1},
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT3,            convert_a8r8g8b8_dxt3},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT3,            convert_x8r8g8b8_dxt3},
+    {WINED3DFMT_B8G8R8A8_UNORM, WINED3DFMT_DXT5,            convert_a8r8g8b8_dxt5},
+    {WINED3DFMT_B8G8R8X8_UNORM, WINED3DFMT_DXT5,            convert_x8r8g8b8_dxt5}
+};
+
 static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_format_id from,
         enum wined3d_format_id to)
 {
@@ -2365,16 +2804,33 @@ static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_fo
             return &converters[i];
     }
 
+    for (i = 0; i < (sizeof(dxtn_converters) / sizeof(*dxtn_converters)); ++i)
+    {
+        if (dxtn_converters[i].from == from && dxtn_converters[i].to == to)
+            return wined3d_dxtn_supported() ? &dxtn_converters[i] : NULL;
+    }
+
     return NULL;
 }
 
 static struct wined3d_texture *surface_convert_format(struct wined3d_surface *source, enum wined3d_format_id to_fmt)
 {
+#if defined(STAGING_CSMT)
+    void *dst_data = NULL, *src_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
+    const struct d3dfmt_converter_desc *conv;
+    struct wined3d_texture *ret = NULL;
+    struct wined3d_resource_desc desc;
+    struct wined3d_surface *dst;
+    struct wined3d_context *context = NULL;
+    struct wined3d_device *device = source->resource.device;
+#else  /* STAGING_CSMT */
     struct wined3d_map_desc src_map, dst_map;
     const struct d3dfmt_converter_desc *conv;
     struct wined3d_texture *ret = NULL;
     struct wined3d_resource_desc desc;
     struct wined3d_surface *dst;
+#endif /* STAGING_CSMT */
 
     conv = find_converter(source->resource.format->id, to_fmt);
     if (!conv)
@@ -2398,6 +2854,48 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_surface *so
     }
     dst = surface_from_resource(wined3d_texture_get_sub_resource(ret, 0));
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_get_pitch(&source->resource, &src_row_pitch, &src_slice_pitch);
+    wined3d_resource_get_pitch(&ret->resource, &dst_row_pitch, &dst_slice_pitch);
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_resource_load_location(&source->resource, context, source->resource.map_binding);
+    src_data = wined3d_resource_get_map_ptr(&source->resource, context, WINED3D_MAP_READONLY);
+    if (!src_data)
+        goto error;
+
+    if (!wined3d_resource_prepare_map_memory(&dst->resource, context))
+        goto error;
+    dst_data = wined3d_resource_get_map_ptr(&dst->resource, context, 0);
+    if (!dst_data)
+        goto error;
+
+    conv->convert(src_data, dst_data, src_row_pitch, dst_row_pitch,
+            source->resource.width, source->resource.height);
+
+    wined3d_resource_release_map_ptr(&dst->resource, context);
+    wined3d_resource_release_map_ptr(&source->resource, context);
+
+    if (context)
+        context_release(context);
+
+    return ret;
+
+error:
+    ERR("Surface conversion failed.\n");
+
+    if (src_data)
+        wined3d_resource_release_map_ptr(&source->resource, context);
+    if (dst_data)
+        wined3d_resource_release_map_ptr(&ret->resource, context);
+    if (ret)
+        wined3d_texture_decref(ret);
+    if (context)
+        context_release(context);
+    return NULL;
+#else  /* STAGING_CSMT */
     memset(&src_map, 0, sizeof(src_map));
     memset(&dst_map, 0, sizeof(dst_map));
 
@@ -2422,6 +2920,7 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_surface *so
     wined3d_surface_unmap(source);
 
     return ret;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -2489,6 +2988,25 @@ struct wined3d_surface * CDECL wined3d_surface_from_resource(struct wined3d_reso
 
 HRESULT CDECL wined3d_surface_unmap(struct wined3d_surface *surface)
 {
+#if defined(STAGING_CSMT)
+    HRESULT hr;
+    TRACE("surface %p.\n", surface);
+
+    hr = wined3d_resource_unmap(&surface->resource);
+    if (FAILED(hr))
+        return hr;
+
+    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
+
+    return hr;
+}
+
+HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
+        struct wined3d_map_desc *map_desc, const RECT *rect, DWORD flags)
+{
+    struct wined3d_box box;
+    const struct wined3d_format *format = surface->resource.format;
+#else  /* STAGING_CSMT */
     TRACE("surface %p.\n", surface);
 
     if (!surface->resource.map_count)
@@ -2520,6 +3038,7 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         WARN("Surface is already mapped.\n");
         return WINED3DERR_INVALIDCALL;
     }
+#endif /* STAGING_CSMT */
 
     if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && rect
             && !surface_check_block_align(surface, rect))
@@ -2531,11 +3050,13 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
             return WINED3DERR_INVALIDCALL;
     }
 
+#if !defined(STAGING_CSMT)
     ++surface->resource.map_count;
 
     if (!(surface->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
         WARN("Trying to lock unlockable surface.\n");
 
+#endif /* STAGING_CSMT */
     /* Performance optimization: Count how often a surface is mapped, if it is
      * mapped regularly do not throw away the system memory copy. This avoids
      * the need to download the surface from OpenGL all the time. The surface
@@ -2551,19 +3072,85 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         }
     }
 
-    surface_prepare_map_memory(surface);
-    if (flags & WINED3D_MAP_DISCARD)
+#if defined(STAGING_CSMT)
+    if (rect)
     {
-        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
-                wined3d_debug_location(surface->resource.map_binding));
-        surface_validate_location(surface, surface->resource.map_binding);
+        surface->lockedRect = *rect;
+
+        box.left = rect->left;
+        box.top = rect->top;
+        box.front = 0;
+        box.right = rect->right;
+        box.bottom = rect->bottom;
+        box.back = 1;
     }
     else
     {
-        if (surface->resource.usage & WINED3DUSAGE_DYNAMIC)
-            WARN_(d3d_perf)("Mapping a dynamic surface without WINED3D_MAP_DISCARD.\n");
-
-        surface_load_location(surface, surface->resource.map_binding);
+        surface->lockedRect.left = 0;
+        surface->lockedRect.top = 0;
+        surface->lockedRect.right = surface->resource.width;
+        surface->lockedRect.bottom = surface->resource.height;
+    }
+
+    return wined3d_resource_map(&surface->resource, map_desc, rect ? &box : NULL, flags);
+}
+
+void wined3d_surface_getdc_cs(struct wined3d_surface *surface)
+{
+    struct wined3d_device *device = surface->resource.device;
+    struct wined3d_context *context = NULL;
+
+    if (device->d3d_initialized)
+        context = context_acquire(surface->resource.device, NULL);
+
+    /* Create a DIB section if there isn't a dc yet. */
+    if (!surface->hDC)
+    {
+        HRESULT hr = surface_create_dib_section(surface);
+        if (FAILED(hr))
+        {
+            if (context)
+                context_release(context);
+            return;
+        }
+        if (!(surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY
+                || surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
+                || surface->resource.buffer))
+            surface->resource.map_binding = WINED3D_LOCATION_DIB;
+    }
+
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_DIB);
+    wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DIB);
+
+    if (context)
+        context_release(context);
+}
+
+HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
+{
+    struct wined3d_device *device = surface->resource.device;
+
+    TRACE("surface %p, dc %p.\n", surface, dc);
+
+    if (!(surface->resource.format->flags & WINED3DFMT_FLAG_GETDC))
+    {
+        WARN("Cannot use GetDC on a %s surface.\n", debug_d3dformat(surface->resource.format->id));
+        return WINED3DERR_INVALIDCALL;
+    }
+#else  /* STAGING_CSMT */
+    surface_prepare_map_memory(surface);
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
+                wined3d_debug_location(surface->resource.map_binding));
+        surface_validate_location(surface, surface->resource.map_binding);
+    }
+    else
+    {
+        if (surface->resource.usage & WINED3DUSAGE_DYNAMIC)
+            WARN_(d3d_perf)("Mapping a dynamic surface without WINED3D_MAP_DISCARD.\n");
+
+        surface_load_location(surface, surface->resource.map_binding);
     }
 
     if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
@@ -2603,7 +3190,7 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
     if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
         map_desc->row_pitch = surface->resource.width * format->byte_count;
     else
-        map_desc->row_pitch = wined3d_surface_get_pitch(surface);
+        wined3d_resource_get_pitch(&surface->resource, &map_desc->row_pitch, &map_desc->slice_pitch);
     map_desc->slice_pitch = 0;
 
     if (!rect)
@@ -2647,6 +3234,7 @@ HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
     HRESULT hr;
 
     TRACE("surface %p, dc %p.\n", surface, dc);
+#endif /* STAGING_CSMT */
 
     /* Give more detailed info for ddraw. */
     if (surface->flags & SFLAG_DCINUSE)
@@ -2656,6 +3244,40 @@ HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
     if (surface->resource.map_count)
         return WINED3DERR_INVALIDCALL;
 
+#if defined(STAGING_CSMT)
+    surface->flags |= SFLAG_DCINUSE;
+    surface->resource.map_count++;
+    wined3d_cs_emit_getdc(device->cs, surface);
+    *dc = surface->hDC;
+    TRACE("Returning dc %p.\n", *dc);
+
+    return *dc ? WINED3D_OK : WINED3DERR_INVALIDCALL;
+}
+
+void wined3d_surface_releasedc_cs(struct wined3d_surface *surface)
+{
+    if (surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY || (surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
+            && surface->resource.map_binding != WINED3D_LOCATION_DIB))
+    {
+        /* The game Salammbo modifies the surface contents without mapping the surface between
+         * a GetDC/ReleaseDC operation and flipping the surface. If the DIB remains the active
+         * copy and is copied to the screen, this update, which draws the mouse pointer, is lost.
+         * Do not only copy the DIB to the map location, but also make sure the map location is
+         * copied back to the DIB in the next getdc call.
+         *
+         * The same consideration applies to user memory surfaces. */
+        struct wined3d_device *device = surface->resource.device;
+        struct wined3d_context *context = NULL;
+
+        if (device->d3d_initialized)
+            context = context_acquire(device, NULL);
+
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_DIB);
+        if (context)
+            context_release(context);
+    }
+#else  /* STAGING_CSMT */
     /* Create a DIB section if there isn't a dc yet. */
     if (!surface->hDC)
     {
@@ -2683,6 +3305,7 @@ HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
     TRACE("Returning dc %p.\n", *dc);
 
     return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
@@ -2702,6 +3325,20 @@ HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
     surface->resource.map_count--;
     surface->flags &= ~SFLAG_DCINUSE;
 
+#if defined(STAGING_CSMT)
+    wined3d_cs_emit_releasedc(surface->resource.device->cs, surface);
+
+    return WINED3D_OK;
+}
+
+static void read_from_framebuffer(struct wined3d_surface *surface,
+        struct wined3d_context *old_ctx, DWORD dst_location)
+{
+    struct wined3d_device *device = surface->resource.device;
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_surface *restore_rt;
+#else  /* STAGING_CSMT */
     if (surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY
             || (surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
             && surface->resource.map_binding != WINED3D_LOCATION_DIB))
@@ -2725,15 +3362,37 @@ static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_loc
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+#endif /* STAGING_CSMT */
     BYTE *mem;
     BYTE *row, *top, *bottom;
     int i;
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
+    UINT row_pitch, slice_pitch;
+
+#if defined(STAGING_CSMT)
+    wined3d_resource_get_memory(&surface->resource, dst_location, &data);
+
+    /* Context_release does not restore the original context in case of
+     * nested context_acquire calls. Only read_from_framebuffer and
+     * surface_blt_to_drawable use nested context_acquire calls. Manually
+     * restore the original context at the end of the function if needed. */
+    if (old_ctx->current_rt == surface)
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+    else
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, surface);
+    }
 
+#else  /* STAGING_CSMT */
     surface_get_memory(surface, &data, dst_location);
 
     context = context_acquire(device, surface);
+#endif /* STAGING_CSMT */
     context_apply_blit_state(context, device);
     gl_info = context->gl_info;
 
@@ -2766,8 +3425,8 @@ static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_loc
     }
 
     /* Setup pixel store pack state -- to glReadPixels into the correct place */
-    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH,
-            wined3d_surface_get_pitch(surface) / surface->resource.format->byte_count);
+    wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+    gl_info->gl_ops.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, row_pitch / surface->resource.format->byte_count);
     checkGLcall("glPixelStorei");
 
     gl_info->gl_ops.gl.p_glReadPixels(0, 0,
@@ -2784,7 +3443,9 @@ static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_loc
     {
         /* glReadPixels returns the image upside down, and there is no way to prevent this.
          * Flip the lines in software. */
-        UINT pitch = wined3d_surface_get_pitch(surface);
+        UINT pitch, slice_pitch;
+
+        wined3d_resource_get_pitch(&surface->resource, &pitch, &slice_pitch);
 
         if (!(row = HeapAlloc(GetProcessHeap(), 0, pitch)))
             goto error;
@@ -2820,7 +3481,16 @@ error:
         checkGLcall("glBindBuffer");
     }
 
+#if defined(STAGING_CSMT)
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
+#else  /* STAGING_CSMT */
     context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 /* Read the framebuffer contents into a texture. Note that this function
@@ -2882,6 +3552,7 @@ void surface_prepare_rb(struct wined3d_surface *surface, const struct wined3d_gl
     }
 }
 
+#if !defined(STAGING_CSMT)
 void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back)
 {
     if (front->container->level_count != 1 || front->container->layer_count != 1
@@ -2959,6 +3630,7 @@ void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back)
     }
 }
 
+#endif /* STAGING_CSMT */
 /* Does a direct frame buffer -> texture copy. Stretching is done with single
  * pixel copy calls. */
 static void fb_copy_to_texture_direct(struct wined3d_surface *dst_surface, struct wined3d_surface *src_surface,
@@ -3065,8 +3737,13 @@ static void fb_copy_to_texture_direct(struct wined3d_surface *dst_surface, struc
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
+#if defined(STAGING_CSMT)
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
     surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
     surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 }
 
 /* Uses the hardware to stretch and flip the image */
@@ -3134,7 +3811,11 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glEnable(texture_target)");
 
         /* For now invalidate the texture copy of the back buffer. Drawable and sysmem copy are untouched */
+#if defined(STAGING_CSMT)
+        wined3d_resource_invalidate_location(&src_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
         src_surface->locations &= ~WINED3D_LOCATION_TEXTURE_RGB;
+#endif /* STAGING_CSMT */
     }
 
     /* Make sure that the top pixel is always above the bottom pixel, and keep a separate upside down flag
@@ -3331,6 +4012,19 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering)
+        gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
+
+    context_release(context);
+
+    /* The texture is now most up to date - If the surface is a render target
+     * and has a drawable, this path is never entered. */
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
+#else  /* STAGING_CSMT */
     if (wined3d_settings.strict_draw_ordering)
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
@@ -3340,6 +4034,7 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
      * and has a drawable, this path is never entered. */
     surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
     surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+#endif /* STAGING_CSMT */
 }
 
 /* Front buffer coordinates are always full screen coordinates, but our GL
@@ -3370,6 +4065,42 @@ void surface_translate_drawable_coords(const struct wined3d_surface *surface, HW
     rect->bottom = drawable_height - rect->bottom;
 }
 
+#if defined(STAGING_CSMT)
+/* Context activation is done by the caller. */
+static void surface_blt_to_drawable(const struct wined3d_device *device,
+        struct wined3d_context *old_ctx,
+        enum wined3d_texture_filter_type filter, BOOL alpha_test,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in,
+        struct wined3d_surface *dst_surface, const RECT *dst_rect_in)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_context *context;
+    struct wined3d_surface *restore_rt;
+    RECT src_rect, dst_rect;
+
+    src_rect = *src_rect_in;
+    dst_rect = *dst_rect_in;
+
+    /* Context_release does not restore the original context in case of
+     * nested context_acquire calls. Only read_from_framebuffer and
+     * surface_blt_to_drawable use nested context_acquire calls. Manually
+     * restore the original context at the end of the function if needed. */
+    if (old_ctx->current_rt == dst_surface)
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+    else
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, dst_surface);
+    }
+    gl_info = context->gl_info;
+
+    /* Make sure the surface is up-to-date. This should probably use
+     * wined3d_resource_load_location() and worry about the destination
+     * surface too, unless we're overwriting it completely. */
+#else  /* STAGING_CSMT */
 static void surface_blt_to_drawable(const struct wined3d_device *device,
         enum wined3d_texture_filter_type filter, BOOL alpha_test,
         struct wined3d_surface *src_surface, const RECT *src_rect_in,
@@ -3388,6 +4119,7 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     /* Make sure the surface is up-to-date. This should probably use
      * surface_load_location() and worry about the destination surface too,
      * unless we're overwriting it completely. */
+#endif /* STAGING_CSMT */
     wined3d_texture_load(src_surface->container, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -3430,12 +4162,28 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
+            || (dst_surface->container->swapchain
+            && dst_surface->container->swapchain->front_buffer == dst_surface->container))
+        gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
+
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
+#else  /* STAGING_CSMT */
     if (wined3d_settings.strict_draw_ordering
             || (dst_surface->container->swapchain
             && dst_surface->container->swapchain->front_buffer == dst_surface->container))
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const struct wined3d_color *color)
@@ -3459,8 +4207,13 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
         enum wined3d_texture_filter_type filter)
 {
     struct wined3d_device *device = dst_surface->resource.device;
+#if defined(STAGING_CSMT)
+    struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[0]);
+#else  /* STAGING_CSMT */
     const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]);
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+#endif /* STAGING_CSMT */
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, blt_fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
@@ -3651,6 +4404,16 @@ void surface_modify_ds_location(struct wined3d_surface *surface,
 {
     TRACE("surface %p, new location %#x, w %u, h %u.\n", surface, location, w, h);
 
+#if defined(STAGING_CSMT)
+    if (((surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB) && !(location & WINED3D_LOCATION_TEXTURE_RGB))
+            || (!(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+            && (location & WINED3D_LOCATION_TEXTURE_RGB)))
+        wined3d_texture_set_dirty(surface->container);
+
+    surface->ds_current_size.cx = w;
+    surface->ds_current_size.cy = h;
+    surface->resource.locations = location;
+#else  /* STAGING_CSMT */
     if (((surface->locations & WINED3D_LOCATION_TEXTURE_RGB) && !(location & WINED3D_LOCATION_TEXTURE_RGB))
             || (!(surface->locations & WINED3D_LOCATION_TEXTURE_RGB) && (location & WINED3D_LOCATION_TEXTURE_RGB)))
         wined3d_texture_set_dirty(surface->container);
@@ -3658,6 +4421,7 @@ void surface_modify_ds_location(struct wined3d_surface *surface,
     surface->ds_current_size.cx = w;
     surface->ds_current_size.cy = h;
     surface->locations = location;
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -3672,7 +4436,11 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
     /* TODO: Make this work for modes other than FBO */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO) return;
 
+#if defined(STAGING_CSMT)
+    if (!(surface->resource.locations & location))
+#else  /* STAGING_CSMT */
     if (!(surface->locations & location))
+#endif /* STAGING_CSMT */
     {
         w = surface->ds_current_size.cx;
         h = surface->ds_current_size.cy;
@@ -3698,7 +4466,11 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         return;
     }
 
+#if defined(STAGING_CSMT)
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+#else  /* STAGING_CSMT */
     if (surface->locations & WINED3D_LOCATION_DISCARDED)
+#endif /* STAGING_CSMT */
     {
         TRACE("Surface was discarded, no need copy data.\n");
         switch (location)
@@ -3715,6 +4487,19 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
             default:
                 FIXME("Unhandled location %#x\n", location);
         }
+#if defined(STAGING_CSMT)
+        surface->resource.locations &= ~WINED3D_LOCATION_DISCARDED;
+        surface->resource.locations |= location;
+        surface->ds_current_size.cx = surface->resource.width;
+        surface->ds_current_size.cy = surface->resource.height;
+        return;
+    }
+
+    if (!surface->resource.locations)
+    {
+        FIXME("No up to date depth stencil location.\n");
+        surface->resource.locations |= location;
+#else  /* STAGING_CSMT */
         surface->locations &= ~WINED3D_LOCATION_DISCARDED;
         surface->locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
@@ -3726,6 +4511,7 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
     {
         FIXME("No up to date depth stencil location.\n");
         surface->locations |= location;
+#endif /* STAGING_CSMT */
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
@@ -3790,7 +4576,13 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if defined(STAGING_CSMT)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
         if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -3806,7 +4598,13 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
+#if defined(STAGING_CSMT)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
+#else  /* STAGING_CSMT */
         if (wined3d_settings.strict_draw_ordering)
+#endif /* STAGING_CSMT */
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -3814,6 +4612,53 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         ERR("Invalid location (%#x) specified.\n", location);
     }
 
+#if defined(STAGING_CSMT)
+    surface->resource.locations |= location;
+    surface->ds_current_size.cx = surface->resource.width;
+    surface->ds_current_size.cy = surface->resource.height;
+}
+
+/* Context activation is done by the caller. */
+static void surface_load_sysmem(struct wined3d_surface *surface,
+        struct wined3d_context *context, DWORD dst_location)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+    /* Download the surface to system memory. */
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+    {
+        wined3d_texture_bind_and_dirtify(surface->container, context,
+                !(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB));
+        surface_download_data(surface, gl_info, dst_location);
+
+        return;
+    }
+
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
+    {
+        read_from_framebuffer(surface, context, dst_location);
+        return;
+    }
+
+    FIXME("Can't load surface %p with location flags %s into sysmem.\n",
+            surface, wined3d_debug_location(surface->resource.locations));
+}
+
+/* Context activation is done by the caller. */
+static HRESULT surface_load_drawable(struct wined3d_surface *surface,
+        struct wined3d_context *context)
+{
+    RECT r;
+
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        return WINED3D_OK;
+    }
+#else  /* STAGING_CSMT */
     surface->locations |= location;
     surface->ds_current_size.cx = surface->resource.width;
     surface->ds_current_size.cy = surface->resource.height;
@@ -3828,7 +4673,7 @@ void surface_validate_location(struct wined3d_surface *surface, DWORD location)
 
 void surface_invalidate_location(struct wined3d_surface *surface, DWORD location)
 {
-    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
+//    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
 
     if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
         wined3d_texture_set_dirty(surface->container);
@@ -3941,6 +4786,7 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info)
 {
     RECT r;
+#endif /* STAGING_CSMT */
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && wined3d_resource_is_offscreen(&surface->container->resource))
@@ -3950,6 +4796,76 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
     }
 
     surface_get_rect(surface, NULL, &r);
+#if defined(STAGING_CSMT)
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+    surface_blt_to_drawable(surface->resource.device, context,
+            WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
+
+    return WINED3D_OK;
+}
+
+static HRESULT surface_load_texture(struct wined3d_surface *surface,
+        struct wined3d_context *context, BOOL srgb)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    RECT src_rect = {0, 0, surface->resource.width, surface->resource.height};
+    struct wined3d_device *device = surface->resource.device;
+    const struct wined3d_color_key_conversion *conversion;
+    struct wined3d_texture *texture = surface->container;
+    UINT width, src_row_pitch, src_slice_pitch, dst_pitch;
+    struct wined3d_bo_address data;
+    struct wined3d_format format;
+    POINT dst_point = {0, 0};
+    BYTE *mem = NULL;
+    const DWORD simple_locations =
+            WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        wined3d_texture_prepare_texture(texture, context, srgb);
+        return WINED3D_OK;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && wined3d_resource_is_offscreen(&texture->resource)
+            && (surface->resource.locations & WINED3D_LOCATION_DRAWABLE))
+    {
+        surface_load_fb_texture(surface, srgb);
+
+        return WINED3D_OK;
+    }
+
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB | WINED3D_LOCATION_TEXTURE_RGB)
+            && (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB)
+            && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
+                NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
+                NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
+    {
+        if (srgb)
+            surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_RGB,
+                    &src_rect, surface, WINED3D_LOCATION_TEXTURE_SRGB, &src_rect);
+        else
+            surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_SRGB,
+                    &src_rect, surface, WINED3D_LOCATION_TEXTURE_RGB, &src_rect);
+
+        return WINED3D_OK;
+    }
+
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED)
+            && (!srgb || (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB))
+            && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
+                NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
+                NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
+    {
+        DWORD src_location = surface->resource.locations & WINED3D_LOCATION_RB_RESOLVED ?
+                WINED3D_LOCATION_RB_RESOLVED : WINED3D_LOCATION_RB_MULTISAMPLE;
+        DWORD dst_location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
+        RECT rect = {0, 0, surface->resource.width, surface->resource.height};
+
+        surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, src_location,
+#else  /* STAGING_CSMT */
     surface_load_location(surface, WINED3D_LOCATION_TEXTURE_RGB);
     surface_blt_to_drawable(surface->resource.device,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
@@ -3965,7 +4881,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     const struct wined3d_color_key_conversion *conversion;
     struct wined3d_texture *texture = surface->container;
     struct wined3d_context *context;
-    UINT width, src_pitch, dst_pitch;
+    UINT width, src_row_pitch, src_slice_pitch, dst_pitch;
     struct wined3d_bo_address data;
     struct wined3d_format format;
     POINT dst_point = {0, 0};
@@ -4008,6 +4924,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
         surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, src_location,
+#endif /* STAGING_CSMT */
                 &rect, surface, dst_location, &rect);
 
         return WINED3D_OK;
@@ -4017,6 +4934,36 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
 
     if (srgb)
     {
+#if defined(STAGING_CSMT)
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | surface->resource.map_binding))
+                == WINED3D_LOCATION_TEXTURE_RGB)
+        {
+            /* Performance warning... */
+            FIXME("Downloading RGB surface %p to reload it as sRGB.\n", surface);
+            wined3d_resource_prepare_map_memory(&surface->resource, context);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        }
+    }
+    else
+    {
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB | surface->resource.map_binding))
+                == WINED3D_LOCATION_TEXTURE_SRGB)
+        {
+            /* Performance warning... */
+            FIXME("Downloading sRGB surface %p to reload it as RGB.\n", surface);
+            wined3d_resource_prepare_map_memory(&surface->resource, context);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        }
+    }
+
+    if (!(surface->resource.locations & simple_locations))
+    {
+        WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
+        /* Lets hope we get it from somewhere... */
+        wined3d_resource_prepare_system_memory(&surface->resource);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_SYSMEM);
+    }
+#else  /* STAGING_CSMT */
         if ((surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | surface->resource.map_binding))
                 == WINED3D_LOCATION_TEXTURE_RGB)
         {
@@ -4048,12 +4995,13 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
 
     /* TODO: Use already acquired context when possible. */
     context = context_acquire(device, NULL);
+#endif /* STAGING_CSMT */
 
     wined3d_texture_prepare_texture(texture, context, srgb);
     wined3d_texture_bind_and_dirtify(texture, context, srgb);
 
     width = surface->resource.width;
-    src_pitch = wined3d_surface_get_pitch(surface);
+    wined3d_resource_get_pitch(&surface->resource, &src_row_pitch, &src_slice_pitch);
 
     format = *texture->resource.format;
     if ((conversion = wined3d_format_get_color_key_conversion(texture, TRUE)))
@@ -4062,7 +5010,11 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
+#if defined(STAGING_CSMT)
+    if ((format.convert || conversion) && surface->resource.buffer)
+#else  /* STAGING_CSMT */
     if ((format.convert || conversion) && surface->pbo)
+#endif /* STAGING_CSMT */
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
@@ -4071,12 +5023,22 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         else
             surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
+#if defined(STAGING_CSMT)
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_free_bo(&surface->resource);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_BUFFER);
+    }
+
+    wined3d_resource_get_memory(&surface->resource, surface->resource.locations, &data);
+#else  /* STAGING_CSMT */
         surface_prepare_map_memory(surface);
         surface_load_location(surface, surface->resource.map_binding);
         surface_remove_pbo(surface, gl_info);
     }
 
     surface_get_memory(surface, &data, surface->locations);
+#endif /* STAGING_CSMT */
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -4091,9 +5053,9 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             context_release(context);
             return E_OUTOFMEMORY;
         }
-        format.convert(data.addr, mem, src_pitch, src_pitch * height,
+        format.convert(data.addr, mem, src_row_pitch, src_row_pitch * height,
                 dst_pitch, dst_pitch * height, width, height, 1);
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
     else if (conversion)
@@ -4113,38 +5075,64 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         }
         if (texture->swapchain && texture->swapchain->palette)
             palette = texture->swapchain->palette;
-        conversion->convert(data.addr, src_pitch, mem, dst_pitch,
+        conversion->convert(data.addr, src_row_pitch, mem, dst_pitch,
                 width, height, palette, &texture->async.gl_color_key);
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
 
     wined3d_surface_upload_data(surface, gl_info, &format, &src_rect,
-            src_pitch, &dst_point, srgb, wined3d_const_bo_address(&data));
-
-    context_release(context);
+            src_row_pitch, &dst_point, srgb, wined3d_const_bo_address(&data));
 
+#if defined(STAGING_CSMT)
     HeapFree(GetProcessHeap(), 0, mem);
 
     return WINED3D_OK;
 }
 
-static void surface_multisample_resolve(struct wined3d_surface *surface)
+/* Context activation is done by the caller. */
+static void surface_multisample_resolve(struct wined3d_surface *surface, struct wined3d_context *context)
 {
     RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
-    if (!(surface->locations & WINED3D_LOCATION_RB_MULTISAMPLE))
+    if (!(surface->resource.locations & WINED3D_LOCATION_RB_MULTISAMPLE))
         ERR("Trying to resolve multisampled surface %p, but location WINED3D_LOCATION_RB_MULTISAMPLE not current.\n",
                 surface);
 
-    surface_blt_fbo(surface->resource.device, WINED3D_TEXF_POINT,
+    surface_blt_fbo(surface->resource.device, context, WINED3D_TEXF_POINT,
             surface, WINED3D_LOCATION_RB_MULTISAMPLE, &rect, surface, WINED3D_LOCATION_RB_RESOLVED, &rect);
 }
 
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
+/* Context activation is done by the caller. */
+static void wined3d_surface_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
 {
-    struct wined3d_device *device = surface->resource.device;
+    struct wined3d_surface *surface = surface_from_resource(resource);
+#else  /* STAGING_CSMT */
+    context_release(context);
+
+    HeapFree(GetProcessHeap(), 0, mem);
+
+    return WINED3D_OK;
+}
+
+static void surface_multisample_resolve(struct wined3d_surface *surface)
+{
+    RECT rect = {0, 0, surface->resource.width, surface->resource.height};
+
+    if (!(surface->locations & WINED3D_LOCATION_RB_MULTISAMPLE))
+        ERR("Trying to resolve multisampled surface %p, but location WINED3D_LOCATION_RB_MULTISAMPLE not current.\n",
+                surface);
+
+    surface_blt_fbo(surface->resource.device, WINED3D_TEXF_POINT,
+            surface, WINED3D_LOCATION_RB_MULTISAMPLE, &rect, surface, WINED3D_LOCATION_RB_RESOLVED, &rect);
+}
+
+HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
+{
+    struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+#endif /* STAGING_CSMT */
     HRESULT hr;
 
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
@@ -4152,6 +5140,32 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
         if (location == WINED3D_LOCATION_TEXTURE_RGB
+#if defined(STAGING_CSMT)
+                && surface->resource.locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
+        {
+            surface_load_ds_location(surface, context, location);
+            return;
+        }
+        else if (location & surface->resource.locations
+                && surface->container->resource.draw_binding != WINED3D_LOCATION_DRAWABLE)
+        {
+            /* Already up to date, nothing to do. */
+            return;
+        }
+        else
+        {
+            FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
+                    wined3d_debug_location(surface->resource.locations), wined3d_debug_location(location));
+            return;
+        }
+    }
+
+    if (!surface->resource.locations)
+    {
+        ERR("Surface %p does not have any up to date location.\n", surface);
+        surface->flags |= SFLAG_LOST;
+        return;
+#else  /* STAGING_CSMT */
                 && surface->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
         {
             struct wined3d_context *context = context_acquire(device, NULL);
@@ -4192,6 +5206,7 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
         ERR("Surface %p does not have any up to date location.\n", surface);
         surface->flags |= SFLAG_LOST;
         return WINED3DERR_DEVICELOST;
+#endif /* STAGING_CSMT */
     }
 
     switch (location)
@@ -4200,6 +5215,25 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
         case WINED3D_LOCATION_USER_MEMORY:
         case WINED3D_LOCATION_SYSMEM:
         case WINED3D_LOCATION_BUFFER:
+#if defined(STAGING_CSMT)
+            surface_load_sysmem(surface, context, location);
+            break;
+
+        case WINED3D_LOCATION_DRAWABLE:
+            if (FAILED(hr = surface_load_drawable(surface, context)))
+                return;
+            break;
+
+        case WINED3D_LOCATION_RB_RESOLVED:
+            surface_multisample_resolve(surface, context);
+            break;
+
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+            if (FAILED(hr = surface_load_texture(surface, context,
+                    location == WINED3D_LOCATION_TEXTURE_SRGB)))
+                return;
+#else  /* STAGING_CSMT */
             surface_load_sysmem(surface, gl_info, location);
             break;
 
@@ -4216,6 +5250,7 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
         case WINED3D_LOCATION_TEXTURE_SRGB:
             if (FAILED(hr = surface_load_texture(surface, gl_info, location == WINED3D_LOCATION_TEXTURE_SRGB)))
                 return hr;
+#endif /* STAGING_CSMT */
             break;
 
         default:
@@ -4223,12 +5258,21 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
             break;
     }
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_validate_location(&surface->resource, location);
+
+    if (location != WINED3D_LOCATION_SYSMEM && (surface->resource.locations & WINED3D_LOCATION_SYSMEM))
+        surface_evict_sysmem(surface);
+
+    return;
+#else  /* STAGING_CSMT */
     surface_validate_location(surface, location);
 
     if (location != WINED3D_LOCATION_SYSMEM && (surface->locations & WINED3D_LOCATION_SYSMEM))
         surface_evict_sysmem(surface);
 
     return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static HRESULT ffp_blit_alloc(struct wined3d_device *device) { return WINED3D_OK; }
@@ -4338,6 +5382,28 @@ static HRESULT ffp_blit_color_fill(struct wined3d_device *device, struct wined3d
         const RECT *dst_rect, const struct wined3d_color *color)
 {
     const RECT draw_rect = {0, 0, dst_surface->resource.width, dst_surface->resource.height};
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view view, *view_ptr = &view;
+    struct wined3d_fb_state fb = {&view_ptr, NULL, 1};
+    struct wined3d_texture *texture = dst_surface->container;
+
+    /* Can't incref / decref the resource here. This is executed inside the worker
+     * thread. Playing with the refcount here makes the worker thread visible to
+     * the client lib. Problems occur when the worker thread happens to hold the
+     * last reference and the resource destruction callbacks are called from the
+     * wrong thread. */
+    view.resource = &texture->resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = dst_surface->resource.format;
+    view.buffer_offset = 0;
+    view.width = dst_surface->resource.width;
+    view.height = dst_surface->resource.height;
+    view.depth = 1;
+    view.sub_resource_idx = dst_surface->texture_layer * texture->level_count + dst_surface->texture_level;
+
+    device_clear_render_targets(device, 1, &fb, 1, dst_rect, &draw_rect, WINED3DCLEAR_TARGET, color, 0.0f, 0);
+#else  /* STAGING_CSMT */
     struct wined3d_rendertarget_view *view;
     struct wined3d_fb_state fb = {&view, NULL};
     HRESULT hr;
@@ -4351,6 +5417,7 @@ static HRESULT ffp_blit_color_fill(struct wined3d_device *device, struct wined3d
 
     device_clear_render_targets(device, 1, &fb, 1, dst_rect, &draw_rect, WINED3DCLEAR_TARGET, color, 0.0f, 0);
     wined3d_rendertarget_view_decref(view);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4359,6 +5426,23 @@ static HRESULT ffp_blit_depth_fill(struct wined3d_device *device, struct wined3d
         const RECT *dst_rect, float depth)
 {
     const RECT draw_rect = {0, 0, dst_surface->resource.width, dst_surface->resource.height};
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view view;
+    struct wined3d_fb_state fb = {NULL, &view};
+    struct wined3d_texture *texture = dst_surface->container;
+
+    view.resource = &dst_surface->container->resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = dst_surface->resource.format;
+    view.buffer_offset = 0;
+    view.width = dst_surface->resource.width;
+    view.height = dst_surface->resource.height;
+    view.depth = 1;
+    view.sub_resource_idx = dst_surface->texture_layer * texture->level_count + dst_surface->texture_level;
+
+    device_clear_render_targets(device, 0, &fb, 1, dst_rect, &draw_rect, WINED3DCLEAR_ZBUFFER, 0, depth, 0);
+#else  /* STAGING_CSMT */
     struct wined3d_fb_state fb = {NULL, NULL};
     HRESULT hr;
 
@@ -4371,6 +5455,7 @@ static HRESULT ffp_blit_depth_fill(struct wined3d_device *device, struct wined3d
 
     device_clear_render_targets(device, 0, &fb, 1, dst_rect, &draw_rect, WINED3DCLEAR_ZBUFFER, 0, depth, 0);
     wined3d_rendertarget_view_decref(fb.depth_stencil);
+#endif /* STAGING_CSMT */
 
     return WINED3D_OK;
 }
@@ -4383,6 +5468,25 @@ static void ffp_blit_blit_surface(struct wined3d_device *device, DWORD filter,
     /* Blit from offscreen surface to render target */
     struct wined3d_color_key old_blt_key = src_surface->container->async.src_blt_color_key;
     DWORD old_color_key_flags = src_surface->container->async.color_key_flags;
+#if defined(STAGING_CSMT)
+    struct wined3d_context *context;
+
+    TRACE("Blt from surface %p to rendertarget %p\n", src_surface, dst_surface);
+
+    wined3d_texture_set_color_key(src_surface->container, WINED3D_CKEY_SRC_BLT, color_key);
+
+    context = context_acquire(device, dst_surface);
+    surface_blt_to_drawable(device, context, filter,
+            !!color_key, src_surface, src_rect, dst_surface, dst_rect);
+    context_release(context);
+
+    /* Restore the color key parameters */
+    wined3d_texture_set_color_key(src_surface->container, WINED3D_CKEY_SRC_BLT,
+            (old_color_key_flags & WINED3D_CKEY_SRC_BLT) ? &old_blt_key : NULL);
+
+    wined3d_resource_validate_location(&dst_surface->resource, dst_surface->container->resource.draw_binding);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->container->resource.draw_binding);
+#else  /* STAGING_CSMT */
 
     TRACE("Blt from surface %p to rendertarget %p\n", src_surface, dst_surface);
 
@@ -4397,6 +5501,7 @@ static void ffp_blit_blit_surface(struct wined3d_device *device, DWORD filter,
 
     surface_validate_location(dst_surface, dst_surface->container->resource.draw_binding);
     surface_invalidate_location(dst_surface, ~dst_surface->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
 }
 
 const struct blit_shader ffp_blit =  {
@@ -4555,6 +5660,38 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     int bpp, srcheight, srcwidth, dstheight, dstwidth, width;
     const struct wined3d_format *src_format, *dst_format;
     struct wined3d_texture *src_texture = NULL;
+#if defined(STAGING_CSMT)
+    void *src_data = NULL, *dst_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
+    const BYTE *sbase = NULL;
+    HRESULT hr = WINED3D_OK;
+    const BYTE *sbuf;
+    BYTE *dbuf;
+    int x, y;
+    struct wined3d_device *device = dst_surface->resource.device;
+    struct wined3d_context *context = NULL;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(&dst_surface->resource, context))
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+    wined3d_resource_load_location(&dst_surface->resource, context, dst_surface->resource.map_binding);
+
+    if (src_surface == dst_surface)
+    {
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        src_data = dst_data;
+        src_row_pitch = dst_row_pitch;
+#else  /* STAGING_CSMT */
     struct wined3d_map_desc dst_map, src_map;
     const BYTE *sbase = NULL;
     HRESULT hr = WINED3D_OK;
@@ -4570,6 +5707,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     {
         wined3d_surface_map(dst_surface, &dst_map, NULL, 0);
         src_map = dst_map;
+#endif /* STAGING_CSMT */
         src_format = dst_surface->resource.format;
         dst_format = src_format;
     }
@@ -4578,6 +5716,14 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         dst_format = dst_surface->resource.format;
         if (src_surface)
         {
+#if defined(STAGING_CSMT)
+            if (!wined3d_resource_prepare_map_memory(&src_surface->resource, context))
+            {
+                hr = E_OUTOFMEMORY;
+                goto error;
+            }
+
+#endif /* STAGING_CSMT */
             if (dst_surface->resource.format->id != src_surface->resource.format->id)
             {
                 if (!(src_texture = surface_convert_format(src_surface, dst_format->id)))
@@ -4588,7 +5734,13 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                 }
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, 0));
             }
+#if defined(STAGING_CSMT)
+            wined3d_resource_load_location(&src_surface->resource, context, src_surface->resource.map_binding);
+            wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
+            src_data = wined3d_resource_get_map_ptr(&src_surface->resource, context, 0);
+#else  /* STAGING_CSMT */
             wined3d_surface_map(src_surface, &src_map, NULL, WINED3D_MAP_READONLY);
+#endif /* STAGING_CSMT */
             src_format = src_surface->resource.format;
         }
         else
@@ -4596,7 +5748,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
             src_format = dst_format;
         }
 
+#if defined(STAGING_CSMT)
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
+#else  /* STAGING_CSMT */
         wined3d_surface_map(dst_surface, &dst_map, dst_rect, 0);
+#endif /* STAGING_CSMT */
     }
 
     bpp = dst_surface->resource.format->byte_count;
@@ -4607,6 +5764,14 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     width = (dst_rect->right - dst_rect->left) * bpp;
 
     if (src_surface)
+#if defined(STAGING_CSMT)
+        sbase = (BYTE *)src_data
+                + ((src_rect->top / src_format->block_height) * src_row_pitch)
+                + ((src_rect->left / src_format->block_width) * src_format->block_byte_count);
+    dbuf = (BYTE *)dst_data
+            + ((dst_rect->top / dst_format->block_height) * dst_row_pitch)
+            + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
+#else  /* STAGING_CSMT */
         sbase = (BYTE *)src_map.data
                 + ((src_rect->top / src_format->block_height) * src_map.row_pitch)
                 + ((src_rect->left / src_format->block_width) * src_format->block_byte_count);
@@ -4616,6 +5781,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         dbuf = (BYTE *)dst_map.data
                 + ((dst_rect->top / dst_format->block_height) * dst_map.row_pitch)
                 + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
+#endif /* STAGING_CSMT */
 
     if (src_format->flags & dst_format->flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -4650,7 +5816,11 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         }
 
         hr = surface_cpu_blt_compressed(sbase, dbuf,
+#if defined(STAGING_CSMT)
+                src_row_pitch, dst_row_pitch, dstwidth, dstheight,
+#else  /* STAGING_CSMT */
                 src_map.row_pitch, dst_map.row_pitch, dstwidth, dstheight,
+#endif /* STAGING_CSMT */
                 src_format, flags, fx);
         goto release;
     }
@@ -4658,7 +5828,11 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     /* First, all the 'source-less' blits */
     if (flags & WINEDDBLT_COLORFILL)
     {
+#if defined(STAGING_CSMT)
+        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, fx->u5.dwFillColor);
+#else  /* STAGING_CSMT */
         hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, fx->u5.dwFillColor);
+#endif /* STAGING_CSMT */
         flags &= ~WINEDDBLT_COLORFILL;
     }
 
@@ -4707,6 +5881,21 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         for (y = 0; y < dstheight; ++y)
                         {
                             memcpy(dbuf, sbuf, width);
+#if defined(STAGING_CSMT)
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
+                        }
+                    }
+                    else if (dst_rect->top > src_rect->top)
+                    {
+                        /* Copy from bottom upwards. */
+                        sbuf += src_row_pitch * dstheight;
+                        dbuf += dst_row_pitch * dstheight;
+                        for (y = 0; y < dstheight; ++y)
+                        {
+                            sbuf -= src_row_pitch;
+                            dbuf -= dst_row_pitch;
+#else  /* STAGING_CSMT */
                             sbuf += src_map.row_pitch;
                             dbuf += dst_map.row_pitch;
                         }
@@ -4720,6 +5909,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         {
                             sbuf -= src_map.row_pitch;
                             dbuf -= dst_map.row_pitch;
+#endif /* STAGING_CSMT */
                             memcpy(dbuf, sbuf, width);
                         }
                     }
@@ -4729,8 +5919,13 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         for (y = 0; y < dstheight; ++y)
                         {
                             memmove(dbuf, sbuf, width);
+#if defined(STAGING_CSMT)
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
+#else  /* STAGING_CSMT */
                             sbuf += src_map.row_pitch;
                             dbuf += dst_map.row_pitch;
+#endif /* STAGING_CSMT */
                         }
                     }
                 }
@@ -4739,9 +5934,15 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                     /* Stretching in y direction only. */
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
+#if defined(STAGING_CSMT)
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
+                        memcpy(dbuf, sbuf, width);
+                        dbuf += dst_row_pitch;
+#else  /* STAGING_CSMT */
                         sbuf = sbase + (sy >> 16) * src_map.row_pitch;
                         memcpy(dbuf, sbuf, width);
                         dbuf += dst_map.row_pitch;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -4751,6 +5952,15 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                 int last_sy = -1;
                 for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                 {
+#if defined(STAGING_CSMT)
+                    sbuf = sbase + (sy >> 16) * src_row_pitch;
+
+                    if ((sy >> 16) == (last_sy >> 16))
+                    {
+                        /* This source row is the same as last source row -
+                         * Copy the already stretched row. */
+                        memcpy(dbuf, dbuf - dst_row_pitch, width);
+#else  /* STAGING_CSMT */
                     sbuf = sbase + (sy >> 16) * src_map.row_pitch;
 
                     if ((sy >> 16) == (last_sy >> 16))
@@ -4758,6 +5968,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         /* This source row is the same as last source row -
                          * Copy the already stretched row. */
                         memcpy(dbuf, dbuf - dst_map.row_pitch, width);
+#endif /* STAGING_CSMT */
                     }
                     else
                     {
@@ -4804,6 +6015,16 @@ do { \
                         }
 #undef STRETCH_ROW
                     }
+#if defined(STAGING_CSMT)
+                    dbuf += dst_row_pitch;
+                    last_sy = sy;
+                }
+            }
+        }
+        else
+        {
+            LONG dstyinc = dst_row_pitch, dstxinc = bpp;
+#else  /* STAGING_CSMT */
                     dbuf += dst_map.row_pitch;
                     last_sy = sy;
                 }
@@ -4812,6 +6033,7 @@ do { \
         else
         {
             LONG dstyinc = dst_map.row_pitch, dstxinc = bpp;
+#endif /* STAGING_CSMT */
             DWORD keylow = 0xffffffff, keyhigh = 0, keymask = 0xffffffff;
             DWORD destkeylow = 0x0, destkeyhigh = 0xffffffff, destkeymask = 0xffffffff;
             if (flags & (WINEDDBLT_KEYSRC | WINEDDBLT_KEYDEST | WINEDDBLT_KEYSRCOVERRIDE | WINEDDBLT_KEYDESTOVERRIDE))
@@ -4861,7 +6083,11 @@ do { \
                 LONG tmpxy;
                 dTopLeft     = dbuf;
                 dTopRight    = dbuf + ((dstwidth - 1) * bpp);
+#if defined(STAGING_CSMT)
+                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_row_pitch);
+#else  /* STAGING_CSMT */
                 dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_map.row_pitch);
+#endif /* STAGING_CSMT */
                 dBottomRight = dBottomLeft + ((dstwidth - 1) * bpp);
 
                 if (fx->dwDDFX & WINEDDBLTFX_ARITHSTRETCHY)
@@ -4938,6 +6164,29 @@ do { \
                 flags &= ~(WINEDDBLT_DDFX);
             }
 
+#if defined(STAGING_CSMT)
+#define COPY_COLORKEY_FX(type) \
+do { \
+    const type *s; \
+    type *d = (type *)dbuf, *dx, tmp; \
+    for (y = sy = 0; y < dstheight; ++y, sy += yinc) \
+    { \
+        s = (const type *)(sbase + (sy >> 16) * src_row_pitch); \
+        dx = d; \
+        for (x = sx = 0; x < dstwidth; ++x, sx += xinc) \
+        { \
+            tmp = s[sx >> 16]; \
+            if (((tmp & keymask) < keylow || (tmp & keymask) > keyhigh) \
+                    && ((dx[0] & destkeymask) >= destkeylow && (dx[0] & destkeymask) <= destkeyhigh)) \
+            { \
+                dx[0] = tmp; \
+            } \
+            dx = (type *)(((BYTE *)dx) + dstxinc); \
+        } \
+        d = (type *)(((BYTE *)d) + dstyinc); \
+    } \
+} while(0)
+#else  /* STAGING_CSMT */
 #define COPY_COLORKEY_FX(type) \
 do { \
     const type *s; \
@@ -4959,6 +6208,7 @@ do { \
         d = (type *)(((BYTE *)d) + dstyinc); \
     } \
 } while(0)
+#endif /* STAGING_CSMT */
 
             switch (bpp)
             {
@@ -4977,7 +6227,11 @@ do { \
                     BYTE *d = dbuf, *dx;
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
+#if defined(STAGING_CSMT)
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
+#else  /* STAGING_CSMT */
                         sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+#endif /* STAGING_CSMT */
                         dx = d;
                         for (x = sx = 0; x < dstwidth; ++x, sx+= xinc)
                         {
@@ -5008,6 +6262,12 @@ do { \
         }
     }
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->resource.map_binding);
+    if (dst_surface->container)
+        wined3d_texture_set_dirty(dst_surface->container);
+
+#endif /* STAGING_CSMT */
 error:
     if (flags && FIXME_ON(d3d_surface))
     {
@@ -5015,12 +6275,33 @@ error:
     }
 
 release:
+#if defined(STAGING_CSMT)
+    if (dst_data)
+    {
+        wined3d_resource_release_map_ptr(&dst_surface->resource, context);
+
+        if (dst_surface->container->swapchain
+                && dst_surface->container == dst_surface->container->swapchain->front_buffer)
+        {
+            dst_surface->lockedRect = *dst_rect;
+            dst_surface->surface_ops->surface_frontbuffer_updated(dst_surface);
+        }
+    }
+    if (src_surface && src_surface != dst_surface && src_data)
+        wined3d_resource_release_map_ptr(&src_surface->resource, context);
+    /* Release the converted surface, if any. */
+    if (src_texture)
+        wined3d_texture_decref(src_texture);
+    if (context)
+        context_release(context);
+#else  /* STAGING_CSMT */
     wined3d_surface_unmap(dst_surface);
     if (src_surface && src_surface != dst_surface)
         wined3d_surface_unmap(src_surface);
     /* Release the converted surface, if any. */
     if (src_texture)
         wined3d_texture_decref(src_texture);
+#endif /* STAGING_CSMT */
 
     return hr;
 }
@@ -5065,6 +6346,15 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_blit_surface,
 };
 
+#if defined(STAGING_CSMT)
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    struct wined3d_device *device = dst_surface->resource.device;
+    DWORD src_ds_flags, dst_ds_flags;
+#else  /* STAGING_CSMT */
 HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
         struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
         const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
@@ -5073,6 +6363,7 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
     struct wined3d_device *device = dst_surface->resource.device;
     DWORD src_ds_flags, dst_ds_flags;
     RECT src_rect, dst_rect;
+#endif /* STAGING_CSMT */
     BOOL scale, convert;
 
     static const DWORD simple_blit = WINEDDBLT_ASYNC
@@ -5083,6 +6374,7 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             | WINEDDBLT_DEPTHFILL
             | WINEDDBLT_DONOTWAIT;
 
+#if !defined(STAGING_CSMT)
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
             flags, fx, debug_d3dtexturefiltertype(filter));
@@ -5181,6 +6473,7 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
         flags &= ~WINEDDBLT_DONOTWAIT;
     }
 
+#endif /* STAGING_CSMT */
     if (!device->d3d_initialized)
     {
         WARN("D3D not initialized, using fallback.\n");
@@ -5223,8 +6516,13 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
     }
 
     scale = src_surface
+#if defined(STAGING_CSMT)
+            && (src_rect->right - src_rect->left != dst_rect->right - dst_rect->left
+            || src_rect->bottom - src_rect->top != dst_rect->bottom - dst_rect->top);
+#else  /* STAGING_CSMT */
             && (src_rect.right - src_rect.left != dst_rect.right - dst_rect.left
             || src_rect.bottom - src_rect.top != dst_rect.bottom - dst_rect.top);
+#endif /* STAGING_CSMT */
     convert = src_surface && src_surface->resource.format->id != dst_surface->resource.format->id;
 
     dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
@@ -5242,6 +6540,18 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->u5.dwFillDepth, &depth))
+#if defined(STAGING_CSMT)
+                return;
+
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return;
+        }
+        else
+        {
+            if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->container->resource.draw_binding,
+                    src_rect, dst_surface, dst_surface->container->resource.draw_binding, dst_rect)))
+                return;
+#else  /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
 
             if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, &dst_rect, depth)))
@@ -5258,6 +6568,7 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->container->resource.draw_binding,
                     &src_rect, dst_surface, dst_surface->container->resource.draw_binding, &dst_rect)))
                 return WINED3D_OK;
+#endif /* STAGING_CSMT */
         }
     }
     else
@@ -5266,8 +6577,13 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
 
         /* In principle this would apply to depth blits as well, but we don't
          * implement those in the CPU blitter at the moment. */
+#if defined(STAGING_CSMT)
+        if ((dst_surface->resource.locations & dst_surface->resource.map_binding)
+                && (!src_surface || (src_surface->resource.locations & src_surface->resource.map_binding)))
+#else  /* STAGING_CSMT */
         if ((dst_surface->locations & dst_surface->resource.map_binding)
                 && (!src_surface || (src_surface->locations & src_surface->resource.map_binding)))
+#endif /* STAGING_CSMT */
         {
             if (scale)
                 TRACE("Not doing sysmem blit because of scaling.\n");
@@ -5288,8 +6604,13 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                     palette, fx->u5.dwFillColor, &color))
                 goto fallback;
 
+#if defined(STAGING_CSMT)
+            if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+                return;
+#else  /* STAGING_CSMT */
             if (SUCCEEDED(surface_color_fill(dst_surface, &dst_rect, &color)))
                 return WINED3D_OK;
+#endif /* STAGING_CSMT */
         }
         else
         {
@@ -5307,8 +6628,13 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                 color_key = &src_surface->container->async.src_blt_color_key;
                 blit_op = WINED3D_BLIT_OP_COLOR_BLIT_CKEY;
             }
+#if defined(STAGING_CSMT)
+            else if ((src_surface->resource.locations & WINED3D_LOCATION_SYSMEM)
+                    && !(dst_surface->resource.locations & WINED3D_LOCATION_SYSMEM))
+#else  /* STAGING_CSMT */
             else if ((src_surface->locations & WINED3D_LOCATION_SYSMEM)
                     && !(dst_surface->locations & WINED3D_LOCATION_SYSMEM))
+#endif /* STAGING_CSMT */
             {
                 /* Upload */
                 if (scale)
@@ -5317,6 +6643,20 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                     TRACE("Not doing upload because of format conversion.\n");
                 else
                 {
+#if defined(STAGING_CSMT)
+                    POINT dst_point = {dst_rect->left, dst_rect->top};
+
+                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, src_rect)))
+                    {
+                        if (!wined3d_resource_is_offscreen(&dst_surface->container->resource))
+                        {
+                            struct wined3d_context *context = context_acquire(device, dst_surface);
+                            wined3d_resource_load_location(&dst_surface->resource, context,
+                                    dst_surface->container->resource.draw_binding);
+                            context_release(context);
+                        }
+                        return;
+#else  /* STAGING_CSMT */
                     POINT dst_point = {dst_rect.left, dst_rect.top};
 
                     if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, &src_rect)))
@@ -5324,6 +6664,7 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                         if (!wined3d_resource_is_offscreen(&dst_surface->container->resource))
                             surface_load_location(dst_surface, dst_surface->container->resource.draw_binding);
                         return WINED3D_OK;
+#endif /* STAGING_CSMT */
                     }
                 }
             }
@@ -5347,6 +6688,203 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, NULL, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
+#if defined(STAGING_CSMT)
+                return;
+            }
+
+            if (fbo_blit_supported(&device->adapter->gl_info, blit_op,
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+            {
+                struct wined3d_context *context;
+                TRACE("Using FBO blit.\n");
+
+                context = context_acquire(device, NULL);
+                surface_blt_fbo(device, context, filter,
+                        src_surface, src_surface->container->resource.draw_binding, src_rect,
+                        dst_surface, dst_surface->container->resource.draw_binding, dst_rect);
+                context_release(context);
+
+                wined3d_resource_validate_location(&dst_surface->resource, dst_surface->container->resource.draw_binding);
+                wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->container->resource.draw_binding);
+
+                return;
+            }
+
+            blitter = wined3d_select_blitter(&device->adapter->gl_info, &device->adapter->d3d_info, blit_op,
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format);
+            if (blitter)
+            {
+                blitter->blit_surface(device, filter, src_surface, src_rect, dst_surface, dst_rect, color_key);
+                return;
+            }
+        }
+    }
+
+fallback:
+    /* Special cases for render targets. */
+    if ((dst_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
+            || (src_surface && (src_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)))
+    {
+        if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+            return;
+    }
+
+cpu:
+
+    /* For the rest call the X11 surface implementation. For render targets
+     * this should be implemented OpenGL accelerated in surface_blt_special(),
+     * other blits are rather rare. */
+    surface_cpu_blt(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter);
+    return;
+}
+
+HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_device *device = dst_surface->resource.device;
+    RECT src_rect, dst_rect;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
+
+    if (fx)
+    {
+        TRACE("dwSize %#x.\n", fx->dwSize);
+        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
+        TRACE("dwROP %#x.\n", fx->dwROP);
+        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
+        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
+        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
+        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
+        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
+        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
+        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
+        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
+        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
+        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
+        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
+        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
+        TRACE("dwReserved %#x.\n", fx->dwReserved);
+        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
+        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
+        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
+        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
+        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
+        TRACE("ddckDestColorkey {%#x, %#x}.\n",
+                fx->ddckDestColorkey.color_space_low_value,
+                fx->ddckDestColorkey.color_space_high_value);
+        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
+                fx->ddckSrcColorkey.color_space_low_value,
+                fx->ddckSrcColorkey.color_space_high_value);
+    }
+
+    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_settings.cs_multithreaded)
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(dst_surface->resource.device->cs);
+        dst_surface->resource.device->cs->ops->finish(dst_surface->resource.device->cs);
+
+        if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+
+    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
+            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
+            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
+            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
+            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        DWORD src_ds_flags, dst_ds_flags;
+
+        surface_get_rect(src_surface, src_rect_in, &src_rect);
+
+        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
+                || src_rect.left > src_surface->resource.width || src_rect.left < 0
+                || src_rect.top > src_surface->resource.height || src_rect.top < 0
+                || src_rect.right > src_surface->resource.width || src_rect.right < 0
+                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
+        {
+            WARN("Application gave us bad source rectangle for Blt.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+
+        dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        src_ds_flags = src_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        if (src_ds_flags != dst_ds_flags)
+        {
+            WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
+    }
+    else
+    {
+        memset(&src_rect, 0, sizeof(src_rect));
+    }
+
+    if (!fx || !(fx->dwDDFX))
+        flags &= ~WINEDDBLT_DDFX;
+
+    if (flags & WINEDDBLT_WAIT)
+        flags &= ~WINEDDBLT_WAIT;
+
+    if (flags & WINEDDBLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
+        flags &= ~WINEDDBLT_ASYNC;
+    }
+
+    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
+    if (flags & WINEDDBLT_DONOTWAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
+        flags &= ~WINEDDBLT_DONOTWAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, &dst_rect, src_surface, &src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
+}
+
+static const struct wined3d_resource_ops surface_resource_ops =
+{
+    surface_resource_incref,
+    surface_resource_decref,
+    surface_unload,
+    wined3d_surface_location_invalidated,
+    wined3d_surface_load_location,
+};
+#else  /* STAGING_CSMT */
                 return WINED3D_OK;
             }
 
@@ -5388,6 +6926,7 @@ cpu:
      * other blits are rather rare. */
     return surface_cpu_blt(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter);
 }
+#endif /* STAGING_CSMT */
 
 static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_texture *container,
         const struct wined3d_resource_desc *desc, GLenum target, unsigned int level, unsigned int layer, DWORD flags)
@@ -5455,14 +6994,19 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     }
 
     surface->container = container;
+#if defined(STAGING_CSMT)
+    wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
     surface_validate_location(surface, WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
     list_init(&surface->renderbuffers);
     list_init(&surface->overlays);
 
     /* Flags */
     if (flags & WINED3D_SURFACE_DISCARD)
         surface->flags |= SFLAG_DISCARD;
-    if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE)
+    if (lockable || desc->format == WINED3DFMT_D16_LOCKABLE ||
+        desc->format == WINED3DFMT_D32_LOCKABLE || desc->format == WINED3DFMT_S8_LOCKABLE)
         surface->resource.access_flags |= WINED3D_RESOURCE_ACCESS_CPU;
 
     surface->texture_target = target;
@@ -5487,8 +7031,14 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     if (surface->resource.map_binding == WINED3D_LOCATION_DIB)
     {
         wined3d_resource_free_sysmem(&surface->resource);
+#if defined(STAGING_CSMT)
+        surface->resource.map_heap_memory = NULL;
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DIB);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
         surface_validate_location(surface, WINED3D_LOCATION_DIB);
         surface_invalidate_location(surface, WINED3D_LOCATION_SYSMEM);
+#endif /* STAGING_CSMT */
     }
 
     return hr;
@@ -5508,14 +7058,19 @@ HRESULT wined3d_surface_create(struct wined3d_texture *container, const struct w
             container, desc->width, desc->height, debug_d3dformat(desc->format),
             debug_d3dusage(desc->usage), desc->usage, debug_d3dpool(desc->pool),
             desc->multisample_type, desc->multisample_quality, target, level, layer, flags, surface);
-
+//trace:d3d_surface:wined3d_surface_create container 0xafe670, width 256, height 256, format WINED3DFMT_B8G8R8A8_UNORM, usage WINED3DUSAGE_TEXTURE (0x10000000), pool WINED3D_POOL_MANAGED, multisample_type 0, multisample_quality 0, target 0xde1, level 0, layer 0, flags 0x1, surface 0x33dc1c.
+  //target = GL_TEXTURE_2D
     if (!(object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object))))
         return E_OUTOFMEMORY;
 
     if (FAILED(hr = surface_init(object, container, desc, target, level, layer, flags)))
     {
         WARN("Failed to initialize surface, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
+        /* The command stream takes care of freeing the memory. */
+#else  /* STAGING_CSMT */
         HeapFree(GetProcessHeap(), 0, object);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 146f5d6..2acb467 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -136,12 +136,17 @@ HRESULT CDECL wined3d_swapchain_present(struct wined3d_swapchain *swapchain,
         const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
         const RGNDATA *dirty_region, DWORD flags)
 {
+    static DWORD notified_flags = 0;
+
     TRACE("swapchain %p, src_rect %s, dst_rect %s, dst_window_override %p, dirty_region %p, flags %#x.\n",
             swapchain, wine_dbgstr_rect(src_rect), wine_dbgstr_rect(dst_rect),
             dst_window_override, dirty_region, flags);
 
-    if (flags)
-        FIXME("Ignoring flags %#x.\n", flags);
+    if (flags & ~notified_flags)
+    {
+        FIXME("Ignoring flags %#x.\n", flags & ~notified_flags);
+        notified_flags |= flags;
+    }
 
     if (!swapchain->back_buffers)
     {
@@ -249,7 +254,7 @@ HRESULT CDECL wined3d_swapchain_set_gamma_ramp(const struct wined3d_swapchain *s
     TRACE("swapchain %p, flags %#x, ramp %p.\n", swapchain, flags, ramp);
 
     if (flags)
-        FIXME("Ignoring flags %#x.\n", flags);
+        FIXME("Ignoring flags %#x.\n", flags); //D3DSGR_CALIBRATE //Slice-todo
 
     dc = GetDC(swapchain->device_window);
     SetDeviceGammaRamp(dc, (void *)ramp);
@@ -309,7 +314,11 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
         if (backbuffer->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
+#if defined(STAGING_CSMT)
+            wined3d_resource_load_location(&backbuffer->resource, context, location);
+#else  /* STAGING_CSMT */
             surface_load_location(backbuffer, location);
+#endif /* STAGING_CSMT */
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, backbuffer, NULL, location);
@@ -417,11 +426,19 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
+#if defined(STAGING_CSMT)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
+{
+    struct wined3d_surface *back_buffer = surface_from_resource(
+            wined3d_texture_get_sub_resource(swapchain->back_buffers[0], 0));
+#else  /* STAGING_CSMT */
         const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
 {
     struct wined3d_surface *back_buffer = surface_from_resource(
             wined3d_texture_get_sub_resource(swapchain->back_buffers[0], 0));
     const struct wined3d_fb_state *fb = &swapchain->device->fb;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_surface *front;
@@ -449,6 +466,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
                 NULL, WINED3D_TEXF_POINT);
     }
 
+#if !defined(STAGING_CSMT)
     if (swapchain->device->bCursorVisible && swapchain->device->cursor_texture
             && !swapchain->device->hardwareCursor)
     {
@@ -470,6 +488,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
                 NULL, WINED3D_TEXF_POINT);
     }
 
+#endif /* STAGING_CSMT */
     TRACE("Presenting HDC %p.\n", context->hdc);
 
     render_to_fbo = swapchain->render_to_fbo;
@@ -511,6 +530,16 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
+#if defined(STAGING_CSMT)
+        wined3d_resource_load_location(&back_buffer->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_invalidate_location(&back_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+        swapchain->render_to_fbo = TRUE;
+        swapchain_update_draw_bindings(swapchain);
+    }
+    else
+    {
+        wined3d_resource_load_location(&back_buffer->resource, context, back_buffer->container->resource.draw_binding);
+#else  /* STAGING_CSMT */
         surface_load_location(back_buffer, WINED3D_LOCATION_TEXTURE_RGB);
         surface_invalidate_location(back_buffer, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
@@ -519,6 +548,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
     else
     {
         surface_load_location(back_buffer, back_buffer->container->resource.draw_binding);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->render_to_fbo)
@@ -531,8 +561,13 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
         swapchain_blit(swapchain, context, &src_rect, &dst_rect);
     }
 
+#if defined(STAGING_CSMT)
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFlush();
+#else  /* STAGING_CSMT */
     if (swapchain->num_contexts > 1)
         gl_info->gl_ops.gl.p_glFinish();
+#endif /* STAGING_CSMT */
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc); /* TODO: cycle through the swapchain buffers */
@@ -555,6 +590,36 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
     }
 
     front = surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0));
+#if defined(STAGING_CSMT)
+    wined3d_resource_validate_location(&front->resource, WINED3D_LOCATION_DRAWABLE);
+    wined3d_resource_invalidate_location(&front->resource, ~WINED3D_LOCATION_DRAWABLE);
+    switch (swapchain->desc.swap_effect)
+    {
+        case WINED3D_SWAP_EFFECT_DISCARD:
+            wined3d_resource_validate_location(&back_buffer->resource, WINED3D_LOCATION_DISCARDED);
+            break;
+
+        case WINED3D_SWAP_EFFECT_FLIP:
+            wined3d_resource_validate_location(&back_buffer->resource, back_buffer->container->resource.draw_binding);
+            wined3d_resource_invalidate_location(&back_buffer->resource, ~back_buffer->container->resource.draw_binding);
+            break;
+
+        default:
+            break;
+    }
+
+    if (depth_stencil)
+    {
+        if (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || depth_stencil->flags & SFLAG_DISCARD)
+        {
+            surface_modify_ds_location(depth_stencil, WINED3D_LOCATION_DISCARDED,
+                    depth_stencil->resource.width, depth_stencil->resource.height);
+            if (depth_stencil == swapchain->device->cs->onscreen_depth_stencil)
+            {
+                wined3d_surface_decref(swapchain->device->cs->onscreen_depth_stencil);
+                swapchain->device->cs->onscreen_depth_stencil = NULL;
+#else  /* STAGING_CSMT */
     if (!swapchain->render_to_fbo && ((front->locations & WINED3D_LOCATION_SYSMEM)
             || (back_buffer->locations & WINED3D_LOCATION_SYSMEM)))
     {
@@ -608,6 +673,7 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
             {
                 wined3d_surface_decref(swapchain->device->onscreen_depth_stencil);
                 swapchain->device->onscreen_depth_stencil = NULL;
+#endif /* STAGING_CSMT */
             }
         }
     }
@@ -640,7 +706,11 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 
     TRACE("Copying surface %p to screen.\n", front);
 
+#if defined(STAGING_CSMT)
+    wined3d_resource_load_location(&front->resource, NULL, WINED3D_LOCATION_DIB);
+#else  /* STAGING_CSMT */
     surface_load_location(front, WINED3D_LOCATION_DIB);
+#endif /* STAGING_CSMT */
 
     src_dc = front->hDC;
     window = swapchain->win_handle;
@@ -668,7 +738,12 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
+#if defined(STAGING_CSMT)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
+#else  /* STAGING_CSMT */
         const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+#endif /* STAGING_CSMT */
 {
     struct wined3d_surface *front, *back;
 
@@ -695,9 +770,15 @@ static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const REC
     {
         void *tmp;
 
+#if defined(STAGING_CSMT)
+        tmp = front->resource.bitmap_data;
+        front->resource.bitmap_data = back->resource.bitmap_data;
+        back->resource.bitmap_data = tmp;
+#else  /* STAGING_CSMT */
         tmp = front->dib.bitmap_data;
         front->dib.bitmap_data = back->dib.bitmap_data;
         back->dib.bitmap_data = tmp;
+#endif /* STAGING_CSMT */
 
         if (front->resource.heap_memory)
             ERR("GDI Surface %p has heap memory allocated.\n", front);
@@ -768,6 +849,71 @@ void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain)
     swapchain->render_to_fbo = TRUE;
 }
 
+#if defined(STAGING_CSMT)
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    unsigned int i;
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+    struct wined3d_surface *front_buffer;
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    front_buffer = surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0));
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+        swapchain->context[0] = context_create(swapchain, front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+
+    return WINED3D_OK;
+}
+
+#endif /* STAGING_CSMT */
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -865,8 +1011,13 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
     wined3d_texture_set_swapchain(swapchain->front_buffer, swapchain);
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
+#if defined(STAGING_CSMT)
+        wined3d_resource_validate_location(&front_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_invalidate_location(&front_buffer->resource, ~WINED3D_LOCATION_DRAWABLE);
+#else  /* STAGING_CSMT */
         surface_validate_location(front_buffer, WINED3D_LOCATION_DRAWABLE);
         surface_invalidate_location(front_buffer, ~WINED3D_LOCATION_DRAWABLE);
+#endif /* STAGING_CSMT */
     }
 
     /* MSDN says we're only allowed a single fullscreen swapchain per device,
@@ -892,6 +1043,11 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
+#if defined(STAGING_CSMT)
+        hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+        if (FAILED(hr))
+            goto err;
+#else  /* STAGING_CSMT */
         static const enum wined3d_format_id formats[] =
         {
             WINED3DFMT_D24_UNORM_S8_UINT,
@@ -946,6 +1102,7 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
             FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
         }
         context_release(swapchain->context[0]);
+#endif /* STAGING_CSMT */
     }
 
     if (swapchain->desc.backbuffer_count > 0)
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 78d1266..3ea79e2 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -33,6 +33,7 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
         const struct wined3d_resource_ops *resource_ops)
 {
     const struct wined3d_format *format = wined3d_get_format(&device->adapter->gl_info, desc->format);
+  UINT resource_size = 0;
     HRESULT hr;
 
     TRACE("texture %p, texture_ops %p, layer_count %u, level_count %u, resource_type %s, format %s, "
@@ -51,19 +52,22 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
             return WINED3DERR_INVALIDCALL;
     }
 
+ // resource_size = wined3d_format_calculate_size(format, device->surface_alignment, desc->width, desc->height, desc->depth);
     if (FAILED(hr = resource_init(&texture->resource, device, desc->resource_type, format,
             desc->multisample_type, desc->multisample_quality, desc->usage, desc->pool,
-            desc->width, desc->height, desc->depth, 0, parent, parent_ops, resource_ops)))
+            desc->width, desc->height, desc->depth, resource_size, parent, parent_ops, resource_ops)))
     {
         static unsigned int once;
+      if (device->adapter->gl_info.quirks & WINED3D_QUIRK_NO_DXTN) {
 
         if ((desc->format == WINED3DFMT_DXT1 || desc->format == WINED3DFMT_DXT2 || desc->format == WINED3DFMT_DXT3
                 || desc->format == WINED3DFMT_DXT4 || desc->format == WINED3DFMT_DXT5)
                 && !(format->flags & WINED3DFMT_FLAG_TEXTURE) && !once++)
             ERR_(winediag)("The application tried to create a DXTn texture, but the driver does not support them.\n");
 
-        WARN("Failed to initialize resource, returning %#x\n", hr);
+        ERR("Failed to initialize resource, returning %#x\n", hr);
         return hr;
+      }
     }
     wined3d_resource_update_draw_binding(&texture->resource);
 
@@ -74,6 +78,10 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
     {
         ERR("Failed to allocate sub-resource array.\n");
         resource_cleanup(&texture->resource);
+#if defined(STAGING_CSMT)
+        if (wined3d_settings.cs_multithreaded)
+            texture->resource.device->cs->ops->finish(texture->resource.device->cs);
+#endif /* STAGING_CSMT */
         return E_OUTOFMEMORY;
     }
 
@@ -118,24 +126,47 @@ static void wined3d_texture_unload_gl_texture(struct wined3d_texture *texture)
     resource_unload(&texture->resource);
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture)
+{
+    wined3d_texture_unload_gl_texture(texture);
+    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
+    HeapFree(GetProcessHeap(), 0, texture);
+}
+
 static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 {
     UINT sub_count = texture->level_count * texture->layer_count;
     UINT i;
+    struct wined3d_device *device = texture->resource.device;
+#else  /* STAGING_CSMT */
+static void wined3d_texture_cleanup(struct wined3d_texture *texture)
+{
+    UINT sub_count = texture->level_count * texture->layer_count;
+    UINT i;
+#endif /* STAGING_CSMT */
+  TRACE("sub_count=%d\n", sub_count);
 
     TRACE("texture %p.\n", texture);
 
     for (i = 0; i < sub_count; ++i)
     {
         struct wined3d_resource *sub_resource = texture->sub_resources[i];
-
-        if (sub_resource)
-            texture->texture_ops->texture_sub_resource_cleanup(sub_resource);
+      TRACE("i=%d subresource=%p, ops=%p\n", i, sub_resource, texture->texture_ops);
+        if (sub_resource && texture->texture_ops && texture->texture_ops->texture_sub_resource_cleanup)
+            texture->texture_ops->texture_sub_resource_cleanup(sub_resource); //Slice - crash
     }
 
+#if defined(STAGING_CSMT)
+  TRACE("resource_cleanup\n");
+    resource_cleanup(&texture->resource);
+  TRACE("wined3d_cs_emit_texture_cleanup\n");
+    wined3d_cs_emit_texture_cleanup(device->cs, texture);
+#else  /* STAGING_CSMT */
     wined3d_texture_unload_gl_texture(texture);
     HeapFree(GetProcessHeap(), 0, texture->sub_resources);
     resource_cleanup(&texture->resource);
+#endif /* STAGING_CSMT */
 }
 
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture, struct wined3d_swapchain *swapchain)
@@ -187,13 +218,6 @@ void wined3d_texture_bind(struct wined3d_texture *texture,
         return;
     }
 
-    if (texture->resource.pool == WINED3D_POOL_DEFAULT)
-    {
-        /* Tell OpenGL to try and keep this texture in video ram (well mostly). */
-        GLclampf tmp = 0.9f;
-        gl_info->gl_ops.gl.p_glPrioritizeTextures(1, &gl_tex->name, &tmp);
-    }
-
     /* Initialise the state of the texture object to the OpenGL defaults, not
      * the wined3d defaults. */
     gl_tex->sampler_desc.address_u = WINED3D_TADDRESS_WRAP;
@@ -422,9 +446,23 @@ ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 
     if (!refcount)
     {
+      //Slice - here HeroesVI crashed
+#if defined(STAGING_CSMT)
+        void *parent = texture->resource.parent;
+        const struct wined3d_parent_ops *parent_ops = texture->resource.parent_ops;
+      TRACE("1c\n");
         wined3d_texture_cleanup(texture);
+      TRACE("2c\n");
+        parent_ops->wined3d_object_destroyed(parent);
+      TRACE("3c\n");
+#else  /* STAGING_CSMT */
+      TRACE("1n\n");
+        wined3d_texture_cleanup(texture);
+      TRACE("2n\n");
         texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
+      TRACE("3n\n");
         HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -496,10 +534,15 @@ void wined3d_texture_load(struct wined3d_texture *texture,
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
+#if defined(STAGING_CSMT)
+    const struct wined3d_device *device = texture->resource.device;
+    wined3d_cs_emit_texture_preload(device->cs, texture);
+#else  /* STAGING_CSMT */
     struct wined3d_context *context;
     context = context_acquire(texture->resource.device, NULL);
     wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
     context_release(context);
+#endif /* STAGING_CSMT */
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -528,6 +571,15 @@ DWORD CDECL wined3d_texture_set_lod(struct wined3d_texture *texture, DWORD lod)
 
     if (texture->lod != lod)
     {
+#if defined(STAGING_CSMT)
+        if (wined3d_settings.cs_multithreaded)
+        {
+            struct wined3d_device *device = texture->resource.device;
+            FIXME("Waiting for cs.\n");
+            device->cs->ops->finish(device->cs);
+        }
+
+#endif /* STAGING_CSMT */
         texture->lod = lod;
 
         texture->texture_rgb.base_level = ~0u;
@@ -592,7 +644,7 @@ HRESULT CDECL wined3d_texture_set_color_key(struct wined3d_texture *texture,
     }
 
     if (flags & WINED3D_CKEY_COLORSPACE)
-    {
+        {
         FIXME("Unhandled flags %#x.\n", flags);
         return WINED3DERR_INVALIDCALL;
     }
@@ -652,7 +704,14 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     }
 
     if (device->d3d_initialized)
+#if defined(STAGING_CSMT)
+    {
+        wined3d_cs_emit_evict_resource(device->cs, &surface->resource);
+        device->cs->ops->finish(device->cs);
+    }
+#else  /* STAGING_CSMT */
         texture->resource.resource_ops->resource_unload(&texture->resource);
+#endif /* STAGING_CSMT */
 
     texture->resource.format = format;
     texture->resource.multisample_type = multisample_type;
@@ -766,6 +825,22 @@ static void wined3d_texture_upload_data(struct wined3d_texture *texture, const s
 static void texture2d_sub_resource_load(struct wined3d_resource *sub_resource,
         struct wined3d_context *context, BOOL srgb)
 {
+#if defined(STAGING_CSMT)
+    surface_load(surface_from_resource(sub_resource), context, srgb);
+}
+
+static void texture2d_sub_resource_add_dirty_region(struct wined3d_resource *sub_resource,
+        const struct wined3d_box *dirty_region)
+{
+    struct wined3d_surface *surface = surface_from_resource(sub_resource);
+    struct wined3d_context *context;
+
+    context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_prepare_map_memory(&surface->resource, context);
+    wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+    context_release(context);
+    wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
+#else  /* STAGING_CSMT */
     surface_load(surface_from_resource(sub_resource), srgb);
 }
 
@@ -777,18 +852,35 @@ static void texture2d_sub_resource_add_dirty_region(struct wined3d_resource *sub
     surface_prepare_map_memory(surface);
     surface_load_location(surface, surface->resource.map_binding);
     surface_invalidate_location(surface, ~surface->resource.map_binding);
+#endif /* STAGING_CSMT */
 }
 
 static void texture2d_sub_resource_cleanup(struct wined3d_resource *sub_resource)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
-
+  //Slice
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
     wined3d_surface_destroy(surface);
 }
 
 static void texture2d_sub_resource_invalidate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
+#if defined(STAGING_CSMT)
+    wined3d_resource_invalidate_location(sub_resource, location);
+}
+
+static void texture2d_sub_resource_validate_location(struct wined3d_resource *sub_resource, DWORD location)
+{
+    wined3d_resource_validate_location(sub_resource, location);
+#else  /* STAGING_CSMT */
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
 
     surface_invalidate_location(surface, location);
 }
@@ -796,8 +888,13 @@ static void texture2d_sub_resource_invalidate_location(struct wined3d_resource *
 static void texture2d_sub_resource_validate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
 
     surface_validate_location(surface, location);
+#endif /* STAGING_CSMT */
 }
 
 static void texture2d_sub_resource_upload_data(struct wined3d_resource *sub_resource,
@@ -807,6 +904,10 @@ static void texture2d_sub_resource_upload_data(struct wined3d_resource *sub_reso
     static const POINT dst_point = {0, 0};
     struct wined3d_const_bo_address addr;
     RECT src_rect;
+  if (!surface) {
+    ERR("no surface\n");
+    return;
+  }
 
     src_rect.left = 0;
     src_rect.top = 0;
@@ -876,6 +977,16 @@ static void texture2d_prepare_texture(struct wined3d_texture *texture, struct wi
 
         if (gl_info->supported[APPLE_CLIENT_STORAGE])
         {
+#if defined(STAGING_CSMT)
+            if (surface->flags & (SFLAG_NONPOW2)
+                    || texture->flags & WINED3D_TEXTURE_CONVERTED)
+            {
+                /* In some cases we want to disable client storage.
+                 * SFLAG_NONPOW2 has a bigger opengl texture than the client memory, and different pitches
+                 * WINED3D_TEXTURE_CONVERTED: The conversion destination memory is freed after loading the surface
+                 * heap_memory == NULL: Not defined in the extension. Seems to disable client storage effectively
+                 */
+#else  /* STAGING_CSMT */
             if (surface->flags & (SFLAG_NONPOW2 | SFLAG_DIBSECTION)
                     || texture->flags & WINED3D_TEXTURE_CONVERTED
                     || !surface->resource.heap_memory)
@@ -886,10 +997,15 @@ static void texture2d_prepare_texture(struct wined3d_texture *texture, struct wi
                  * WINED3D_TEXTURE_CONVERTED: The conversion destination memory is freed after loading the surface
                  * heap_memory == NULL: Not defined in the extension. Seems to disable client storage effectively
                  */
+#endif /* STAGING_CSMT */
                 surface->flags &= ~SFLAG_CLIENT;
             }
             else
             {
+#if defined(STAGING_CSMT)
+                wined3d_resource_prepare_system_memory(&surface->resource);
+
+#endif /* STAGING_CSMT */
                 surface->flags |= SFLAG_CLIENT;
                 mem = surface->resource.heap_memory;
 
@@ -959,11 +1075,33 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
     wined3d_texture_unload_gl_texture(texture);
 }
 
+#if defined(STAGING_CSMT)
+static void wined3d_texture_load_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_texture_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
 static const struct wined3d_resource_ops texture_resource_ops =
 {
     texture_resource_incref,
     texture_resource_decref,
     wined3d_texture_unload,
+    wined3d_texture_load_location_invalidated,
+    wined3d_texture_load_location,
+#else  /* STAGING_CSMT */
+static const struct wined3d_resource_ops texture_resource_ops =
+{
+    texture_resource_incref,
+    texture_resource_decref,
+    wined3d_texture_unload,
+#endif /* STAGING_CSMT */
 };
 
 static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wined3d_resource_desc *desc,
@@ -980,12 +1118,23 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, texture);
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!gl_info->supported[ARB_TEXTURE_CUBE_MAP] && desc->pool != WINED3D_POOL_SCRATCH)
+    {
+        WARN("(%p) : Tried to create not supported cube texture.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[ARB_TEXTURE_CUBE_MAP] && desc->pool != WINED3D_POOL_SCRATCH)
     {
         WARN("(%p) : Tried to create not supported cube texture.\n", texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -995,12 +1144,23 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels != 1)
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (levels != 1)
+        {
+            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -1021,6 +1181,9 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
             else
             {
                 WARN("Attempted to create a NPOT cube texture (edge length %u) without GL support.\n", desc->width);
+#if defined(STAGING_CSMT)
+                HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -1030,6 +1193,9 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
             surface_flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x\n", hr);
+#if defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -1092,6 +1258,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1122,6 +1291,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
                 else
                 {
                     WARN("Attempted to create a mipmapped NPOT texture without unconditional NPOT support.\n");
+#if defined(STAGING_CSMT)
+                    HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                     return WINED3DERR_INVALIDCALL;
                 }
             }
@@ -1134,12 +1306,23 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
+            HeapFree(GetProcessHeap(), 0, texture);
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (levels != 1)
+        {
+            FIXME("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels != 1)
         {
-            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
+            FIXME("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning WINED3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -1148,6 +1331,9 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             surface_flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -1233,13 +1419,32 @@ static void texture3d_sub_resource_add_dirty_region(struct wined3d_resource *sub
 static void texture3d_sub_resource_cleanup(struct wined3d_resource *sub_resource)
 {
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
-
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
+  TRACE("volume %p destroy\n", volume);
+  //trace:d3d_texture:texture3d_sub_resource_cleanup volume 0x70f1c60 destroy
     wined3d_volume_destroy(volume);
 }
 
 static void texture3d_sub_resource_invalidate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
+#if defined(STAGING_CSMT)
+    wined3d_resource_invalidate_location(sub_resource, location);
+}
+
+static void texture3d_sub_resource_validate_location(struct wined3d_resource *sub_resource, DWORD location)
+{
+    wined3d_resource_validate_location(sub_resource, location);
+#else  /* STAGING_CSMT */
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
 
     wined3d_volume_invalidate_location(volume, location);
 }
@@ -1247,8 +1452,14 @@ static void texture3d_sub_resource_invalidate_location(struct wined3d_resource *
 static void texture3d_sub_resource_validate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
 
     wined3d_volume_validate_location(volume, location);
+#endif /* STAGING_CSMT */
 }
 
 static void texture3d_sub_resource_upload_data(struct wined3d_resource *sub_resource,
@@ -1257,8 +1468,13 @@ static void texture3d_sub_resource_upload_data(struct wined3d_resource *sub_reso
     struct wined3d_volume *volume = volume_from_resource(sub_resource);
     struct wined3d_const_bo_address addr;
     unsigned int row_pitch, slice_pitch;
+  //Slice
+  if (!volume) {
+    ERR("no sub-volume\n");
+    return;
+  }
 
-    wined3d_volume_get_pitch(volume, &row_pitch, &slice_pitch);
+    wined3d_resource_get_pitch(sub_resource, &row_pitch, &slice_pitch);
     if (row_pitch != data->row_pitch || slice_pitch != data->slice_pitch)
         FIXME("Ignoring row/slice pitch (%u/%u).\n", data->row_pitch, data->slice_pitch);
 
@@ -1283,7 +1499,11 @@ static void texture3d_prepare_texture(struct wined3d_texture *texture, struct wi
         void *mem = NULL;
 
         if (gl_info->supported[APPLE_CLIENT_STORAGE] && !format->convert
+#if defined(STAGING_CSMT)
+                && wined3d_resource_prepare_system_memory(&volume->resource))
+#else  /* STAGING_CSMT */
                 && volume_prepare_system_memory(volume))
+#endif /* STAGING_CSMT */
         {
             TRACE("Enabling GL_UNPACK_CLIENT_STORAGE_APPLE for volume %p\n", volume);
             gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);
@@ -1330,27 +1550,57 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+#if defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[EXT_TEXTURE3D])
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
         return WINED3DERR_INVALIDCALL;
     }
 
+    if (!gl_info->supported[EXT_TEXTURE3D])
+    {
+        WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+#endif /* STAGING_CSMT */
+        return WINED3DERR_INVALIDCALL;
+    }
+//hack by Stefan Dsinger
+    if (desc->format == WINED3DFMT_DXT1 || desc->format == WINED3DFMT_DXT2 ||
+        desc->format == WINED3DFMT_DXT3 || desc->format == WINED3DFMT_DXT4 ||
+        desc->format == WINED3DFMT_DXT5) {
+          FIXME("create dxtn texture 0x%x.\n", desc->format);
+          if (gl_info->quirks & WINED3D_QUIRK_NO_DXTN)
+          return WINED3DERR_INVALIDCALL;
+    }
+
     /* Calculate levels for mip mapping. */
     if (desc->usage & WINED3DUSAGE_AUTOGENMIPMAP)
     {
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+#if defined(STAGING_CSMT)
+            HeapFree(GetProcessHeap(), 0, texture);
+            return WINED3DERR_INVALIDCALL;
+        }
+
+        if (levels != 1)
+        {
+            WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
+#else  /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels != 1)
         {
             WARN("WINED3DUSAGE_AUTOGENMIPMAP is set, and level count != 1, returning D3DERR_INVALIDCALL.\n");
+#endif /* STAGING_CSMT */
             return WINED3DERR_INVALIDCALL;
         }
     }
@@ -1378,6 +1628,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+#if defined(STAGING_CSMT)
+                HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -1387,6 +1640,9 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             0, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if defined(STAGING_CSMT)
+        HeapFree(GetProcessHeap(), 0, texture);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
@@ -1402,7 +1658,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     for (i = 0; i < texture->level_count; ++i)
     {
         struct wined3d_volume *volume;
-
+/*
+    trace:d3d9:device_parent_volume_created device_parent 0x19b76c, container_parent 0x1d06e8, volume 0x7142030, parent 0x32dd24, parent_ops 0x32dd28.
+    trace:d3d9:device_parent_volume_created Created volume 0x1747a738.
+    trace:d3d9:device_parent_volume_created device_parent 0x19b76c, container_parent 0x1d06e8, volume 0x174774a0, parent 0x32dd24, parent_ops 0x32dd28.
+    trace:d3d9:device_parent_volume_created Created volume 0x1d2428.
+    trace:d3d9:device_parent_volume_created device_parent 0x19b76c, container_parent 0x1d06e8, volume 0x17477528, parent 0x32dd24, parent_ops 0x32dd28.
+    trace:d3d9:device_parent_volume_created Created volume 0x70dc528.
+*/
         if (FAILED(hr = wined3d_volume_create(texture, &volume_desc, i, &volume)))
         {
             ERR("Creating a volume for the volume texture failed, hr %#x.\n", hr);
@@ -1463,7 +1726,9 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     if (FAILED(hr))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+#if !defined(STAGING_CSMT)
         HeapFree(GetProcessHeap(), 0, object);
+#endif /* STAGING_CSMT */
         return hr;
     }
 
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index 1686e30..af49bac 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -112,7 +112,9 @@ static const struct wined3d_format_channels formats[] =
     {WINED3DFMT_R10G11B11_SNORM,           10, 11, 11,  0,   0, 10, 21,  0,    4,   0,     0},
     {WINED3DFMT_R10G10B10_SNORM_A2_UNORM,  10, 10, 10,  2,   0, 10, 20, 30,    4,   0,     0},
     /* Depth stencil formats */
+    {WINED3DFMT_D32_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
     {WINED3DFMT_D16_LOCKABLE,               0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
+    {WINED3DFMT_S8_LOCKABLE,                0,  0,  0,  0,   0,  0,  0,  0,    1,   8,     0},
     {WINED3DFMT_D32_UNORM,                  0,  0,  0,  0,   0,  0,  0,  0,    4,  32,     0},
     {WINED3DFMT_S1_UINT_D15_UNORM,          0,  0,  0,  0,   0,  0,  0,  0,    2,  15,     1},
     {WINED3DFMT_D24_UNORM_S8_UINT,          0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
@@ -132,6 +134,9 @@ static const struct wined3d_format_channels formats[] =
     {WINED3DFMT_ATI1N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
     {WINED3DFMT_ATI2N,                      0,  0,  0,  0,   0,  0,  0,  0,    1,   0,     0},
     {WINED3DFMT_NVDB,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
+// hack by Michael Bond bug 23807
+    {WINED3DFMT_DF16,                       0,  0,  0,  0,   0,  0,  0,  0,    2,  16,     0},
+    {WINED3DFMT_DF24,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     0},
     {WINED3DFMT_INST,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
     {WINED3DFMT_INTZ,                       0,  0,  0,  0,   0,  0,  0,  0,    4,  24,     8},
     {WINED3DFMT_RESZ,                       0,  0,  0,  0,   0,  0,  0,  0,    0,   0,     0},
@@ -666,9 +671,22 @@ static void convert_s8_uint_d24_float(const BYTE *src, BYTE *dst, UINT src_row_p
 static BOOL color_in_range(const struct wined3d_color_key *color_key, DWORD color)
 {
     /* FIXME: Is this really how color keys are supposed to work? I think it
-     * makes more sense to compare the individual channels. */
-    return color >= color_key->color_space_low_value
-            && color <= color_key->color_space_high_value;
+     * makes more sense to compare the individual channels. 
+      return color >= color_key->color_space_low_value
+          && color <= color_key->color_space_high_value; */
+ 
+#define RED_KEY(x)   (x & 0xff0000)
+#define GREEN_KEY(x) (x & 0x00ff00)  
+#define BLUE_KEY(x)  (x & 0x0000ff)
+    return ((RED_KEY(color) >= RED_KEY(color_key->color_space_low_value)) &&
+            (RED_KEY(color) <= RED_KEY(color_key->color_space_high_value)) &&
+            (GREEN_KEY(color) >= GREEN_KEY(color_key->color_space_low_value)) &&
+            (GREEN_KEY(color) <= GREEN_KEY(color_key->color_space_high_value)) &&
+            (BLUE_KEY(color) >= BLUE_KEY(color_key->color_space_low_value)) &&
+            (BLUE_KEY(color) <= BLUE_KEY(color_key->color_space_high_value)));
+#undef RED_KEY
+#undef GREEN_KEY
+#undef BLUE_KEY
 }
 
 static void convert_p8_uint_b8g8r8a8_unorm(const BYTE *src, unsigned int src_pitch,
@@ -1169,14 +1187,26 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             | WINED3DFMT_FLAG_BUMPMAP,
             EXT_TEXTURE_SNORM,          NULL},
     /* Depth stencil formats */
-    {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+    {WINED3DFMT_D32_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
+            WINED3DFMT_FLAG_DEPTH,
+            WINED3D_GL_EXT_NONE,        NULL},
+    {WINED3DFMT_D32_LOCKABLE,           GL_DEPTH_COMPONENT32_ARB,         GL_DEPTH_COMPONENT32_ARB,               0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
+            WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_SHADOW,
+            ARB_DEPTH_TEXTURE,          NULL},
+    {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
             WINED3DFMT_FLAG_DEPTH,
             WINED3D_GL_EXT_NONE,        NULL},
     {WINED3DFMT_D16_LOCKABLE,           GL_DEPTH_COMPONENT24_ARB,         GL_DEPTH_COMPONENT24_ARB,               0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_SHORT,                0,
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_SHADOW,
             ARB_DEPTH_TEXTURE,          NULL},
+    {WINED3DFMT_S8_LOCKABLE,            GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
+            GL_DEPTH_COMPONENT,         GL_BYTE,                          0,
+            WINED3DFMT_FLAG_DEPTH,
+            WINED3D_GL_EXT_NONE,        NULL},
     {WINED3DFMT_D32_UNORM,              GL_DEPTH_COMPONENT,               GL_DEPTH_COMPONENT,                     0,
             GL_DEPTH_COMPONENT,         GL_UNSIGNED_INT,                  0,
             WINED3DFMT_FLAG_DEPTH,
@@ -1270,6 +1300,28 @@ static const struct wined3d_format_texture_info format_texture_info[] =
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING
             | WINED3DFMT_FLAG_COMPRESSED,
             ARB_TEXTURE_COMPRESSION_RGTC, NULL},
+  //bug 23807
+  {WINED3DFMT_DF16,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
+      GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_SHORT,                0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      EXT_PACKED_DEPTH_STENCIL,   NULL},
+    {WINED3DFMT_DF16,                   GL_DEPTH24_STENCIL8,              GL_DEPTH24_STENCIL8,                    0,
+      GL_DEPTH_STENCIL,           GL_UNSIGNED_SHORT,                0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      ARB_FRAMEBUFFER_OBJECT,     NULL},
+    {WINED3DFMT_DF24,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
+      GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_INT_24_8_EXT,         0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      EXT_PACKED_DEPTH_STENCIL,   NULL},
+    {WINED3DFMT_DF24,                   GL_DEPTH24_STENCIL8,              GL_DEPTH24_STENCIL8,                    0,
+      GL_DEPTH_STENCIL,           GL_UNSIGNED_INT_24_8,             0,
+      WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING | WINED3DFMT_FLAG_DEPTH
+      | WINED3DFMT_FLAG_STENCIL,
+      ARB_FRAMEBUFFER_OBJECT,     NULL},
+
     {WINED3DFMT_INTZ,                   GL_DEPTH24_STENCIL8_EXT,          GL_DEPTH24_STENCIL8_EXT,                0,
             GL_DEPTH_STENCIL_EXT,       GL_UNSIGNED_INT_24_8_EXT,         0,
             WINED3DFMT_FLAG_TEXTURE | WINED3DFMT_FLAG_POSTPIXELSHADER_BLENDING | WINED3DFMT_FLAG_FILTERING
@@ -2284,8 +2336,12 @@ const struct wined3d_format *wined3d_get_format(const struct wined3d_gl_info *gl
 
     if (idx == -1)
     {
+        static enum wined3d_format_id old_id;
+        if (old_id != format_id) {
+          old_id = format_id;
         FIXME("Can't find format %s (%#x) in the format lookup table\n",
                 debug_d3dformat(format_id), format_id);
+        }
         /* Get the caller a valid pointer */
         idx = getFmtIdx(WINED3DFMT_UNKNOWN);
     }
@@ -2374,6 +2430,8 @@ const char *debug_d3dformat(enum wined3d_format_id format_id)
         FMT_TO_STR(WINED3DFMT_G8R8_G8B8);
         FMT_TO_STR(WINED3DFMT_R8G8_B8G8);
         FMT_TO_STR(WINED3DFMT_D16_LOCKABLE);
+        FMT_TO_STR(WINED3DFMT_D32_LOCKABLE);
+        FMT_TO_STR(WINED3DFMT_S8_LOCKABLE);
         FMT_TO_STR(WINED3DFMT_D32_UNORM);
         FMT_TO_STR(WINED3DFMT_S1_UINT_D15_UNORM);
         FMT_TO_STR(WINED3DFMT_X8D24_UNORM);
@@ -2476,6 +2534,9 @@ const char *debug_d3dformat(enum wined3d_format_id format_id)
         FMT_TO_STR(WINED3DFMT_B5G5R5A1_UNORM);
         FMT_TO_STR(WINED3DFMT_B8G8R8A8_UNORM);
         FMT_TO_STR(WINED3DFMT_B8G8R8X8_UNORM);
+        //bug 23807
+        FMT_TO_STR(WINED3DFMT_DF16);
+        FMT_TO_STR(WINED3DFMT_DF24);
         FMT_TO_STR(WINED3DFMT_INTZ);
         FMT_TO_STR(WINED3DFMT_RESZ);
         FMT_TO_STR(WINED3DFMT_NULL);
@@ -2516,7 +2577,7 @@ const char *debug_d3ddevicetype(enum wined3d_device_type device_type)
 
 const char *debug_d3dusage(DWORD usage)
 {
-    char buf[333];
+    char buf[433];
 
     buf[0] = '\0';
 #define WINED3DUSAGE_TO_STR(u) if (usage & u) { strcat(buf, " | "#u); usage &= ~u; }
@@ -2533,8 +2594,9 @@ const char *debug_d3dusage(DWORD usage)
     WINED3DUSAGE_TO_STR(WINED3DUSAGE_DMAP);
     WINED3DUSAGE_TO_STR(WINED3DUSAGE_STATICDECL);
     WINED3DUSAGE_TO_STR(WINED3DUSAGE_OVERLAY);
+    WINED3DUSAGE_TO_STR(WINED3DUSAGE_TEXTURE);
 #undef WINED3DUSAGE_TO_STR
-    if (usage) FIXME("Unrecognized usage flag(s) %#x\n", usage);
+    if (usage & ~WINED3DUSAGE_QUERY_MASK) FIXME("Unrecognized usage flag(s) %#x\n", usage);
 
     return buf[0] ? wine_dbg_sprintf("%s", &buf[3]) : "0";
 }
@@ -2553,7 +2615,7 @@ const char *debug_d3dusagequery(DWORD usagequery)
     WINED3DUSAGEQUERY_TO_STR(WINED3DUSAGE_QUERY_VERTEXTEXTURE);
     WINED3DUSAGEQUERY_TO_STR(WINED3DUSAGE_QUERY_WRAPANDMIP);
 #undef WINED3DUSAGEQUERY_TO_STR
-    if (usagequery) FIXME("Unrecognized usage query flag(s) %#x\n", usagequery);
+    if (usagequery & WINED3DUSAGE_QUERY_MASK) FIXME("Unrecognized usage query flag(s) %#x\n", usagequery);
 
     return buf[0] ? wine_dbg_sprintf("%s", &buf[3]) : "0";
 }
@@ -3192,7 +3254,11 @@ void get_projection_matrix(const struct wined3d_context *context, const struct w
         float y_offset = context->render_offscreen
                 ? (center_offset - (2.0f * y) - h) / h
                 : (center_offset - (2.0f * y) - h) / -h;
+#if defined(STAGING_CSMT)
+        enum wined3d_depth_buffer_type zenable = state->fb.depth_stencil ?
+#else  /* STAGING_CSMT */
         enum wined3d_depth_buffer_type zenable = state->fb->depth_stencil ?
+#endif /* STAGING_CSMT */
                 state->render_states[WINED3D_RS_ZENABLE] : WINED3D_ZB_FALSE;
         float z_scale = zenable ? 2.0f : 0.0f;
         float z_offset = zenable ? -1.0f : 0.0f;
@@ -3315,6 +3381,20 @@ static void compute_texture_matrix(const struct wined3d_gl_info *gl_info, const
                 /* case WINED3D_TTFF_COUNT1: Won't ever get here. */
                 case WINED3D_TTFF_COUNT2:
                     mat._13 = mat._23 = mat._33 = mat._43 = 0.0f;
+#if defined(STAGING_CSMT)
+                /* OpenGL divides the first 3 vertex coord by the 4th by default,
+                * which is essentially the same as D3DTTFF_PROJECTED. Make sure that
+                * the 4th coord evaluates to 1.0 to eliminate that.
+                *
+                * If the fixed function pipeline is used, the 4th value remains unused,
+                * so there is no danger in doing this. With vertex shaders we have a
+                * problem. Should an app hit that problem, the code here would have to
+                * check for pixel shaders, and the shader has to undo the default gl divide.
+                *
+                * A more serious problem occurs if the app passes 4 coordinates in, and the
+                * 4th is != 1.0(opengl default). This would have to be fixed in draw_strided_slow
+                * or a replacement shader. */
+#else  /* STAGING_CSMT */
                 /* OpenGL divides the first 3 vertex coord by the 4th by default,
                 * which is essentially the same as D3DTTFF_PROJECTED. Make sure that
                 * the 4th coord evaluates to 1.0 to eliminate that.
@@ -3327,6 +3407,7 @@ static void compute_texture_matrix(const struct wined3d_gl_info *gl_info, const
                 * A more serious problem occurs if the app passes 4 coordinates in, and the
                 * 4th is != 1.0(opengl default). This would have to be fixed in drawStridedSlow
                 * or a replacement shader. */
+#endif /* STAGING_CSMT */
                 default:
                     mat._14 = mat._24 = mat._34 = 0.0f; mat._44 = 1.0f;
             }
@@ -3427,6 +3508,8 @@ BOOL getDepthStencilBits(const struct wined3d_format *format, BYTE *depthSize, B
     switch (format->id)
     {
         case WINED3DFMT_D16_LOCKABLE:
+        case WINED3DFMT_D32_LOCKABLE:
+        case WINED3DFMT_S8_LOCKABLE:
         case WINED3DFMT_D16_UNORM:
         case WINED3DFMT_S1_UINT_D15_UNORM:
         case WINED3DFMT_X8D24_UNORM:
@@ -3435,6 +3518,8 @@ BOOL getDepthStencilBits(const struct wined3d_format *format, BYTE *depthSize, B
         case WINED3DFMT_S8_UINT_D24_FLOAT:
         case WINED3DFMT_D32_UNORM:
         case WINED3DFMT_D32_FLOAT:
+        case WINED3DFMT_DF16:
+        case WINED3DFMT_DF24:
         case WINED3DFMT_INTZ:
             break;
         default:
@@ -3686,7 +3771,11 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
     unsigned int i;
     DWORD ttff;
     DWORD cop, aop, carg0, carg1, carg2, aarg0, aarg1, aarg2;
+#if defined(STAGING_CSMT)
+    const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
+#else  /* STAGING_CSMT */
     const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+#endif /* STAGING_CSMT */
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
 
diff --git a/dlls/wined3d/vertexdeclaration.c b/dlls/wined3d/vertexdeclaration.c
index 9eb5907..437d876 100644
--- a/dlls/wined3d/vertexdeclaration.c
+++ b/dlls/wined3d/vertexdeclaration.c
@@ -50,6 +50,14 @@ ULONG CDECL wined3d_vertex_declaration_incref(struct wined3d_vertex_declaration
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration)
+{
+    HeapFree(GetProcessHeap(), 0, declaration->elements);
+    HeapFree(GetProcessHeap(), 0, declaration);
+}
+
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration *declaration)
 {
     ULONG refcount = InterlockedDecrement(&declaration->ref);
@@ -58,9 +66,15 @@ ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        const struct wined3d_device *device = declaration->device;
+        declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
+        wined3d_cs_emit_vertex_declaration_destroy(device->cs, declaration);
+#else  /* STAGING_CSMT */
         HeapFree(GetProcessHeap(), 0, declaration->elements);
         declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
         HeapFree(GetProcessHeap(), 0, declaration);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
@@ -110,7 +124,16 @@ static BOOL declaration_element_valid_ffp(const struct wined3d_vertex_element *e
                 default:
                     return FALSE;
             }
-
+            
+        case WINED3D_DECL_USAGE_BLEND_INDICES:
+            switch(element->format)
+            {
+                case WINED3DFMT_R8G8B8A8_UINT:
+                    return TRUE;
+                default:
+                    return FALSE;
+            }
+            
         case WINED3D_DECL_USAGE_NORMAL:
             switch(element->format)
             {
@@ -124,6 +147,7 @@ static BOOL declaration_element_valid_ffp(const struct wined3d_vertex_element *e
             }
 
         case WINED3D_DECL_USAGE_TEXCOORD:
+        case WINED3D_DECL_USAGE_PSIZE:  //Slice
             switch(element->format)
             {
                 case WINED3DFMT_R32_FLOAT:
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
index 9cda64d..a098555 100644
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -33,6 +33,13 @@ ULONG CDECL wined3d_rendertarget_view_incref(struct wined3d_rendertarget_view *v
     return refcount;
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_rendertarget_view_destroy(struct wined3d_rendertarget_view *view)
+{
+    HeapFree(GetProcessHeap(), 0, view);
+}
+
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_rendertarget_view_decref(struct wined3d_rendertarget_view *view)
 {
     ULONG refcount = InterlockedDecrement(&view->refcount);
@@ -41,11 +48,21 @@ ULONG CDECL wined3d_rendertarget_view_decref(struct wined3d_rendertarget_view *v
 
     if (!refcount)
     {
+#if defined(STAGING_CSMT)
+        struct wined3d_device *device = view->resource->device;
+
+        /* Call wined3d_object_destroyed() before releasing the resource,
+         * since releasing the resource may end up destroying the parent. */
+        view->parent_ops->wined3d_object_destroyed(view->parent);
+        wined3d_resource_decref(view->resource);
+        wined3d_cs_emit_view_destroy(device->cs, view);
+#else  /* STAGING_CSMT */
         /* Call wined3d_object_destroyed() before releasing the resource,
          * since releasing the resource may end up destroying the parent. */
         view->parent_ops->wined3d_object_destroyed(view->parent);
         wined3d_resource_decref(view->resource);
         HeapFree(GetProcessHeap(), 0, view);
+#endif /* STAGING_CSMT */
     }
 
     return refcount;
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
index 357608f..c99609d 100644
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -40,30 +40,6 @@ BOOL volume_prepare_system_memory(struct wined3d_volume *volume)
     return TRUE;
 }
 
-void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch, UINT *slice_pitch)
-{
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
-    {
-        /* Since compressed formats are block based, pitch means the amount of
-         * bytes to the next row of block rather than the next row of pixels. */
-        UINT row_block_count = (volume->resource.width + format->block_width - 1) / format->block_width;
-        UINT slice_block_count = (volume->resource.height + format->block_height - 1) / format->block_height;
-        *row_pitch = row_block_count * format->block_byte_count;
-        *slice_pitch = *row_pitch * slice_block_count;
-    }
-    else
-    {
-        unsigned char alignment = volume->resource.device->surface_alignment;
-        *row_pitch = format->byte_count * volume->resource.width;  /* Bytes / row */
-        *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
-        *slice_pitch = *row_pitch * volume->resource.height;
-    }
-
-    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
-}
-
 /* This call just uploads data, the caller is responsible for binding the
  * correct texture. */
 /* Context activation is done by the caller. */
@@ -95,7 +71,7 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
         dst_row_pitch = width * format->conv_byte_count;
         dst_slice_pitch = dst_row_pitch * height;
 
-        wined3d_volume_get_pitch(volume, &src_row_pitch, &src_slice_pitch);
+        wined3d_resource_get_pitch(&volume->resource, &src_row_pitch, &src_slice_pitch);
 
         converted_mem = HeapAlloc(GetProcessHeap(), 0, dst_slice_pitch * depth);
         format->convert(data->addr, converted_mem, src_row_pitch, src_slice_pitch,
@@ -123,6 +99,7 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
     HeapFree(GetProcessHeap(), 0, converted_mem);
 }
 
+#if !defined(STAGING_CSMT)
 void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD location)
 {
     TRACE("Volume %p, setting %s.\n", volume, wined3d_debug_location(location));
@@ -132,11 +109,12 @@ void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD locat
 
 void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location)
 {
-    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
+//    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
     volume->locations &= ~location;
     TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
 }
 
+#endif /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void wined3d_volume_download_data(struct wined3d_volume *volume,
         const struct wined3d_context *context, const struct wined3d_bo_address *data)
@@ -172,6 +150,10 @@ static void wined3d_volume_download_data(struct wined3d_volume *volume,
 static void wined3d_volume_evict_sysmem(struct wined3d_volume *volume)
 {
     wined3d_resource_free_sysmem(&volume->resource);
+#if defined(STAGING_CSMT)
+    volume->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
+#else  /* STAGING_CSMT */
     wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_SYSMEM);
 }
 
@@ -194,6 +176,7 @@ static DWORD volume_access_from_location(DWORD location)
             FIXME("Unhandled location %#x.\n", location);
             return 0;
     }
+#endif /* STAGING_CSMT */
 }
 
 /* Context activation is done by the caller. */
@@ -235,6 +218,18 @@ static BOOL wined3d_volume_can_evict(const struct wined3d_volume *volume)
 
     return TRUE;
 }
+#if defined(STAGING_CSMT)
+
+/* Context activation is done by the caller. */
+static void wined3d_volume_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    struct wined3d_volume *volume = volume_from_resource(resource);
+    DWORD required_access = wined3d_resource_access_from_location(location);
+
+    TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
+        wined3d_debug_location(volume->resource.locations));
+#else  /* STAGING_CSMT */
 /* Context activation is done by the caller. */
 static void wined3d_volume_load_location(struct wined3d_volume *volume,
         struct wined3d_context *context, DWORD location)
@@ -249,6 +244,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
         TRACE("Location(s) already up to date.\n");
         return;
     }
+#endif /* STAGING_CSMT */
 
     if ((volume->resource.access_flags & required_access) != required_access)
     {
@@ -267,6 +263,41 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                     && !(volume->container->flags & WINED3D_TEXTURE_SRGB_ALLOCATED)))
                 ERR("Trying to load (s)RGB texture without prior allocation.\n");
 
+#if defined(STAGING_CSMT)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
+            {
+                TRACE("Volume previously discarded, nothing to do.\n");
+                wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
+            }
+            else if (volume->resource.locations & WINED3D_LOCATION_SYSMEM)
+            {
+                struct wined3d_const_bo_address data = {0, volume->resource.heap_memory};
+                wined3d_texture_bind_and_dirtify(volume->container, context,
+                        location == WINED3D_LOCATION_TEXTURE_SRGB);
+                wined3d_volume_upload_data(volume, context, &data);
+            }
+            else if (volume->resource.locations & WINED3D_LOCATION_BUFFER)
+            {
+                struct wined3d_const_bo_address data = {volume->resource.buffer->name, NULL};
+                wined3d_texture_bind_and_dirtify(volume->container, context,
+                        location == WINED3D_LOCATION_TEXTURE_SRGB);
+                wined3d_volume_upload_data(volume, context, &data);
+            }
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+            {
+                wined3d_volume_srgb_transfer(volume, context, TRUE);
+            }
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_SRGB)
+            {
+                wined3d_volume_srgb_transfer(volume, context, FALSE);
+            }
+            else
+            {
+                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->resource.locations));
+                return;
+            }
+            wined3d_resource_validate_location(&volume->resource, location);
+#else  /* STAGING_CSMT */
             if (volume->locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
@@ -300,6 +331,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                 return;
             }
             wined3d_volume_validate_location(volume, location);
+#endif /* STAGING_CSMT */
 
             if (wined3d_volume_can_evict(volume))
                 wined3d_volume_evict_sysmem(volume);
@@ -310,6 +342,13 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             if (!volume->resource.heap_memory)
                 ERR("Trying to load WINED3D_LOCATION_SYSMEM without setting it up first.\n");
 
+#if defined(STAGING_CSMT)
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            {
+                struct wined3d_bo_address data = {0, volume->resource.heap_memory};
+
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+#else  /* STAGING_CSMT */
             if (volume->locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
@@ -320,6 +359,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
 
                 if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+#endif /* STAGING_CSMT */
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -330,6 +370,23 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_SYSMEM loading from %s.\n",
+#if defined(STAGING_CSMT)
+                        wined3d_debug_location(volume->resource.locations));
+                return;
+            }
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
+            break;
+
+        case WINED3D_LOCATION_BUFFER:
+            if (!volume->resource.buffer)
+                ERR("Trying to load WINED3D_LOCATION_BUFFER without setting it up first.\n");
+
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            {
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
+
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+#else  /* STAGING_CSMT */
                         wined3d_debug_location(volume->locations));
                 return;
             }
@@ -350,6 +407,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                 struct wined3d_bo_address data = {volume->pbo, NULL};
 
                 if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+#endif /* STAGING_CSMT */
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -359,6 +417,17 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_BUFFER loading from %s.\n",
+#if defined(STAGING_CSMT)
+                        wined3d_debug_location(volume->resource.locations));
+                return;
+            }
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_BUFFER);
+            break;
+
+        default:
+            FIXME("Implement %s loading from %s.\n", wined3d_debug_location(location),
+                    wined3d_debug_location(volume->resource.locations));
+#else  /* STAGING_CSMT */
                         wined3d_debug_location(volume->locations));
                 return;
             }
@@ -368,6 +437,7 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
         default:
             FIXME("Implement %s loading from %s.\n", wined3d_debug_location(location),
                     wined3d_debug_location(volume->locations));
+#endif /* STAGING_CSMT */
     }
 }
 
@@ -375,6 +445,22 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context, BOOL srgb_mode)
 {
     wined3d_texture_prepare_texture(volume->container, context, srgb_mode);
+#if defined(STAGING_CSMT)
+    wined3d_resource_load_location(&volume->resource, context,
+            srgb_mode ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB);
+}
+
+void wined3d_volume_destroy(struct wined3d_volume *volume)
+{
+    struct wined3d_device *device = volume->resource.device;
+    TRACE_(d3d_perf)("volume %p device %p.\n", volume, device);
+  //Slice
+
+    resource_cleanup(&volume->resource);
+    volume->resource.parent_ops->wined3d_object_destroyed(volume->resource.parent);
+    TRACE_(d3d_perf)("->wined3d_object_destroyed %p.\n", volume->resource.parent_ops->wined3d_object_destroyed);
+    wined3d_cs_emit_volume_cleanup(device->cs, volume);
+#else  /* STAGING_CSMT */
     wined3d_volume_load_location(volume, context,
             srgb_mode ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB);
 }
@@ -418,6 +504,7 @@ void wined3d_volume_destroy(struct wined3d_volume *volume)
     resource_cleanup(&volume->resource);
     volume->resource.parent_ops->wined3d_object_destroyed(volume->resource.parent);
     HeapFree(GetProcessHeap(), 0, volume);
+#endif /* STAGING_CSMT */
 }
 
 static void volume_unload(struct wined3d_resource *resource)
@@ -431,6 +518,20 @@ static void volume_unload(struct wined3d_resource *resource)
 
     TRACE("texture %p.\n", resource);
 
+#if defined(STAGING_CSMT)
+    if (wined3d_resource_prepare_system_memory(&volume->resource))
+    {
+        context = context_acquire(device, NULL);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_SYSMEM);
+        context_release(context);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_SYSMEM);
+    }
+    else
+    {
+        ERR("Out of memory when unloading volume %p.\n", volume);
+        wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_DISCARDED);
+#else  /* STAGING_CSMT */
     if (volume_prepare_system_memory(volume))
     {
         context = context_acquire(device, NULL);
@@ -452,6 +553,7 @@ static void volume_unload(struct wined3d_resource *resource)
          * and must be freed before a non-ex device reset. */
         ERR("Unloading a volume with a buffer\n");
         wined3d_volume_free_pbo(volume);
+#endif /* STAGING_CSMT */
     }
 
     /* The texture name is managed by the container. */
@@ -467,6 +569,13 @@ ULONG CDECL wined3d_volume_incref(struct wined3d_volume *volume)
     return wined3d_texture_incref(volume->container);
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume)
+{
+    HeapFree(GetProcessHeap(), 0, volume);
+}
+
+#endif /* STAGING_CSMT */
 ULONG CDECL wined3d_volume_decref(struct wined3d_volume *volume)
 {
     TRACE("Forwarding to container %p.\n", volume->container);
@@ -493,6 +602,7 @@ struct wined3d_resource * CDECL wined3d_volume_get_resource(struct wined3d_volum
     return &volume->resource;
 }
 
+#if !defined(STAGING_CSMT)
 static BOOL volume_check_block_align(const struct wined3d_volume *volume,
         const struct wined3d_box *box)
 {
@@ -521,6 +631,7 @@ static BOOL volume_check_block_align(const struct wined3d_volume *volume,
     return TRUE;
 }
 
+#endif /* STAGING_CSMT */
 static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *volume,
         const struct wined3d_box *box)
 {
@@ -546,6 +657,51 @@ static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *vol
 HRESULT CDECL wined3d_volume_map(struct wined3d_volume *volume,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
+#if defined(STAGING_CSMT)
+    HRESULT hr;
+    const struct wined3d_format *format = volume->resource.format;
+  WARN("format %#x w=%d h=%d\n", format->block_width, format->block_height);
+    if (box) {
+        WARN("box w=%d h=%d\n", box->right - box->left, box->bottom - box->top);
+    }
+    else {
+        WARN("no box\n");
+    }
+  
+
+    map_desc->data = NULL;
+    if (!(volume->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
+    {
+        WARN("Volume %p is not CPU accessible.\n", volume);
+        return WINED3DERR_INVALIDCALL;
+    }
+    if (!wined3d_volume_check_box_dimensions(volume, box))
+    {
+        WARN("Map box is invalid.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && !(flags & WINED3D_MAP_DISCARD) &&
+            !wined3d_resource_check_block_align(&volume->resource, box))
+    {
+        WARN("Map box is misaligned for %ux%u blocks. box=(%d,%d,%d)-(%d,%d,%d)\n",
+             format->block_width, format->block_height,
+             box->left, box->top, box->front, box->right, box->bottom, box->back);
+
+      //fixme:d3dx:D3DXLoadVolumeFromMemory convert volume tex from 0x15 to 0x31545844
+      //warn:d3d_surface:wined3d_volume_map Map box is misaligned for 4x4 blocks.
+      //err:d3dx:D3DXLoadVolumeFromMemory fail to LockBox
+
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    hr = wined3d_resource_map(&volume->resource, map_desc, box, flags);
+  if (FAILED(hr)) {
+    WARN("Fail to map\n");
+        return hr;
+  }
+
+    return hr;
+#else  /* not STAGING_CSMT */
     struct wined3d_device *device = volume->resource.device;
     struct wined3d_context *context;
     const struct wined3d_gl_info *gl_info;
@@ -642,7 +798,7 @@ HRESULT CDECL wined3d_volume_map(struct wined3d_volume *volume,
     }
     else
     {
-        wined3d_volume_get_pitch(volume, &map_desc->row_pitch, &map_desc->slice_pitch);
+        wined3d_resource_get_pitch(&volume->resource, &map_desc->row_pitch, &map_desc->slice_pitch);
     }
 
     if (!box)
@@ -685,6 +841,7 @@ HRESULT CDECL wined3d_volume_map(struct wined3d_volume *volume,
             map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
 
     return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resource *resource)
@@ -694,6 +851,17 @@ struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resour
 
 HRESULT CDECL wined3d_volume_unmap(struct wined3d_volume *volume)
 {
+#if defined(STAGING_CSMT)
+    HRESULT hr;
+
+    if (volume->resource.unmap_dirtify)
+        wined3d_texture_set_dirty(volume->container);
+
+    hr = wined3d_resource_unmap(&volume->resource);
+    if (hr == WINEDDERR_NOTLOCKED)
+        return WINED3DERR_INVALIDCALL;
+    return hr;
+#else  /* STAGING_CSMT */
     TRACE("volume %p.\n", volume);
 
     if (!volume->resource.map_count)
@@ -719,6 +887,7 @@ HRESULT CDECL wined3d_volume_unmap(struct wined3d_volume *volume)
     volume->resource.map_count--;
 
     return WINED3D_OK;
+#endif /* STAGING_CSMT */
 }
 
 static ULONG volume_resource_incref(struct wined3d_resource *resource)
@@ -731,11 +900,29 @@ static ULONG volume_resource_decref(struct wined3d_resource *resource)
     return wined3d_volume_decref(volume_from_resource(resource));
 }
 
+#if defined(STAGING_CSMT)
+static void wined3d_volume_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    struct wined3d_volume *volume = volume_from_resource(resource);
+
+    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+        wined3d_texture_set_dirty(volume->container);
+}
+
 static const struct wined3d_resource_ops volume_resource_ops =
 {
     volume_resource_incref,
     volume_resource_decref,
     volume_unload,
+    wined3d_volume_location_invalidated,
+    wined3d_volume_load_location,
+#else  /* STAGING_CSMT */
+static const struct wined3d_resource_ops volume_resource_ops =
+{
+    volume_resource_incref,
+    volume_resource_decref,
+    volume_unload,
+#endif /* STAGING_CSMT */
 };
 
 static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture *container,
@@ -749,7 +936,7 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
 
     if (!gl_info->supported[EXT_TEXTURE3D])
     {
-        WARN("Volume cannot be created - no volume texture support.\n");
+        ERR("Volume cannot be created - no volume texture support.\n");
         return WINED3DERR_INVALIDCALL;
     }
     /* TODO: Write tests for other resources and move this check
@@ -762,7 +949,8 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     }
 
     size = wined3d_format_calculate_size(format, device->surface_alignment, desc->width, desc->height, desc->depth);
-
+  FIXME("format 0x%x size=%d \n", format->id, size);
+    //fixme:d3d_surface:volume_init format 0x74 size=1048576
     if (FAILED(hr = resource_init(&volume->resource, device, WINED3D_RTYPE_VOLUME, format,
             WINED3D_MULTISAMPLE_NONE, 0, desc->usage, desc->pool, desc->width, desc->height, desc->depth,
             size, NULL, &wined3d_null_parent_ops, &volume_resource_ops)))
@@ -772,7 +960,11 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     }
 
     volume->texture_level = level;
+#if defined(STAGING_CSMT)
+    volume->resource.locations = WINED3D_LOCATION_DISCARDED;
+#else  /* STAGING_CSMT */
     volume->locations = WINED3D_LOCATION_DISCARDED;
+#endif /* STAGING_CSMT */
 
     if (desc->pool == WINED3D_POOL_DEFAULT && desc->usage & WINED3DUSAGE_DYNAMIC
             && gl_info->supported[ARB_PIXEL_BUFFER_OBJECT]
@@ -780,6 +972,9 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     {
         wined3d_resource_free_sysmem(&volume->resource);
         volume->resource.map_binding = WINED3D_LOCATION_BUFFER;
+#if defined(STAGING_CSMT)
+        volume->resource.map_heap_memory = NULL;
+#endif /* STAGING_CSMT */
     }
 
     volume->container = container;
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index a79d6a6..9bf3194 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -182,6 +182,7 @@
 
 @ cdecl wined3d_resource_get_desc(ptr ptr)
 @ cdecl wined3d_resource_get_parent(ptr)
+@ cdecl wined3d_resource_get_pitch(ptr ptr ptr)
 @ cdecl wined3d_resource_get_priority(ptr)
 @ cdecl wined3d_resource_set_parent(ptr ptr)
 @ cdecl wined3d_resource_set_priority(ptr long)
@@ -220,6 +221,8 @@
 @ cdecl wined3d_stateblock_decref(ptr)
 @ cdecl wined3d_stateblock_incref(ptr)
 
+@ cdecl wined3d_strictdrawing_set(long)
+
 @ cdecl wined3d_surface_blt(ptr ptr ptr ptr long ptr long)
 @ cdecl wined3d_surface_decref(ptr)
 @ cdecl wined3d_surface_from_resource(ptr)
@@ -227,7 +230,6 @@
 @ cdecl wined3d_surface_get_flip_status(ptr long)
 @ cdecl wined3d_surface_get_overlay_position(ptr ptr ptr)
 @ cdecl wined3d_surface_get_parent(ptr)
-@ cdecl wined3d_surface_get_pitch(ptr)
 @ cdecl wined3d_surface_get_render_target_data(ptr ptr)
 @ cdecl wined3d_surface_get_resource(ptr)
 @ cdecl wined3d_surface_getdc(ptr ptr)
@@ -289,3 +291,11 @@
 @ cdecl wined3d_volume_map(ptr ptr ptr long)
 @ cdecl wined3d_volume_preload(ptr)
 @ cdecl wined3d_volume_unmap(ptr)
+
+@ cdecl wined3d_dxtn_supported()
+@ cdecl wined3d_dxt1_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt1_encode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt3_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt3_encode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt5_decode(ptr ptr long long long long long)
+@ cdecl wined3d_dxt5_encode(ptr ptr long long long long long)
diff --git a/dlls/wined3d/wined3d_gl.h b/dlls/wined3d/wined3d_gl.h
index 4919cf6..f7f35f1 100644
--- a/dlls/wined3d/wined3d_gl.h
+++ b/dlls/wined3d/wined3d_gl.h
@@ -48,6 +48,7 @@ enum wined3d_gl_extension
     ARB_COLOR_BUFFER_FLOAT,
     ARB_DEBUG_OUTPUT,
     ARB_DEPTH_BUFFER_FLOAT,
+    ARB_DEPTH_CLAMP,
     ARB_DEPTH_TEXTURE,
     ARB_DRAW_BUFFERS,
     ARB_DRAW_ELEMENTS_BASE_VERTEX,
@@ -81,6 +82,7 @@ enum wined3d_gl_extension
     ARB_TEXTURE_COMPRESSION,
     ARB_TEXTURE_COMPRESSION_RGTC,
     ARB_TEXTURE_CUBE_MAP,
+    ARB_TEXTURE_ENV_ADD,
     ARB_TEXTURE_ENV_COMBINE,
     ARB_TEXTURE_ENV_DOT3,
     ARB_TEXTURE_FLOAT,
@@ -117,6 +119,7 @@ enum wined3d_gl_extension
     EXT_GPU_PROGRAM_PARAMETERS,
     EXT_GPU_SHADER4,
     EXT_PACKED_DEPTH_STENCIL,
+    EXT_PALETTED_TEXTURE,
     EXT_POINT_PARAMETERS,
     EXT_PROVOKING_VERTEX,
     EXT_SECONDARY_COLOR,
@@ -125,6 +128,7 @@ enum wined3d_gl_extension
     EXT_TEXTURE3D,
     EXT_TEXTURE_COMPRESSION_RGTC,
     EXT_TEXTURE_COMPRESSION_S3TC,
+    EXT_TEXTURE_ENV_ADD,
     EXT_TEXTURE_ENV_COMBINE,
     EXT_TEXTURE_ENV_DOT3,
     EXT_TEXTURE_FILTER_ANISOTROPIC,
@@ -135,6 +139,7 @@ enum wined3d_gl_extension
     EXT_TEXTURE_SRGB_DECODE,
     EXT_VERTEX_ARRAY_BGRA,
     /* NVIDIA */
+    NV_DEPTH_CLAMP,
     NV_FENCE,
     NV_FOG_DISTANCE,
     NV_FRAGMENT_PROGRAM,
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
index 758ba43..d2ba7bd 100644
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -76,6 +76,7 @@ struct wined3d_settings wined3d_settings =
     ORM_FBO,        /* Use FBOs to do offscreen rendering */
     PCI_VENDOR_NONE,/* PCI Vendor ID */
     PCI_DEVICE_NONE,/* PCI Device ID */
+    0,              /* Multisampling AA Quality Levels */
     0,              /* The default of memory is set in init_driver_info */
     NULL,           /* No wine logo by default */
     TRUE,           /* Multisampling enabled by default. */
@@ -85,6 +86,14 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+#if defined(STAGING_CSMT)
+    TRUE,           /* Multithreaded CS by default. */
+    FALSE,          /* Do not ignore render target maps. */
+#endif /* STAGING_CSMT */
+  FALSE,            /* Override vertex constants? */
+  256,              /* Number of vertex shaders to use */
+  253,              /* default for UserQuirks */
+
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -236,6 +245,7 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
                 wined3d_settings.pci_device_id = pci_device_id;
             }
         }
+        tmpvalue = 0;
         if ( !get_config_key_dword( hkey, appkey, "VideoPciVendorID", &tmpvalue) )
         {
             int pci_vendor_id = tmpvalue;
@@ -251,6 +261,17 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
                 wined3d_settings.pci_vendor_id = pci_vendor_id;
             }
         }
+        if (!get_config_key( hkey, appkey, "MultisamplingAAQualityLevels", buffer, size ))
+        {
+            int quality_levels = atoi(buffer);
+            if(quality_levels > 0)
+            {
+                wined3d_settings.msaa_quality_levels = quality_levels;
+                TRACE("Setting MultisamplingAAQualityLevels to %i\n", quality_levels);
+            }
+            else
+                ERR("MultisamplingAAQualityLevels is %i but must be >0\n", quality_levels);
+        }
         if ( !get_config_key( hkey, appkey, "VideoMemorySize", buffer, size) )
         {
             int TmpVideoMemorySize = atoi(buffer);
@@ -292,6 +313,31 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Not always rendering backbuffers offscreen.\n");
             wined3d_settings.always_offscreen = FALSE;
         }
+        if (!get_config_key(hkey, appkey, "OverrideVertexShaders", buffer, size) && !strcmp(buffer,"enabled"))
+        {
+          TRACE("Override Vertex Shader Constants\n");
+          wined3d_settings.override_vertex_constants = TRUE;
+        }
+        if (!get_config_key(hkey, appkey, "VertexShaderConstants", buffer, size))
+        {
+          int TmpVertexShaderConstants = atoi(buffer);
+          if (TmpVertexShaderConstants > 0)
+          {
+            wined3d_settings.vertex_constants_number = TmpVertexShaderConstants;
+            TRACE("Use %i Vertex Shader Constants\n", TmpVertexShaderConstants);
+          }
+        }
+        tmpvalue = 0;
+      if (!get_config_key_dword(hkey, appkey, "UserQuirks", &tmpvalue))
+      {
+        int TmpUserQuirks = tmpvalue;
+        if (TmpUserQuirks > 0)
+        {
+          wined3d_settings.user_quirks = TmpUserQuirks;
+          TRACE("Use %i UserQuirks\n", TmpUserQuirks);
+        }
+      }
+
         if (!get_config_key_dword(hkey, appkey, "MaxShaderModelVS", &wined3d_settings.max_sm_vs))
             TRACE("Limiting VS shader model to %u.\n", wined3d_settings.max_sm_vs);
         if (!get_config_key_dword(hkey, appkey, "MaxShaderModelGS", &wined3d_settings.max_sm_gs))
@@ -304,11 +350,32 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+#if defined(STAGING_CSMT)
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"disabled"))
+        {
+            TRACE("Disabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = FALSE;
+        }
+        if (!get_config_key(hkey, appkey, "ignore_rt_map", buffer, size)
+                && !strcmp(buffer,"enabled"))
+        {
+            TRACE("Ignoring render target maps.\n");
+            wined3d_settings.ignore_rt_map = TRUE;
+        }
+    }
+
+    FIXME_(winediag)("Experimental wined3d CSMT feature is currently %s.\n",
+        wined3d_settings.cs_multithreaded ? "enabled" : "disabled");
+#else  /* STAGING_CSMT */
     }
+#endif /* STAGING_CSMT */
 
     if (appkey) RegCloseKey( appkey );
     if (hkey) RegCloseKey( hkey );
 
+    wined3d_dxtn_init();
+
     return TRUE;
 }
 
@@ -340,6 +407,9 @@ static BOOL wined3d_dll_destroy(HINSTANCE hInstDLL)
 
     DeleteCriticalSection(&wined3d_wndproc_cs);
     DeleteCriticalSection(&wined3d_cs);
+
+    wined3d_dxtn_free();
+
     return TRUE;
 }
 
@@ -505,6 +575,11 @@ void wined3d_unregister_window(HWND window)
     wined3d_wndproc_mutex_unlock();
 }
 
+void wined3d_strictdrawing_set(int value)
+{
+    wined3d_settings.strict_draw_ordering = value;
+}
+
 /* At process attach */
 BOOL WINAPI DllMain(HINSTANCE inst, DWORD reason, void *reserved)
 {
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 9b9973c..fc3aea4 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -1,3 +1,28 @@
+#if defined(STAGING_CSMT)
+/*
+ * Direct3D wine internal private include file
+ *
+ * Copyright 2002-2003 The wine-d3d team
+ * Copyright 2002-2003 Raphael Junqueira
+ * Copyright 2002-2003, 2004 Jason Edmeades
+ * Copyright 2005 Oliver Stieber
+ * Copyright 2006-2011, 2013-2014 Stefan Dsinger for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#else  /* STAGING_CSMT */
 /*
  * Direct3D wine internal private include file
  *
@@ -21,6 +46,7 @@
  * License along with this library; if not, write to the Free Software
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
+#endif /* STAGING_CSMT */
 
 #ifndef __WINE_WINED3D_PRIVATE_H
 #define __WINE_WINED3D_PRIVATE_H
@@ -31,6 +57,9 @@
 #define WINE_GLAPI
 #endif
 
+#if defined(STAGING_CSMT)
+#include <assert.h>
+#endif /* STAGING_CSMT */
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -68,6 +97,16 @@
 #define WINED3D_QUIRK_LIMITED_TEX_FILTERING     0x00000100
 #define WINED3D_QUIRK_BROKEN_ARB_FOG            0x00000200
 
+#define WINED3D_CX_QUIRK_APPLE_DOUBLE_BUFFER    0x00010000
+#define WINED3D_CX_QUIRK_COMPRESSED_CUBE_MIP    0x00020000  /* Intel GPU */
+#define WINED3D_CX_QUIRK_GLSL_CLIP_BROKEN       0x00040000
+#define WINED3D_CX_QUIRK_TEXCOORD_FOG           0x00080000  /* old ATI */
+#define WINED3D_CX_QUIRK_BROKEN_ARA             0x00100000  /* Nvidia 8xxx */
+#define WINED3D_CX_QUIRK_BLIT                   0x00200000
+#define WINED3D_CX_QUIRK_RENDER_TO_FBO          0x00800000
+#define WINED3D_QUIRK_NO_DXTN                   0x01000000
+
+
 /* Texture format fixups */
 
 enum fixup_channel_source
@@ -269,6 +308,7 @@ struct wined3d_settings
     unsigned short pci_vendor_id;
     unsigned short pci_device_id;
     /* Memory tracking and object counting. */
+    unsigned int msaa_quality_levels;
     UINT64 emulated_textureram;
     char *logo;
     int allow_multisampling;
@@ -278,6 +318,14 @@ struct wined3d_settings
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+#if defined(STAGING_CSMT)
+    BOOL cs_multithreaded;
+    BOOL ignore_rt_map;
+#endif /* STAGING_CSMT */
+  BOOL override_vertex_constants;
+  int vertex_constants_number;
+  int user_quirks;
+
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -995,8 +1043,14 @@ struct wined3d_stream_info
     WORD use_map; /* MAX_ATTRIBS, 16 */
 };
 
+#if defined(STAGING_CSMT)
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
         UINT start_instance, UINT instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 DWORD get_flexible_vertex_size(DWORD d3dvtVertexType) DECLSPEC_HIDDEN;
 
 #define eps 1e-8f
@@ -1084,6 +1138,10 @@ struct wined3d_occlusion_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
+    DWORD samples;
+    BOOL started;
+#endif /* STAGING_CSMT */
 };
 
 union wined3d_gl_query_object
@@ -1119,11 +1177,49 @@ struct wined3d_timestamp_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+#if defined(STAGING_CSMT)
+    UINT64 timestamp;
 };
 
 void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 
+struct wined3d_fb_state
+{
+    struct wined3d_rendertarget_view **render_targets;
+    struct wined3d_rendertarget_view *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+#else  /* STAGING_CSMT */
+};
+
+void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
+void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
+
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1138,6 +1234,9 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state current_fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_swapchain *swapchain;
     struct wined3d_surface *current_rt;
@@ -1165,10 +1264,8 @@ struct wined3d_context
     DWORD lowest_disabled_stage : 4;    /* Max MAX_TEXTURES, 8 */
     DWORD rebind_fbo : 1;
     DWORD needs_set : 1;
-    DWORD hdc_is_private : 1;
-    DWORD hdc_has_format : 1;           /* only meaningful if hdc_is_private */
     DWORD update_shader_resource_bindings : 1;
-    DWORD padding : 15;
+    DWORD padding : 17;
     DWORD shader_update_mask;
     DWORD constant_update_mask;
     DWORD                   numbered_array_mask;
@@ -1186,7 +1283,6 @@ struct wined3d_context
     HGLRC restore_ctx;
     HDC restore_dc;
     int restore_pf;
-    HWND restore_pf_win;
     HGLRC                   glCtx;
     HWND                    win_handle;
     HDC                     hdc;
@@ -1237,12 +1333,17 @@ struct wined3d_context
     GLfloat                 fog_coord_value;
     GLfloat                 color[4], fogstart, fogend, fogcolor[4];
     GLuint                  dummy_arbfp_prog;
+#if defined(STAGING_CSMT)
+
+    GLenum                  offscreenBuffer;
+#else  /* STAGING_CSMT */
 };
 
 struct wined3d_fb_state
 {
     struct wined3d_rendertarget_view **render_targets;
     struct wined3d_rendertarget_view *depth_stencil;
+#endif /* STAGING_CSMT */
 };
 
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
@@ -1376,7 +1477,12 @@ void context_alloc_occlusion_query(struct wined3d_context *context,
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_device *device,
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void context_apply_fbo_state_blit(struct wined3d_context *context, GLenum target,
         struct wined3d_surface *render_target, struct wined3d_surface *depth_stencil, DWORD location) DECLSPEC_HIDDEN;
 void context_active_texture(struct wined3d_context *context, const struct wined3d_gl_info *gl_info,
@@ -1513,6 +1619,7 @@ enum wined3d_pci_device
     CARD_NVIDIA_GEFORCE_6800        = 0x0041,
     CARD_NVIDIA_GEFORCE_7400        = 0x01d8,
     CARD_NVIDIA_GEFORCE_7300        = 0x01d7, /* GeForce Go 7300 */
+    CARD_NVIDIA_GEFORCE_7300LE      = 0x01d1, /* GeForce 7300LE */
     CARD_NVIDIA_GEFORCE_7600        = 0x0391,
     CARD_NVIDIA_GEFORCE_7800GT      = 0x0092,
     CARD_NVIDIA_GEFORCE_8200        = 0x0849, /* Other PCI ID 0x084b */
@@ -1928,7 +2035,11 @@ struct wined3d_stream_state
 struct wined3d_state
 {
     DWORD flags;
+#if defined(STAGING_CSMT)
+    struct wined3d_fb_state fb;
+#else  /* STAGING_CSMT */
     const struct wined3d_fb_state *fb;
+#endif /* STAGING_CSMT */
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -1973,6 +2084,16 @@ struct wined3d_state
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+#if defined(STAGING_CSMT)
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
+#endif /* STAGING_CSMT */
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -2028,6 +2149,13 @@ struct wined3d_device
     struct wined3d_rendertarget_view *back_buffer_view;
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+#if defined(STAGING_CSMT)
+    struct wined3d_rendertarget_view *auto_depth_stencil_view;
+
+    struct list             resources; /* a linked list to track resources created by the device */
+    struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
+    struct wine_rb_tree samplers;
+#else  /* STAGING_CSMT */
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
@@ -2037,6 +2165,7 @@ struct wined3d_device
     struct wined3d_fb_state fb;
     struct wined3d_surface *onscreen_depth_stencil;
     struct wined3d_rendertarget_view *auto_depth_stencil_view;
+#endif /* STAGING_CSMT */
 
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
@@ -2047,7 +2176,9 @@ struct wined3d_device
     UINT                    xScreenSpace;
     UINT                    yScreenSpace;
     UINT                    cursorWidth, cursorHeight;
+#if !defined(STAGING_CSMT)
     struct wined3d_texture *cursor_texture;
+#endif /* STAGING_CSMT */
     HCURSOR                 hardwareCursor;
 
     /* The Wine logo texture */
@@ -2079,9 +2210,23 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
         struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2090,6 +2235,13 @@ static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD sta
     return context->isStateDirty[idx] & (1 << shift);
 }
 
+static inline void context_invalidate_active_texture(struct wined3d_context *context)
+{
+    DWORD sampler = context->rev_tex_unit_map[context->active_texture];
+    if (sampler != WINED3D_UNMAPPED_STAGE)
+        context_invalidate_state(context, STATE_SAMPLER(sampler));
+}
+
 #define WINED3D_RESOURCE_ACCESS_GPU     0x1
 #define WINED3D_RESOURCE_ACCESS_CPU     0x2
 
@@ -2098,6 +2250,11 @@ struct wined3d_resource_ops
     ULONG (*resource_incref)(struct wined3d_resource *resource);
     ULONG (*resource_decref)(struct wined3d_resource *resource);
     void (*resource_unload)(struct wined3d_resource *resource);
+#if defined(STAGING_CSMT)
+    void (*resource_location_invalidated)(struct wined3d_resource *resource, DWORD location);
+    void (*resource_load_location)(struct wined3d_resource *resource,
+            struct wined3d_context *context, DWORD location);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_resource
@@ -2120,8 +2277,19 @@ struct wined3d_resource
     UINT depth;
     UINT size;
     DWORD priority;
+#if defined(STAGING_CSMT)
+    void *heap_memory, *map_heap_memory, *user_memory, *bitmap_data;
+    UINT custom_row_pitch, custom_slice_pitch;
+    struct wined3d_gl_bo *buffer, *map_buffer;
+    struct list resource_list_entry;
+    DWORD locations;
+    LONG access_fence;
+    BOOL unmap_dirtify;
+#else  /* STAGING_CSMT */
     void *heap_memory;
+    UINT custom_row_pitch, custom_slice_pitch;
     struct list resource_list_entry;
+#endif /* STAGING_CSMT */
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2146,6 +2314,54 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
         void *parent, const struct wined3d_parent_ops *parent_ops,
         const struct wined3d_resource_ops *resource_ops) DECLSPEC_HIDDEN;
 void resource_unload(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+DWORD wined3d_resource_access_from_location(DWORD location) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_changed(struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box) DECLSPEC_HIDDEN;
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_free_bo(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
+GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource, DWORD location) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_is_offscreen(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_map(struct wined3d_resource *resource, struct wined3d_map_desc *map_desc,
+        const struct wined3d_box *box, DWORD flags) DECLSPEC_HIDDEN;
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_update_draw_binding(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_validate_location(struct wined3d_resource *resource, DWORD location) DECLSPEC_HIDDEN;
+
+static inline void wined3d_resource_inc_fence(struct wined3d_resource *resource)
+{
+    InterlockedIncrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_dec_fence(struct wined3d_resource *resource)
+{
+    InterlockedDecrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_wait_fence(struct wined3d_resource *resource)
+{
+    while(InterlockedCompareExchange(&resource->access_fence, 0, 0));
+}
+#else  /* STAGING_CSMT */
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
@@ -2153,6 +2369,7 @@ GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_is_offscreen(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
 void wined3d_resource_update_draw_binding(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 /* Tests show that the start address of resources is 32 byte aligned */
 #define RESOURCE_ALIGNMENT 16
@@ -2237,6 +2454,9 @@ static inline struct gl_texture *wined3d_texture_get_gl_texture(struct wined3d_t
 
 void wined3d_texture_apply_sampler_desc(struct wined3d_texture *texture,
         const struct wined3d_sampler_desc *sampler_desc, const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void wined3d_texture_bind(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
@@ -2270,10 +2490,16 @@ struct wined3d_volume
     struct wined3d_resource resource;
     struct wined3d_texture *container;
 
+#if defined(STAGING_CSMT)
+    DWORD flags;
+    GLint texture_level;
+    DWORD download_count;
+#else  /* STAGING_CSMT */
     DWORD flags, locations;
     GLint texture_level;
     DWORD download_count;
     GLuint pbo;
+#endif /* STAGING_CSMT */
 };
 
 static inline struct wined3d_volume *volume_from_resource(struct wined3d_resource *resource)
@@ -2281,11 +2507,24 @@ static inline struct wined3d_volume *volume_from_resource(struct wined3d_resourc
     return CONTAINING_RECORD(resource, struct wined3d_volume, resource);
 }
 
+#if defined(STAGING_CSMT)
+HRESULT wined3d_volume_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
+        unsigned int level, struct wined3d_volume **volume) DECLSPEC_HIDDEN;
+void wined3d_volume_destroy(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
+void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context,
+        BOOL srgb_mode) DECLSPEC_HIDDEN;
+void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
+        const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
+
+struct wined3d_surface_dib
+{
+    HBITMAP DIBsection;
+#else  /* STAGING_CSMT */
 BOOL volume_prepare_system_memory(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
 HRESULT wined3d_volume_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
         unsigned int level, struct wined3d_volume **volume) DECLSPEC_HIDDEN;
 void wined3d_volume_destroy(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
-void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch, UINT *slice_pitch) DECLSPEC_HIDDEN;
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context,
         BOOL srgb_mode) DECLSPEC_HIDDEN;
 void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location) DECLSPEC_HIDDEN;
@@ -2297,6 +2536,7 @@ struct wined3d_surface_dib
 {
     HBITMAP DIBsection;
     void *bitmap_data;
+#endif /* STAGING_CSMT */
     UINT bitmap_size;
 };
 
@@ -2322,7 +2562,11 @@ struct fbo_entry
 struct wined3d_surface_ops
 {
     HRESULT (*surface_private_setup)(struct wined3d_surface *surface);
+#if defined(STAGING_CSMT)
+    void (*surface_frontbuffer_updated)(struct wined3d_surface *surface);
+#else  /* STAGING_CSMT */
     void (*surface_unmap)(struct wined3d_surface *surface);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_surface
@@ -2330,17 +2574,25 @@ struct wined3d_surface
     struct wined3d_resource resource;
     const struct wined3d_surface_ops *surface_ops;
     struct wined3d_texture *container;
+#if defined(STAGING_CSMT)
+
+    DWORD flags;
+
+    UINT pow2Width;
+    UINT pow2Height;
+
+#else  /* STAGING_CSMT */
     void *user_memory;
     DWORD locations;
 
     DWORD flags;
 
-    UINT pitch;
     UINT pow2Width;
     UINT pow2Height;
 
     /* PBO */
     GLuint                    pbo;
+#endif /* STAGING_CSMT */
     GLuint rb_multisample;
     GLuint rb_resolved;
     GLenum texture_target;
@@ -2384,12 +2636,19 @@ HRESULT surface_color_fill(struct wined3d_surface *s,
 GLenum surface_get_gl_buffer(const struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
         unsigned int *width, unsigned int *height) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
+void surface_load_ds_location(struct wined3d_surface *surface,
+        struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 void surface_invalidate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 void surface_load(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
 void surface_load_ds_location(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
 HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_prepare_rb(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info, BOOL multisample) DECLSPEC_HIDDEN;
@@ -2401,6 +2660,26 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info, void *mem, unsigned int pitch) DECLSPEC_HIDDEN;
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
         struct wined3d_surface *src_surface, const RECT *src_rect) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT wined3d_surface_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
+        GLenum target, unsigned int level, unsigned int layer, DWORD flags,
+        struct wined3d_surface **surface) DECLSPEC_HIDDEN;
+void wined3d_surface_destroy(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_format *format, const RECT *src_rect, UINT src_pitch, const POINT *dst_point,
+        BOOL srgb, const struct wined3d_const_bo_address *data) DECLSPEC_HIDDEN;
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect) DECLSPEC_HIDDEN;
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_getdc_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_releasedc_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+
+void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
+        const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void surface_flip(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 void surface_validate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 HRESULT wined3d_surface_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
         GLenum target, unsigned int level, unsigned int layer, DWORD flags,
@@ -2414,6 +2693,7 @@ void wined3d_surface_upload_data(struct wined3d_surface *surface, const struct w
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
 void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 /* Surface flags: */
 #define SFLAG_DIBSECTION        0x00000001 /* Has a DIB section attached for GetDC. */
@@ -2461,6 +2741,10 @@ struct wined3d_vertex_declaration
     BOOL half_float_conv_needed;
 };
 
+#if defined(STAGING_CSMT)
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+
+#endif /* STAGING_CSMT */
 struct wined3d_saved_states
 {
     DWORD transform[(HIGHEST_TRANSFORMSTATE >> 5) + 1];
@@ -2528,6 +2812,58 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
+void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
+
+struct wined3d_cs_list
+{
+    struct list blocks;
+};
+
+#define WINED3D_CS_QUEUE_SIZE 0x100000
+#define WINED3D_CS_SPIN_COUNT 10000000
+
+struct wined3d_cs_queue
+{
+    LONG head, tail;
+    BYTE data[WINED3D_CS_QUEUE_SIZE];
+};
+
+struct wined3d_cs_ops
+{
+    void *(*require_space)(struct wined3d_cs *cs, size_t size);
+    void *(*require_space_prio)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs, size_t size);
+    void (*submit_prio)(struct wined3d_cs *cs, size_t size);
+    void (*finish)(struct wined3d_cs *cs);
+    void (*finish_prio)(struct wined3d_cs *cs);
+};
+
+struct wined3d_cs
+{
+    const struct wined3d_cs_ops *ops;
+    struct wined3d_device *device;
+    struct wined3d_state state;
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_surface *onscreen_depth_stencil;
+
+    struct wined3d_cs_queue queue, prio_queue;
+
+    LONG pending_presents;
+    struct list query_poll_list;
+
+    HANDLE event;
+    BOOL waiting_for_event;
+};
+
+struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
+void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
         DWORD flags) DECLSPEC_HIDDEN;
@@ -2552,6 +2888,7 @@ struct wined3d_cs
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -2601,6 +2938,67 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register, const float *constants,
+        UINT vector4f_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs,
+        GLenum primitive_type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, const struct wined3d_color *color) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_get_data(struct wined3d_cs *cs, struct wined3d_query *query, void *data,
+        UINT data_size, DWORD flags, HRESULT *ret) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src,
+        const RECT *src_rect, struct wined3d_surface *dst, const POINT *dst_point) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        BYTE *mem) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_view_destroy(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs,
+        struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_getdc(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_releasedc(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 /* Direct3D terminology with little modifications. We do not have an issued state
  * because only the driver knows about it, but we have a created state because d3d
@@ -2615,7 +3013,12 @@ enum query_state {
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
+#if defined(STAGING_CSMT)
+    BOOL (*query_poll)(struct wined3d_query *query);
+    BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
+#else  /* STAGING_CSMT */
     HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_query
@@ -2629,8 +3032,17 @@ struct wined3d_query
     enum wined3d_query_type type;
     DWORD data_size;
     void                     *extendedData;
+#if defined(STAGING_CSMT)
+
+    LONG                     counter_main, counter_retrieved;
+    struct list              poll_list_entry;
 };
 
+void wined3d_query_destroy(struct wined3d_query *query) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
+};
+#endif /* STAGING_CSMT */
+
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
 enum wined3d_buffer_conversion_type
@@ -2656,6 +3068,9 @@ struct wined3d_buffer
     GLenum buffer_object_usage;
     GLenum buffer_type_hint;
     DWORD flags;
+#if defined(STAGING_CSMT)
+    BOOL ignore_discard;
+#endif /* STAGING_CSMT */
     void *map_ptr;
 
     struct wined3d_map_range *maps;
@@ -2680,7 +3095,15 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
 BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void buffer_invalidate_bo_range(struct wined3d_buffer *This, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
+void buffer_create_buffer_object(struct wined3d_buffer *This,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+#else  /* STAGING_CSMT */
 void buffer_mark_used(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 struct wined3d_rendertarget_view
 {
@@ -2718,6 +3141,10 @@ static inline struct wined3d_surface *wined3d_rendertarget_view_get_surface(
     return surface_from_resource(resource);
 }
 
+#if defined(STAGING_CSMT)
+void wined3d_rendertarget_view_destroy(struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
+
+#endif /* STAGING_CSMT */
 struct wined3d_shader_resource_view
 {
     LONG refcount;
@@ -2730,7 +3157,12 @@ struct wined3d_shader_resource_view
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain, const RECT *src_rect,
+#if defined(STAGING_CSMT)
+            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags,
+            struct wined3d_surface *depth_stencil);
+#else  /* STAGING_CSMT */
             const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags);
+#endif /* STAGING_CSMT */
 };
 
 struct wined3d_swapchain
@@ -2770,6 +3202,10 @@ void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HI
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 /*****************************************************************************
  * Utility function prototypes
@@ -2984,6 +3420,9 @@ unsigned int shader_find_free_input_register(const struct wined3d_shader_reg_map
 void shader_generate_main(const struct wined3d_shader *shader, struct wined3d_shader_buffer *buffer,
         const struct wined3d_shader_reg_maps *reg_maps, const DWORD *byte_code, void *backend_ctx) DECLSPEC_HIDDEN;
 BOOL shader_match_semantic(const char *semantic_name, enum wined3d_decl_usage usage) DECLSPEC_HIDDEN;
+#if defined(STAGING_CSMT)
+void shader_cleanup(struct wined3d_shader *shader) DECLSPEC_HIDDEN;
+#endif /* STAGING_CSMT */
 
 static inline BOOL shader_is_scalar(const struct wined3d_shader_register *reg)
 {
@@ -3209,6 +3648,9 @@ static inline void context_apply_state(struct wined3d_context *context,
     state_table[rep].apply(context, state, rep);
 }
 
+BOOL wined3d_dxtn_init(void) DECLSPEC_HIDDEN;
+void wined3d_dxtn_free(void) DECLSPEC_HIDDEN;
+
 /* The WNDCLASS-Name for the fake window which we use to retrieve the GL capabilities */
 #define WINED3D_OPENGL_WINDOW_CLASS_NAME "WineD3D_OpenGL"
 
diff --git a/dlls/winemac.drv/cocoa_app.m b/dlls/winemac.drv/cocoa_app.m
index 82925c8..9d0af0d 100644
--- a/dlls/winemac.drv/cocoa_app.m
+++ b/dlls/winemac.drv/cocoa_app.m
@@ -705,11 +705,12 @@ - (CGDisplayModeRef)modeMatchingMode:(CGDisplayModeRef)mode forDisplay:(CGDirect
         NSDictionary* options = nil;
 
 #if defined(MAC_OS_X_VERSION_10_8) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+#ifdef  kCGDisplayShowDuplicateLowResolutionModes     
         if (&kCGDisplayShowDuplicateLowResolutionModes != NULL)
             options = [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:TRUE]
                                                   forKey:(NSString*)kCGDisplayShowDuplicateLowResolutionModes];
 #endif
-
+#endif
         NSArray *modes = [(NSArray*)CGDisplayCopyAllDisplayModes(displayID, (CFDictionaryRef)options) autorelease];
         for (id candidateModeObject in modes)
         {
diff --git a/dlls/winemac.drv/cocoa_window.m b/dlls/winemac.drv/cocoa_window.m
index f68a1c5..33eb5c5 100644
--- a/dlls/winemac.drv/cocoa_window.m
+++ b/dlls/winemac.drv/cocoa_window.m
@@ -197,8 +197,6 @@ @interface WineWindow ()
 
 @property (readonly, copy, nonatomic) NSArray* childWineWindows;
 
-    - (void) updateColorSpace;
-
     - (BOOL) becameEligibleParentOrChild;
     - (void) becameIneligibleChild;
 
@@ -333,15 +331,12 @@ - (void) addGLContext:(WineOpenGLContext*)context
             [pendingGlContexts addObject:context];
             [self setNeedsDisplay:YES];
         }
-
-        [(WineWindow*)[self window] updateColorSpace];
     }
 
     - (void) removeGLContext:(WineOpenGLContext*)context
     {
         [glContexts removeObjectIdenticalTo:context];
         [pendingGlContexts removeObjectIdenticalTo:context];
-        [(WineWindow*)[self window] updateColorSpace];
     }
 
     - (void) updateGLContexts
@@ -350,11 +345,6 @@ - (void) updateGLContexts
             context.needsUpdate = TRUE;
     }
 
-    - (BOOL) hasGLContext
-    {
-        return [glContexts count] || [pendingGlContexts count];
-    }
-
     - (BOOL) acceptsFirstMouse:(NSEvent*)theEvent
     {
         return YES;
@@ -1360,9 +1350,6 @@ - (void) setFrameFromWine:(NSRect)contentRect
                 if (needEnableScreenUpdates)
                     NSEnableScreenUpdates();
 
-                if (!equalSizes)
-                    [self updateColorSpace];
-
                 if (!enteringFullScreen &&
                     [[NSProcessInfo processInfo] systemUptime] - enteredFullScreenTime > 1.0)
                     nonFullscreenFrame = frame;
@@ -1744,38 +1731,6 @@ - (NSArray*) childWineWindows
         return [childWindows objectsAtIndexes:indexes];
     }
 
-    // We normally use the generic/calibrated RGB color space for the window,
-    // rather than the device color space, to avoid expensive color conversion
-    // which slows down drawing.  However, for windows displaying OpenGL, having
-    // a different color space than the screen greatly reduces frame rates, often
-    // limiting it to the display refresh rate.
-    //
-    // To avoid this, we switch back to the screen color space whenever the
-    // window is covered by a view with an attached OpenGL context.
-    - (void) updateColorSpace
-    {
-        NSRect contentRect = [[self contentView] frame];
-        BOOL coveredByGLView = FALSE;
-        for (WineContentView* view in [[self contentView] subviews])
-        {
-            if ([view hasGLContext])
-            {
-                NSRect frame = [view convertRect:[view bounds] toView:nil];
-                if (NSContainsRect(frame, contentRect))
-                {
-                    coveredByGLView = TRUE;
-                    break;
-                }
-            }
-        }
-
-        if (coveredByGLView)
-            [self setColorSpace:nil];
-        else
-            [self setColorSpace:[NSColorSpace genericRGBColorSpace]];
-    }
-
-
     /*
      * ---------- NSResponder method overrides ----------
      */
@@ -2683,7 +2638,6 @@ macdrv_view macdrv_create_view(macdrv_window w, CGRect rect)
                    name:NSApplicationDidChangeScreenParametersNotification
                  object:NSApp];
         [[window contentView] addSubview:view];
-        [window updateColorSpace];
     });
 
     [pool release];
@@ -2702,7 +2656,6 @@ void macdrv_dispose_view(macdrv_view v)
 
     OnMainThread(^{
         NSNotificationCenter* nc = [NSNotificationCenter defaultCenter];
-        WineWindow* window = (WineWindow*)[view window];
 
         [nc removeObserver:view
                       name:NSViewGlobalFrameDidChangeNotification
@@ -2712,7 +2665,6 @@ void macdrv_dispose_view(macdrv_view v)
                     object:NSApp];
         [view removeFromSuperview];
         [view release];
-        [window updateColorSpace];
     });
 
     [pool release];
@@ -2737,15 +2689,11 @@ void macdrv_set_view_window_and_frame(macdrv_view v, macdrv_window w, CGRect rec
         BOOL changedWindow = (window && window != [view window]);
         NSRect newFrame = NSRectFromCGRect(rect);
         NSRect oldFrame = [view frame];
-        BOOL needUpdateWindowColorSpace = FALSE;
 
         if (changedWindow)
         {
-            WineWindow* oldWindow = (WineWindow*)[view window];
             [view removeFromSuperview];
-            [oldWindow updateColorSpace];
             [[window contentView] addSubview:view];
-            needUpdateWindowColorSpace = TRUE;
         }
 
         if (!NSEqualRects(oldFrame, newFrame))
@@ -2759,11 +2707,8 @@ void macdrv_set_view_window_and_frame(macdrv_view v, macdrv_window w, CGRect rec
             else
                 [view setFrame:newFrame];
             [view setNeedsDisplay:YES];
-            needUpdateWindowColorSpace = TRUE;
         }
 
-        if (needUpdateWindowColorSpace)
-            [(WineWindow*)[view window] updateColorSpace];
     });
 
     [pool release];
diff --git a/dlls/winemac.drv/display.c b/dlls/winemac.drv/display.c
index 10ecf67..1bed777 100644
--- a/dlls/winemac.drv/display.c
+++ b/dlls/winemac.drv/display.c
@@ -25,6 +25,7 @@
 #include "winuser.h"
 #include "winreg.h"
 #include "ddrawi.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(display);
 
@@ -287,6 +288,7 @@ static CFArrayRef copy_display_modes(CGDirectDisplayID display)
     CFArrayRef modes = NULL;
 
 #if defined(MAC_OS_X_VERSION_10_8) && MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_8
+#ifdef kCGDisplayShowDuplicateLowResolutionModes
     if (&kCGDisplayShowDuplicateLowResolutionModes != NULL &&
         CGDisplayModeGetPixelWidth != NULL && CGDisplayModeGetPixelHeight != NULL)
     {
@@ -390,6 +392,7 @@ static CFArrayRef copy_display_modes(CGDirectDisplayID display)
     }
     else
 #endif
+#endif
         modes = CGDisplayCopyAllDisplayModes(display, NULL);
 
     return modes;
@@ -410,9 +413,9 @@ LONG CDECL macdrv_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
     struct macdrv_display *displays;
     int num_displays;
     CFArrayRef display_modes;
-    CFIndex count, i, safe, best;
+    CFIndex count, i, safe, best = 0;
     CGDisplayModeRef best_display_mode;
-    uint32_t best_io_flags;
+    uint32_t best_io_flags = 0;
 
     TRACE("%s %p %p 0x%08x %p\n", debugstr_w(devname), devmode, hwnd, flags, lpvoid);
 
@@ -669,7 +672,7 @@ BOOL CDECL macdrv_EnumDisplaySettingsEx(LPCWSTR devname, DWORD mode,
     struct macdrv_display *displays = NULL;
     int num_displays;
     CGDisplayModeRef display_mode;
-    int display_mode_bpp;
+    int display_mode_bpp = 24;
     BOOL synthesized = FALSE;
     double rotation;
     uint32_t io_flags;
@@ -935,11 +938,12 @@ done:
  */
 BOOL CDECL macdrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info)
 {
-    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 };
+    static const WCHAR adapter_name[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0 }; /* CrossOver Hack 11692 */
     struct macdrv_display *displays;
     int num_displays;
     CGDirectDisplayID display_id;
     int i;
+  BOOL unique_monitor_names = TRUE;
 
     TRACE("%p, %p\n", monitor, info);
 
@@ -965,10 +969,13 @@ BOOL CDECL macdrv_GetMonitorInfo(HMONITOR monitor, LPMONITORINFO info)
         info->dwFlags = (i == 0) ? MONITORINFOF_PRIMARY : 0;
 
         if (info->cbSize >= sizeof(MONITORINFOEXW))
-            lstrcpyW(((MONITORINFOEXW*)info)->szDevice, adapter_name);
+            /* CrossOver Hack 11692: Unique device names from GetMonitorInfo */
+            snprintfW(((MONITORINFOEXW*)info)->szDevice, sizeof(((MONITORINFOEXW*)info)->szDevice) / sizeof(WCHAR),
+                      adapter_name, unique_monitor_names ? i + 1 : 1);
 
-        TRACE(" -> rcMonitor %s rcWork %s dwFlags %08x\n", wine_dbgstr_rect(&info->rcMonitor),
-              wine_dbgstr_rect(&info->rcWork), info->dwFlags);
+        TRACE(" -> rcMonitor %s rcWork %s dwFlags %08x szDevice %s\n", wine_dbgstr_rect(&info->rcMonitor),
+              wine_dbgstr_rect(&info->rcWork), info->dwFlags,
+              info->cbSize >= sizeof(MONITORINFOEXW) ? debugstr_w(((MONITORINFOEXW*)info)->szDevice) : "n/a");
     }
     else
     {
diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index dad4a7a..6dd83e8 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -148,6 +148,7 @@ static HANDLE X11DRV_CLIPBOARD_ImportImageBmp(Display *d, Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportXAString(Display *d, Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportUTF8(Display *d, Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportCompoundText(Display *d, Window w, Atom prop);
+static HANDLE X11DRV_CLIPBOARD_ImportTextHtml(Display *display, Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ImportTextUriList(Display *display, Window w, Atom prop);
 static HANDLE X11DRV_CLIPBOARD_ExportClipboardData(Display *display, Window requestor, Atom aTarget,
     Atom rprop, LPWINE_CLIPDATA lpData, LPDWORD lpBytes);
@@ -343,10 +344,11 @@ void X11DRV_InitClipboard(void)
         X11DRV_CLIPBOARD_InsertClipboardFormat( RegisterClipboardFormatW(PropertyFormatMap[i].lpszFormat),
                                                 GET_ATOM(PropertyFormatMap[i].prop));
 
-    /* Set up a conversion function from "HTML Format" to "text/html" */
+    /* Set up a conversion function between "HTML Format" and "text/html" */
     format = X11DRV_CLIPBOARD_InsertClipboardFormat( RegisterClipboardFormatW(wszHTMLFormat),
                                                      GET_ATOM(XATOM_text_html));
     format->lpDrvExportFunc = X11DRV_CLIPBOARD_ExportTextHtml;
+    format->lpDrvImportFunc = X11DRV_CLIPBOARD_ImportTextHtml;
 }
 
 
@@ -1568,6 +1570,206 @@ static HANDLE X11DRV_CLIPBOARD_ImportEnhMetaFile(Display *display, Window w, Ato
 }
 
 
+static char* read_and_standardize_text_html(Display *display, Window w, Atom prop)
+{
+    BOOL needHtmlTag = FALSE, needBodyTag = FALSE;
+    char *textHtml, *dst, *fullHtml = NULL;
+    unsigned long textHtmlLen;
+    int startOfMarkup = 0;
+
+    if (!X11DRV_CLIPBOARD_ReadProperty(display, w, prop, (LPBYTE*)&textHtml, &textHtmlLen))
+        return 0;
+
+    /* Firefox uses UTF-16LE with byte order mark. Convert to UTF-8 without the BOM. */
+    if (textHtmlLen >= 2 && ((BYTE*)textHtml)[0] == 0xff && ((BYTE*)textHtml)[1] == 0xfe)
+    {
+        char *textHtmlUtf8;
+        INT size = WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)&textHtml[2], (textHtmlLen-2)/sizeof(WCHAR),
+                                       NULL, 0, NULL, NULL);
+        textHtmlUtf8 = HeapAlloc(GetProcessHeap(), 0, size);
+        if (!textHtmlUtf8)
+        {
+            ERR("out of memory\n");
+            goto end;
+        }
+
+        WideCharToMultiByte(CP_UTF8, 0, (LPCWSTR)&textHtml[2], (textHtmlLen-2)/sizeof(WCHAR),
+                            textHtmlUtf8, size, NULL, NULL);
+        HeapFree(GetProcessHeap(), 0, textHtml);
+
+        textHtml = textHtmlUtf8;
+        textHtmlLen = size;
+    }
+
+    /* Strip trailing null characters. */
+    while (textHtmlLen > 0 && textHtml[textHtmlLen-1] == '\0')
+        textHtmlLen--;
+
+    /* While HTML fragments are supposed to be valid in Windows, some apps only want
+     * to paste a complete HTML document. So if we got an HTML fragment, complete it. */
+    if (textHtmlLen >= 7 && strncasecmp(&textHtml[textHtmlLen - 7], "</HTML>", 7))
+    {
+        int i;
+        needHtmlTag = TRUE;
+        needBodyTag = TRUE;
+        for (i = textHtmlLen - 7; i > 0; i--)
+        {
+            if (!strncasecmp(&textHtml[i], "</BODY>", 7))
+            {
+                needBodyTag = FALSE;
+                break;
+            }
+        }
+
+        for (startOfMarkup = 0; startOfMarkup < textHtmlLen; startOfMarkup++)
+        {
+            if (isspace(textHtml[startOfMarkup]))
+                continue;
+            else if (textHtml[startOfMarkup] != '<')
+                break;
+            else if (startOfMarkup + 1 < textHtmlLen && (textHtml[startOfMarkup + 1] == '!' ||
+                                                         textHtml[startOfMarkup + 1] == '/'))
+            {
+                char *pos = memchr(&textHtml[startOfMarkup + 1], '>', textHtmlLen - startOfMarkup - 1);
+                if (!pos) break;
+                startOfMarkup = pos - textHtml;
+                continue;
+            }
+            else
+                break;
+        }
+        if (startOfMarkup >= textHtmlLen) startOfMarkup = 0;
+    }
+
+    fullHtml = HeapAlloc(GetProcessHeap(), 0, textHtmlLen + (needBodyTag ? (6 + 7) : 0) +
+                                                            (needHtmlTag ? (6 + 7) : 0) + 1);
+    if (fullHtml)
+    {
+        dst = fullHtml;
+        memcpy(dst, textHtml, startOfMarkup);
+        dst += startOfMarkup;
+        if (needHtmlTag)
+        {
+            memcpy(dst, "<HTML>", 6);
+            dst += 6;
+        }
+        if (needBodyTag)
+        {
+            memcpy(dst, "<BODY>", 6);
+            dst += 6;
+        }
+        memcpy(dst, &textHtml[startOfMarkup], textHtmlLen - startOfMarkup);
+        dst += textHtmlLen - startOfMarkup;
+        if (needBodyTag)
+        {
+            memcpy(dst, "</BODY>", 7);
+            dst += 7;
+        }
+        if (needHtmlTag)
+        {
+            memcpy(dst, "</HTML>", 7);
+            dst += 7;
+        }
+        *dst = '\0';
+    }
+    else
+        ERR("out of memory\n");
+
+end:
+    HeapFree(GetProcessHeap(), 0, textHtml);
+    return fullHtml;
+}
+
+
+/**************************************************************************
+ *      X11DRV_CLIPBOARD_ImportTextHtml
+ *
+ *  Import text/html into "HTML Format".
+ */
+static HANDLE X11DRV_CLIPBOARD_ImportTextHtml(Display *display, Window w, Atom prop)
+{
+    static const char startFragment[] = "<!--StartFragment -->";
+    static const char endFragment[]   = "<!--EndFragment -->";
+    int i, bodyStart = -1, bodyEnd = -1;
+    HGLOBAL hClipData = NULL;
+    char *textHtml = NULL;
+    char description[256];
+
+    textHtml = read_and_standardize_text_html(display, w, prop);
+    if (textHtml == NULL)
+        goto end;
+
+    /* find <BODY> tag */
+    for (i = 0; textHtml[i]; i++)
+    {
+        if (strncasecmp(&textHtml[i], "<BODY>", 6) == 0)
+        {
+            bodyStart = i + 6;
+            break;
+        }
+    }
+    if (bodyStart < 0)
+    {
+        ERR("HTML doesn't have <BODY>\n");
+        goto end;
+    }
+
+    /* find </BODY> tag */
+    for (i = strlen(textHtml) - 7; i >= bodyStart; i--)
+    {
+        if (strncasecmp(&textHtml[i], "</BODY>", 7) == 0)
+        {
+            bodyEnd = i;
+            break;
+        }
+    }
+    if (bodyEnd < 0)
+    {
+        ERR("HTML doesn't have </BODY>\n");
+        goto end;
+    }
+
+    snprintf(description, sizeof(description),
+            "Version:0.9\n"         /* 12 */
+            "StartHTML:%010u\n"     /* 21 */
+            "EndHTML:%010u\n"       /* 19 */
+            "StartFragment:%010u\n" /* 25 */
+            "EndFragment:%010u\n",  /* 23 */
+            100,
+            100 + (UINT)(strlen(textHtml) + strlen(startFragment) + strlen(endFragment)),
+            100 + (UINT)(bodyStart + strlen(startFragment)),
+            100 + (UINT)(strlen(startFragment) + bodyEnd));
+
+    hClipData = GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, strlen(description) +
+                            strlen(textHtml) + strlen(startFragment) + strlen(endFragment) + 1);
+    if (hClipData)
+    {
+        char *dst, *htmlFormat;
+        dst = htmlFormat = GlobalLock(hClipData);
+        strcpy(dst, description);
+        dst += strlen(description);
+        memcpy(dst, textHtml, bodyStart);
+        dst += bodyStart;
+        memcpy(dst, startFragment, strlen(startFragment));
+        dst += strlen(startFragment);
+        memcpy(dst, &textHtml[bodyStart], bodyEnd - bodyStart);
+        dst += (bodyEnd - bodyStart);
+        memcpy(dst, endFragment, strlen(endFragment));
+        dst += strlen(endFragment);
+        memcpy(dst, &textHtml[bodyEnd], strlen(textHtml) - bodyEnd);
+        dst += (strlen(textHtml) - bodyEnd);
+        *dst = 0;
+        GlobalUnlock(hClipData);
+    }
+    else
+        ERR("out of memory\n");
+
+end:
+    HeapFree(GetProcessHeap(), 0, textHtml);
+    return hClipData;
+}
+
+
 /**************************************************************************
  *      X11DRV_CLIPBOARD_ImportTextUriList
  *
diff --git a/dlls/winex11.drv/event.c b/dlls/winex11.drv/event.c
index a1abfe7..bfa2a32 100644
--- a/dlls/winex11.drv/event.c
+++ b/dlls/winex11.drv/event.c
@@ -920,6 +920,7 @@ static void X11DRV_Expose( HWND hwnd, XEvent *xev )
 static void X11DRV_MapNotify( HWND hwnd, XEvent *event )
 {
     struct x11drv_win_data *data;
+    BOOL is_embedded;
 
     if (event->xany.window == x11drv_thread_data()->clip_window)
     {
@@ -934,7 +935,12 @@ static void X11DRV_MapNotify( HWND hwnd, XEvent *event )
         if (hwndFocus && IsChild( hwnd, hwndFocus ))
             set_input_focus( data );
     }
+
+    is_embedded = data->embedded;
     release_win_data( data );
+
+    if (is_embedded)
+        EnableWindow( hwnd, TRUE );
 }
 
 
@@ -943,8 +949,19 @@ static void X11DRV_MapNotify( HWND hwnd, XEvent *event )
  */
 static void X11DRV_UnmapNotify( HWND hwnd, XEvent *event )
 {
+    struct x11drv_win_data *data;
+    BOOL is_embedded;
+
     if (event->xany.window == x11drv_thread_data()->clip_window)
         clipping_cursor = FALSE;
+
+    if (!(data = get_win_data( hwnd ))) return;
+
+    is_embedded = data->embedded;
+    release_win_data( data );
+
+    if (is_embedded)
+        EnableWindow( hwnd, FALSE );
 }
 
 
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 5a7d316..68d3f96 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -440,6 +440,9 @@ static INT X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOID in_d
                     return TRUE;
                 }
                 break;
+            case X11DRV_FLUSH_GDI_DISPLAY:
+                XFlush( gdi_display );
+                return TRUE;
             default:
                 break;
             }
diff --git a/dlls/winex11.drv/mouse.c b/dlls/winex11.drv/mouse.c
index 3a11b41..e191d25 100644
--- a/dlls/winex11.drv/mouse.c
+++ b/dlls/winex11.drv/mouse.c
@@ -445,6 +445,8 @@ void reset_clipping_window(void)
     ClipCursor( NULL );  /* make sure the clip rectangle is reset too */
 }
 
+BOOL CDECL X11DRV_ClipCursor( LPCRECT clip );
+
 /***********************************************************************
  *             clip_cursor_notify
  *
@@ -452,7 +454,7 @@ void reset_clipping_window(void)
  */
 LRESULT clip_cursor_notify( HWND hwnd, HWND new_clip_hwnd )
 {
-    struct x11drv_thread_data *data = x11drv_thread_data();
+    struct x11drv_thread_data *data = x11drv_init_thread_data();
 
     if (hwnd == GetDesktopWindow())  /* change the clip window stored in the desktop process */
     {
@@ -473,12 +475,10 @@ LRESULT clip_cursor_notify( HWND hwnd, HWND new_clip_hwnd )
     }
     else if (hwnd == GetForegroundWindow())  /* request to clip */
     {
-        RECT clip, virtual_rect = get_virtual_screen_rect();
+        RECT clip;
 
         GetClipCursor( &clip );
-        if (clip.left > virtual_rect.left || clip.right < virtual_rect.right ||
-            clip.top > virtual_rect.top   || clip.bottom < virtual_rect.bottom)
-            return grab_clipping_window( &clip );
+        X11DRV_ClipCursor( &clip );
     }
     return 0;
 }
@@ -1390,22 +1390,22 @@ BOOL CDECL X11DRV_ClipCursor( LPCRECT clip )
     if (grab_pointer)
     {
         HWND foreground = GetForegroundWindow();
+        DWORD tid, pid;
+
+        /* forward request to the foreground window if it's in a different thread */
+        tid = GetWindowThreadProcessId( foreground, &pid );
+        if (tid && tid != GetCurrentThreadId() && pid == GetCurrentProcessId())
+        {
+            TRACE( "forwarding clip request to %p\n", foreground );
+            SendNotifyMessageW( foreground, WM_X11DRV_CLIP_CURSOR, 0, 0 );
+            return TRUE;
+        }
 
         /* we are clipping if the clip rectangle is smaller than the screen */
         if (clip->left > virtual_rect.left || clip->right < virtual_rect.right ||
             clip->top > virtual_rect.top || clip->bottom < virtual_rect.bottom)
         {
-            DWORD tid, pid;
-
-            /* forward request to the foreground window if it's in a different thread */
-            tid = GetWindowThreadProcessId( foreground, &pid );
-            if (tid && tid != GetCurrentThreadId() && pid == GetCurrentProcessId())
-            {
-                TRACE( "forwarding clip request to %p\n", foreground );
-                SendNotifyMessageW( foreground, WM_X11DRV_CLIP_CURSOR, 0, 0 );
-                return TRUE;
-            }
-            else if (grab_clipping_window( clip )) return TRUE;
+            if (grab_clipping_window( clip )) return TRUE;
         }
         else /* if currently clipping, check if we should switch to fullscreen clipping */
         {
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 7b8ba82..3612d8f 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -438,6 +438,7 @@ static int GLXErrorHandler(Display *dpy, XErrorEvent *event, void *arg)
 static BOOL X11DRV_WineGL_InitOpenglInfo(void)
 {
     static const char legacy_extensions[] = " WGL_EXT_extensions_string WGL_EXT_swap_control";
+    static const char direct_extension[] = " WINE_EXT_direct_rendering";
 
     int screen = DefaultScreen(gdi_display);
     Window win = 0, root = 0;
@@ -489,10 +490,13 @@ static BOOL X11DRV_WineGL_InitOpenglInfo(void)
     }
     gl_renderer = (const char *)opengl_funcs.gl.p_glGetString(GL_RENDERER);
     WineGLInfo.glVersion = (const char *) opengl_funcs.gl.p_glGetString(GL_VERSION);
+    WineGLInfo.glxDirect = pglXIsDirect(gdi_display, ctx);
     str = (const char *) opengl_funcs.gl.p_glGetString(GL_EXTENSIONS);
-    WineGLInfo.glExtensions = HeapAlloc(GetProcessHeap(), 0, strlen(str)+sizeof(legacy_extensions));
+    WineGLInfo.glExtensions = HeapAlloc(GetProcessHeap(), 0, strlen(str)+sizeof(legacy_extensions)+sizeof(direct_extension));
     strcpy(WineGLInfo.glExtensions, str);
     strcat(WineGLInfo.glExtensions, legacy_extensions);
+    if (WineGLInfo.glxDirect)
+        strcat(WineGLInfo.glExtensions, direct_extension);
 
     /* Get the common GLX version supported by GLX client and server ( major/minor) */
     pglXQueryVersion(gdi_display, &WineGLInfo.glxVersion[0], &WineGLInfo.glxVersion[1]);
@@ -506,7 +510,7 @@ static BOOL X11DRV_WineGL_InitOpenglInfo(void)
     WineGLInfo.glxClientExtensions = pglXGetClientString(gdi_display, GLX_EXTENSIONS);
 
     WineGLInfo.glxExtensions = pglXQueryExtensionsString(gdi_display, screen);
-    WineGLInfo.glxDirect = pglXIsDirect(gdi_display, ctx);
+
 
     TRACE("GL version             : %s.\n", WineGLInfo.glVersion);
     TRACE("GL renderer            : %s.\n", gl_renderer);
@@ -1947,18 +1951,16 @@ static BOOL glxdrv_wglShareLists(struct wgl_context *org, struct wgl_context *de
      * current or when it hasn't shared display lists before.
      */
 
-    if((org->has_been_current && dest->has_been_current) || dest->has_been_current)
-    {
-        ERR("Could not share display lists, one of the contexts has been current already !\n");
-        return FALSE;
-    }
-    else if(dest->sharing)
+    if(dest->sharing)
     {
         ERR("Could not share display lists because hglrc2 has already shared lists before\n");
         return FALSE;
     }
     else
     {
+        if(dest->has_been_current)
+            ERR("Recreating OpenGL context to share display lists, although the context has been current!\n");
+
         describeContext(org);
         describeContext(dest);
 
@@ -1983,6 +1985,9 @@ static void wglFinish(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+#if defined(STAGING_CSMT)
+    ERR("glFinish\n");
+#endif /* STAGING_CSMT */
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
@@ -2008,6 +2013,9 @@ static void wglFlush(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+#if defined(STAGING_CSMT)
+    ERR("glFlush\n");
+#endif /* STAGING_CSMT */
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 06e2294..6593fce 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -260,7 +260,7 @@ static unsigned long get_mwm_decorations( struct x11drv_win_data *data,
     if (data->shaped) return 0;
 
     if (ex_style & WS_EX_TOOLWINDOW) return 0;
-    if (ex_style & WS_EX_LAYERED) return 0;
+    if ((ex_style & (WS_EX_LAYERED | WS_EX_COMPOSITED)) == WS_EX_LAYERED) return 0;
 
     if ((style & WS_CAPTION) == WS_CAPTION)
     {
@@ -842,10 +842,8 @@ static void set_initial_wm_hints( Display *display, Window window )
     /* class hints */
     if ((class_hints = XAllocClassHint()))
     {
-        static char wine[] = "Wine";
-
         class_hints->res_name = process_name;
-        class_hints->res_class = wine;
+        class_hints->res_class = process_name;
         XSetClassHint( display, window, class_hints );
         XFree( class_hints );
     }
@@ -2320,7 +2318,8 @@ void CDECL X11DRV_WindowPosChanged( HWND hwnd, HWND insert_after, UINT swp_flags
             BOOL needs_map = TRUE;
 
             /* layered windows are mapped only once their attributes are set */
-            if (GetWindowLongW( hwnd, GWL_EXSTYLE ) & WS_EX_LAYERED) needs_map = data->layered;
+            if ((GetWindowLongW( hwnd, GWL_EXSTYLE ) & (WS_EX_LAYERED | WS_EX_COMPOSITED)) == WS_EX_LAYERED)
+                needs_map = data->layered;
             release_win_data( data );
             if (needs_icon) fetch_icon_data( hwnd, 0, 0 );
             if (needs_map) map_window( hwnd, new_style );
diff --git a/dlls/winex11.drv/winex11.drv.spec b/dlls/winex11.drv/winex11.drv.spec
index b6e5c05..2a0d737 100644
--- a/dlls/winex11.drv/winex11.drv.spec
+++ b/dlls/winex11.drv/winex11.drv.spec
@@ -53,6 +53,7 @@
 @ cdecl WindowPosChanging(long long long ptr ptr ptr ptr) X11DRV_WindowPosChanging
 @ cdecl WindowPosChanged(long long long ptr ptr ptr ptr ptr) X11DRV_WindowPosChanged
 @ cdecl SystemParametersInfo(long long ptr long) X11DRV_SystemParametersInfo
+@ cdecl UpdateCandidatePos(long ptr) X11DRV_UpdateCandidatePos
 
 # WinTab32
 @ cdecl AttachEventQueueToTablet(long) X11DRV_AttachEventQueueToTablet
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index da13c6e..9a2629d 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -275,7 +275,8 @@ enum x11drv_escape_codes
     X11DRV_GET_DRAWABLE,     /* get current drawable for a DC */
     X11DRV_START_EXPOSURES,  /* start graphics exposures */
     X11DRV_END_EXPOSURES,    /* end graphics exposures */
-    X11DRV_FLUSH_GL_DRAWABLE /* flush changes made to the gl drawable */
+    X11DRV_FLUSH_GL_DRAWABLE, /* flush changes made to the gl drawable */
+    X11DRV_FLUSH_GDI_DISPLAY /* flush the gdi display */
 };
 
 struct x11drv_escape_set_drawable
diff --git a/dlls/winex11.drv/xim.c b/dlls/winex11.drv/xim.c
index e0548b8..187323f 100644
--- a/dlls/winex11.drv/xim.c
+++ b/dlls/winex11.drv/xim.c
@@ -31,6 +31,7 @@
 #include "x11drv.h"
 #include "imm.h"
 #include "wine/debug.h"
+#include "wine/server.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(xim);
 
@@ -471,6 +472,48 @@ static BOOL X11DRV_DestroyIC(XIC xic, XPointer p, XPointer data)
     return TRUE;
 }
 
+/***********************************************************************
+ *           X11DRV_UpdateCandidatePos
+ */
+void X11DRV_UpdateCandidatePos( HWND hwnd, const RECT *caret_rect )
+{
+    if (ximStyle & XIMPreeditPosition)
+    {
+        struct x11drv_win_data *data;
+        HWND parent;
+
+        for (parent = hwnd; parent && parent != GetDesktopWindow(); parent = GetAncestor( parent, GA_PARENT ))
+        {
+            if (!(data = get_win_data( parent ))) continue;
+            if (data->xic)
+            {
+                XVaNestedList preedit;
+                XPoint xpoint;
+                POINT pt;
+
+                pt.x = caret_rect->left;
+                pt.y = caret_rect->bottom;
+
+                if (hwnd != data->hwnd)
+                    MapWindowPoints( hwnd, data->hwnd, &pt, 1 );
+
+                if (GetWindowLongW( data->hwnd, GWL_EXSTYLE ) & WS_EX_LAYOUTRTL)
+                    pt.x = data->client_rect.right - data->client_rect.left - 1 - pt.x;
+
+                xpoint.x = pt.x + data->client_rect.left - data->whole_rect.left;
+                xpoint.y = pt.y + data->client_rect.top - data->whole_rect.top;
+
+                preedit = XVaCreateNestedList( 0, XNSpotLocation, &xpoint, NULL );
+                if (preedit)
+                {
+                    XSetICValues( data->xic, XNPreeditAttributes, preedit, NULL );
+                    XFree( preedit );
+                }
+            }
+            release_win_data( data );
+        }
+    }
+}
 
 XIC X11DRV_CreateIC(XIM xim, struct x11drv_win_data *data)
 {
@@ -498,7 +541,7 @@ XIC X11DRV_CreateIC(XIM xim, struct x11drv_win_data *data)
                         XNDestroyCallback, &destroy,
                         NULL);
         data->xic = xic;
-        return xic;
+        goto return_xic;
     }
 
     /* create callbacks */
@@ -596,5 +639,32 @@ XIC X11DRV_CreateIC(XIM xim, struct x11drv_win_data *data)
     if (status != NULL)
         XFree(status);
 
+return_xic:
+    if (xic != NULL && (ximStyle & XIMPreeditPosition))
+    {
+        SERVER_START_REQ( set_caret_info )
+        {
+            req->flags  = 0;  /* don't set anything */
+            req->handle = 0;
+            req->x      = 0;
+            req->y      = 0;
+            req->hide   = 0;
+            req->state  = 0;
+            if (!wine_server_call_err( req ))
+            {
+                HWND hwnd;
+                RECT r;
+
+                hwnd      = wine_server_ptr_handle( reply->full_handle );
+                r.left    = reply->old_rect.left;
+                r.top     = reply->old_rect.top;
+                r.right   = reply->old_rect.right;
+                r.bottom  = reply->old_rect.bottom;
+                X11DRV_UpdateCandidatePos( hwnd, &r );
+            }
+        }
+        SERVER_END_REQ;
+    }
+
     return xic;
 }
diff --git a/dlls/winex11.drv/xinerama.c b/dlls/winex11.drv/xinerama.c
index 7e28726..ace84c5 100644
--- a/dlls/winex11.drv/xinerama.c
+++ b/dlls/winex11.drv/xinerama.c
@@ -30,6 +30,7 @@
 #include "wine/library.h"
 #include "x11drv.h"
 #include "wine/debug.h"
+#include "wine/unicode.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
 
@@ -43,6 +44,7 @@ static MONITORINFOEXW default_monitor =
     MONITORINFOF_PRIMARY,       /* dwFlags */
     { '\\','\\','.','\\','D','I','S','P','L','A','Y','1',0 }   /* szDevice */
 };
+static const WCHAR monitor_deviceW[] = { '\\','\\','.','\\','D','I','S','P','L','A','Y','%','d',0 };
 
 static MONITORINFOEXW *monitors;
 static int nb_monitors;
@@ -127,6 +129,8 @@ static int query_screens(void)
     if (monitors != &default_monitor) HeapFree( GetProcessHeap(), 0, monitors );
     if ((monitors = HeapAlloc( GetProcessHeap(), 0, count * sizeof(*monitors) )))
     {
+        int device = 2; /* 1 is reserved for primary */
+
         nb_monitors = count;
         for (i = 0; i < nb_monitors; i++)
         {
@@ -138,11 +142,15 @@ static int query_screens(void)
             monitors[i].dwFlags          = 0;
             if (!IntersectRect( &monitors[i].rcWork, &rc_work, &monitors[i].rcMonitor ))
                 monitors[i].rcWork = monitors[i].rcMonitor;
-            /* FIXME: using the same device name for all monitors for now */
-            lstrcpyW( monitors[i].szDevice, default_monitor.szDevice );
         }
 
         get_primary()->dwFlags |= MONITORINFOF_PRIMARY;
+
+        for (i = 0; i < nb_monitors; i++)
+        {
+            snprintfW( monitors[i].szDevice, sizeof(monitors[i].szDevice) / sizeof(WCHAR),
+                       monitor_deviceW, (monitors[i].dwFlags & MONITORINFOF_PRIMARY) ? 1 : device++ );
+        }
     }
     else count = 0;
 
diff --git a/dlls/wininet/dialogs.c b/dlls/wininet/dialogs.c
index bf4121b..46b876e 100644
--- a/dlls/wininet/dialogs.c
+++ b/dlls/wininet/dialogs.c
@@ -576,6 +576,15 @@ BOOL WINAPI InternetShowSecurityInfoByURLW(LPCWSTR url, HWND window)
 }
 
 /***********************************************************************
+ *           ParseX509EncodedCertificateForListBoxEntry (@)
+ */
+DWORD WINAPI ParseX509EncodedCertificateForListBoxEntry(LPBYTE cert, DWORD len, LPSTR szlistbox, LPDWORD listbox)
+{
+   FIXME("stub: %p %d %s %p\n", cert, len, debugstr_a(szlistbox), listbox);
+   return ERROR_CALL_NOT_IMPLEMENTED;
+}
+
+/***********************************************************************
  *           ShowX509EncodedCertificate (@)
  */
 DWORD WINAPI ShowX509EncodedCertificate(HWND parent, LPBYTE cert, DWORD len)
diff --git a/dlls/wininet/wininet.spec b/dlls/wininet/wininet.spec
index 3c4bf5a..c4bf442 100644
--- a/dlls/wininet/wininet.spec
+++ b/dlls/wininet/wininet.spec
@@ -216,7 +216,7 @@
 @ stdcall IsUrlCacheEntryExpiredA(str long ptr)
 @ stdcall IsUrlCacheEntryExpiredW(wstr long ptr)
 @ stdcall LoadUrlCacheContent()
-@ stub ParseX509EncodedCertificateForListBoxEntry
+@ stdcall ParseX509EncodedCertificateForListBoxEntry(ptr long str ptr)
 @ stdcall PrivacyGetZonePreferenceW(long long ptr ptr ptr)
 @ stdcall PrivacySetZonePreferenceW(long long long wstr)
 @ stdcall ReadUrlCacheEntryStream(ptr long ptr ptr long)
diff --git a/dlls/winmm/Makefile.in b/dlls/winmm/Makefile.in
index 3036526..0cf4b3c 100644
--- a/dlls/winmm/Makefile.in
+++ b/dlls/winmm/Makefile.in
@@ -1,7 +1,8 @@
 EXTRADEFS = -D_WINMM_
 MODULE    = winmm.dll
 IMPORTLIB = winmm
-IMPORTS   = uuid user32 advapi32 ole32 msacm32
+IMPORTS   = uuid user32 advapi32
+DELAYIMPORTS = ole32 msacm32
 
 C_SRCS = \
 	driver.c \
diff --git a/dlls/wpcap/Makefile.in b/dlls/wpcap/Makefile.in
index e44613f..aeef71a 100644
--- a/dlls/wpcap/Makefile.in
+++ b/dlls/wpcap/Makefile.in
@@ -1,6 +1,5 @@
 MODULE    = wpcap.dll
 DELAYIMPORTS = ws2_32
-EXTRALIBS = @LIBPCAP@
 
 C_SRCS = \
 	wpcap.c
diff --git a/dlls/wpcap/wpcap.c b/dlls/wpcap/wpcap.c
index da545a8..fb7cea7 100644
--- a/dlls/wpcap/wpcap.c
+++ b/dlls/wpcap/wpcap.c
@@ -18,6 +18,9 @@
  * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
  */
 
+#include "config.h"
+#include "wine/port.h"
+#include "wine/library.h"
 #include <pcap/pcap.h>
 #include "winsock2.h"
 #include "windef.h"
@@ -27,47 +30,124 @@
 WINE_DEFAULT_DEBUG_CHANNEL(wpcap);
 WINE_DECLARE_DEBUG_CHANNEL(winediag);
 
+static void          (*ppcap_breakloop)(pcap_t *);
+static void          (*ppcap_close)(pcap_t *);
+static int           (*ppcap_compile)(pcap_t *, struct bpf_program *, const char *, int, unsigned int);
+static int           (*ppcap_datalink)(pcap_t *);
+static int           (*ppcap_datalink_name_to_val)(const char *);
+static const char*   (*ppcap_datalink_val_to_description)(int);
+static const char*   (*ppcap_datalink_val_to_name)(int);
+static int           (*ppcap_dispatch)(pcap_t *, int, pcap_handler, u_char *);
+static int           (*ppcap_findalldevs)(pcap_if_t **, char *);
+static void          (*ppcap_freealldevs)(pcap_if_t *);
+static void          (*ppcap_freecode)(struct bpf_program *);
+static char*         (*ppcap_geterr)(pcap_t *);
+static int           (*ppcap_getnonblock)(pcap_t *, char *);
+static const char*   (*ppcap_lib_version)(void);
+static int           (*ppcap_list_datalinks)(pcap_t *, int **);
+static char*         (*ppcap_lookupdev)(char *);
+static int           (*ppcap_lookupnet)(const char *, unsigned int *, unsigned int *, char *);
+static int           (*ppcap_loop)(pcap_t *, int, pcap_handler, u_char *);
+static int           (*ppcap_major_version)(pcap_t *);
+static int           (*ppcap_minor_version)(pcap_t *);
+static const u_char* (*ppcap_next)(pcap_t *, struct pcap_pkthdr *);
+static int           (*ppcap_next_ex)(pcap_t *, struct pcap_pkthdr **, const u_char **);
+static pcap_t*       (*ppcap_open_live)(const char *, int, int, int, char *);
+static int           (*ppcap_sendpacket)(pcap_t *, const u_char *, int);
+static int           (*ppcap_set_datalink)(pcap_t *, int);
+static int           (*ppcap_setfilter)(pcap_t *, struct bpf_program *);
+static int           (*ppcap_setnonblock)(pcap_t *, int, char *);
+static int           (*ppcap_snapshot)(pcap_t *);
+static int           (*ppcap_stats)(pcap_t *, struct pcap_stat *);
+
+static void *pcap_handle = NULL;
+
+static BOOL load_functions(void)
+{
+    pcap_handle = wine_dlopen(SONAME_LIBPCAP, RTLD_NOW, NULL, 0);
+
+    if (!pcap_handle)
+    {
+        FIXME("Wine cannot find the library %s, wpcap.dll not working.\n", SONAME_LIBPCAP);
+        return FALSE;
+    }
+
+    #define LOAD_FUNCPTR(f) if((p##f = wine_dlsym(pcap_handle, #f, NULL, 0)) == NULL){WARN("Can't find symbol %s\n", #f); return FALSE;}
+    LOAD_FUNCPTR(pcap_breakloop);
+    LOAD_FUNCPTR(pcap_close);
+    LOAD_FUNCPTR(pcap_compile);
+    LOAD_FUNCPTR(pcap_datalink);
+    LOAD_FUNCPTR(pcap_datalink_name_to_val);
+    LOAD_FUNCPTR(pcap_datalink_val_to_description);
+    LOAD_FUNCPTR(pcap_datalink_val_to_name);
+    LOAD_FUNCPTR(pcap_dispatch);
+    LOAD_FUNCPTR(pcap_findalldevs);
+    LOAD_FUNCPTR(pcap_freealldevs);
+    LOAD_FUNCPTR(pcap_freecode);
+    LOAD_FUNCPTR(pcap_geterr);
+    LOAD_FUNCPTR(pcap_getnonblock);
+    LOAD_FUNCPTR(pcap_lib_version);
+    LOAD_FUNCPTR(pcap_list_datalinks);
+    LOAD_FUNCPTR(pcap_lookupdev);
+    LOAD_FUNCPTR(pcap_lookupnet);
+    LOAD_FUNCPTR(pcap_loop);
+    LOAD_FUNCPTR(pcap_major_version);
+    LOAD_FUNCPTR(pcap_minor_version);
+    LOAD_FUNCPTR(pcap_next);
+    LOAD_FUNCPTR(pcap_next_ex);
+    LOAD_FUNCPTR(pcap_open_live);
+    LOAD_FUNCPTR(pcap_sendpacket);
+    LOAD_FUNCPTR(pcap_set_datalink);
+    LOAD_FUNCPTR(pcap_setfilter);
+    LOAD_FUNCPTR(pcap_setnonblock);
+    LOAD_FUNCPTR(pcap_snapshot);
+    LOAD_FUNCPTR(pcap_stats);
+    #undef LOAD_FUNCPTR
+
+    return TRUE;
+}
+
 void CDECL wine_pcap_breakloop(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    return pcap_breakloop(p);
+    return ppcap_breakloop(p);
 }
 
 void CDECL wine_pcap_close(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    pcap_close(p);
+    return ppcap_close(p);
 }
 
 int CDECL wine_pcap_compile(pcap_t *p, struct bpf_program *program, const char *buf, int optimize,
                             unsigned int mask)
 {
     TRACE("(%p %p %s %i %u)\n", p, program, debugstr_a(buf), optimize, mask);
-    return pcap_compile(p, program, buf, optimize, mask);
+    return ppcap_compile(p, program, buf, optimize, mask);
 }
 
 int CDECL wine_pcap_datalink(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    return pcap_datalink(p);
+    return ppcap_datalink(p);
 }
 
 int CDECL wine_pcap_datalink_name_to_val(const char *name)
 {
     TRACE("(%s)\n", debugstr_a(name));
-    return pcap_datalink_name_to_val(name);
+    return ppcap_datalink_name_to_val(name);
 }
 
 const char* CDECL wine_pcap_datalink_val_to_description(int dlt)
 {
     TRACE("(%i)\n", dlt);
-    return pcap_datalink_val_to_description(dlt);
+    return ppcap_datalink_val_to_description(dlt);
 }
 
 const char* CDECL wine_pcap_datalink_val_to_name(int dlt)
 {
     TRACE("(%i)\n", dlt);
-    return pcap_datalink_val_to_name(dlt);
+    return ppcap_datalink_val_to_name(dlt);
 }
 
 typedef struct
@@ -98,10 +178,10 @@ int CDECL wine_pcap_dispatch(pcap_t *p, int cnt,
         pcb = HeapAlloc(GetProcessHeap(), 0, sizeof(PCAP_HANDLER_CALLBACK));
         pcb->pfn_cb = callback;
         pcb->user_data = user;
-        return pcap_dispatch(p, cnt, pcap_handler_callback, (unsigned char*)pcb);
+        return ppcap_dispatch(p, cnt, pcap_handler_callback, (unsigned char*)pcb);
     }
 
-    return pcap_dispatch(p, cnt, NULL, user);
+    return ppcap_dispatch(p, cnt, NULL, user);
 }
 
 int CDECL wine_pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
@@ -109,7 +189,7 @@ int CDECL wine_pcap_findalldevs(pcap_if_t **alldevsp, char *errbuf)
     int ret;
 
     TRACE("(%p %p)\n", alldevsp, errbuf);
-    ret = pcap_findalldevs(alldevsp, errbuf);
+    ret = ppcap_findalldevs(alldevsp, errbuf);
     if(alldevsp && !*alldevsp)
         ERR_(winediag)("Failed to access raw network (pcap), this requires special permissions.\n");
 
@@ -125,13 +205,13 @@ int CDECL wine_pcap_findalldevs_ex(char *source, void *auth, pcap_if_t **alldevs
 void CDECL wine_pcap_freealldevs(pcap_if_t *alldevs)
 {
     TRACE("(%p)\n", alldevs);
-    pcap_freealldevs(alldevs);
+    ppcap_freealldevs(alldevs);
 }
 
 void CDECL wine_pcap_freecode(struct bpf_program *fp)
 {
     TRACE("(%p)\n", fp);
-    return pcap_freecode(fp);
+    return ppcap_freecode(fp);
 }
 
 typedef struct _AirpcapHandle *PAirpcapHandle;
@@ -144,18 +224,18 @@ PAirpcapHandle CDECL wine_pcap_get_airpcap_handle(pcap_t *p)
 char* CDECL wine_pcap_geterr(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    return pcap_geterr(p);
+    return ppcap_geterr(p);
 }
 
 int CDECL wine_pcap_getnonblock(pcap_t *p, char *errbuf)
 {
     TRACE("(%p %p)\n", p, errbuf);
-    return pcap_getnonblock(p, errbuf);
+    return ppcap_getnonblock(p, errbuf);
 }
 
 const char* CDECL wine_pcap_lib_version(void)
 {
-    const char* ret = pcap_lib_version();
+    const char* ret = ppcap_lib_version();
     TRACE("%s\n", debugstr_a(ret));
     return ret;
 }
@@ -163,20 +243,20 @@ const char* CDECL wine_pcap_lib_version(void)
 int CDECL wine_pcap_list_datalinks(pcap_t *p, int **dlt_buffer)
 {
     TRACE("(%p %p)\n", p, dlt_buffer);
-    return pcap_list_datalinks(p, dlt_buffer);
+    return ppcap_list_datalinks(p, dlt_buffer);
 }
 
 char* CDECL wine_pcap_lookupdev(char *errbuf)
 {
     TRACE("(%p)\n", errbuf);
-    return pcap_lookupdev(errbuf);
+    return ppcap_lookupdev(errbuf);
 }
 
 int CDECL wine_pcap_lookupnet(const char *device, unsigned int *netp, unsigned int *maskp,
                               char *errbuf)
 {
     TRACE("(%s %p %p %p)\n", debugstr_a(device), netp, maskp, errbuf);
-    return pcap_lookupnet(device, netp, maskp, errbuf);
+    return ppcap_lookupnet(device, netp, maskp, errbuf);
 }
 
 int CDECL wine_pcap_loop(pcap_t *p, int cnt,
@@ -191,34 +271,34 @@ int CDECL wine_pcap_loop(pcap_t *p, int cnt,
         pcb = HeapAlloc(GetProcessHeap(), 0, sizeof(PCAP_HANDLER_CALLBACK));
         pcb->pfn_cb = callback;
         pcb->user_data = user;
-        return pcap_loop(p, cnt, pcap_handler_callback, (unsigned char*)pcb);
+        return ppcap_loop(p, cnt, pcap_handler_callback, (unsigned char*)pcb);
     }
 
-    return pcap_loop(p, cnt, NULL, user);
+    return ppcap_loop(p, cnt, NULL, user);
 }
 
 int CDECL wine_pcap_major_version(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    return pcap_major_version(p);
+    return ppcap_major_version(p);
 }
 
 int CDECL wine_pcap_minor_version(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    return pcap_minor_version(p);
+    return ppcap_minor_version(p);
 }
 
 const unsigned char* CDECL wine_pcap_next(pcap_t *p, struct pcap_pkthdr *h)
 {
     TRACE("(%p %p)\n", p, h);
-    return pcap_next(p, h);
+    return ppcap_next(p, h);
 }
 
 int CDECL wine_pcap_next_ex(pcap_t *p, struct pcap_pkthdr **pkt_header, const unsigned char **pkt_data)
 {
     TRACE("(%p %p %p)\n", p, pkt_header, pkt_data);
-    return pcap_next_ex(p, pkt_header, pkt_data);
+    return ppcap_next_ex(p, pkt_header, pkt_data);
 }
 
 #define PCAP_OPENFLAG_PROMISCUOUS 1
@@ -229,26 +309,26 @@ pcap_t* CDECL wine_pcap_open(const char *source, int snaplen, int flags, int rea
     int promisc = flags & PCAP_OPENFLAG_PROMISCUOUS;
     FIXME("(%s %i %i %i %p %p): partial stub\n", debugstr_a(source), snaplen, flags, read_timeout,
                                                  auth, errbuf);
-    return pcap_open_live(source, snaplen, promisc, read_timeout, errbuf);
+    return ppcap_open_live(source, snaplen, promisc, read_timeout, errbuf);
 }
 
 pcap_t* CDECL wine_pcap_open_live(const char *source, int snaplen, int promisc, int to_ms,
                                   char *errbuf)
 {
     TRACE("(%s %i %i %i %p)\n", debugstr_a(source), snaplen, promisc, to_ms, errbuf);
-    return pcap_open_live(source, snaplen, promisc, to_ms, errbuf);
+    return ppcap_open_live(source, snaplen, promisc, to_ms, errbuf);
 }
 
 int CDECL wine_pcap_sendpacket(pcap_t *p, const unsigned char *buf, int size)
 {
     TRACE("(%p %p %i)\n", p, buf, size);
-    return pcap_sendpacket(p, buf, size);
+    return ppcap_sendpacket(p, buf, size);
 }
 
 int CDECL wine_pcap_set_datalink(pcap_t *p, int dlt)
 {
     TRACE("(%p %i)\n", p, dlt);
-    return pcap_set_datalink(p, dlt);
+    return ppcap_set_datalink(p, dlt);
 }
 
 int CDECL wine_pcap_setbuff(pcap_t * p, int dim)
@@ -260,25 +340,25 @@ int CDECL wine_pcap_setbuff(pcap_t * p, int dim)
 int CDECL wine_pcap_setfilter(pcap_t *p, struct bpf_program *fp)
 {
     TRACE("(%p %p)\n", p, fp);
-    return pcap_setfilter(p, fp);
+    return ppcap_setfilter(p, fp);
 }
 
 int CDECL wine_pcap_setnonblock(pcap_t *p, int nonblock, char *errbuf)
 {
     TRACE("(%p %i %p)\n", p, nonblock, errbuf);
-    return pcap_setnonblock(p, nonblock, errbuf);
+    return ppcap_setnonblock(p, nonblock, errbuf);
 }
 
 int CDECL wine_pcap_snapshot(pcap_t *p)
 {
     TRACE("(%p)\n", p);
-    return pcap_snapshot(p);
+    return ppcap_snapshot(p);
 }
 
 int CDECL wine_pcap_stats(pcap_t *p, struct pcap_stat *ps)
 {
     TRACE("(%p %p)\n", p, ps);
-    return pcap_stats(p, ps);
+    return ppcap_stats(p, ps);
 }
 
 int CDECL wine_wsockinit(void)
@@ -288,3 +368,22 @@ int CDECL wine_wsockinit(void)
     if (WSAStartup(MAKEWORD(1,1), &wsadata)) return -1;
     return 0;
 }
+
+BOOL WINAPI DllMain (HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
+{
+    TRACE("%p,%x,%p\n", hinstDLL, fdwReason, lpvReserved);
+
+    switch (fdwReason)
+    {
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(hinstDLL);
+            if (!load_functions()) return FALSE;
+            break;
+        case DLL_PROCESS_DETACH:
+            if (lpvReserved) break;
+            if (pcap_handle) wine_dlclose(pcap_handle, NULL, 0);
+            break;
+    }
+
+    return TRUE;
+}
diff --git a/dlls/ws2_32/socket.c b/dlls/ws2_32/socket.c
index 95ea83c..845ef39 100644
--- a/dlls/ws2_32/socket.c
+++ b/dlls/ws2_32/socket.c
@@ -454,6 +454,7 @@ static inline const char *debugstr_optval(const char *optval, int optlenval)
 struct ws2_async_io
 {
     struct ws2_async_io *next;
+    DWORD                size;
 };
 
 struct ws2_async_shutdown
@@ -499,6 +500,19 @@ struct ws2_accept_async
     struct ws2_async    *read;
 };
 
+struct ws2_transmitfile_async
+{
+    struct ws2_async_io   io;
+    char                  *buffer;
+    HANDLE                file;
+    DWORD                 file_read;
+    DWORD                 file_bytes;
+    DWORD                 bytes_per_send;
+    TRANSMIT_FILE_BUFFERS buffers;
+    DWORD                 flags;
+    struct ws2_async      write;
+};
+
 static struct ws2_async_io *async_io_freelist;
 
 static void release_async_io( struct ws2_async_io *io )
@@ -515,16 +529,30 @@ static struct ws2_async_io *alloc_async_io( DWORD size )
 {
     /* first free remaining previous fileinfos */
 
-    struct ws2_async_io *io = InterlockedExchangePointer( (void **)&async_io_freelist, NULL );
+    struct ws2_async_io *old_io = InterlockedExchangePointer( (void **)&async_io_freelist, NULL );
+    struct ws2_async_io *io = NULL;
 
-    while (io)
+    while (old_io)
     {
-        struct ws2_async_io *next = io->next;
-        HeapFree( GetProcessHeap(), 0, io );
-        io = next;
+        if (!io && old_io->size >= size && old_io->size <= max(4096, 4 * size))
+        {
+            io     = old_io;
+            size   = old_io->size;
+            old_io = old_io->next;
+        }
+        else
+        {
+            struct ws2_async_io *next = old_io->next;
+            HeapFree( GetProcessHeap(), 0, old_io );
+            old_io = next;
+        }
     }
 
-    return HeapAlloc( GetProcessHeap(), 0, size );
+    if (io || (io = HeapAlloc( GetProcessHeap(), 0, size )))
+    {
+        io->size = size;
+    }
+    return io;
 }
 
 /****************************************************************/
@@ -1052,6 +1080,21 @@ static NTSTATUS _is_blocking(SOCKET s, BOOL *ret)
     return status;
 }
 
+static DWORD _get_connect_time(SOCKET s)
+{
+    NTSTATUS status;
+    DWORD connect_time = ~0u;
+    SERVER_START_REQ( get_socket_info )
+    {
+        req->handle  = wine_server_obj_handle( SOCKET2HANDLE(s) );
+        status = wine_server_call( req );
+        if (!status)
+            connect_time = reply->connect_time / -10000000;
+    }
+    SERVER_END_REQ;
+    return connect_time;
+}
+
 static unsigned int _get_sock_mask(SOCKET s)
 {
     unsigned int ret;
@@ -2139,7 +2182,17 @@ static int WS2_recv( int fd, struct ws2_async *wsa, int flags )
 
     while ((n = recvmsg(fd, &hdr, flags)) == -1)
     {
-        if (errno != EINTR)
+        if (errno == EFAULT)
+        {
+            unsigned int i;
+            for (i = wsa->first_iovec; i < wsa->n_iovecs; i++)
+            {
+                struct iovec *iov = &wsa->iovec[i];
+                if (wine_uninterrupted_write_memory( iov->iov_base, NULL, iov->iov_len ) < iov->iov_len)
+                    return -1;
+            }
+        }
+        else if (errno != EINTR)
             return -1;
     }
 
@@ -2700,6 +2753,262 @@ static BOOL WINAPI WS2_AcceptEx(SOCKET listener, SOCKET acceptor, PVOID dest, DW
 }
 
 /***********************************************************************
+ *     WS2_transmitfile_getbuffer       (INTERNAL)
+ *
+ * Pick the appropriate buffer for a TransmitFile send operation.
+ */
+static NTSTATUS WS2_transmitfile_getbuffer( int fd, struct ws2_transmitfile_async *wsa )
+{
+    /* send any incomplete writes from a previous iteration */
+    if (wsa->write.first_iovec < wsa->write.n_iovecs)
+        return STATUS_PENDING;
+
+    /* process the header (if applicable) */
+    if (wsa->buffers.Head)
+    {
+        wsa->write.first_iovec       = 0;
+        wsa->write.n_iovecs          = 1;
+        wsa->write.iovec[0].iov_base = wsa->buffers.Head;
+        wsa->write.iovec[0].iov_len  = wsa->buffers.HeadLength;
+        wsa->buffers.Head            = NULL;
+        return STATUS_PENDING;
+    }
+
+    /* process the main file */
+    if (wsa->file)
+    {
+        DWORD bytes_per_send = wsa->bytes_per_send;
+        IO_STATUS_BLOCK iosb;
+        NTSTATUS status;
+
+        /* when the size of the transfer is limited ensure that we don't go past that limit */
+        if (wsa->file_bytes != 0)
+            bytes_per_send = min(bytes_per_send, wsa->file_bytes - wsa->file_read);
+        status = NtReadFile( wsa->file, 0, NULL, NULL, &iosb, wsa->buffer, bytes_per_send,
+                             NULL, NULL );
+        if (status == STATUS_END_OF_FILE)
+            wsa->file = NULL; /* continue on to the footer */
+        else if (status != STATUS_SUCCESS)
+            return status;
+        else
+        {
+            if (iosb.Information)
+            {
+                wsa->write.first_iovec       = 0;
+                wsa->write.n_iovecs          = 1;
+                wsa->write.iovec[0].iov_base = wsa->buffer;
+                wsa->write.iovec[0].iov_len  = iosb.Information;
+                wsa->file_read += iosb.Information;
+            }
+
+            if (wsa->file_bytes != 0 && wsa->file_read >= wsa->file_bytes)
+                wsa->file = NULL;
+
+            return STATUS_PENDING;
+        }
+    }
+
+    /* send the footer (if applicable) */
+    if (wsa->buffers.Tail)
+    {
+        wsa->write.first_iovec       = 0;
+        wsa->write.n_iovecs          = 1;
+        wsa->write.iovec[0].iov_base = wsa->buffers.Tail;
+        wsa->write.iovec[0].iov_len  = wsa->buffers.TailLength;
+        wsa->buffers.Tail            = NULL;
+        return STATUS_PENDING;
+    }
+
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *     WS2_transmitfile_base            (INTERNAL)
+ *
+ * Shared implementation for both synchronous and asynchronous TransmitFile.
+ */
+static NTSTATUS WS2_transmitfile_base( int fd, struct ws2_transmitfile_async *wsa )
+{
+    NTSTATUS status;
+
+    status = WS2_transmitfile_getbuffer( fd, wsa );
+    if (status == STATUS_PENDING)
+    {
+        IO_STATUS_BLOCK *iosb = (IO_STATUS_BLOCK *)wsa->write.user_overlapped;
+        int n;
+
+        n = WS2_send( fd, &wsa->write, convert_flags(wsa->write.flags) );
+        if (n >= 0)
+        {
+            if (iosb) iosb->Information += n;
+        }
+        else if (errno != EAGAIN)
+            return wsaErrStatus();
+    }
+
+    if (status != STATUS_SUCCESS)
+        return status;
+
+    if (wsa->flags & TF_REUSE_SOCKET)
+    {
+        SERVER_START_REQ( reuse_socket )
+        {
+            req->handle = wine_server_obj_handle( wsa->write.hSocket );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+        if (status != STATUS_SUCCESS)
+            return status;
+    }
+    if (wsa->flags & TF_DISCONNECT)
+    {
+        /* we can't use WS_closesocket because it modifies the last error */
+        NtClose( SOCKET2HANDLE(wsa->write.hSocket) );
+    }
+
+    return STATUS_SUCCESS;
+}
+
+/***********************************************************************
+ *     WS2_async_transmitfile           (INTERNAL)
+ *
+ * Asynchronous callback for overlapped TransmitFile operations.
+ */
+static NTSTATUS WS2_async_transmitfile( void *user, IO_STATUS_BLOCK *iosb,
+                                        NTSTATUS status, void **apc, void **arg )
+{
+    struct ws2_transmitfile_async *wsa = user;
+    int fd;
+
+    if (status == STATUS_ALERTED)
+    {
+        if (!(status = wine_server_handle_to_fd( wsa->write.hSocket, FILE_WRITE_DATA, &fd, NULL )))
+        {
+            status = WS2_transmitfile_base( fd, wsa );
+            wine_server_release_fd( wsa->write.hSocket, fd );
+        }
+        if (status == STATUS_PENDING)
+            return status;
+    }
+
+    iosb->u.Status = status;
+    release_async_io( &wsa->io );
+    return status;
+}
+
+/***********************************************************************
+ *     TransmitFile
+ */
+static BOOL WINAPI WS2_TransmitFile( SOCKET s, HANDLE h, DWORD file_bytes, DWORD bytes_per_send,
+                                     LPOVERLAPPED overlapped, LPTRANSMIT_FILE_BUFFERS buffers,
+                                     DWORD flags )
+{
+    DWORD unsupported_flags = flags & ~(TF_DISCONNECT|TF_REUSE_SOCKET);
+    IO_STATUS_BLOCK *iosb = (IO_STATUS_BLOCK *)overlapped;
+    union generic_unix_sockaddr uaddr;
+    unsigned int uaddrlen = sizeof(uaddr);
+    struct ws2_transmitfile_async *wsa;
+    NTSTATUS status;
+    int fd;
+
+    TRACE("(%lx, %p, %d, %d, %p, %p, %d)\n", s, h, file_bytes, bytes_per_send, overlapped,
+            buffers, flags );
+
+    fd = get_sock_fd( s, FILE_WRITE_DATA, NULL );
+    if (fd == -1)
+    {
+        WSASetLastError( WSAENOTSOCK );
+        return FALSE;
+    }
+    if (getpeername( fd, &uaddr.addr, &uaddrlen ) != 0)
+    {
+        release_sock_fd( s, fd );
+        WSASetLastError( WSAENOTCONN );
+        return FALSE;
+    }
+    if (unsupported_flags)
+        FIXME("Flags are not currently supported (0x%x).\n", unsupported_flags);
+
+    /* set reasonable defaults when requested */
+    if (!bytes_per_send)
+        bytes_per_send = 1024;
+
+    if (!(wsa = (struct ws2_transmitfile_async *)alloc_async_io( sizeof(*wsa) + bytes_per_send )))
+    {
+        release_sock_fd( s, fd );
+        WSASetLastError( WSAEFAULT );
+        return FALSE;
+    }
+    if (buffers)
+        memcpy(&wsa->buffers, buffers, sizeof(wsa->buffers));
+    else
+        memset(&wsa->buffers, 0x0, sizeof(wsa->buffers));
+    wsa->buffer                = (char *)(wsa + 1);
+    wsa->file                  = h;
+    wsa->file_read             = 0;
+    wsa->file_bytes            = file_bytes;
+    wsa->bytes_per_send        = bytes_per_send;
+    wsa->flags                 = flags;
+    wsa->write.hSocket         = SOCKET2HANDLE(s);
+    wsa->write.addr            = NULL;
+    wsa->write.addrlen.val     = 0;
+    wsa->write.flags           = 0;
+    wsa->write.lpFlags         = &wsa->flags;
+    wsa->write.control         = NULL;
+    wsa->write.n_iovecs        = 0;
+    wsa->write.first_iovec     = 0;
+    wsa->write.user_overlapped = overlapped;
+
+    if (overlapped)
+    {
+        LARGE_INTEGER offset;
+        int status;
+
+        /* set the file offset to the desired point */
+        offset.u.LowPart = overlapped->u.s.Offset;
+        offset.u.HighPart = overlapped->u.s.OffsetHigh;
+        SetFilePointerEx( wsa->file, offset, NULL, FILE_BEGIN );
+
+        iosb->u.Status = STATUS_PENDING;
+        iosb->Information = 0;
+        SERVER_START_REQ( register_async )
+        {
+            req->type           = ASYNC_TYPE_WRITE;
+            req->async.handle   = wine_server_obj_handle( SOCKET2HANDLE(s) );
+            req->async.event    = wine_server_obj_handle( overlapped->hEvent );
+            req->async.callback = wine_server_client_ptr( WS2_async_transmitfile );
+            req->async.iosb     = wine_server_client_ptr( iosb );
+            req->async.arg      = wine_server_client_ptr( wsa );
+            status = wine_server_call( req );
+        }
+        SERVER_END_REQ;
+
+        if(status != STATUS_PENDING) HeapFree( GetProcessHeap(), 0, wsa );
+        release_sock_fd( s, fd );
+        WSASetLastError( NtStatusToWSAError(status) );
+        return FALSE;
+    }
+
+    do
+    {
+        status = WS2_transmitfile_base( fd, wsa );
+        if (status == STATUS_PENDING)
+        {
+            /* block here */
+            do_block(fd, POLLOUT, -1);
+            _sync_sock_state(s); /* let wineserver notice connection */
+        }
+    }
+    while (status == STATUS_PENDING);
+    release_sock_fd( s, fd );
+
+    if (status != STATUS_SUCCESS)
+        WSASetLastError( NtStatusToWSAError(status) );
+    HeapFree( GetProcessHeap(), 0, wsa );
+    return (status == STATUS_SUCCESS);
+}
+
+/***********************************************************************
  *     GetAcceptExSockaddrs
  */
 static void WINAPI WS2_GetAcceptExSockaddrs(PVOID buffer, DWORD data_size, DWORD local_size, DWORD remote_size,
@@ -3480,7 +3789,6 @@ INT WINAPI WS_getsockopt(SOCKET s, INT level,
 
         case WS_SO_CONNECT_TIME:
         {
-            static int pretendtime = 0;
             struct WS_sockaddr addr;
             int len = sizeof(addr);
 
@@ -3492,10 +3800,7 @@ INT WINAPI WS_getsockopt(SOCKET s, INT level,
             if (WS_getpeername(s, &addr, &len) == SOCKET_ERROR)
                 *(DWORD *)optval = ~0u;
             else
-            {
-                if (!pretendtime) FIXME("WS_SO_CONNECT_TIME - faking results\n");
-                *(DWORD *)optval = pretendtime++;
-            }
+                *(DWORD *)optval = _get_connect_time(s);
             *optlen = sizeof(DWORD);
             return ret;
         }
@@ -4421,7 +4726,8 @@ INT WINAPI WSAIoctl(SOCKET s, DWORD code, LPVOID in_buff, DWORD in_size, LPVOID
         }
         else if ( IsEqualGUID(&transmitfile_guid, in_buff) )
         {
-            FIXME("SIO_GET_EXTENSION_FUNCTION_POINTER: unimplemented TransmitFile\n");
+            *(LPFN_TRANSMITFILE *)out_buff = WS2_TransmitFile;
+            break;
         }
         else if ( IsEqualGUID(&transmitpackets_guid, in_buff) )
         {
@@ -4788,7 +5094,13 @@ static void release_poll_fds( const WS_fd_set *readfds, const WS_fd_set *writefd
     if (exceptfds)
     {
         for (i = 0; i < exceptfds->fd_count; i++, j++)
-            if (fds[j].fd != -1) release_sock_fd( exceptfds->fd_array[i], fds[j].fd );
+        {
+            if (fds[j].fd == -1) continue;
+            release_sock_fd( exceptfds->fd_array[i], fds[j].fd );
+            if (!(fds[j].revents & POLLHUP)) continue;
+            if (wine_server_handle_exists( SOCKET2HANDLE( exceptfds->fd_array[i] ), 0 )) continue;
+            fds[j].revents = 0;
+        }
     }
 }
 
@@ -5964,7 +6276,7 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
     struct addrinfo *unixaires = NULL;
     int   result;
     struct addrinfo unixhints, *punixhints = NULL;
-    char *hostname = NULL;
+    char *hostname;
     const char *node;
 
     *res = NULL;
@@ -5974,13 +6286,13 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
         return WSAHOST_NOT_FOUND;
     }
 
+    hostname = get_hostname();
+    if (!hostname) return WSA_NOT_ENOUGH_MEMORY;
+
     if (!nodename)
         node = NULL;
     else if (!nodename[0])
-    {
-        node = hostname = get_hostname();
-        if (!node) return WSA_NOT_ENOUGH_MEMORY;
-    }
+        node = hostname;
     else
         node = nodename;
 
@@ -6024,6 +6336,14 @@ int WINAPI WS_getaddrinfo(LPCSTR nodename, LPCSTR servname, const struct WS_addr
     /* getaddrinfo(3) is thread safe, no need to wrap in CS */
     result = getaddrinfo(node, servname, punixhints, &unixaires);
 
+    if (result && !strcmp(hostname, node))
+    {
+        /* If it didn't work it means the host name IP is not in /etc/hosts, try again
+         * by sending a NULL host and avoid sending a NULL servname too because that
+         * is invalid */
+        ERR_(winediag)("Failed to resolve your host name IP, attempting to resolve as NULL. You should fix this!\n");
+        result = getaddrinfo(NULL, servname ? servname : "0", punixhints, &unixaires);
+    }
     TRACE("%s, %s %p -> %p %d\n", debugstr_a(nodename), debugstr_a(servname), hints, res, result);
     HeapFree(GetProcessHeap(), 0, hostname);
 
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index aa06a08..b32618c 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -3834,7 +3834,6 @@ todo_wine
     FD_ZERO_ALL();
     FD_SET_ALL(fdWrite);
     ret = select(0, &readfds, NULL, &exceptfds, &select_timeout);
-todo_wine
     ok(ret == 1, "expected 1, got %d\n", ret);
     ok(FD_ISSET(fdWrite, &readfds), "fdWrite socket is not in the set\n");
     WaitForSingleObject (thread_handle, 1000);
@@ -4894,6 +4893,8 @@ static void test_send(void)
     OVERLAPPED ov;
     BOOL bret;
     DWORD id, bytes_sent, dwRet;
+    DWORD expected_time, connect_time;
+    socklen_t optlen;
 
     memset(&ov, 0, sizeof(ov));
 
@@ -4902,6 +4903,7 @@ static void test_send(void)
         ok(0, "creating socket pair failed, skipping test\n");
         return;
     }
+    expected_time = GetTickCount();
 
     set_blocking(dst, FALSE);
     /* force disable buffering so we can get a pending overlapped request */
@@ -4988,6 +4990,22 @@ static void test_send(void)
     ok(ret == SOCKET_ERROR && WSAGetLastError() == ERROR_IO_PENDING,
        "Failed to start overlapped send %d - %d\n", ret, WSAGetLastError());
 
+    expected_time = (GetTickCount() - expected_time) / 1000;
+
+    connect_time = 0xdeadbeef;
+    optlen = sizeof(connect_time);
+    ret = getsockopt(dst, SOL_SOCKET, SO_CONNECT_TIME, (char *)&connect_time, &optlen);
+    ok(!ret, "getsockopt failed %d\n", WSAGetLastError());
+    ok(connect_time >= expected_time && connect_time <= expected_time + 1,
+       "unexpected connect time %u, expected %u\n", connect_time, expected_time);
+
+    connect_time = 0xdeadbeef;
+    optlen = sizeof(connect_time);
+    ret = getsockopt(src, SOL_SOCKET, SO_CONNECT_TIME, (char *)&connect_time, &optlen);
+    ok(!ret, "getsockopt failed %d\n", WSAGetLastError());
+    ok(connect_time >= expected_time && connect_time <= expected_time + 1,
+       "unexpected connect time %u, expected %u\n", connect_time, expected_time);
+
 end:
     if (src != INVALID_SOCKET)
         closesocket(src);
@@ -6286,12 +6304,17 @@ static void test_GetAddrInfoW(void)
     static const WCHAR zero[] = {'0',0};
     int i, ret;
     ADDRINFOW *result, *result2, *p, hint;
+    char computernameA[256];
+    WCHAR computername[sizeof(computernameA)];
 
     if (!pGetAddrInfoW || !pFreeAddrInfoW)
     {
         win_skip("GetAddrInfoW and/or FreeAddrInfoW not present\n");
         return;
     }
+    ret = gethostname(computernameA, sizeof(computernameA));
+    ok(!ret, "Expected gethostname to work\n");
+    MultiByteToWideChar(CP_ACP, 0, computernameA, -1, computername, sizeof(computernameA));
     memset(&hint, 0, sizeof(ADDRINFOW));
 
     result = (ADDRINFOW *)0xdeadbeef;
@@ -6356,6 +6379,25 @@ static void test_GetAddrInfoW(void)
     ok(!ret, "GetAddrInfoW failed with %d\n", WSAGetLastError());
     pFreeAddrInfoW(result);
 
+    ret = pGetAddrInfoW(computername, NULL, NULL, &result);
+    ok(!ret, "GetAddrInfoW failed with %d\n", WSAGetLastError());
+    pFreeAddrInfoW(result);
+
+    result = NULL;
+    ret = pGetAddrInfoW(computername, empty, NULL, &result);
+    ok(!ret, "GetAddrInfoW failed with %d\n", WSAGetLastError());
+    pFreeAddrInfoW(result);
+
+    result = NULL;
+    ret = pGetAddrInfoW(computername, zero, NULL, &result);
+    ok(!ret, "GetAddrInfoW failed with %d\n", WSAGetLastError());
+    pFreeAddrInfoW(result);
+
+    result = NULL;
+    ret = pGetAddrInfoW(computername, port, NULL, &result);
+    ok(!ret, "GetAddrInfoW failed with %d\n", WSAGetLastError());
+    pFreeAddrInfoW(result);
+
     result = NULL;
     ret = pGetAddrInfoW(localhost, NULL, &hint, &result);
     ok(!ret, "GetAddrInfoW failed with %d\n", WSAGetLastError());
@@ -6448,12 +6490,15 @@ static void test_getaddrinfo(void)
 {
     int i, ret;
     ADDRINFOA *result, *result2, *p, hint;
+    char computername[256];
 
     if (!pgetaddrinfo || !pfreeaddrinfo)
     {
         win_skip("getaddrinfo and/or freeaddrinfo not present\n");
         return;
     }
+    ret = gethostname(computername, sizeof(computername));
+    ok(!ret, "Expected gethostname to work\n");
     memset(&hint, 0, sizeof(ADDRINFOA));
 
     result = (ADDRINFOA *)0xdeadbeef;
@@ -6520,6 +6565,26 @@ static void test_getaddrinfo(void)
     pfreeaddrinfo(result);
 
     result = NULL;
+    ret = pgetaddrinfo(computername, NULL, NULL, &result);
+    ok(!ret, "getaddrinfo failed with %d\n", WSAGetLastError());
+    pfreeaddrinfo(result);
+
+    result = NULL;
+    ret = pgetaddrinfo(computername, "", NULL, &result);
+    ok(!ret, "getaddrinfo failed with %d\n", WSAGetLastError());
+    pfreeaddrinfo(result);
+
+    result = NULL;
+    ret = pgetaddrinfo(computername, "0", NULL, &result);
+    ok(!ret, "getaddrinfo failed with %d\n", WSAGetLastError());
+    pfreeaddrinfo(result);
+
+    result = NULL;
+    ret = pgetaddrinfo(computername, "80", NULL, &result);
+    ok(!ret, "getaddrinfo failed with %d\n", WSAGetLastError());
+    pfreeaddrinfo(result);
+
+    result = NULL;
     ret = pgetaddrinfo("localhost", NULL, &hint, &result);
     ok(!ret, "getaddrinfo failed with %d\n", WSAGetLastError());
     pfreeaddrinfo(result);
@@ -7320,6 +7385,266 @@ end:
         closesocket(connector2);
 }
 
+#define compare_file(h,s,o) compare_file2(h,s,o,__FILE__,__LINE__)
+
+static void compare_file2(HANDLE handle, SOCKET sock, int offset, const char *file, int line)
+{
+    char buf1[256], buf2[256];
+    BOOL success;
+    int i = 0;
+
+    SetFilePointer(handle, offset, NULL, FILE_BEGIN);
+    while (1)
+    {
+        DWORD n1 = 0, n2 = 0;
+
+        success = ReadFile(handle, buf1, sizeof(buf1), &n1, NULL);
+        ok_(file,line)(success, "Failed to read from file.\n");
+        if (success && n1 == 0)
+            break;
+        else if(!success)
+            return;
+        n2 = recv(sock, buf2, n1, 0);
+        ok_(file,line)(n1 == n2, "Block %d size mismatch (%d != %d)\n", i, n1, n2);
+        ok_(file,line)(memcmp(buf1, buf2, n2) == 0, "Block %d failed\n", i);
+        i++;
+    }
+}
+
+static void test_TransmitFile(void)
+{
+    DWORD num_bytes, err, file_size, total_sent;
+    GUID transmitFileGuid = WSAID_TRANSMITFILE;
+    LPFN_TRANSMITFILE pTransmitFile = NULL;
+    HANDLE file = INVALID_HANDLE_VALUE;
+    char header_msg[] = "hello world";
+    char footer_msg[] = "goodbye!!!";
+    char system_ini_path[MAX_PATH];
+    struct sockaddr_in bindAddress;
+    TRANSMIT_FILE_BUFFERS buffers;
+    SOCKET client, server, dest;
+    WSAOVERLAPPED ov;
+    char buf[256];
+    int iret, len;
+    BOOL bret;
+
+    memset( &ov, 0, sizeof(ov) );
+
+    /* Setup sockets for testing TransmitFile */
+    client = socket(AF_INET, SOCK_STREAM, 0);
+    server = socket(AF_INET, SOCK_STREAM, 0);
+    if (client == INVALID_SOCKET || server == INVALID_SOCKET)
+    {
+        skip("could not create acceptor socket, error %d\n", WSAGetLastError());
+        goto cleanup;
+    }
+    iret = WSAIoctl(client, SIO_GET_EXTENSION_FUNCTION_POINTER, &transmitFileGuid, sizeof(transmitFileGuid),
+                    &pTransmitFile, sizeof(pTransmitFile), &num_bytes, NULL, NULL);
+    if (iret)
+    {
+        skip("WSAIoctl failed to get TransmitFile with ret %d + errno %d\n", iret, WSAGetLastError());
+        goto cleanup;
+    }
+    GetSystemWindowsDirectoryA(system_ini_path, MAX_PATH );
+    strcat(system_ini_path, "\\system.ini");
+    file = CreateFileA(system_ini_path, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_ALWAYS, 0x0, NULL);
+    if (file == INVALID_HANDLE_VALUE)
+    {
+        skip("Unable to open a file to transmit.\n");
+        goto cleanup;
+    }
+    file_size = GetFileSize(file, NULL);
+
+    /* Test TransmitFile with an invalid socket */
+    bret = pTransmitFile(INVALID_SOCKET, file, 0, 0, NULL, NULL, 0);
+    err = WSAGetLastError();
+    ok(!bret, "TransmitFile succeeded unexpectedly.\n");
+    ok(err == WSAENOTSOCK, "TransmitFile triggered unexpected errno (%d != %d)\n", err, WSAENOTSOCK);
+
+    /* Test a bogus TransmitFile without a connected socket */
+    bret = pTransmitFile(client, NULL, 0, 0, NULL, NULL, TF_REUSE_SOCKET);
+    err = WSAGetLastError();
+    ok(!bret, "TransmitFile succeeded unexpectedly.\n");
+    ok(err == WSAENOTCONN, "TransmitFile triggered unexpected errno (%d != %d)\n", err, WSAENOTCONN);
+
+    /* Setup a properly connected socket for transfers */
+    memset(&bindAddress, 0, sizeof(bindAddress));
+    bindAddress.sin_family = AF_INET;
+    bindAddress.sin_port = htons(9375);
+    bindAddress.sin_addr.s_addr = inet_addr("127.0.0.1");
+    iret = bind(server, (struct sockaddr*)&bindAddress, sizeof(bindAddress));
+    if (iret != 0)
+    {
+        skip("failed to bind(), error %d\n", WSAGetLastError());
+        goto cleanup;
+    }
+    iret = listen(server, 1);
+    if (iret != 0)
+    {
+        skip("failed to listen(), error %d\n", WSAGetLastError());
+        goto cleanup;
+    }
+    iret = connect(client, (struct sockaddr*)&bindAddress, sizeof(bindAddress));
+    if (iret != 0)
+    {
+        skip("failed to connect(), error %d\n", WSAGetLastError());
+        goto cleanup;
+    }
+    len = sizeof(bindAddress);
+    dest = accept(server, (struct sockaddr*)&bindAddress, &len);
+    if (dest == INVALID_SOCKET)
+    {
+        skip("failed to accept(), error %d\n", WSAGetLastError());
+        goto cleanup;
+    }
+    if (set_blocking(dest, FALSE))
+    {
+        skip("couldn't make socket non-blocking, error %d\n", WSAGetLastError());
+        goto cleanup;
+    }
+
+    /* Test TransmitFile with no possible buffer */
+    bret = pTransmitFile(client, NULL, 0, 0, NULL, NULL, 0);
+    ok(bret, "TransmitFile failed unexpectedly.\n");
+    iret = recv(dest, buf, sizeof(buf), 0);
+    ok(iret == -1, "Returned an unexpected buffer from TransmitFile (%d != -1).\n", iret);
+
+    /* Test TransmitFile with only buffer data */
+    buffers.Head = &header_msg[0];
+    buffers.HeadLength = sizeof(header_msg)+1;
+    buffers.Tail = &footer_msg[0];
+    buffers.TailLength = sizeof(footer_msg)+1;
+    bret = pTransmitFile(client, NULL, 0, 0, NULL, &buffers, 0);
+    ok(bret, "TransmitFile failed unexpectedly.\n");
+    iret = recv(dest, buf, sizeof(buf), 0);
+    ok(iret == sizeof(header_msg)+sizeof(footer_msg)+2,
+       "Returned an unexpected buffer from TransmitFile (%d != %d).\n", iret,
+       sizeof(header_msg)+sizeof(footer_msg)+2);
+    ok(memcmp(&buf[0], &header_msg[0], sizeof(header_msg)+1) == 0,
+       "TransmitFile header buffer did not match!\n");
+    ok(memcmp(&buf[sizeof(header_msg)+1], &footer_msg[0], sizeof(footer_msg)+1) == 0,
+       "TransmitFile footer buffer did not match!\n");
+
+    /* Test TransmitFile with only file data */
+    bret = pTransmitFile(client, file, 0, 0, NULL, NULL, 0);
+    ok(bret, "TransmitFile failed unexpectedly.\n");
+    compare_file(file, dest, 0);
+
+    /* Test TransmitFile with both file and buffer data */
+    buffers.Head = &header_msg[0];
+    buffers.HeadLength = sizeof(header_msg)+1;
+    buffers.Tail = &footer_msg[0];
+    buffers.TailLength = sizeof(footer_msg)+1;
+    SetFilePointer(file, 0, NULL, FILE_BEGIN);
+    bret = pTransmitFile(client, file, 0, 0, NULL, &buffers, 0);
+    ok(bret, "TransmitFile failed unexpectedly.\n");
+    iret = recv(dest, buf, sizeof(header_msg)+1, 0);
+    ok(memcmp(buf, &header_msg[0], sizeof(header_msg)+1) == 0,
+       "TransmitFile header buffer did not match!\n");
+    compare_file(file, dest, 0);
+    iret = recv(dest, buf, sizeof(footer_msg)+1, 0);
+    ok(memcmp(buf, &footer_msg[0], sizeof(footer_msg)+1) == 0,
+       "TransmitFile footer buffer did not match!\n");
+
+    /* Test overlapped TransmitFile */
+    ov.hEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+    if (ov.hEvent == INVALID_HANDLE_VALUE)
+    {
+        skip("Could not create event object, some tests will be skipped. errno = %d\n",
+             GetLastError());
+        goto cleanup;
+    }
+    SetFilePointer(file, 0, NULL, FILE_BEGIN);
+    bret = pTransmitFile(client, file, 0, 0, &ov, NULL, 0);
+    err = WSAGetLastError();
+    ok(!bret, "TransmitFile succeeded unexpectedly.\n");
+    ok(err == ERROR_IO_PENDING, "TransmitFile triggered unexpected errno (%d != %d)\n",
+       err, ERROR_IO_PENDING);
+    iret = WaitForSingleObject(ov.hEvent, 2000);
+    ok(iret == WAIT_OBJECT_0, "Overlapped TransmitFile failed.\n");
+    WSAGetOverlappedResult(client, &ov, &total_sent, FALSE, NULL);
+    ok(total_sent == file_size,
+       "Overlapped TransmitFile sent an unexpected number of bytes (%d != %d).\n",
+       total_sent, file_size);
+    compare_file(file, dest, 0);
+
+    /* Test overlapped TransmitFile w/ start offset */
+    ov.hEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+    if (ov.hEvent == INVALID_HANDLE_VALUE)
+    {
+        skip("Could not create event object, some tests will be skipped. errno = %d\n", GetLastError());
+        goto cleanup;
+    }
+    SetFilePointer(file, 0, NULL, FILE_BEGIN);
+    ov.Offset = 10;
+    bret = pTransmitFile(client, file, 0, 0, &ov, NULL, 0);
+    err = WSAGetLastError();
+    ok(!bret, "TransmitFile succeeded unexpectedly.\n");
+    ok(err == ERROR_IO_PENDING, "TransmitFile triggered unexpected errno (%d != %d)\n", err, ERROR_IO_PENDING);
+    iret = WaitForSingleObject(ov.hEvent, 2000);
+    ok(iret == WAIT_OBJECT_0, "Overlapped TransmitFile failed.\n");
+    WSAGetOverlappedResult(client, &ov, &total_sent, FALSE, NULL);
+    ok(total_sent == (file_size - ov.Offset),
+       "Overlapped TransmitFile sent an unexpected number of bytes (%d != %d).\n",
+       total_sent, file_size - ov.Offset);
+    compare_file(file, dest, ov.Offset);
+
+    /* Test overlapped TransmitFile w/ file and buffer data */
+    ov.hEvent = CreateEventW(NULL, FALSE, FALSE, NULL);
+    if (ov.hEvent == INVALID_HANDLE_VALUE)
+    {
+        skip("Could not create event object, some tests will be skipped. errno = %d\n", GetLastError());
+        goto cleanup;
+    }
+    buffers.Head = &header_msg[0];
+    buffers.HeadLength = sizeof(header_msg)+1;
+    buffers.Tail = &footer_msg[0];
+    buffers.TailLength = sizeof(footer_msg)+1;
+    SetFilePointer(file, 0, NULL, FILE_BEGIN);
+    ov.Offset = 0;
+    bret = pTransmitFile(client, file, 0, 0, &ov, &buffers, 0);
+    err = WSAGetLastError();
+    ok(!bret, "TransmitFile succeeded unexpectedly.\n");
+    ok(err == ERROR_IO_PENDING, "TransmitFile triggered unexpected errno (%d != %d)\n", err, ERROR_IO_PENDING);
+    iret = WaitForSingleObject(ov.hEvent, 2000);
+    ok(iret == WAIT_OBJECT_0, "Overlapped TransmitFile failed.\n");
+    WSAGetOverlappedResult(client, &ov, &total_sent, FALSE, NULL);
+    ok(total_sent == (file_size + buffers.HeadLength + buffers.TailLength),
+       "Overlapped TransmitFile sent an unexpected number of bytes (%d != %d).\n",
+       total_sent, file_size  + buffers.HeadLength + buffers.TailLength);
+    iret = recv(dest, buf, sizeof(header_msg)+1, 0);
+    ok(memcmp(buf, &header_msg[0], sizeof(header_msg)+1) == 0,
+       "TransmitFile header buffer did not match!\n");
+    compare_file(file, dest, 0);
+    iret = recv(dest, buf, sizeof(footer_msg)+1, 0);
+    ok(memcmp(buf, &footer_msg[0], sizeof(footer_msg)+1) == 0,
+       "TransmitFile footer buffer did not match!\n");
+
+    /* Test TransmitFile w/ TF_DISCONNECT */
+    SetFilePointer(file, 0, NULL, FILE_BEGIN);
+    bret = pTransmitFile(client, file, 0, 0, NULL, NULL, TF_DISCONNECT);
+    ok(bret, "TransmitFile failed unexpectedly.\n");
+    compare_file(file, dest, 0);
+    closesocket(client);
+    ok(send(client, "test", 4, 0) == -1, "send() after TF_DISCONNECT succeeded unexpectedly.\n");
+    err = WSAGetLastError();
+    todo_wine ok(err == WSAENOTSOCK, "send() after TF_DISCONNECT triggered unexpected errno (%d != %d)\n",
+                 err, WSAENOTSOCK);
+
+    /* Test TransmitFile with a UDP datagram socket */
+    client = socket(AF_INET, SOCK_DGRAM, 0);
+    bret = pTransmitFile(client, NULL, 0, 0, NULL, NULL, 0);
+    err = WSAGetLastError();
+    ok(!bret, "TransmitFile succeeded unexpectedly.\n");
+    ok(err == WSAENOTCONN, "TransmitFile triggered unexpected errno (%d != %d)\n", err, WSAENOTCONN);
+
+cleanup:
+    CloseHandle(file);
+    CloseHandle(ov.hEvent);
+    closesocket(client);
+    closesocket(server);
+}
+
 static void test_getpeername(void)
 {
     SOCKET sock;
@@ -8688,6 +9013,7 @@ START_TEST( sock )
     test_events(1);
 
     test_ipv6only();
+    test_TransmitFile();
     test_GetAddrInfoW();
     test_getaddrinfo();
     test_AcceptEx();
diff --git a/dlls/wtsapi32/tests/wtsapi.c b/dlls/wtsapi32/tests/wtsapi.c
index e8dced7..a317e5f9 100644
--- a/dlls/wtsapi32/tests/wtsapi.c
+++ b/dlls/wtsapi32/tests/wtsapi.c
@@ -85,7 +85,6 @@ static void test_WTSEnumerateProcessesW(void)
     {
         found = found || !lstrcmpW(pname, info[i].pProcessName);
     }
-    todo_wine
     ok(found || broken(!ret), "process name %s not found\n", wine_dbgstr_w(pname));
     if (info) WTSFreeMemory(info);
 }
diff --git a/dlls/wtsapi32/wtsapi32.c b/dlls/wtsapi32/wtsapi32.c
index 79d5a7f..9457143 100644
--- a/dlls/wtsapi32/wtsapi32.c
+++ b/dlls/wtsapi32/wtsapi32.c
@@ -18,8 +18,11 @@
 #include "config.h"
 #include <stdarg.h>
 #include <stdlib.h>
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
 #include "windef.h"
 #include "winbase.h"
+#include "winternl.h"
 #include "wtsapi32.h"
 #include "wine/debug.h"
 
@@ -84,8 +87,13 @@ BOOL WINAPI WTSEnumerateProcessesA(HANDLE hServer, DWORD Reserved, DWORD Version
 BOOL WINAPI WTSEnumerateProcessesW(HANDLE hServer, DWORD Reserved, DWORD Version,
     PWTS_PROCESS_INFOW* ppProcessInfo, DWORD* pCount)
 {
-    FIXME("Stub %p 0x%08x 0x%08x %p %p\n", hServer, Reserved, Version,
-          ppProcessInfo, pCount);
+    WTS_PROCESS_INFOW *processInfo;
+    SYSTEM_PROCESS_INFORMATION *spi;
+    ULONG size = 0x4000;
+    void *buf = NULL;
+    NTSTATUS status;
+    DWORD count;
+    WCHAR *name;
 
     if (!ppProcessInfo || !pCount || Reserved != 0 || Version != 1)
     {
@@ -93,9 +101,71 @@ BOOL WINAPI WTSEnumerateProcessesW(HANDLE hServer, DWORD Reserved, DWORD Version
         return FALSE;
     }
 
-    *pCount = 0;
-    *ppProcessInfo = NULL;
+    if (hServer != WTS_CURRENT_SERVER_HANDLE)
+    {
+        SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
+        return FALSE;
+    }
+
+    do
+    {
+        size *= 2;
+        HeapFree(GetProcessHeap(), 0, buf);
+        buf = HeapAlloc(GetProcessHeap(), 0, size);
+        if (!buf)
+        {
+            SetLastError(ERROR_OUTOFMEMORY);
+            return FALSE;
+        }
+        status = NtQuerySystemInformation(SystemProcessInformation, buf, size, NULL);
+    }
+    while (status == STATUS_INFO_LENGTH_MISMATCH);
+
+    if (status != STATUS_SUCCESS)
+    {
+        HeapFree(GetProcessHeap(), 0, buf);
+        SetLastError(RtlNtStatusToDosError(status));
+        return FALSE;
+    }
 
+    spi = buf;
+    count = size = 0;
+    for (;;)
+    {
+        size += sizeof(WTS_PROCESS_INFOW) + spi->ProcessName.Length + sizeof(WCHAR);
+        count++;
+        if (spi->NextEntryOffset == 0) break;
+        spi = (SYSTEM_PROCESS_INFORMATION *)(((PCHAR)spi) + spi->NextEntryOffset);
+    }
+
+    processInfo = HeapAlloc(GetProcessHeap(), 0, size);
+    if (!processInfo)
+    {
+        HeapFree(GetProcessHeap(), 0, buf);
+        SetLastError(ERROR_OUTOFMEMORY);
+        return FALSE;
+    }
+    name = (WCHAR *)&processInfo[count];
+
+    *ppProcessInfo = processInfo;
+    *pCount = count;
+
+    spi = buf;
+    while (count--)
+    {
+        processInfo->SessionId = 0;
+        processInfo->ProcessId = HandleToUlong(spi->UniqueProcessId);
+        processInfo->pProcessName = name;
+        processInfo->pUserSid = NULL;
+        memcpy( name, spi->ProcessName.Buffer, spi->ProcessName.Length );
+        name[ spi->ProcessName.Length/sizeof(WCHAR) ] = 0;
+
+        processInfo++;
+        name += (spi->ProcessName.Length + sizeof(WCHAR))/sizeof(WCHAR);
+        spi = (SYSTEM_PROCESS_INFORMATION *)(((PCHAR)spi) + spi->NextEntryOffset);
+    }
+
+    HeapFree(GetProcessHeap(), 0, buf);
     return TRUE;
 }
 
@@ -159,9 +229,7 @@ BOOL WINAPI WTSEnumerateSessionsW(HANDLE hServer, DWORD Reserved, DWORD Version,
  */
 void WINAPI WTSFreeMemory(PVOID pMemory)
 {
-    static int once;
-
-    if (!once++) FIXME("Stub %p\n", pMemory);
+    HeapFree(GetProcessHeap(), 0, pMemory);
 }
 
 /************************************************************
diff --git a/fonts/Makefile.in b/fonts/Makefile.in
index 9d4ea9f..d08736d 100644
--- a/fonts/Makefile.in
+++ b/fonts/Makefile.in
@@ -1,9 +1,12 @@
 FONT_SRCS = \
+	arial.sfd \
+	cour.sfd \
 	courier.sfd \
 	fixedsys.sfd \
 	fixedsys_jp.sfd \
 	marlett.sfd \
 	ms_sans_serif.sfd \
+	msyh.sfd \
 	small_fonts.sfd \
 	small_fonts_jp.sfd \
 	symbol.sfd \
diff --git a/fonts/tahoma.ttf b/fonts/tahoma.ttf
old mode 100644
new mode 100755
index 4f68d1e..bd62e60
Binary files a/fonts/tahoma.ttf and b/fonts/tahoma.ttf differ
diff --git a/fonts/tahomabd.ttf b/fonts/tahomabd.ttf
old mode 100644
new mode 100755
index c01f9e1..0915b52
Binary files a/fonts/tahomabd.ttf and b/fonts/tahomabd.ttf differ
diff --git a/include/Makefile.in b/include/Makefile.in
index e114f9f..287fcd9 100644
--- a/include/Makefile.in
+++ b/include/Makefile.in
@@ -197,7 +197,9 @@ SRCDIR_INCLUDES = \
 	crtrow.idl \
 	cryptdlg.h \
 	cryptuiapi.h \
+	cuda.h \
 	custcntl.h \
+	cuviddec.h \
 	cvconst.h \
 	d2dbasetypes.h \
 	d2derr.h \
@@ -314,6 +316,7 @@ SRCDIR_INCLUDES = \
 	dxfile.h \
 	dxgiformat.h \
 	dxgitype.h \
+	dxva.h \
 	dyngraph.idl \
 	errorrep.h \
 	errors.h \
@@ -476,10 +479,14 @@ SRCDIR_INCLUDES = \
 	ntddstor.h \
 	ntdef.h \
 	ntdsapi.h \
+	ntifs.h \
 	ntquery.h \
 	ntsecapi.h \
 	ntsecpkg.h \
 	ntstatus.h \
+	nvapi.h \
+	nvcuvid.h \
+	nvencodeapi.h \
 	objbase.h \
 	objsel.h \
 	odbcinst.h \
diff --git a/include/commctrl.h b/include/commctrl.h
index 0bcaeb6..525f356 100644
--- a/include/commctrl.h
+++ b/include/commctrl.h
@@ -1374,6 +1374,12 @@ typedef struct tagTBADDBITMAP {
 #define HIST_ADDTOFAVORITES     3
 #define HIST_VIEWTREE           4
 
+enum _LI_METRIC
+{
+   LIM_SMALL,
+   LIM_LARGE,
+};
+
 typedef struct tagTBSAVEPARAMSA {
     HKEY   hkr;
     LPCSTR pszSubKey;
diff --git a/include/config.h.in b/include/config.h.in
index 4d7c7ac..266ec7a 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -7,6 +7,9 @@
 /* Define to a function attribute for Microsoft hotpatch assembly prefix. */
 #undef DECLSPEC_HOTPATCH
 
+/* Define if you want to enable Exagear emulator workarounds */
+#undef EXAGEAR_COMPAT
+
 /* Define to the file extension for executables. */
 #undef EXEEXT
 
@@ -38,6 +41,9 @@
 /* Define to 1 if you have the <asm/user.h> header file. */
 #undef HAVE_ASM_USER_H
 
+/* Define to 1 if you have the <attr/xattr.h> header file. */
+#undef HAVE_ATTR_XATTR_H
+
 /* Define to 1 if you have the <AudioToolbox/AudioConverter.h> header file. */
 #undef HAVE_AUDIOTOOLBOX_AUDIOCONVERTER_H
 
@@ -77,6 +83,9 @@
 /* Define to 1 if you have the <CoreServices/CoreServices.h> header file. */
 #undef HAVE_CORESERVICES_CORESERVICES_H
 
+/* Define to 1 if you have the `coshl' function. */
+#undef HAVE_COSHL
+
 /* Define to 1 if you have the <cups/cups.h> header file. */
 #undef HAVE_CUPS_CUPS_H
 
@@ -117,6 +126,9 @@
 /* Define to 1 if you have the `exp2f' function. */
 #undef HAVE_EXP2F
 
+/* Define to 1 if you have the `expl' function. */
+#undef HAVE_EXPL
+
 /* Define to 1 if you have the `fallocate' function. */
 #undef HAVE_FALLOCATE
 
@@ -651,6 +663,9 @@
 /* Define to 1 if you have the <port.h> header file. */
 #undef HAVE_PORT_H
 
+/* Define to 1 if you have the `powl' function. */
+#undef HAVE_POWL
+
 /* Define if we can use ppdev.h for parallel port access */
 #undef HAVE_PPDEV
 
@@ -687,6 +702,12 @@
 /* Define to 1 if you have the <pthread_np.h> header file. */
 #undef HAVE_PTHREAD_NP_H
 
+/* Define if you have pulseaudio */
+#undef HAVE_PULSEAUDIO
+
+/* Define to 1 if you have the <pulse/pulseaudio.h> header file. */
+#undef HAVE_PULSE_PULSEAUDIO_H
+
 /* Define to 1 if you have the <pwd.h> header file. */
 #undef HAVE_PWD_H
 
@@ -780,6 +801,9 @@
 /* Define to 1 if the system has the type `sigset_t'. */
 #undef HAVE_SIGSET_T
 
+/* Define to 1 if you have the `sinhl' function. */
+#undef HAVE_SINHL
+
 /* Define to 1 if the system has the type `size_t'. */
 #undef HAVE_SIZE_T
 
@@ -993,6 +1017,9 @@
 /* Define to 1 if you have the <sys/exec_elf.h> header file. */
 #undef HAVE_SYS_EXEC_ELF_H
 
+/* Define to 1 if you have the <sys/extattr.h> header file. */
+#undef HAVE_SYS_EXTATTR_H
+
 /* Define to 1 if you have the <sys/filio.h> header file. */
 #undef HAVE_SYS_FILIO_H
 
@@ -1125,6 +1152,9 @@
 /* Define to 1 if you have the <sys/wait.h> header file. */
 #undef HAVE_SYS_WAIT_H
 
+/* Define to 1 if you have the <sys/xattr.h> header file. */
+#undef HAVE_SYS_XATTR_H
+
 /* Define to 1 if you have the `tcdrain' function. */
 #undef HAVE_TCDRAIN
 
@@ -1158,12 +1188,21 @@
 /* Define to 1 if you have the <utime.h> header file. */
 #undef HAVE_UTIME_H
 
+/* Define if you have the libva development files */
+#undef HAVE_VAAPI
+
 /* Define to 1 if you have the <valgrind/memcheck.h> header file. */
 #undef HAVE_VALGRIND_MEMCHECK_H
 
 /* Define to 1 if you have the <valgrind/valgrind.h> header file. */
 #undef HAVE_VALGRIND_VALGRIND_H
 
+/* Define to 1 if you have the <va/va_drm.h> header file. */
+#undef HAVE_VA_VA_DRM_H
+
+/* Define to 1 if you have the <va/va_x11.h> header file. */
+#undef HAVE_VA_VA_X11_H
+
 /* Define to 1 if you have the `vsnprintf' function. */
 #undef HAVE_VSNPRINTF
 
@@ -1362,6 +1401,9 @@
 /* Define to the soname of the libOSMesa library. */
 #undef SONAME_LIBOSMESA
 
+/* Define to the soname of the libpcap library. */
+#undef SONAME_LIBPCAP
+
 /* Define to the soname of the libpng library. */
 #undef SONAME_LIBPNG
 
@@ -1371,9 +1413,21 @@
 /* Define to the soname of the libtiff library. */
 #undef SONAME_LIBTIFF
 
+/* Define to the soname of the libtxc_dxtn library. */
+#undef SONAME_LIBTXC_DXTN
+
 /* Define to the soname of the libv4l1 library. */
 #undef SONAME_LIBV4L1
 
+/* Define to the soname of the libva library. */
+#undef SONAME_LIBVA
+
+/* Define to the soname of the libva-drm library. */
+#undef SONAME_LIBVA_DRM
+
+/* Define to the soname of the libva-x11 library. */
+#undef SONAME_LIBVA_X11
+
 /* Define to the soname of the libX11 library. */
 #undef SONAME_LIBX11
 
@@ -1410,6 +1464,9 @@
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
+/* Define if xattr functions take additional arguments (Mac OS X) */
+#undef XATTR_ADDITIONAL_OPTIONS
+
 /* Define to 1 if the X Window System is missing or not being used. */
 #undef X_DISPLAY_MISSING
 
diff --git a/include/d3d9types.h b/include/d3d9types.h
index 3afcf89..6091b7f 100644
--- a/include/d3d9types.h
+++ b/include/d3d9types.h
@@ -814,23 +814,36 @@ typedef enum _D3DFORMAT {
     D3DFMT_L16                  =  81,
     D3DFMT_D32F_LOCKABLE        =  82,
     D3DFMT_D24FS8               =  83,
+    /* d3d9ex formats */
+    /* Z-Stencil formats valid for CPU access */  
+    D3DFMT_D32_LOCKABLE         =  84,
+    D3DFMT_S8_LOCKABLE          =  85,
+
 
     D3DFMT_VERTEXDATA           = 100,
     D3DFMT_INDEX16              = 101,
     D3DFMT_INDEX32              = 102,
     D3DFMT_Q16W16V16U16         = 110,
     /* Floating point formats */
+    /* s10e5 formats (16-bits per channel) */
     D3DFMT_R16F                 = 111,
-    D3DFMT_G16R16F              = 112,
+    D3DFMT_G16R16F              = 112, /* 0x70 */
     D3DFMT_A16B16G16R16F        = 113,
     
     /* IEEE formats */
+    /* IEEE s23e8 formats (32-bits per channel) */
     D3DFMT_R32F                 = 114,
     D3DFMT_G32R32F              = 115,
     D3DFMT_A32B32G32R32F        = 116,
     
     D3DFMT_CxV8U8               = 117,
-
+    /* d3d9ex formats */
+    /* Monochrome 1 bit per pixel format */
+    D3DFMT_A1                   = 118,
+    /* 2.8 biased fixed point */
+    D3DFMT_A2B10G10R10_XR_BIAS  = 119,
+    /* Binary format indicating that the data has no inherent type */
+    D3DFMT_BINARYBUFFER         = 199,
 
     D3DFMT_FORCE_DWORD          = 0xFFFFFFFF
 } D3DFORMAT;
diff --git a/include/d3dcommon.idl b/include/d3dcommon.idl
index f8fe203..8312a63 100644
--- a/include/d3dcommon.idl
+++ b/include/d3dcommon.idl
@@ -235,6 +235,18 @@ typedef enum _D3D_SHADER_VARIABLE_TYPE
     D3D_SVT_FORCE_DWORD = 0x7fffffff,
 } D3D_SHADER_VARIABLE_TYPE;
 
+typedef enum _D3D_SHADER_VARIABLE_FLAGS {
+    D3D_SVF_USERPACKED = 1,
+    D3D_SVF_USED = 2,
+    D3D_SVF_INTERFACE_POINTER = 4,
+    D3D_SVF_INTERFACE_PARAMETER = 8,
+    D3D10_SVF_USERPACKED = D3D_SVF_USERPACKED,
+    D3D10_SVF_USED = D3D_SVF_USED,
+    D3D11_SVF_INTERFACE_POINTER = D3D_SVF_INTERFACE_POINTER,
+    D3D11_SVF_INTERFACE_PARAMETER = D3D_SVF_INTERFACE_PARAMETER,
+    D3D_SVF_FORCE_DWORD = 0x7fffffff
+} D3D_SHADER_VARIABLE_FLAGS;
+
 typedef enum D3D_PRIMITIVE
 {
     D3D_PRIMITIVE_UNDEFINED,
diff --git a/include/d3dx9anim.h b/include/d3dx9anim.h
index b5f2232..c4d4d64 100644
--- a/include/d3dx9anim.h
+++ b/include/d3dx9anim.h
@@ -327,7 +327,7 @@ DECLARE_INTERFACE_(ID3DXAnimationController, IUnknown)
     STDMETHOD_(UINT, GetNumAnimationSets)(THIS) PURE;
     STDMETHOD(GetAnimationSet)(THIS_ UINT index, ID3DXAnimationSet **anim_set) PURE;
     STDMETHOD(GetAnimationSetByName)(THIS_ const char *name, ID3DXAnimationSet **anim_set) PURE;
-    STDMETHOD(AdvanceTime)(THIS_ double time_delta, ID3DXAnimationCallbackHandler **callback_handler) PURE;
+    STDMETHOD(AdvanceTime)(THIS_ DOUBLE time_delta, ID3DXAnimationCallbackHandler **callback_handler) PURE;
     STDMETHOD(ResetTime)(THIS) PURE;
     STDMETHOD_(DOUBLE, GetTime)(THIS) PURE;
     STDMETHOD(SetTrackAnimationSet)(THIS_ UINT track, ID3DXAnimationSet *anim_set) PURE;
@@ -337,8 +337,8 @@ DECLARE_INTERFACE_(ID3DXAnimationController, IUnknown)
     STDMETHOD(SetTrackWeight)(THIS_ UINT track, FLOAT weight) PURE;
     STDMETHOD(SetTrackPosition)(THIS_ UINT track, DOUBLE position) PURE;
     STDMETHOD(SetTrackEnable)(THIS_ UINT track, BOOL enable) PURE;
-    STDMETHOD(SetTrackDesc)(THIS_ UINT track, LPD3DXTRACK_DESC desc) PURE;
-    STDMETHOD(GetTrackDesc)(THIS_ UINT track, LPD3DXTRACK_DESC desc) PURE;
+    STDMETHOD(SetTrackDesc)(THIS_ UINT track, D3DXTRACK_DESC *desc) PURE;
+    STDMETHOD(GetTrackDesc)(THIS_ UINT track, D3DXTRACK_DESC *desc) PURE;
     STDMETHOD(SetPriorityBlend)(THIS_ FLOAT blend_weight) PURE;
     STDMETHOD_(FLOAT, GetPriorityBlend)(THIS) PURE;
     STDMETHOD_(D3DXEVENTHANDLE, KeyTrackSpeed)(THIS_ UINT track, FLOAT new_speed,
@@ -357,7 +357,7 @@ DECLARE_INTERFACE_(ID3DXAnimationController, IUnknown)
     STDMETHOD_(D3DXEVENTHANDLE, GetUpcomingTrackEvent)(THIS_ UINT track, D3DXEVENTHANDLE event) PURE;
     STDMETHOD_(D3DXEVENTHANDLE, GetUpcomingPriorityBlend)(THIS_ D3DXEVENTHANDLE handle) PURE;
     STDMETHOD(ValidateEvent)(THIS_ D3DXEVENTHANDLE event) PURE;
-    STDMETHOD(GetEventDesc)(THIS_ D3DXEVENTHANDLE event, LPD3DXEVENT_DESC desc) PURE;
+    STDMETHOD(GetEventDesc)(THIS_ D3DXEVENTHANDLE event, D3DXEVENT_DESC *desc) PURE;
     STDMETHOD(CloneAnimationController)(THIS_ UINT max_num_anim_outputs, UINT max_num_anim_sets,
             UINT max_num_tracks, UINT max_num_events, ID3DXAnimationController **anim_controller) PURE;
 };
diff --git a/include/d3dx9effect.h b/include/d3dx9effect.h
index 25d1fd2..3f527ed 100644
--- a/include/d3dx9effect.h
+++ b/include/d3dx9effect.h
@@ -425,6 +425,8 @@ HRESULT WINAPI D3DXCreateEffectCompilerFromResourceW(HMODULE srcmodule, const WC
         ID3DXEffectCompiler **effectcompiler, ID3DXBuffer **parseerrors);
 #define D3DXCreateEffectCompilerFromResource WINELIB_NAME_AW(D3DXCreateEffectCompilerFromResource)
 
+HRESULT WINAPI D3DXDisassembleEffect(ID3DXEffect *effect, BOOL enable_color_code, ID3DXBuffer **disassembly);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/include/d3dx9shader.h b/include/d3dx9shader.h
index d665f72..f565432 100644
--- a/include/d3dx9shader.h
+++ b/include/d3dx9shader.h
@@ -315,6 +315,7 @@ DWORD WINAPI D3DXGetShaderVersion(const DWORD *byte_code);
 const char * WINAPI D3DXGetVertexShaderProfile(struct IDirect3DDevice9 *device);
 HRESULT WINAPI D3DXFindShaderComment(const DWORD *byte_code, DWORD fourcc, const void **data, UINT *size);
 HRESULT WINAPI D3DXGetShaderSamplers(const DWORD *byte_code, const char **samplers, UINT *count);
+HRESULT WINAPI D3DXGetShaderInputSemantics(const DWORD *byte_code, D3DXSEMANTIC *semantics, UINT *count);
 
 HRESULT WINAPI D3DXAssembleShaderFromFileA(const char *filename, const D3DXMACRO *defines,
         ID3DXInclude *include, DWORD flags, ID3DXBuffer **shader, ID3DXBuffer **error_messages);
diff --git a/include/d3dx9tex.h b/include/d3dx9tex.h
index 542460f..fbe8ae6 100644
--- a/include/d3dx9tex.h
+++ b/include/d3dx9tex.h
@@ -185,6 +185,8 @@ HRESULT WINAPI D3DXSaveVolumeToFileA(const char *destfile, D3DXIMAGE_FILEFORMAT
         struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *srcpalette, const D3DBOX *srcbox);
 HRESULT WINAPI D3DXSaveVolumeToFileW(const WCHAR *destfile, D3DXIMAGE_FILEFORMAT destformat,
         struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *srcpalette, const D3DBOX *srcbox);
+HRESULT WINAPI D3DXSaveVolumeToFileInMemory(ID3DXBuffer **dst_buffer, D3DXIMAGE_FILEFORMAT file_format,
+        struct IDirect3DVolume9 *srcvolume, const PALETTEENTRY *srcpalette, const D3DBOX *srcbox);
 #define D3DXSaveVolumeToFile WINELIB_NAME_AW(D3DXSaveVolumeToFile)
 
 
diff --git a/include/ddk/wdm.h b/include/ddk/wdm.h
index c234375..7ec56cf 100644
--- a/include/ddk/wdm.h
+++ b/include/ddk/wdm.h
@@ -31,6 +31,7 @@
 typedef LONG KPRIORITY;
 
 typedef ULONG_PTR KSPIN_LOCK, *PKSPIN_LOCK;
+typedef ULONG_PTR ERESOURCE_THREAD, *PERESOURCE_THREAD;
 
 struct _KDPC;
 struct _KAPC;
@@ -1211,6 +1212,7 @@ void      WINAPI IoDeleteDriver(DRIVER_OBJECT*);
 NTSTATUS  WINAPI IoDeleteSymbolicLink(UNICODE_STRING*);
 void      WINAPI IoFreeIrp(IRP*);
 void      WINAPI IoFreeMdl(MDL*);
+PDEVICE_OBJECT WINAPI IoGetAttachedDeviceReference(PDEVICE_OBJECT);
 PEPROCESS WINAPI IoGetCurrentProcess(void);
 NTSTATUS  WINAPI IoGetDeviceInterfaces(const GUID*,PDEVICE_OBJECT,ULONG,PWSTR*);
 NTSTATUS  WINAPI IoGetDeviceObjectPointer(UNICODE_STRING*,ACCESS_MASK,PFILE_OBJECT*,PDEVICE_OBJECT*);
@@ -1221,6 +1223,7 @@ void      WINAPI IoInitializeIrp(IRP*,USHORT,CCHAR);
 VOID      WINAPI IoInitializeRemoveLockEx(PIO_REMOVE_LOCK,ULONG,ULONG,ULONG,ULONG);
 NTSTATUS  WINAPI IoWMIRegistrationControl(PDEVICE_OBJECT,ULONG);
 
+NTSTATUS  WINAPI KeDelayExecutionThread(KPROCESSOR_MODE,BOOLEAN,PLARGE_INTEGER);
 PKTHREAD  WINAPI KeGetCurrentThread(void);
 void      WINAPI KeQuerySystemTime(LARGE_INTEGER*);
 void      WINAPI KeQueryTickCount(LARGE_INTEGER*);
@@ -1237,7 +1240,9 @@ PMDL      WINAPI MmAllocatePagesForMdl(PHYSICAL_ADDRESS,PHYSICAL_ADDRESS,PHYSICA
 void      WINAPI MmFreeNonCachedMemory(PVOID,SIZE_T);
 MM_SYSTEMSIZE WINAPI MmQuerySystemSize(void);
 
+void      WINAPI ObDereferenceObject(VOID*);
 NTSTATUS  WINAPI ObReferenceObjectByHandle(HANDLE,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE,PVOID*,POBJECT_HANDLE_INFORMATION);
+NTSTATUS  WINAPI ObReferenceObjectByPointer(VOID*,ACCESS_MASK,POBJECT_TYPE,KPROCESSOR_MODE);
 
 POWER_STATE WINAPI PoSetPowerState(PDEVICE_OBJECT,POWER_STATE_TYPE,POWER_STATE);
 NTSTATUS  WINAPI PsCreateSystemThread(PHANDLE,ULONG,POBJECT_ATTRIBUTES,HANDLE,PCLIENT_ID,PKSTART_ROUTINE,PVOID);
@@ -1337,6 +1342,7 @@ NTSTATUS  WINAPI ZwSetInformationObject(HANDLE, OBJECT_INFORMATION_CLASS, PVOID,
 NTSTATUS  WINAPI ZwSetInformationProcess(HANDLE,PROCESS_INFORMATION_CLASS,PVOID,ULONG);
 NTSTATUS  WINAPI ZwSetInformationThread(HANDLE,THREADINFOCLASS,LPCVOID,ULONG);
 NTSTATUS  WINAPI ZwSetIoCompletion(HANDLE,ULONG,ULONG,NTSTATUS,ULONG);
+NTSTATUS  WINAPI ZwSetLdtEntries(ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
 NTSTATUS  WINAPI ZwSetSecurityObject(HANDLE,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
 NTSTATUS  WINAPI ZwSetSystemInformation(SYSTEM_INFORMATION_CLASS,PVOID,ULONG);
 NTSTATUS  WINAPI ZwSetSystemTime(const LARGE_INTEGER*,LARGE_INTEGER*);
diff --git a/include/dxva2api.idl b/include/dxva2api.idl
index ebd508b..7388b37 100644
--- a/include/dxva2api.idl
+++ b/include/dxva2api.idl
@@ -86,6 +86,11 @@ cpp_quote("#define DXVA2_ModeVC1_VLD           DXVA2_ModeVC1_D")
 /* Encryption */
 cpp_quote("DEFINE_GUID(DXVA_NoEncrypt,         0x1b81bed0, 0xa0c7,0x11d3, 0xb9,0x84,0x00,0xc0,0x4f,0x2e,0x73,0xc5);")
 
+/* Video Processor */
+cpp_quote("DEFINE_GUID(DXVA2_VideoProcProgressiveDevice, 0x5a54a0c9, 0xc7ec,0x4bd9, 0x8e, 0xde, 0xf3, 0xc7, 0x5d, 0xc4, 0x39, 0x3b);")
+cpp_quote("DEFINE_GUID(DXVA2_VideoProcBobDevice,         0x335aa36e, 0x7884,0x43a4, 0x9c, 0x91, 0x7f, 0x87, 0xfa, 0xf3, 0xe3, 0x7e);")
+cpp_quote("DEFINE_GUID(DXVA2_VideoProcSoftwareDevice,    0x4553d47f, 0xee7e,0x4e3f, 0x94, 0x75, 0xdb, 0xf1, 0x37, 0x6c, 0x48, 0x10);")
+
 typedef LONGLONG REFERENCE_TIME;
 
 enum
@@ -434,7 +439,7 @@ interface IDirectXVideoDecoder : IUnknown
  */
 [
     object,
-    uuid(fc51a551-d5e7-11d9-af55-00054e43ff02),
+    uuid(fc51a552-d5e7-11d9-af55-00054e43ff02),
     local
 ]
 interface IDirectXVideoProcessorService : IDirectXVideoAccelerationService
diff --git a/include/mfapi.h b/include/mfapi.h
index 929a36d..49a86ac 100644
--- a/include/mfapi.h
+++ b/include/mfapi.h
@@ -24,8 +24,8 @@
 #define MFSTARTUP_FULL     0
 
 typedef struct _MFT_REGISTER_TYPE_INFO {
-  GUID major_type;
-  GUID sub_type;
+  GUID guidMajorType;
+  GUID guidSubtype;
 } MFT_REGISTER_TYPE_INFO;
 
 typedef unsigned __int64 MFWORKITEM_KEY;
diff --git a/include/winbase.h b/include/winbase.h
index f845082..f8db4e5 100644
--- a/include/winbase.h
+++ b/include/winbase.h
@@ -805,6 +805,68 @@ typedef enum _FILE_INFO_BY_HANDLE_CLASS {
     MaximumFileInfoByHandlesClass
 } FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;
 
+typedef struct _FILE_BASIC_INFO {
+    LARGE_INTEGER CreationTime;
+    LARGE_INTEGER LastAccessTime;
+    LARGE_INTEGER LastWriteTime;
+    LARGE_INTEGER ChangeTime;
+    DWORD FileAttributes;
+} FILE_BASIC_INFO, *PFILE_BASIC_INFO;
+
+typedef struct _FILE_STANDARD_INFO {
+    LARGE_INTEGER AllocationSize;
+    LARGE_INTEGER EndOfFile;
+    DWORD NumberOfLinks;
+    BOOLEAN DeletePending;
+    BOOLEAN Directory;
+} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;
+
+typedef struct _FILE_NAME_INFO {
+    DWORD FileNameLength;
+    WCHAR FileName[1];
+} FILE_NAME_INFO, *PFILE_NAME_INFO;
+
+typedef struct _FILE_RENAME_INFO {
+    BOOLEAN ReplaceIfExists;
+    HANDLE RootDirectory;
+    DWORD FileNameLength;
+    WCHAR FileName[1];
+} FILE_RENAME_INFO, *PFILE_RENAME_INFO;
+
+typedef struct _FILE_DISPOSITION_INFO {
+    BOOLEAN DoDeleteFile;
+} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;
+
+typedef struct _FILE_ALLOCATION_INFO {
+    LARGE_INTEGER AllocationSize;
+} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;
+
+typedef struct _FILE_END_OF_FILE_INFO {
+    LARGE_INTEGER EndOfFile;
+} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;
+
+typedef struct _FILE_STREAM_INFO {
+    DWORD NextEntryOffset;
+    DWORD StreamNameLength;
+    LARGE_INTEGER StreamSize;
+    LARGE_INTEGER StreamAllocationSize;
+    WCHAR StreamName[1];
+} FILE_STREAM_INFO, *PFILE_STREAM_INFO;
+
+typedef struct _FILE_COMPRESSION_INFO {
+    LARGE_INTEGER CompressedFileSize;
+    WORD CompressionFormat;
+    UCHAR CompressionUnitShift;
+    UCHAR ChunkShift;
+    UCHAR ClusterShift;
+    UCHAR Reserved[3];
+} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;
+
+typedef struct _FILE_ATTRIBUTE_TAG_INFO {
+    DWORD FileAttributes;
+    DWORD ReparseTag;
+} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;
+
 typedef struct _FILE_ID_BOTH_DIR_INFO {
     DWORD         NextEntryOffset;
     DWORD         FileIndex;
@@ -823,6 +885,32 @@ typedef struct _FILE_ID_BOTH_DIR_INFO {
     WCHAR         FileName[1];
 } FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;
 
+typedef struct _FILE_FULL_DIR_INFO {
+    ULONG NextEntryOffset;
+    ULONG FileIndex;
+    LARGE_INTEGER CreationTime;
+    LARGE_INTEGER LastAccessTime;
+    LARGE_INTEGER LastWriteTime;
+    LARGE_INTEGER ChangeTime;
+    LARGE_INTEGER EndOfFile;
+    LARGE_INTEGER AllocationSize;
+    ULONG FileAttributes;
+    ULONG FileNameLength;
+    ULONG EaSize;
+    WCHAR FileName[1];
+} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;
+
+typedef enum _PRIORITY_HINT {
+    IoPriorityHintVeryLow = 0,
+    IoPriorityHintLow,
+    IoPriorityHintNormal,
+    MaximumIoPriorityHintType
+} PRIORITY_HINT;
+
+typedef struct _FILE_IO_PRIORITY_HINT_INFO {
+  PRIORITY_HINT PriorityHint;
+} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;
+
 #define PIPE_ACCESS_INBOUND  1
 #define PIPE_ACCESS_OUTBOUND 2
 #define PIPE_ACCESS_DUPLEX   3
@@ -1968,6 +2056,7 @@ WINBASEAPI BOOL        WINAPI GetNamedPipeHandleStateW(HANDLE,LPDWORD,LPDWORD,LP
 #define                       GetNamedPipeHandleState WINELIB_NAME_AW(GetNamedPipeHandleState)
 WINBASEAPI BOOL        WINAPI GetNamedPipeInfo(HANDLE,LPDWORD,LPDWORD,LPDWORD,LPDWORD);
 WINBASEAPI VOID        WINAPI GetNativeSystemInfo(LPSYSTEM_INFO);
+WINBASEAPI BOOL        WINAPI GetNumaProcessorNode(UCHAR, PUCHAR);
 WINADVAPI  BOOL        WINAPI GetNumberOfEventLogRecords(HANDLE,PDWORD);
 WINADVAPI  BOOL        WINAPI GetOldestEventLogRecord(HANDLE,PDWORD);
 WINBASEAPI BOOL        WINAPI GetOverlappedResult(HANDLE,LPOVERLAPPED,LPDWORD,BOOL);
@@ -2375,6 +2464,7 @@ WINBASEAPI VOID        WINAPI SetFileApisToOEM(void);
 WINBASEAPI BOOL        WINAPI SetFileAttributesA(LPCSTR,DWORD);
 WINBASEAPI BOOL        WINAPI SetFileAttributesW(LPCWSTR,DWORD);
 #define                       SetFileAttributes WINELIB_NAME_AW(SetFileAttributes)
+WINBASEAPI BOOL        WINAPI SetFileInformationByHandle(HANDLE,FILE_INFO_BY_HANDLE_CLASS,LPVOID,DWORD);
 WINBASEAPI DWORD       WINAPI SetFilePointer(HANDLE,LONG,LPLONG,DWORD);
 WINBASEAPI BOOL        WINAPI SetFilePointerEx(HANDLE,LARGE_INTEGER,LARGE_INTEGER*,DWORD);
 WINADVAPI  BOOL        WINAPI SetFileSecurityA(LPCSTR,SECURITY_INFORMATION,PSECURITY_DESCRIPTOR);
diff --git a/include/windef.h b/include/windef.h
index e914726..47de414 100644
--- a/include/windef.h
+++ b/include/windef.h
@@ -86,10 +86,17 @@ extern "C" {
 
 #ifndef __ms_va_list
 # if defined(__x86_64__) && defined (__GNUC__)
+#   if defined(__APPLE__)
+#     define __ms_va_list __builtin_va_list
+#     define __ms_va_start(list,arg) __builtin_va_start(list,arg)
+#     define __ms_va_end(list) __builtin_va_end(list)
+#     define __ms_va_copy(dest,src) __builtin_va_copy(dest,src)
+#   else  
 #  define __ms_va_list __builtin_ms_va_list
 #  define __ms_va_start(list,arg) __builtin_ms_va_start(list,arg)
 #  define __ms_va_end(list) __builtin_ms_va_end(list)
 #  define __ms_va_copy(dest,src) __builtin_ms_va_copy(dest,src)
+#  endif
 # else
 #  define __ms_va_list va_list
 #  define __ms_va_start(list,arg) va_start(list,arg)
diff --git a/include/wine/library.h b/include/wine/library.h
index 242bb69..7395a11 100644
--- a/include/wine/library.h
+++ b/include/wine/library.h
@@ -40,9 +40,11 @@ extern "C" {
 extern const char *wine_get_build_dir(void);
 extern const char *wine_get_config_dir(void);
 extern const char *wine_get_data_dir(void);
+extern const char **wine_get_libs(void);
 extern const char *wine_get_server_dir(void);
 extern const char *wine_get_user_name(void);
 extern const char *wine_get_version(void);
+extern const void *wine_get_patches(void);
 extern const char *wine_get_build_id(void);
 extern void wine_init_argv0_path( const char *argv0 );
 extern void wine_exec_wine_binary( const char *name, char **argv, const char *env_var );
@@ -51,6 +53,7 @@ extern void wine_exec_wine_binary( const char *name, char **argv, const char *en
 
 typedef void (*load_dll_callback_t)( void *, const char * );
 
+extern int wine_dladdr( void *addr, void *info, char *error, size_t errorsize );
 extern void *wine_dlopen( const char *filename, int flag, char *error, size_t errorsize );
 extern void *wine_dlsym( void *handle, const char *symbol, char *error, size_t errorsize );
 extern int wine_dlclose( void *handle, char *error, size_t errorsize );
diff --git a/include/wine/port.h b/include/wine/port.h
index 3548a44..71be265 100644
--- a/include/wine/port.h
+++ b/include/wine/port.h
@@ -363,6 +363,22 @@ extern int mkstemps(char *template, int suffix_len);
 extern int _spawnvp(int mode, const char *cmdname, const char * const argv[]);
 #endif
 
+/* Extended attribute functions */
+
+#ifndef XATTR_USER_PREFIX
+# define XATTR_USER_PREFIX "user."
+#endif
+#ifndef XATTR_SIZE_MAX
+# define XATTR_SIZE_MAX    65536
+#endif
+
+extern int xattr_fget( int filedes, const char *name, void *value, size_t size );
+extern int xattr_fremove( int filedes, const char *name );
+extern int xattr_fset( int filedes, const char *name, void *value, size_t size );
+extern int xattr_get( const char *path, const char *name, void *value, size_t size );
+extern int xattr_remove( const char *path, const char *name );
+extern int xattr_set( const char *path, const char *name, void *value, size_t size );
+
 /* Interlocked functions */
 
 #if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
diff --git a/include/wine/server.h b/include/wine/server.h
index d573d1f..9d3c315 100644
--- a/include/wine/server.h
+++ b/include/wine/server.h
@@ -52,6 +52,7 @@ struct __server_request_info
 extern unsigned int wine_server_call( void *req_ptr );
 extern void CDECL wine_server_send_fd( int fd );
 extern int CDECL wine_server_fd_to_handle( int fd, unsigned int access, unsigned int attributes, HANDLE *handle );
+extern int CDECL wine_server_handle_exists( HANDLE handle, unsigned int access );
 extern int CDECL wine_server_handle_to_fd( HANDLE handle, unsigned int access, int *unix_fd, unsigned int *options );
 extern void CDECL wine_server_release_fd( HANDLE handle, int unix_fd );
 
@@ -120,6 +121,17 @@ static inline void *wine_server_get_ptr( client_ptr_t ptr )
     return (void *)(ULONG_PTR)ptr;
 }
 
+/* returns a pointer to the wineserver global shared memory block */
+static inline shmglobal_t *wine_get_shmglobal(void)
+{
+    return (shmglobal_t *)NtCurrentTeb()->Reserved5[0];
+}
+
+/* returns a pointer to the wineserver local shared memory block */
+static inline shmlocal_t *wine_get_shmlocal(void)
+{
+    return (shmlocal_t *)NtCurrentTeb()->Reserved5[1];
+}
 
 /* macros for server requests */
 
diff --git a/include/wine/server_protocol.h b/include/wine/server_protocol.h
index d27914a..e5b8bda 100644
--- a/include/wine/server_protocol.h
+++ b/include/wine/server_protocol.h
@@ -54,6 +54,21 @@ struct request_max_size
 #define LAST_USER_HANDLE  0xffef
 
 
+typedef struct
+{
+    unsigned int last_input_time;
+    unsigned int foreground_wnd_epoch;
+} shmglobal_t;
+
+
+typedef struct
+{
+    int             queue_bits;
+    user_handle_t   input_focus;
+    user_handle_t   input_capture;
+    user_handle_t   input_active;
+} shmlocal_t;
+
 
 typedef union
 {
@@ -658,9 +673,13 @@ struct new_process_request
     unsigned int thread_attr;
     cpu_type_t   cpu;
     data_size_t  info_size;
+    data_size_t  env_size;
+    data_size_t  process_sd_size;
     /* VARARG(info,startup_info,info_size); */
-    /* VARARG(env,unicode_str); */
-    char __pad_52[4];
+    /* VARARG(env,unicode_str,env_size); */
+    /* VARARG(process_sd,security_descriptor,process_sd_size); */
+    /* VARARG(thread_sd,security_descriptor); */
+    char __pad_60[4];
 };
 struct new_process_reply
 {
@@ -836,6 +855,22 @@ struct set_process_info_reply
 
 
 
+struct get_thread_times_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct get_thread_times_reply
+{
+    struct reply_header __header;
+    timeout_t    creation_time;
+    timeout_t    exit_time;
+    int          unix_pid;
+    int          unix_tid;
+};
+
+
+
 struct get_thread_info_request
 {
     struct request_header __header;
@@ -1400,6 +1435,18 @@ enum server_fd_type
 
 
 
+struct get_shared_memory_request
+{
+    struct request_header __header;
+    thread_id_t tid;
+};
+struct get_shared_memory_reply
+{
+    struct reply_header __header;
+};
+
+
+
 struct flush_file_request
 {
     struct request_header __header;
@@ -1446,6 +1493,19 @@ struct unlock_file_reply
 
 
 
+struct set_file_info_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+    int          unlink;
+    char __pad_20[4];
+};
+struct set_file_info_reply
+{
+    struct reply_header __header;
+};
+
+
 struct create_socket_request
 {
     struct request_header __header;
@@ -1496,6 +1556,18 @@ struct accept_into_socket_reply
 
 
 
+struct reuse_socket_request
+{
+    struct request_header __header;
+    obj_handle_t handle;
+};
+struct reuse_socket_reply
+{
+    struct reply_header __header;
+};
+
+
+
 struct set_socket_event_request
 {
     struct request_header __header;
@@ -1543,6 +1615,7 @@ struct get_socket_info_reply
     int type;
     int protocol;
     char __pad_20[4];
+    timeout_t connect_time;
 };
 
 
@@ -2101,8 +2174,16 @@ struct get_mapping_info_reply
     int          protect;
     int          header_size;
     client_ptr_t base;
+    client_ptr_t entry;
+    short int    subsystem;
+    short int    major_subsystem;
+    short int    minor_subsystem;
+    short int    characteristics;
+    short int    dll_characteristics;
+    short int    machine;
     obj_handle_t mapping;
     obj_handle_t shared_file;
+    char __pad_60[4];
 };
 
 
@@ -3175,8 +3256,8 @@ struct create_named_pipe_request
 struct create_named_pipe_reply
 {
     struct reply_header __header;
+    unsigned int   flags;
     obj_handle_t   handle;
-    char __pad_12[4];
 };
 
 
@@ -5182,6 +5263,7 @@ enum request
     REQ_terminate_thread,
     REQ_get_process_info,
     REQ_set_process_info,
+    REQ_get_thread_times,
     REQ_get_thread_info,
     REQ_set_thread_info,
     REQ_get_dll_info,
@@ -5215,12 +5297,15 @@ enum request
     REQ_alloc_file_handle,
     REQ_get_handle_unix_name,
     REQ_get_handle_fd,
+    REQ_get_shared_memory,
     REQ_flush_file,
     REQ_lock_file,
     REQ_unlock_file,
+    REQ_set_file_info,
     REQ_create_socket,
     REQ_accept_socket,
     REQ_accept_into_socket,
+    REQ_reuse_socket,
     REQ_set_socket_event,
     REQ_get_socket_event,
     REQ_get_socket_info,
@@ -5451,6 +5536,7 @@ union generic_request
     struct terminate_thread_request terminate_thread_request;
     struct get_process_info_request get_process_info_request;
     struct set_process_info_request set_process_info_request;
+    struct get_thread_times_request get_thread_times_request;
     struct get_thread_info_request get_thread_info_request;
     struct set_thread_info_request set_thread_info_request;
     struct get_dll_info_request get_dll_info_request;
@@ -5484,12 +5570,15 @@ union generic_request
     struct alloc_file_handle_request alloc_file_handle_request;
     struct get_handle_unix_name_request get_handle_unix_name_request;
     struct get_handle_fd_request get_handle_fd_request;
+    struct get_shared_memory_request get_shared_memory_request;
     struct flush_file_request flush_file_request;
     struct lock_file_request lock_file_request;
     struct unlock_file_request unlock_file_request;
+    struct set_file_info_request set_file_info_request;
     struct create_socket_request create_socket_request;
     struct accept_socket_request accept_socket_request;
     struct accept_into_socket_request accept_into_socket_request;
+    struct reuse_socket_request reuse_socket_request;
     struct set_socket_event_request set_socket_event_request;
     struct get_socket_event_request get_socket_event_request;
     struct get_socket_info_request get_socket_info_request;
@@ -5718,6 +5807,7 @@ union generic_reply
     struct terminate_thread_reply terminate_thread_reply;
     struct get_process_info_reply get_process_info_reply;
     struct set_process_info_reply set_process_info_reply;
+    struct get_thread_times_reply get_thread_times_reply;
     struct get_thread_info_reply get_thread_info_reply;
     struct set_thread_info_reply set_thread_info_reply;
     struct get_dll_info_reply get_dll_info_reply;
@@ -5751,12 +5841,15 @@ union generic_reply
     struct alloc_file_handle_reply alloc_file_handle_reply;
     struct get_handle_unix_name_reply get_handle_unix_name_reply;
     struct get_handle_fd_reply get_handle_fd_reply;
+    struct get_shared_memory_reply get_shared_memory_reply;
     struct flush_file_reply flush_file_reply;
     struct lock_file_reply lock_file_reply;
     struct unlock_file_reply unlock_file_reply;
+    struct set_file_info_reply set_file_info_reply;
     struct create_socket_reply create_socket_reply;
     struct accept_socket_reply accept_socket_reply;
     struct accept_into_socket_reply accept_into_socket_reply;
+    struct reuse_socket_reply reuse_socket_reply;
     struct set_socket_event_reply set_socket_event_reply;
     struct get_socket_event_reply get_socket_event_reply;
     struct get_socket_info_reply get_socket_info_reply;
@@ -5972,6 +6065,6 @@ union generic_reply
     struct terminate_job_reply terminate_job_reply;
 };
 
-#define SERVER_PROTOCOL_VERSION 467
+#define SERVER_PROTOCOL_VERSION 468
 
 #endif /* __WINE_WINE_SERVER_PROTOCOL_H */
diff --git a/include/wine/test.h b/include/wine/test.h
index 567229a..cb9018d 100644
--- a/include/wine/test.h
+++ b/include/wine/test.h
@@ -61,7 +61,13 @@ extern int winetest_loop_todo(void);
 extern void winetest_end_todo( const char* platform );
 extern int winetest_get_mainargs( char*** pargv );
 extern LONG winetest_get_failures(void);
+extern int winetest_get_report_success(void);
+extern int winetest_get_debug(void);
 extern void winetest_add_failures( LONG new_failures );
+extern void winetest_add_successes( LONG new_successes );
+extern void winetest_add_todo_failures( LONG new_todo_failures );
+extern void winetest_add_todo_successes( LONG new_todo_successes );
+extern void winetest_add_skipped( LONG new_skipped );
 extern void winetest_wait_child_process( HANDLE process );
 
 extern const char *wine_dbgstr_wn( const WCHAR *str, int n );
@@ -436,10 +442,39 @@ LONG winetest_get_failures(void)
     return failures;
 }
 
+int winetest_get_report_success(void)
+{
+    return report_success;
+}
+
+int winetest_get_debug(void)
+{
+    return winetest_debug;
+}
+
 void winetest_add_failures( LONG new_failures )
 {
-    while (new_failures-- > 0)
-        InterlockedIncrement( &failures );
+    InterlockedExchangeAdd( &failures, new_failures );
+}
+
+void winetest_add_successes( LONG new_successes )
+{
+    InterlockedExchangeAdd( &successes, new_successes );
+}
+
+void winetest_add_todo_failures( LONG new_todo_failures )
+{
+    InterlockedExchangeAdd( &todo_failures, new_todo_failures );
+}
+
+void winetest_add_todo_successes( LONG new_todo_successes )
+{
+    InterlockedExchangeAdd( &todo_successes, new_todo_successes );
+}
+
+void winetest_add_skipped( LONG new_skipped )
+{
+    InterlockedExchangeAdd( &skipped, new_skipped );
 }
 
 void winetest_wait_child_process( HANDLE process )
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index 8bc4c25..c529552 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -135,7 +135,9 @@ enum wined3d_format_id
     WINED3DFMT_R8G8_SNORM_L8X8_UNORM,
     WINED3DFMT_R10G11B11_SNORM,
     WINED3DFMT_R10G10B10_SNORM_A2_UNORM,
+    WINED3DFMT_D32_LOCKABLE,
     WINED3DFMT_D16_LOCKABLE,
+    WINED3DFMT_S8_LOCKABLE,
     WINED3DFMT_D32_UNORM,
     WINED3DFMT_S1_UINT_D15_UNORM,
     WINED3DFMT_X8D24_UNORM,
@@ -251,6 +253,9 @@ enum wined3d_format_id
     WINED3DFMT_NVDB                         = WINEMAKEFOURCC('N','V','D','B'),
     WINED3DFMT_NVHU                         = WINEMAKEFOURCC('N','V','H','U'),
     WINED3DFMT_NVHS                         = WINEMAKEFOURCC('N','V','H','S'),
+    WINED3DFMT_DF16                         = WINEMAKEFOURCC('D','F','1','6'),
+    WINED3DFMT_DF24                         = WINEMAKEFOURCC('D','F','2','4'),
+
     WINED3DFMT_INTZ                         = WINEMAKEFOURCC('I','N','T','Z'),
     WINED3DFMT_RESZ                         = WINEMAKEFOURCC('R','E','S','Z'),
     WINED3DFMT_NULL                         = WINEMAKEFOURCC('N','U','L','L'),
@@ -2426,6 +2431,8 @@ static inline HRESULT wined3d_private_store_set_private_data(struct wined3d_priv
 void __cdecl wined3d_resource_get_desc(const struct wined3d_resource *resource,
         struct wined3d_resource_desc *desc);
 void * __cdecl wined3d_resource_get_parent(const struct wined3d_resource *resource);
+void __cdecl wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch);
 DWORD __cdecl wined3d_resource_get_priority(const struct wined3d_resource *resource);
 void __cdecl wined3d_resource_set_parent(struct wined3d_resource *resource, void *parent);
 DWORD __cdecl wined3d_resource_set_priority(struct wined3d_resource *resource, DWORD priority);
@@ -2484,7 +2491,6 @@ HRESULT __cdecl wined3d_surface_get_blt_status(const struct wined3d_surface *sur
 HRESULT __cdecl wined3d_surface_get_flip_status(const struct wined3d_surface *surface, DWORD flags);
 HRESULT __cdecl wined3d_surface_get_overlay_position(const struct wined3d_surface *surface, LONG *x, LONG *y);
 void * __cdecl wined3d_surface_get_parent(const struct wined3d_surface *surface);
-DWORD __cdecl wined3d_surface_get_pitch(const struct wined3d_surface *surface);
 HRESULT __cdecl wined3d_surface_get_render_target_data(struct wined3d_surface *surface,
         struct wined3d_surface *render_target);
 struct wined3d_resource * __cdecl wined3d_surface_get_resource(struct wined3d_surface *surface);
@@ -2606,4 +2612,18 @@ static inline unsigned int wined3d_log2i(unsigned int x)
 #endif
 }
 
+BOOL wined3d_dxt1_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt1_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt3_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt3_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt5_decode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxt5_encode(const BYTE *src, BYTE *dst, DWORD pitch_in, DWORD pitch_out,
+                         enum wined3d_format_id format, unsigned int w, unsigned int h);
+BOOL wined3d_dxtn_supported(void);
+
 #endif /* __WINE_WINED3D_H */
diff --git a/include/winerror.h b/include/winerror.h
index 2958cbd..9b9fb72 100644
--- a/include/winerror.h
+++ b/include/winerror.h
@@ -2090,6 +2090,7 @@ static inline HRESULT HRESULT_FROM_WIN32(unsigned int x)
 #define S_FALSE                                            _HRESULT_TYPEDEF_(1)
 
 #define E_PENDING                                          _HRESULT_TYPEDEF_(0x8000000A)
+#define E_BOUNDS                                           _HRESULT_TYPEDEF_(0x8000000B)
 
 
 #define E_NOTIMPL                                          _HRESULT_TYPEDEF_(0x80004001)
diff --git a/include/winineti.h b/include/winineti.h
index 5b6f15f..5e38424 100644
--- a/include/winineti.h
+++ b/include/winineti.h
@@ -120,6 +120,7 @@ BOOL        WINAPI InternetQueryFortezzaStatus(DWORD*,DWORD_PTR);
 BOOL        WINAPI IsUrlCacheEntryExpiredA(LPCSTR,DWORD,FILETIME*);
 BOOL        WINAPI IsUrlCacheEntryExpiredW(LPCWSTR,DWORD,FILETIME*);
 #define     IsUrlCacheEntryExpired WINELIB_NAME_AW(IsUrlCacheEntryExpired)
+DWORD       WINAPI ParseX509EncodedCertificateForListBoxEntry(LPBYTE,DWORD,LPSTR,LPDWORD);
 BOOL        WINAPI SetUrlCacheConfigInfoA(LPINTERNET_CACHE_CONFIG_INFOA,DWORD);
 BOOL        WINAPI SetUrlCacheConfigInfoW(LPINTERNET_CACHE_CONFIG_INFOW,DWORD);
 #define     SetUrlCacheConfigInfo WINELIB_NAME_AW(SetUrlCacheConfigInfo)
diff --git a/include/winnt.h b/include/winnt.h
index 9b08544..3af1aa5 100644
--- a/include/winnt.h
+++ b/include/winnt.h
@@ -4733,6 +4733,12 @@ typedef struct _QUOTA_LIMITS_EX {
 #define	FILE_256_BYTE_ALIGNMENT		0x000000ff
 #define	FILE_512_BYTE_ALIGNMENT		0x000001ff
 
+#define COMPRESSION_FORMAT_NONE     0
+#define COMPRESSION_FORMAT_DEFAULT  1
+#define COMPRESSION_FORMAT_LZNT1    2
+#define COMPRESSION_ENGINE_STANDARD 0
+#define COMPRESSION_ENGINE_MAXIMUM  256
+
 #define MAILSLOT_NO_MESSAGE             ((DWORD)-1)
 #define MAILSLOT_WAIT_FOREVER           ((DWORD)-1)
 
diff --git a/include/winsock.h b/include/winsock.h
index 50237e8..e53aa1e 100644
--- a/include/winsock.h
+++ b/include/winsock.h
@@ -814,6 +814,7 @@ typedef struct WS(WSAData)
 
 /* internal per-socket flags */
 #ifdef __WINESRC__
+#define FD_WINE_REUSE              0x08000000
 #define FD_WINE_LISTENING          0x10000000
 #define FD_WINE_NONBLOCKING        0x20000000
 #define FD_WINE_CONNECTED          0x40000000
diff --git a/include/winternl.h b/include/winternl.h
index 9231468..6b333e1 100644
--- a/include/winternl.h
+++ b/include/winternl.h
@@ -353,7 +353,7 @@ typedef struct _TEB
     PVOID                        Spare4;                            /* f7c/1750 */
     PVOID                        ReservedForOle;                    /* f80/1758 */
     ULONG                        WaitingOnLoaderLock;               /* f84/1760 */
-    PVOID                        Reserved5[3];                      /* f88/1768 */
+    PVOID                        Reserved5[3];                      /* f88/1768 used for wineserver shared memory */
     PVOID                       *TlsExpansionSlots;                 /* f94/1780 */
     ULONG                        ImpersonationLocale;               /* f98/1788 */
     ULONG                        IsImpersonating;                   /* f9c/178c */
@@ -2231,7 +2231,7 @@ NTSYSAPI NTSTATUS  WINAPI NtSetInformationThread(HANDLE,THREADINFOCLASS,LPCVOID,
 NTSYSAPI NTSTATUS  WINAPI NtSetInformationToken(HANDLE,TOKEN_INFORMATION_CLASS,PVOID,ULONG);
 NTSYSAPI NTSTATUS  WINAPI NtSetIntervalProfile(ULONG,KPROFILE_SOURCE);
 NTSYSAPI NTSTATUS  WINAPI NtSetIoCompletion(HANDLE,ULONG_PTR,ULONG_PTR,NTSTATUS,SIZE_T);
-NTSYSAPI NTSTATUS  WINAPI NtSetLdtEntries(ULONG,LDT_ENTRY,ULONG,LDT_ENTRY);
+NTSYSAPI NTSTATUS  WINAPI NtSetLdtEntries(ULONG,ULONG,ULONG,ULONG,ULONG,ULONG);
 NTSYSAPI NTSTATUS  WINAPI NtSetLowEventPair(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtSetLowWaitHighEventPair(HANDLE);
 NTSYSAPI NTSTATUS  WINAPI NtSetLowWaitHighThread(VOID);
@@ -2602,12 +2602,46 @@ NTSYSAPI LONGLONG  WINAPI RtlLargeIntegerSubtract(LONGLONG,LONGLONG);
 NTSYSAPI NTSTATUS  WINAPI RtlLargeIntegerToChar(const ULONGLONG *,ULONG,ULONG,PCHAR);
 #endif
 
+/* Threadpool functions */
+
+NTSYSAPI NTSTATUS  WINAPI TpAllocCleanupGroup(TP_CLEANUP_GROUP **);
+NTSYSAPI NTSTATUS  WINAPI TpAllocPool(TP_POOL **,PVOID);
+NTSYSAPI NTSTATUS  WINAPI TpAllocTimer(TP_TIMER **,PTP_TIMER_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+NTSYSAPI NTSTATUS  WINAPI TpAllocWait(TP_WAIT **,PTP_WAIT_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+NTSYSAPI NTSTATUS  WINAPI TpAllocWork(TP_WORK **,PTP_WORK_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+NTSYSAPI void      WINAPI TpCallbackLeaveCriticalSectionOnCompletion(TP_CALLBACK_INSTANCE *,RTL_CRITICAL_SECTION *);
+NTSYSAPI NTSTATUS  WINAPI TpCallbackMayRunLong(TP_CALLBACK_INSTANCE *);
+NTSYSAPI void      WINAPI TpCallbackReleaseMutexOnCompletion(TP_CALLBACK_INSTANCE *,HANDLE);
+NTSYSAPI void      WINAPI TpCallbackReleaseSemaphoreOnCompletion(TP_CALLBACK_INSTANCE *,HANDLE,DWORD);
+NTSYSAPI void      WINAPI TpCallbackSetEventOnCompletion(TP_CALLBACK_INSTANCE *,HANDLE);
+NTSYSAPI void      WINAPI TpCallbackUnloadDllOnCompletion(TP_CALLBACK_INSTANCE *,HMODULE);
+NTSYSAPI void      WINAPI TpDisassociateCallback(TP_CALLBACK_INSTANCE *);
+NTSYSAPI BOOL      WINAPI TpIsTimerSet(TP_TIMER *);
+NTSYSAPI void      WINAPI TpPostWork(TP_WORK *);
+NTSYSAPI void      WINAPI TpReleaseCleanupGroup(TP_CLEANUP_GROUP *);
+NTSYSAPI void      WINAPI TpReleaseCleanupGroupMembers(TP_CLEANUP_GROUP *,BOOL,PVOID);
+NTSYSAPI void      WINAPI TpReleasePool(TP_POOL *);
+NTSYSAPI void      WINAPI TpReleaseTimer(TP_TIMER *);
+NTSYSAPI void      WINAPI TpReleaseWait(TP_WAIT *);
+NTSYSAPI void      WINAPI TpReleaseWork(TP_WORK *);
+NTSYSAPI void      WINAPI TpSetPoolMaxThreads(TP_POOL *,DWORD);
+NTSYSAPI BOOL      WINAPI TpSetPoolMinThreads(TP_POOL *,DWORD);
+NTSYSAPI void      WINAPI TpSetTimer(TP_TIMER *, LARGE_INTEGER *,LONG,LONG);
+NTSYSAPI void      WINAPI TpSetWait(TP_WAIT *,HANDLE,LARGE_INTEGER *);
+NTSYSAPI NTSTATUS  WINAPI TpSimpleTryPost(PTP_SIMPLE_CALLBACK,PVOID,TP_CALLBACK_ENVIRON *);
+NTSYSAPI void      WINAPI TpWaitForTimer(TP_TIMER *,BOOL);
+NTSYSAPI void      WINAPI TpWaitForWait(TP_WAIT *,BOOL);
+NTSYSAPI void      WINAPI TpWaitForWork(TP_WORK *,BOOL);
+
 /* Wine internal functions */
 
 NTSYSAPI NTSTATUS CDECL wine_nt_to_unix_file_name( const UNICODE_STRING *nameW, ANSI_STRING *unix_name_ret,
                                                    UINT disposition, BOOLEAN check_case );
 NTSYSAPI NTSTATUS CDECL wine_unix_to_nt_file_name( const ANSI_STRING *name, UNICODE_STRING *nt );
 
+NTSYSAPI SIZE_T CDECL wine_uninterrupted_read_memory( const void *addr, void *buffer, SIZE_T size );
+NTSYSAPI SIZE_T CDECL wine_uninterrupted_write_memory( void *addr, const void *buffer, SIZE_T size );
+
 
 /***********************************************************************
  * Inline functions
diff --git a/include/winuser.h b/include/winuser.h
index e9804a9..4920a04 100644
--- a/include/winuser.h
+++ b/include/winuser.h
@@ -4058,6 +4058,7 @@ WINUSERAPI INT         WINAPI wvsprintfW(LPWSTR,LPCWSTR,__ms_va_list);
 WORD        WINAPI SYSTEM_KillSystemTimer( WORD );
 
 #ifdef __WINESRC__
+WINUSERAPI VOID CDECL __wine_check_for_events( UINT flags );
 WINUSERAPI BOOL CDECL __wine_send_input( HWND hwnd, const INPUT *input );
 #endif
 
diff --git a/libs/port/Makefile.in b/libs/port/Makefile.in
index 65f1714..67efbc7 100644
--- a/libs/port/Makefile.in
+++ b/libs/port/Makefile.in
@@ -23,4 +23,5 @@ C_SRCS = \
 	strerror.c \
 	strncasecmp.c \
 	symlink.c \
-	usleep.c
+	usleep.c \
+	xattr.c
diff --git a/libs/wine/Makefile.in b/libs/wine/Makefile.in
index c961ba5..e270f26 100644
--- a/libs/wine/Makefile.in
+++ b/libs/wine/Makefile.in
@@ -105,7 +105,7 @@ config_EXTRADEFS = \
 	-DBIN_TO_DATADIR=\"`$(MAKEDEP) -R ${bindir} ${datadir}/wine`\"
 
 version.c: dummy
-	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-@PACKAGE_VERSION@") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
+	version=`(GIT_DIR=$(top_srcdir)/.git git describe HEAD 2>/dev/null || echo "wine-@PACKAGE_VERSION@") | sed -n -e '$$s/\(.*\)/const char wine_build[] = "\1 (Staging)";/p'` && (echo $$version | cmp -s - $@) || echo $$version >$@ || ($(RM) $@ && exit 1)
 
 # Make sure that make_makefiles sees the generated rules
 .PHONY: install install-lib install-dev uninstall
diff --git a/libs/wine/collation.c b/libs/wine/collation.c
index 465d740..f354a75 100644
--- a/libs/wine/collation.c
+++ b/libs/wine/collation.c
@@ -75,34 +75,34 @@ const unsigned int collation_table[12800] =
     0x00000000, 0x02010111, 0x02020111, 0x02030111, 0x02040111, 0x02050111, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-    0x02090111, 0x024b0111, 0x02700111, 0x02a90111, 0x09e00111, 0x02aa0111, 0x02a70111, 0x02690111,
-    0x027a0111, 0x027b0111, 0x02a20111, 0x039f0111, 0x022d0111, 0x02210111, 0x02550111, 0x02a40111,
-    0x0a0b0111, 0x0a0c0111, 0x0a0d0111, 0x0a0e0111, 0x0a0f0111, 0x0a100111, 0x0a110111, 0x0a120111,
-    0x0a130111, 0x0a140111, 0x02370111, 0x02350111, 0x03a30111, 0x03a40111, 0x03a50111, 0x024e0111,
-    0x02a10111, 0x0a150151, 0x0a290141, 0x0a3d0151, 0x0a490151, 0x0a650151, 0x0a910151, 0x0a990151,
+    0x01290111, 0x020c0111, 0x020d0111, 0x020f0111, 0x02100111, 0x02140111, 0x02190111, 0x01200111,
+    0x021b0111, 0x022d0111, 0x02350111, 0x02a70111, 0x02370111, 0x01210111, 0x024b0111, 0x024c0111,
+    0x0a0b0111, 0x0a0c0111, 0x0a0d0111, 0x0a0e0111, 0x0a0f0181, 0x0a100111, 0x0a110111, 0x0a120111,
+    0x0a130111, 0x0a140111, 0x024e0111, 0x024f0111, 0x02a90111, 0x02aa0111, 0x030a0111, 0x02550111,
+    0x025f0111, 0x0a150151, 0x0a290141, 0x0a3d0151, 0x0a490151, 0x0a650151, 0x0a910151, 0x0a990151,
     0x0ab90151, 0x0ad30161, 0x0ae70141, 0x0af70141, 0x0b030161, 0x0b2b0151, 0x0b330151, 0x0b4b0161,
     0x0b670141, 0x0b730141, 0x0b7f0141, 0x0ba70151, 0x0bbf0151, 0x0bd70141, 0x0bef0151, 0x0bfb0141,
-    0x0c030151, 0x0c070141, 0x0c130141, 0x027c0111, 0x02a60111, 0x027d0111, 0x020f0111, 0x021b0111,
-    0x020c0111, 0x0a150111, 0x0a290111, 0x0a3d0111, 0x0a490111, 0x0a650111, 0x0a910111, 0x0a990111,
+    0x0c030151, 0x0c070141, 0x0c130141, 0x02700111, 0x02780111, 0x02790111, 0x027a0111, 0x027b0111,
+    0x027c0111, 0x0a150111, 0x0a290111, 0x0a3d0111, 0x0a490111, 0x0a650111, 0x0a910111, 0x0a990111,
     0x0ab90111, 0x0ad30111, 0x0ae70111, 0x0af70111, 0x0b030111, 0x0b2b0111, 0x0b330111, 0x0b4b0111,
     0x0b670111, 0x0b730111, 0x0b7f0111, 0x0ba70111, 0x0bbf0111, 0x0bd70111, 0x0bef0111, 0x0bfb0111,
-    0x0c030111, 0x0c070111, 0x0c130111, 0x027e0111, 0x03a70111, 0x027f0111, 0x03aa0111, 0x00000000,
-    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02060111, 0x00000000, 0x00000000,
+    0x0c030111, 0x0c070111, 0x0c130111, 0x027d0111, 0x027e0111, 0x027f0111, 0x029c0111, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
-    0x02090141, 0x024c0111, 0x09df0111, 0x09e10111, 0x09de0111, 0x09e20111, 0x03a80111, 0x029c0111,
-    0x02140111, 0x029f0111, 0x0a150181, 0x02780111, 0x03a60111, 0x02200111, 0x02a00111, 0x02100111,
-    0x030a0111, 0x03a00111, 0x0a0d0151, 0x0a0e0151, 0x020d0111, 0x0c9f0121, 0x029d0111, 0x025f0111,
-    0x02190111, 0x0a0c0151, 0x0b4b01a1, 0x02790111, 0x0a0c0171, 0x0a0c0171, 0x0a0e0171, 0x024f0111,
+    0x01290121, 0x029d0111, 0x03a40111, 0x03a50111, 0x03a60111, 0x03a70111, 0x029f0111, 0x03a80111,
+    0x02a00111, 0x03aa0111, 0x0a150181, 0x03a00111, 0x09de0111, 0x01220111, 0x09df0111, 0x02a10111,
+    0x09e00111, 0x039f0111, 0x0a0d0151, 0x0a0e0151, 0x02a20111, 0x09e10111, 0x09e20111, 0x09ef0111,
+    0x02a40111, 0x0a0c0151, 0x0b4b01a1, 0x03a10111, 0x0a0c0171, 0x0a0c0171, 0x0a0c0171, 0x02a60111,
     0x0a150151, 0x0a150151, 0x0a150151, 0x0a150151, 0x0a150151, 0x0a150151, 0x0a190121, 0x0a3d0151,
     0x0a650151, 0x0a650151, 0x0a650151, 0x0a650151, 0x0ad30161, 0x0ad30161, 0x0ad30161, 0x0ad30161,
     0x0a5d0121, 0x0b330151, 0x0b4b0161, 0x0b4b0161, 0x0b4b0161, 0x0b4b0161, 0x0b4b0161, 0x03a20111,
-    0x0b530121, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0c070141, 0x0c3b0121, 0x0ba70131,
+    0x0b530121, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0bd70141, 0x0c070141, 0x0bd40121, 0x0ba70131,
     0x0a150111, 0x0a150111, 0x0a150111, 0x0a150111, 0x0a150111, 0x0a150111, 0x0a190111, 0x0a3d0111,
     0x0a650111, 0x0a650111, 0x0a650111, 0x0a650111, 0x0ad30111, 0x0ad30111, 0x0ad30111, 0x0ad30111,
-    0x0a5d0111, 0x0b330111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x03a10111,
-    0x0b530111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0c070111, 0x0c3b0111, 0x0c070111,
+    0x0a5d0111, 0x0b330111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x0b4b0111, 0x03a30111,
+    0x0b530111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0bd70111, 0x0c070111, 0x0bd40111, 0x0c070111,
     /* 0x0100 .. 0x01ff */
     0x0a150151, 0x0a150111, 0x0a150151, 0x0a150111, 0x0a150151, 0x0a150111, 0x0a3d0151, 0x0a3d0111,
     0x0a3d0151, 0x0a3d0111, 0x0a3d0151, 0x0a3d0111, 0x0a3d0151, 0x0a3d0111, 0x0a490151, 0x0a490111,
@@ -189,7 +189,7 @@ const unsigned int collation_table[12800] =
     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0x020d0111, 0x02140111, 0x0c910121, 0x025f0111,
     0x0c950131, 0x0c990121, 0x0c9b0121, 0xffffffff, 0x0ca20121, 0xffffffff, 0x0ca80121, 0x0cac0121,
     0x0c9b0111, 0x0c910121, 0x0c920131, 0x0c930121, 0x0c940121, 0x0c950131, 0x0c980121, 0x0c990121,
-    0x0c9a0131, 0x0c9b0121, 0x0c9d0131, 0x0c9e0121, 0x0c9f0131, 0x0ca00121, 0x0ca10121, 0x0ca20121,
+    0x0c9a0131, 0x0c9b0121, 0x0c9d0131, 0x0c9e0121, 0x0c9f0121, 0x0ca00121, 0x0ca10121, 0x0ca20121,
     0x0ca30131, 0x0ca50131, 0xffffffff, 0x0ca60131, 0x0ca70121, 0x0ca80121, 0x0ca90131, 0x0caa0121,
     0x0cab0121, 0x0cac0121, 0x0c9b0121, 0x0ca80121, 0x0c910111, 0x0c950111, 0x0c990111, 0x0c9b0111,
     0x0ca80111, 0x0c910111, 0x0c920111, 0x0c930111, 0x0c940111, 0x0c950111, 0x0c980111, 0x0c990111,
@@ -929,12 +929,12 @@ const unsigned int collation_table[12800] =
     0xffffffff, 0xffffffff, 0x0cac0111, 0x0cac0111, 0x0cac0111, 0xffffffff, 0x0cac0111, 0x0cac0111,
     0x0ca20121, 0x0ca20121, 0x0cac0121, 0x0cac0121, 0x0cac0121, 0x020d0111, 0x02180111, 0xffffffff,
     /* 0x2000 .. 0x20ff */
-    0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090131, 0x02090141,
-    0x02090131, 0x02090131, 0x02090131, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090121, 0x02090131,
+    0x02090121, 0x02090121, 0x02090121, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
     0x02250111, 0x02250121, 0x02260111, 0x02270111, 0x02280111, 0x02290111, 0x03a90111, 0x021c0111,
     0x026a0111, 0x026b0111, 0x026c0111, 0x026d0111, 0x02710111, 0x02720111, 0x02730111, 0x02740111,
     0x02ae0111, 0x02af0111, 0x02b00111, 0x02b10111, 0x02550131, 0x02550131, 0x02550131, 0x02b20111,
-    0x02070111, 0x02080111, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02090141,
+    0x02070111, 0x02080111, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x02090131,
     0x02ac0111, 0x02ad0111, 0x02b60111, 0x02b60121, 0x02b60121, 0x02b70111, 0x02b70121, 0x02b70121,
     0x02b90111, 0x026e0111, 0x026f0111, 0x02ba0111, 0x024b0131, 0x02540111, 0x02110111, 0x02bb0111,
     0x02bc0111, 0x02bd0111, 0x02be0111, 0x02b30111, 0x02a50111, 0x02860111, 0x02870111, 0xffffffff,
@@ -1292,7 +1292,7 @@ const unsigned int collation_table[12800] =
     0x09a90111, 0x09aa0111, 0x09ab0111, 0x09ac0111, 0x09ad0111, 0x09ae0111, 0x09af0111, 0x09b00111,
     0x09b10111, 0x09b20111, 0x09b30111, 0x09b40111, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
     /* 0x3000 .. 0x30ff */
-    0x02090121, 0x02340111, 0x025e0111, 0x02b80111, 0x09b50111, 0x09d70111, 0x192c0111, 0x0a0b0111,
+    0x02090111, 0x02340111, 0x025e0111, 0x02b80111, 0x09b50111, 0x09d70111, 0x192c0111, 0x0a0b0111,
     0x02880111, 0x02890111, 0x028a0111, 0x028b0111, 0x028c0111, 0x028d0111, 0x028e0111, 0x028f0111,
     0x02900111, 0x02910111, 0x09b60111, 0x09b70111, 0x02920111, 0x02930111, 0x02940111, 0x02950111,
     0x02960111, 0x02970111, 0x02980111, 0x02990111, 0x022a0111, 0x02750111, 0x02760111, 0x02770111,
@@ -1407,14 +1407,14 @@ const unsigned int collation_table[12800] =
     0x0a0c0131, 0x0a0c0131, 0x0a0c0131, 0x0a0c0131, 0x0a0d0131, 0x0a0d0131, 0x0a0d0131, 0x0a0d0131,
     0x0a0d0131, 0x0ab901a1, 0x0a490191, 0x0a1501a1, 0x0a290181, 0x0b4b01b1, 0x0b670181, 0xffffffff,
     0xffffffff, 0xffffffff, 0xffffffff, 0xfb400151, 0xfb400151, 0xfb400151, 0xfb400151, 0xfb400151,
-    0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0af70171, 0x0af70181, 0x0b2b01b1, 0x0a990181,
-    0x0a3d01a1, 0x0af70171, 0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0c9f0141, 0x0b2b01a1, 0x0af70171,
-    0x0ab901b1, 0x0af70171, 0x0b2b01b1, 0x0a990181, 0x0bbf01a1, 0x0c9f0141, 0x0b2b01a1, 0x0a490191,
-    0x0af70171, 0x0a910191, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0a3d01a1, 0x0af70171, 0x0b2b01a1,
+    0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0af70171, 0x0af70181, 0x0b2b01b1, 0x0a990181,
+    0x0a3d01a1, 0x0af70171, 0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0c9f0131, 0x0b2b01a1, 0x0af70171,
+    0x0ab901b1, 0x0af70171, 0x0b2b01b1, 0x0a990181, 0x0bbf01a1, 0x0c9f0131, 0x0b2b01a1, 0x0a490191,
+    0x0af70171, 0x0a910191, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0a3d01a1, 0x0af70171, 0x0b2b01a1,
     0x0a3d01a1, 0x0b2b01a1, 0x0af70171, 0x0b2b01a1, 0x0a3d01a1, 0x0b2b01a1, 0x0af70171, 0x0b2b01a1,
     0x0b2b01a1, 0x0b670191, 0x0af70171, 0x0b2b01b1, 0x0a990181, 0x0b7f01a1, 0x0b7f01a1, 0x0b7f01a1,
-    0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1,
-    0x0af70171, 0x0b2b01b1, 0x0b670181, 0x0b3301b1, 0x0c9f0141, 0x0b2b01a1, 0x0af70171, 0x0b2b01b1,
+    0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1,
+    0x0af70171, 0x0b2b01b1, 0x0b670181, 0x0b3301b1, 0x0c9f0131, 0x0b2b01a1, 0x0af70171, 0x0b2b01b1,
     0x0af70171, 0x0b2b01b1, 0x0a150191, 0x0a290191, 0x0a3d01a1, 0x0a3d01a1, 0x0a3d01b1, 0x0a3d01b1,
     0x0a490191, 0x0a990181, 0x0ab901a1, 0x0ab901b1, 0x0ad301b1, 0x0af70181, 0x0af70181, 0x0af70171,
     0x0b0301c1, 0x0b0301c1, 0x0b0301c1, 0x0b0301c1, 0x0b2b01a1, 0x0b2b01a1, 0x0b2b01a1, 0x0b670191,
@@ -1601,7 +1601,7 @@ const unsigned int collation_table[12800] =
     0xffffffff, 0x02110121, 0x02110121, 0x02110121, 0x02110121, 0x021b0131, 0x021b0131, 0x021b0131,
     0x022d0131, 0x02340121, 0x02550141, 0xffffffff, 0x02350131, 0x02370131, 0x024e0141, 0x024b0141,
     0x02280121, 0x027a0141, 0x027b0131, 0x027e0131, 0x027f0131, 0x02920121, 0x02930121, 0x02a90131,
-    0x02a70131, 0x02a20131, 0x039f0141, 0x02210131, 0x03a30131, 0x03a50131, 0x03a40131, 0xffffffff,
+    0x02a70131, 0x02a20131, 0x039f0141, 0x02210121, 0x03a30131, 0x03a50131, 0x03a40131, 0xffffffff,
     0x02a60131, 0x09e00131, 0x02aa0131, 0x02a10131, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,
     0x00006831, 0x00006821, 0x00006921, 0xffffffff, 0x00006a21, 0xffffffff, 0x00006b31, 0x00006b21,
     0x00006c31, 0x00006c21, 0x00006d31, 0x00006d21, 0x00006e31, 0x00006e21, 0x00006f31, 0x00006f21,
@@ -1622,8 +1622,8 @@ const unsigned int collation_table[12800] =
     0x0f480141, 0x0f490161, 0x0f490151, 0x0f490131, 0x0f490141, 0x0f2d0151, 0x0f2d0141, 0x0f2d0151,
     0x0f2d0141, 0x0f2d0151, 0x0f2d0141, 0x0f2d0151, 0x0f2d0141, 0xffffffff, 0xffffffff, 0x00000000,
     /* 0xff00 .. 0xffff */
-    0xffffffff, 0x024b0121, 0x02700121, 0x02a90121, 0x09e00121, 0x02aa0121, 0x02a70121, 0x02690121,
-    0x027a0121, 0x027b0121, 0x02a20121, 0x039f0121, 0x022d0121, 0x02210121, 0x02550121, 0x02a40121,
+    0xffffffff, 0x024b0121, 0x02700121, 0x02a90121, 0x09e00121, 0x02aa0121, 0x02a70121, 0x02690111,
+    0x027a0121, 0x027b0121, 0x02a20121, 0x039f0121, 0x022d0121, 0x02210111, 0x02550121, 0x02a40121,
     0x0a0b0121, 0x0a0c0121, 0x0a0d0121, 0x0a0e0121, 0x0a0f0121, 0x0a100121, 0x0a110121, 0x0a120121,
     0x0a130121, 0x0a140121, 0x02370121, 0x02350121, 0x03a30121, 0x03a40121, 0x03a50121, 0x024e0121,
     0x02a10121, 0x0a150161, 0x0a290151, 0x0a3d0161, 0x0a490161, 0x0a650161, 0x0a910161, 0x0a990161,
diff --git a/libs/wine/config.c b/libs/wine/config.c
index a273502..7acf51b 100644
--- a/libs/wine/config.c
+++ b/libs/wine/config.c
@@ -444,6 +444,118 @@ const char *wine_get_build_dir(void)
     return build_dir;
 }
 
+const char *wine_libs[] = {
+#ifdef SONAME_LIBCAPI20
+    SONAME_LIBCAPI20,
+#endif
+#ifdef SONAME_LIBCUPS
+    SONAME_LIBCUPS,
+#endif
+#ifdef SONAME_LIBCURSES
+    SONAME_LIBCURSES,
+#endif
+#ifdef SONAME_LIBDBUS_1
+    SONAME_LIBDBUS_1,
+#endif
+#ifdef SONAME_LIBFONTCONFIG
+    SONAME_LIBFONTCONFIG,
+#endif
+#ifdef SONAME_LIBFREETYPE
+    SONAME_LIBFREETYPE,
+#endif
+#ifdef SONAME_LIBGL
+    SONAME_LIBGL,
+#endif
+#ifdef SONAME_LIBGNUTLS
+    SONAME_LIBGNUTLS,
+#endif
+#ifdef SONAME_LIBGSM
+    SONAME_LIBGSM,
+#endif
+#ifdef SONAME_LIBHAL
+    SONAME_LIBHAL,
+#endif
+#ifdef SONAME_LIBJPEG
+    SONAME_LIBJPEG,
+#endif
+#ifdef SONAME_LIBNCURSES
+    SONAME_LIBNCURSES,
+#endif
+#ifdef SONAME_LIBNETAPI
+    SONAME_LIBNETAPI,
+#endif
+#ifdef SONAME_LIBODBC
+    SONAME_LIBODBC,
+#endif
+#ifdef SONAME_LIBOSMESA
+    SONAME_LIBOSMESA,
+#endif
+#ifdef SONAME_LIBPCAP
+    SONAME_LIBPCAP,
+#endif
+#ifdef SONAME_LIBPNG
+    SONAME_LIBPNG,
+#endif
+#ifdef SONAME_LIBSANE
+    SONAME_LIBSANE,
+#endif
+#ifdef SONAME_LIBTIFF
+    SONAME_LIBTIFF,
+#endif
+#ifdef SONAME_LIBTXC_DXTN
+    SONAME_LIBTXC_DXTN,
+#endif
+#ifdef SONAME_LIBV4L1
+    SONAME_LIBV4L1,
+#endif
+#ifdef SONAME_LIBVA
+    SONAME_LIBVA,
+#endif
+#ifdef SONAME_LIBVA_DRM
+    SONAME_LIBVA_DRM,
+#endif
+#ifdef SONAME_LIBVA_X11
+    SONAME_LIBVA_X11,
+#endif
+#ifdef SONAME_LIBX11
+    SONAME_LIBX11,
+#endif
+#ifdef SONAME_LIBXCOMPOSITE
+    SONAME_LIBXCOMPOSITE,
+#endif
+#ifdef SONAME_LIBXCURSOR
+    SONAME_LIBXCURSOR,
+#endif
+#ifdef SONAME_LIBXEXT
+    SONAME_LIBXEXT,
+#endif
+#ifdef SONAME_LIBXI
+    SONAME_LIBXI,
+#endif
+#ifdef SONAME_LIBXINERAMA
+    SONAME_LIBXINERAMA,
+#endif
+#ifdef SONAME_LIBXRANDR
+    SONAME_LIBXRANDR,
+#endif
+#ifdef SONAME_LIBXRENDER
+    SONAME_LIBXRENDER,
+#endif
+#ifdef SONAME_LIBXSLT
+    SONAME_LIBXSLT,
+#endif
+#ifdef SONAME_LIBXXF86VM
+    SONAME_LIBXXF86VM,
+#endif
+    NULL
+};
+
+/* return the list of shared libs used by wine */
+const char **wine_get_libs(void)
+{
+    return &wine_libs[0];
+}
+
 /* return the full name of the server directory (the one containing the socket) */
 const char *wine_get_server_dir(void)
 {
@@ -478,6 +590,12 @@ const char *wine_get_version(void)
     return PACKAGE_VERSION;
 }
 
+/* return the applied non-standard patches */
+const void *wine_get_patches(void)
+{
+    return NULL;
+}
+
 /* return the build id string */
 const char *wine_get_build_id(void)
 {
diff --git a/libs/wine/debug.c b/libs/wine/debug.c
index 548ef22..caaf383 100644
--- a/libs/wine/debug.c
+++ b/libs/wine/debug.c
@@ -125,10 +125,22 @@ static void add_option( const char *name, unsigned char set, unsigned char clear
     nb_debug_options++;
 }
 
+/* get name of the current process */
+static const char *get_process_name( void )
+{
+    const char *ret, *tmp;
+    if (__wine_main_argc < 2) return NULL;
+    ret = __wine_main_argv[1];
+    if ((tmp = strrchr(ret, '/'))) ret = ++tmp;
+    if ((tmp = strrchr(ret, '\\'))) ret = ++tmp;
+    return ret;
+}
+
 /* parse a set of debugging option specifications and add them to the option list */
 static void parse_options( const char *str )
 {
-    char *opt, *next, *options;
+    char *opt, *next, *popt, *options;
+    const char *process = get_process_name();
     unsigned int i;
 
     if (!(options = strdup(str))) return;
@@ -139,6 +151,17 @@ static void parse_options( const char *str )
 
         if ((next = strchr( opt, ',' ))) *next++ = 0;
 
+        if ((popt = strchr( opt, ':' )))
+        {
+            unsigned int inv = 0;
+            *popt = 0;
+            if (!process) continue;
+            if (*opt == '-' || *opt == '+')
+                inv = (*opt++ == '-');
+            if (inv == !strcmp( opt, process )) continue;
+            opt = ++popt;
+        }
+
         p = opt + strcspn( opt, "+-" );
         if (!p[0]) p = opt;  /* assume it's a debug channel name */
 
@@ -180,7 +203,7 @@ static void debug_usage(void)
 {
     static const char usage[] =
         "Syntax of the WINEDEBUG variable:\n"
-        "  WINEDEBUG=[class]+xxx,[class]-yyy,...\n\n"
+        "  WINEDEBUG=[+process:][class]+xxx,[-process:][class]-yyy,...\n\n"
         "Example: WINEDEBUG=+all,warn-heap\n"
         "    turns on all messages except warning heap messages\n"
         "Available message classes: err, warn, fixme, trace\n";
diff --git a/libs/wine/loader.c b/libs/wine/loader.c
index 3591ede..2718857 100644
--- a/libs/wine/loader.c
+++ b/libs/wine/loader.c
@@ -1043,6 +1043,42 @@ void *wine_dlopen( const char *filename, int flag, char *error, size_t errorsize
 }
 
 /***********************************************************************
+ *      wine_dladdr
+ */
+int wine_dladdr( void *addr, void *info, char *error, size_t errorsize )
+{
+#ifdef HAVE_DLADDR
+    int ret;
+    const char *s;
+    dlerror(); dlerror();
+    ret = dladdr( addr, (Dl_info *)info );
+    s = dlerror();
+    if (error && errorsize)
+    {
+        if (s)
+        {
+            size_t len = strlen(s);
+            if (len >= errorsize) len = errorsize - 1;
+            memcpy( error, s, len );
+            error[len] = 0;
+        }
+        else error[0] = 0;
+    }
+    dlerror();
+    return ret;
+#else
+    if (error)
+    {
+        static const char msg[] = "dladdr interface not detected by configure";
+        size_t len = min( errorsize, sizeof(msg) );
+        memcpy( error, msg, len );
+        error[len - 1] = 0;
+    }
+    return 0;
+#endif
+}
+
+/***********************************************************************
  *		wine_dlsym
  */
 void *wine_dlsym( void *handle, const char *symbol, char *error, size_t errorsize )
diff --git a/libs/wine/wine.def b/libs/wine/wine.def
index ed315bd..6acf329 100644
--- a/libs/wine/wine.def
+++ b/libs/wine/wine.def
@@ -64,6 +64,7 @@ EXPORTS
     wine_dbg_sprintf
     wine_dbgstr_an
     wine_dbgstr_wn
+    wine_dladdr
     wine_dlclose
     wine_dll_enum_load_path
     wine_dll_get_owner
@@ -79,10 +80,12 @@ EXPORTS
     wine_get_build_id
     wine_get_config_dir
     wine_get_data_dir
+    wine_get_libs
     wine_get_server_dir
     wine_get_sortkey
     wine_get_user_name
     wine_get_version
+    wine_get_patches
     wine_init
     wine_init_argv0_path
     wine_is_dbcs_leadbyte
diff --git a/libs/wine/wine.map b/libs/wine/wine.map
index 2159fac..72ffed8 100644
--- a/libs/wine/wine.map
+++ b/libs/wine/wine.map
@@ -65,6 +65,7 @@ WINE_1.0
     wine_dbg_sprintf;
     wine_dbgstr_an;
     wine_dbgstr_wn;
+    wine_dladdr;
     wine_dlclose;
     wine_dll_enum_load_path;
     wine_dll_get_owner;
@@ -85,11 +86,13 @@ WINE_1.0
     wine_get_es;
     wine_get_fs;
     wine_get_gs;
+    wine_get_libs;
     wine_get_server_dir;
     wine_get_sortkey;
     wine_get_ss;
     wine_get_user_name;
     wine_get_version;
+    wine_get_patches;
     wine_init;
     wine_init_argv0_path;
     wine_is_dbcs_leadbyte;
diff --git a/loader/main.c b/loader/main.c
index bb752b5..44804e1 100644
--- a/loader/main.c
+++ b/loader/main.c
@@ -36,6 +36,12 @@
 #ifdef HAVE_UNISTD_H
 # include <unistd.h>
 #endif
+#ifdef HAVE_DLADDR
+# include <dlfcn.h>
+#endif
+#ifdef HAVE_LINK_H
+# include <link.h>
+#endif
 #include <pthread.h>
 
 #include "wine/library.h"
@@ -89,7 +95,9 @@ static void check_command_line( int argc, char *argv[] )
     static const char usage[] =
         "Usage: wine PROGRAM [ARGUMENTS...]   Run the specified program\n"
         "       wine --help                   Display this help and exit\n"
-        "       wine --version                Output version information and exit";
+        "       wine --version                Output version information and exit\n"
+        "       wine --patches                Output patch information and exit\n"
+        "       wine --check-libs             Checks if shared libs are installed";
 
     if (argc <= 1)
     {
@@ -106,6 +114,86 @@ static void check_command_line( int argc, char *argv[] )
         printf( "%s\n", wine_get_build_id() );
         exit(0);
     }
+    if (!strcmp( argv[1], "--patches" ))
+    {
+        const struct
+        {
+            const char *author;
+            const char *subject;
+            int revision;
+        }
+        *next, *cur = wine_get_patches();
+
+        if (!cur)
+        {
+            fprintf( stderr, "Patchlist not available.\n" );
+            exit(1);
+        }
+
+        while (cur->author)
+        {
+            next = cur + 1;
+            while (next->author)
+            {
+                if (strcmp( cur->author, next->author )) break;
+                next++;
+            }
+
+            printf( "%s (%d):\n", cur->author, (int)(next - cur) );
+            while (cur < next)
+            {
+                printf( "      %s", cur->subject );
+                if (cur->revision != 1)
+                    printf( " [rev %d]", cur->revision );
+                printf( "\n" );
+                cur++;
+            }
+            printf( "\n" );
+        }
+
+        exit(0);
+    }
+    if (!strcmp( argv[1], "--check-libs" ))
+    {
+        void* lib_handle;
+        int ret = 0;
+        const char **wine_libs = wine_get_libs();
+
+        for(; *wine_libs; wine_libs++)
+        {
+            lib_handle = wine_dlopen( *wine_libs, RTLD_NOW, NULL, 0 );
+            if (lib_handle)
+            {
+            #ifdef HAVE_DLADDR
+                Dl_info libinfo;
+                void* symbol;
+
+            #ifdef HAVE_LINK_H
+                struct link_map *lm = (struct link_map *)lib_handle;
+                symbol = (void *)lm->l_addr;
+            #else
+                symbol = wine_dlsym( lib_handle, "_init", NULL, 0 );
+            #endif
+                if (symbol && wine_dladdr( symbol, &libinfo, NULL, 0 ))
+                {
+                    printf( "%s: %s\n", *wine_libs, libinfo.dli_fname );
+                }
+                else
+            #endif
+                {
+                    printf( "%s: found\n", *wine_libs );
+                }
+                wine_dlclose( lib_handle, NULL, 0 );
+            }
+            else
+            {
+                printf( "%s: missing\n", *wine_libs );
+                ret = 1;
+            }
+        }
+
+        exit(ret);
+    }
 }
 
 
diff --git a/loader/wine.inf.in b/loader/wine.inf.in
index d901251..a0bb393 100644
--- a/loader/wine.inf.in
+++ b/loader/wine.inf.in
@@ -489,9 +489,15 @@ HKLM,%CurrentVersionNT%\Image File Execution Options,,16
 HKLM,%CurrentVersionNT%\Language Pack,,16
 HKLM,%CurrentVersionNT%\NetworkCards,,16
 HKLM,%CurrentVersionNT%\Perflib,,16
+HKLM,%CurrentVersionNT%\Perflib,Last Counter,0x10003,1846
+HKLM,%CurrentVersionNT%\Perflib,Last Help,0x10003,1847
+HKLM,%CurrentVersionNT%\Perflib\009,Counter,0x10002,1,1847,1846,End Marker
+HKLM,%CurrentVersionNT%\Perflib\009,Help,0x10002,1847,End Marker
 HKLM,%CurrentVersionNT%\Ports,,16
 HKLM,%CurrentVersionNT%\Print,,16
 HKLM,%CurrentVersionNT%\ProfileList,,16
+; Update/Replace if local_user_sid in server/token.c changes
+HKLM,%CurrentVersionNT%\ProfileList\S-1-5-21-0-0-0-1000,,16
 
 [CurrentVersionWow64]
 HKLM,%CurrentVersion%,"ProgramFilesDir (x86)",,"%16426%"
@@ -620,6 +626,10 @@ HKLM,Software\Borland\Database Engine\Settings\SYSTEM\INIT,SHAREDMEMLOCATION,,90
 HKLM,Software\Clients\Mail,,2,"Native Mail Client"
 HKLM,Software\Clients\Mail\Native Mail Client,,2,"Native Mail Client"
 HKLM,Software\Clients\Mail\Native Mail Client,"DLLPath",2,"%11%\winemapi.dll"
+HKLM,Software\Classes\MediaFoundation,,16
+HKLM,Software\Classes\MediaFoundation\MediaSources,,16
+HKLM,Software\Classes\MediaFoundation\Transforms,,16
+HKLM,Software\Classes\MediaFoundation\Transforms\Categories,,16
 HKLM,Software\Microsoft\Advanced INF Setup,,16
 HKLM,Software\Microsoft\Clients,,16
 HKLM,Software\Microsoft\Cryptography\Calais\Current,,16
@@ -2495,6 +2505,7 @@ HKLM,%CurrentVersion%\Telephony\Country List\998,"SameAreaRule",,"G"
 10,syswow64,stdole2.tlb
 11,,iexplore.exe
 11,,winetest.exe,-
+12,,fltmgr.sys,-
 12,,mountmgr.sys,-
 12,,ndis.sys,-
 ; skip .NET fake dlls in Wine Mono package
@@ -2533,6 +2544,7 @@ HKLM,%CurrentVersion%\Telephony\Country List\998,"SameAreaRule",,"G"
 11,,iexplore.exe
 11,,notepad.exe
 11,,winetest.exe,-
+12,,fltmgr.sys
 12,,mountmgr.sys
 12,,ndis.sys
 ; skip .NET fake dlls in Wine Mono package
@@ -2764,6 +2776,30 @@ HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time,"Display",,"Asia/Jerusal
 HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time,"Dlt",,"Israel Daylight Time"
 HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time,"Std",,"Israel Standard Time"
 HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time,"TZI",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,00,00,0a,00,00,00,05,00,02,00,00,00,00,00,00,00,00,00,03,00,05,00,05,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2017",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,e1,07,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,e1,07,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2018",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,e2,07,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,e2,07,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2023",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,e7,07,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,e7,07,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2028",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,ec,07,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,ec,07,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2029",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,ed,07,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,ed,07,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2034",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,f2,07,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,f2,07,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2035",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,f3,07,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,f3,07,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2040",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,f8,07,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,f8,07,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2045",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,fd,07,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,fd,07,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2046",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,fe,07,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,fe,07,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2051",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,03,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,03,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2056",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,08,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,08,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2057",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,09,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,09,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2062",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,0e,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,0e,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2063",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,0f,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,0f,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2068",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,14,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,14,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2073",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,19,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,19,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2074",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,1a,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,1a,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2079",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,1f,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,1f,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2084",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,24,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,24,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2085",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,25,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,25,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2090",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,2a,08,0a,00,00,00,1d,00,02,00,00,00,00,00,00,00,2a,08,03,00,05,00,18,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2091",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,2b,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,2b,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
+HKLM,%CurrentVersionNT%\Time Zones\Israel Standard Time\Dynamic DST,"2096",1,88,ff,ff,ff,00,00,00,00,c4,ff,ff,ff,30,08,0a,00,00,00,1c,00,02,00,00,00,00,00,00,00,30,08,03,00,05,00,17,00,02,00,00,00,00,00,00,00
 HKLM,%CurrentVersionNT%\Time Zones\Jordan Standard Time,"Display",,"Asia/Amman"
 HKLM,%CurrentVersionNT%\Time Zones\Jordan Standard Time,"Dlt",,"Jordan Daylight Time"
 HKLM,%CurrentVersionNT%\Time Zones\Jordan Standard Time,"Std",,"Jordan Standard Time"
diff --git a/po/ar.po b/po/ar.po
index 07bcad2..6c7984b 100644
--- a/po/ar.po
+++ b/po/ar.po
@@ -13724,12 +13724,12 @@ msgstr "  "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "               "
 "          \" \"  <a "
-"href=\"http://wiki.winehq.org/Bugs\">  </a>    "
+"href=\"http://bugs.wine-staging.com\">  </a>    "
 "  ."
 
 #: winedbg.rc:38
diff --git a/po/bg.po b/po/bg.po
index 4cc4058..6b62e5c 100644
--- a/po/bg.po
+++ b/po/bg.po
@@ -13567,7 +13567,7 @@ msgstr "Program Files"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/ca.po b/po/ca.po
index d3fe1b0..12eefdf 100644
--- a/po/ca.po
+++ b/po/ca.po
@@ -13985,12 +13985,12 @@ msgstr "Detalls d'Error de Programa"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Si aquest problema no est present en el Windows i encara no s'ha reportat, "
 "podeu desar la informaci detallada a un fitxer mediant el bot \"Anomenar i "
-"Desar\", desprs <a href=\"http://wiki.winehq.org/Bugs\">presentar un "
+"Desar\", desprs <a href=\"http://bugs.wine-staging.com\">presentar un "
 "informe d'error</a> i ajuntar aquest fitxer a l'informe."
 
 #: winedbg.rc:38
diff --git a/po/cs.po b/po/cs.po
index f08bfcc..b555b69 100644
--- a/po/cs.po
+++ b/po/cs.po
@@ -13612,12 +13612,12 @@ msgstr "Podrobnosti chyby programu"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Pokud se tento problm v Microsoft Windows neprojevuje a nebyl doposud "
 "nahlen, je mon uloit podrobn informace do souboru kliknutm na "
-"tlatko Uloit jako a nsledn <a href=\"http://wiki.winehq.org/Bugs"
+"tlatko Uloit jako a nsledn <a href=\"http://bugs.wine-staging.com"
 "\">vyplnit hlen o chyb</a> a tento soubor k nmu pipojit."
 
 #: winedbg.rc:38
diff --git a/po/da.po b/po/da.po
index bde3a4a..cca9fd1 100644
--- a/po/da.po
+++ b/po/da.po
@@ -13874,7 +13874,7 @@ msgstr "Programfejl detaljer"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Hvis dette problem ikke er til stede under Windows, og det endnu ikke er "
diff --git a/po/de.po b/po/de.po
index 724db00..9127046 100644
--- a/po/de.po
+++ b/po/de.po
@@ -13813,12 +13813,12 @@ msgstr "Programmfehler-Details"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Tritt dieses Problem unter Windows nicht auf und wurde es noch nicht "
 "gemeldet, knnen Sie mit \"Speichern unter\" die detaillierten Informationen "
-"in einer Datei speichern, danach <a href=\"http://wiki.winehq.org/Bugs"
+"in einer Datei speichern, danach <a href=\"http://bugs.wine-staging.com"
 "\">einen Fehlerbericht hinterlassen</a> und die Datei dort anhngen."
 
 #: winedbg.rc:38
diff --git a/po/el.po b/po/el.po
index f0e5407..8b1f891 100644
--- a/po/el.po
+++ b/po/el.po
@@ -13311,7 +13311,7 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/en.po b/po/en.po
index 2af5bad..4577722 100644
--- a/po/en.po
+++ b/po/en.po
@@ -13716,12 +13716,12 @@ msgstr "Program Error Details"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 
 #: winedbg.rc:38
diff --git a/po/en_US.po b/po/en_US.po
index 7161631..02f15a5 100644
--- a/po/en_US.po
+++ b/po/en_US.po
@@ -13716,12 +13716,12 @@ msgstr "Program Error Details"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 
 #: winedbg.rc:38
diff --git a/po/eo.po b/po/eo.po
index dd74ebb..417b7f5 100644
--- a/po/eo.po
+++ b/po/eo.po
@@ -13178,7 +13178,7 @@ msgstr "Detaloj pri programa eraro"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/es.po b/po/es.po
index 931bf6c..4dcb7b4 100644
--- a/po/es.po
+++ b/po/es.po
@@ -13970,12 +13970,12 @@ msgstr "Detalles del error de programa"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Si este problema no esta presente en Windows y no ha sido informado todava, "
 "puedes salvar la informacin detallada usando el botn \"Salvar Como\", "
-"entonces podrs <a href=\"http://wiki.winehq.org/Bugs\">informar de un "
+"entonces podrs <a href=\"http://bugs.wine-staging.com\">informar de un "
 "error</a> y adjuntar ese archivo al informe de fallo."
 
 #: winedbg.rc:38
diff --git a/po/fa.po b/po/fa.po
index c04ae7a..2557e12 100644
--- a/po/fa.po
+++ b/po/fa.po
@@ -13320,7 +13320,7 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/fi.po b/po/fi.po
index 3d1b907..0cf8a97 100644
--- a/po/fi.po
+++ b/po/fi.po
@@ -13689,13 +13689,13 @@ msgstr "Ohjelman virhetiedot"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Jos tt ongelmaa ei esiinny Windowsin kanssa eik sit ole viel "
 "raportoitu, voit tallentaa yksityiskohtaisemmat tiedot tiedostoon Tallenna "
-"nimell -kohdassa ja sitten <a href=\"http://wiki.winehq.org/Bugs\">lhett "
-"virheraportin</a> ja liitt tiedoston raporttiin."
+"nimell -kohdassa ja sitten <a href=\"http://bugs.wine-staging.com"
+"\">lhett virheraportin</a> ja liitt tiedoston raporttiin."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/fr.po b/po/fr.po
index b95068f..2dbff1a 100644
--- a/po/fr.po
+++ b/po/fr.po
@@ -13888,13 +13888,13 @@ msgstr "Dtails de l'erreur du programme"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Si ce problme ne se produit pas sous Windows et n'a pas dj t rapport, "
 "vous pouvez enregistrer les informations dtailles dans un fichier en "
-"utilisant le bouton Enregistrer sous, et ensuite  <a href=\"http://wiki."
-"winehq.org/Bugs\">soumettre un rapport d'anomalie</a> en y attachant ledit "
+"utilisant le bouton Enregistrer sous, et ensuite <a href=\"http://bugs."
+"wine-staging.com\">soumettre un rapport d'anomalie</a> en y attachant ledit "
 "fichier."
 
 #: winedbg.rc:38
diff --git a/po/he.po b/po/he.po
index ee6b4d4..f1b1644 100644
--- a/po/he.po
+++ b/po/he.po
@@ -14012,7 +14012,7 @@ msgstr ""
 " http://appdb.winehq.org     .\n"
 "\n"
 "       Windows    ,    "
-" http://bugs.winehq.org."
+" http://bugs.wine-staging.com."
 
 #: winedbg.rc:61
 #, fuzzy
@@ -14028,7 +14028,7 @@ msgstr " "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/hi.po b/po/hi.po
index e1fd727..859c1b2 100644
--- a/po/hi.po
+++ b/po/hi.po
@@ -13089,7 +13089,7 @@ msgstr " (&o)"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/hr.po b/po/hr.po
index 6f74dad..8a8e306 100644
--- a/po/hr.po
+++ b/po/hr.po
@@ -13411,7 +13411,7 @@ msgstr "Detalji greke programa"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/hu.po b/po/hu.po
index 8cc8bf6..7071ea7 100644
--- a/po/hu.po
+++ b/po/hu.po
@@ -13883,12 +13883,12 @@ msgstr "Program hibarszletez"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Ha ez a problma mg nincs jelen Windows alatt s nem lett lejelentve, "
 "lementheti a rszletes informcit egy fjlba a Ments msknt nyomgomb "
-"hasznlatval, azutn <a href=\"http://wiki.winehq.org/Bugs\">fjl "
+"hasznlatval, azutn <a href=\"http://bugs.wine-staging.com\">fjl "
 "hibajelentshez</a> s csatolja azt a fjlt a jelentshez."
 
 #: winedbg.rc:38
diff --git a/po/it.po b/po/it.po
index bf9f964..fde0aea 100644
--- a/po/it.po
+++ b/po/it.po
@@ -13974,12 +13974,12 @@ msgstr "Dettagli dell'errore del programma"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Se questo problema non  presente sotto Windows e non  stato ancora "
 "riportato, puoi salvare le informazioni dettagliate su un file usando il "
-"pulsante \"Salva con nome\", poi <a href=\"http://wiki.winehq.org/Bugs"
+"pulsante \"Salva con nome\", poi <a href=\"http://bugs.wine-staging.com"
 "\">segnalalo</a> e allega quel file al report del bug."
 
 #: winedbg.rc:38
diff --git a/po/ja.po b/po/ja.po
index 56352c1..b57bc80 100644
--- a/po/ja.po
+++ b/po/ja.po
@@ -13710,12 +13710,12 @@ msgstr " "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 " Windows ["
-"] <a href=\"http://wiki.winehq.org/"
-"Bugs\"> </a>"
+"] <a href=\"http://bugs.wine-staging"
+".com\"> </a>"
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/ko.po b/po/ko.po
index 92560ab..19ca9c5 100644
--- a/po/ko.po
+++ b/po/ko.po
@@ -13754,12 +13754,12 @@ msgstr "  "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "        ,  \""
 "  \"      , <a href="
-"\"http://wiki.winehq.org/Bugs\">  </a>   "
+"\"http://bugs.wine-staging.com\">  </a>   "
 "  ."
 
 #: winedbg.rc:38
diff --git a/po/lt.po b/po/lt.po
index 68a2957..26d1231 100644
--- a/po/lt.po
+++ b/po/lt.po
@@ -13730,13 +13730,13 @@ msgstr "Isamiau apie programos klaid"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Jei ios problemos nra Windows sistemoje ir apie j dar nebuvo praneta, "
 "galite isaugoti isami informacij  fail naudodami mygtuk Isaugoti "
-"kaip, tada <a href=\"http://wiki.winehq.org/Bugs\">uregistruoti klaid</a> "
-"ir prikabinti t fail prie praneimo."
+"kaip, tada <a href=\"http://bugs.wine-staging.com\">uregistruoti klaid</"
+"a> ir prikabinti t fail prie praneimo."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/ml.po b/po/ml.po
index 360c808..57b8fb2 100644
--- a/po/ml.po
+++ b/po/ml.po
@@ -13089,7 +13089,7 @@ msgstr "_"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/nb_NO.po b/po/nb_NO.po
index aef3fec..e943615 100644
--- a/po/nb_NO.po
+++ b/po/nb_NO.po
@@ -13777,12 +13777,12 @@ msgstr "Detaljer for programfeil"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Hvis dette problemet ikke oppstr i Windows og ikke har blitt rapportert "
 "enn, s kan du lagre detaljert informasjon til en fil ved  trykke p "
-"Lagre som-knappen. Deretter kan du <a href=\"http://wiki.winehq.org/Bugs"
+"Lagre som-knappen. Deretter kan du <a href=\"http://bugs.wine-staging.com"
 "\">opprette en feilrapport</a> og legge ved loggfilen."
 
 #: winedbg.rc:38
diff --git a/po/nl.po b/po/nl.po
index 7639437..c6cb873 100644
--- a/po/nl.po
+++ b/po/nl.po
@@ -13929,7 +13929,7 @@ msgstr ""
 "Database</a> naar tips voor dit programma.\n"
 "\n"
 "Als dit probleem niet optreedt onder Windows en nog niet is gerapporteerd, "
-"dan kunt u <a href=\"http://wiki.winehq.org/Bugs\">een bug rapporteren</a>."
+"dan kunt u <a href=\"http://bugs.wine-staging.com\">een bug rapporteren</a>."
 
 #: winedbg.rc:61
 msgid "Show &Details"
@@ -13943,13 +13943,13 @@ msgstr "Programmafout details"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Indien dit probleem zich niet voordoet onder Windows en het probleem is nog "
 "niet gerapporteerd, dan kunt U gedetailleerde informatie in een bestand "
 "opslaan met de \"Opslaan als\" knop. Dit bestand kunt U via <a href=\"http://"
-"wiki.winehq.org/Bugs\">file a bug report</a> versturen."
+"bugs.wine-staging.com\">file a bug report</a> versturen."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/or.po b/po/or.po
index 1d4f052..345d48f 100644
--- a/po/or.po
+++ b/po/or.po
@@ -13089,7 +13089,7 @@ msgstr " (&o)"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/pa.po b/po/pa.po
index 6cacec8..4cf623c 100644
--- a/po/pa.po
+++ b/po/pa.po
@@ -13089,7 +13089,7 @@ msgstr "(&o)"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/pl.po b/po/pl.po
index fc0c938..d873bde 100644
--- a/po/pl.po
+++ b/po/pl.po
@@ -13786,12 +13786,12 @@ msgstr "Szczegy bdu programu"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Jeeli problem ten nie wystpuje w systemie Windows i nie zosta jeszcze "
 "zgoszony, to moesz zapisa szczegowe informacje do pliku uywajc "
-"przycisku \"Zapisz jako\", a nastpnie <a href=\"http://wiki.winehq.org/Bugs"
+"przycisku \"Zapisz jako\", a nastpnie <a href=\"http://bugs.wine-staging.com"
 "\">wypeni zgoszenie o bdzie</a> i doczy ten plik do zgoszenia."
 
 #: winedbg.rc:38
diff --git a/po/pt_BR.po b/po/pt_BR.po
index 8d719ba..bd22d03 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -13800,13 +13800,13 @@ msgstr "Detalhes do Erro do Programa"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Se este problema no est presente no Windows e no foi reportado ainda, "
 "voc pode salvar a informao detalhada do arquivo usando o boto \"Salvar "
-"Como\", <a href=\"http://wiki.winehq.org/Bugs\">enviar um relatrio de erro</"
-"a> e anexar o arquivo ao relatrio."
+"Como\", <a href=\"http://bugs.wine-staging.com\">enviar um relatrio de "
+"erro</a> e anexar o arquivo ao relatrio."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/pt_PT.po b/po/pt_PT.po
index 9637b51..5ff0332 100644
--- a/po/pt_PT.po
+++ b/po/pt_PT.po
@@ -13761,7 +13761,7 @@ msgstr "Detalhes do erro no programa"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/rm.po b/po/rm.po
index 4c47271..d0af32d 100644
--- a/po/rm.po
+++ b/po/rm.po
@@ -13186,7 +13186,7 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/ro.po b/po/ro.po
index ee27a07..4f5ae41 100644
--- a/po/ro.po
+++ b/po/ro.po
@@ -13969,7 +13969,7 @@ msgstr "Detalii eroare de program"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/ru.po b/po/ru.po
index dbb53ab..d7dd829 100644
--- a/po/ru.po
+++ b/po/ru.po
@@ -13724,13 +13724,13 @@ msgstr "  "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "     Windows       ,  "
 "          "
-",  <a href=\"http://wiki.winehq.org/Bugs\">  </a>  "
-"    ."
+",  <a href=\"http://bugs.wine-staging.com\">  </a> "
+"     ."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/sk.po b/po/sk.po
index b9fd256..abf0c7c 100644
--- a/po/sk.po
+++ b/po/sk.po
@@ -13360,7 +13360,7 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/sl.po b/po/sl.po
index d045cf8..7c2d8d6 100644
--- a/po/sl.po
+++ b/po/sl.po
@@ -13909,13 +13909,13 @@ msgstr "Podrobnosti napake v programu"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "e ta teava ni prisotna na sistemu Windows in e ni bila prijavljena, vas "
 "prosimo, da shranite podrobnosti napake v datoteko preko gumba \"Shrani kot"
-"\", nato pa <a href=\"http://bugs.winehq.org\">prijavite napako</a> in ji "
-"priloite ravno ustvarjeno datoteko."
+"\", nato pa <a href=\"http://bugs.wine-staging.com\">prijavite napako</a> in "
+"ji priloite ravno ustvarjeno datoteko."
 
 #: winedbg.rc:38
 msgid "Wine program crash"
diff --git a/po/sr_RS@cyrillic.po b/po/sr_RS@cyrillic.po
index c270129..0995c06 100644
--- a/po/sr_RS@cyrillic.po
+++ b/po/sr_RS@cyrillic.po
@@ -13862,7 +13862,7 @@ msgstr ""
 "http://appdb.winehq.org      .\n"
 "\n"
 "      Windows-     , "
-"   http://bugs.winehq.org."
+"   http://bugs.wine-staging.com."
 
 #: winedbg.rc:61
 #, fuzzy
@@ -13878,7 +13878,7 @@ msgstr " "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/sr_RS@latin.po b/po/sr_RS@latin.po
index 5b4ce21..0c1c187 100644
--- a/po/sr_RS@latin.po
+++ b/po/sr_RS@latin.po
@@ -14005,7 +14005,7 @@ msgstr ""
 "http://appdb.winehq.org za savete o pokretanju ovog programa.\n"
 "\n"
 "Ako ovaj problem nije prisutan pod Windows-om i jo uvek nije prijavljen, "
-"prijavite ga na http://bugs.winehq.org."
+"prijavite ga na http://bugs.wine-staging.com."
 
 #: winedbg.rc:61
 #, fuzzy
@@ -14021,7 +14021,7 @@ msgstr "Programska greka"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/sv.po b/po/sv.po
index c98f642..6afb96c 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -13663,12 +13663,12 @@ msgstr "Detaljer om programfel"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Om denna problem inte presenterar sig i Windows och nnu inte har "
 "rapporterats, kan du spara detaljerna till ett fil med knappen \"Spara som\" "
-"och <a href=\"http://wiki.winehq.org/Bugs\">skicka en bugrapport</a> med "
+"och <a href=\"http://bugs.wine-staging.com\">skicka en bugrapport</a> med "
 "filet som en bilaga."
 
 #: winedbg.rc:38
diff --git a/po/te.po b/po/te.po
index 2d88fdc..ee92cda 100644
--- a/po/te.po
+++ b/po/te.po
@@ -13089,7 +13089,7 @@ msgstr " (&o)"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/th.po b/po/th.po
index 04f46a9..4656ef1 100644
--- a/po/th.po
+++ b/po/th.po
@@ -13355,7 +13355,7 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/tr.po b/po/tr.po
index 65ef67f..c839389 100644
--- a/po/tr.po
+++ b/po/tr.po
@@ -13718,12 +13718,12 @@ msgstr "Program Hata Detaylar"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "Eer bu problem Windows altnda yoksa ve henz rapor edilmemise, \"Farkl "
 "Kaydet\" dmesi kullanarak ayrntl bilgiyi bir dosyaya kaydedebilir; "
-"ardndan bu dosyay ekleyerek bir <a href=\"http://wiki.winehq.org/Bugs"
+"ardndan bu dosyay ekleyerek bir <a href=\"http://bugs.wine-staging.com"
 "\">dosya hatas raporu</a> gnderebilirsiniz."
 
 #: winedbg.rc:38
diff --git a/po/uk.po b/po/uk.po
index 5d46366..3af5f61 100644
--- a/po/uk.po
+++ b/po/uk.po
@@ -13805,12 +13805,12 @@ msgstr "   "
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 "    - Windows,      ,  "
 "     ,   \"Save As"
-"\",   <a href=\"http://wiki.winehq.org/Bugs\">  "
+"\",   <a href=\"http://bugs.wine-staging.com\">  "
 "</a>,     ."
 
 #: winedbg.rc:38
diff --git a/po/wa.po b/po/wa.po
index 8ce5b41..4312075 100644
--- a/po/wa.po
+++ b/po/wa.po
@@ -13257,7 +13257,7 @@ msgstr "&Propiets"
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/wine.pot b/po/wine.pot
index c308da5..5d9983f 100644
--- a/po/wine.pot
+++ b/po/wine.pot
@@ -13020,7 +13020,7 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 
diff --git a/po/zh_CN.po b/po/zh_CN.po
index 3fde75c..eccabe3 100644
--- a/po/zh_CN.po
+++ b/po/zh_CN.po
@@ -13234,11 +13234,11 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 " Windows "
-"<a href=\"http://wiki.winehq.org/Bugs\">"
+"<a href=\"http://bugs.wine-staging.com\">"
 "</a>"
 
 #: winedbg.rc:38
diff --git a/po/zh_TW.po b/po/zh_TW.po
index 1505962..22938b6 100644
--- a/po/zh_TW.po
+++ b/po/zh_TW.po
@@ -13626,11 +13626,11 @@ msgstr ""
 msgid ""
 "If this problem is not present under Windows and has not been reported yet, "
 "you can save the detailed information to a file using the \"Save As\" "
-"button, then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> "
+"button, then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> "
 "and attach that file to the report."
 msgstr ""
 " Windows  "
-"<a href=\"http://wiki.winehq.org/Bugs\">"
+"<a href=\"http://bugs.wine-staging.com\">"
 "</a>"
 
 #: winedbg.rc:38
diff --git a/programs/regedit/regproc.c b/programs/regedit/regproc.c
index 80beb21..643b559 100644
--- a/programs/regedit/regproc.c
+++ b/programs/regedit/regproc.c
@@ -376,7 +376,6 @@ static LONG setValue(WCHAR* val_name, WCHAR* val_data, BOOL is_unicode)
             return ERROR_INVALID_DATA;
         val_data[dwLen-1] = '\0'; /* remove last quotes */
         lpbData = (BYTE*) val_data;
-        dwLen++;  /* include terminating null */
         dwLen = dwLen * sizeof(WCHAR); /* size is in bytes */
     }
     else if (dwParseType == REG_DWORD)  /* Convert the dword types */
diff --git a/programs/wineboot/wineboot.c b/programs/wineboot/wineboot.c
index a20b4e1..db58e40 100644
--- a/programs/wineboot/wineboot.c
+++ b/programs/wineboot/wineboot.c
@@ -272,6 +272,100 @@ static void create_hardware_registry_keys(void)
     HeapFree( GetProcessHeap(), 0, power_info );
 }
 
+struct dyndata_enum_key{
+    WCHAR id[9];
+    WCHAR hardwarekey[64];
+    char  problem[4];
+    char  status[4];
+    char  allocation[12];
+    char  child[4];
+    char  sibling[4];
+    char  parent[4];
+};
+
+static struct dyndata_enum_key predefined_enums[] =
+{
+    {
+        {'C','2','9','A','2','3','D','0',0},
+        {'H','T','R','E','E','\\','R','O','O','T','\\','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4e, 0x08, 0x08, 0x1a},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x40, 0x5a, 0x9a, 0xc2},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00}
+    },
+    {
+        {'C','2','9','A','5','A','4','0',0},
+        {'H','T','R','E','E','\\','R','E','S','E','R','V','E','D','\\','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4e, 0x08, 0x08, 0x18},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x60, 0x5c, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','C','6','0',0},
+        {'R','O','O','T','\\','N','E','T','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x4f, 0x6a, 0x08, 0x18},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0xf0, 0x93, 0x9b, 0xc2},
+        {0xc0, 0x5d, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','D','C','0',0},
+        {'R','O','O','T','\\','P','R','O','C','E','S','S','O','R','_','U','P','D','A','T','E','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0xcf, 0x6a, 0x88, 0x19},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x20, 0x5f, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    },
+    {
+        {'C','2','9','A','5','F','2','0',0},
+        {'R','O','O','T','\\','S','W','E','N','U','M','\\','0','0','0','0',0},
+        {0x00, 0x00, 0x00, 0x00},
+        {0xcf, 0x6a, 0x88, 0x19},
+        {0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},
+        {0x00, 0x00, 0x00, 0x00},
+        {0x20, 0x5f, 0x9a, 0xc2},
+        {0xd0, 0x23, 0x9a, 0xc2}
+    }
+};
+
+/* add entry to HKEY_DYN_DATA\Config Manager\Enum */
+static void add_dynamic_enum_keys(HKEY key, struct dyndata_enum_key *entry)
+{
+    static const WCHAR HardWareKeyW[] = {'H','a','r','d','W','a','r','e','K','e','y',0};
+    static const WCHAR ProblemW[]     = {'P','r','o','b','l','e','m',0};
+    static const WCHAR StatusW[]      = {'S','t','a','t','u','s',0};
+    static const WCHAR AllocationW[]  = {'A','l','l','o','c','a','t','i','o','n',0};
+    static const WCHAR ChildW[]       = {'C','h','i','l','d',0};
+    static const WCHAR SiblingW[]     = {'S','i','b','l','i','n','g',0};
+    static const WCHAR ParentW[]      = {'P','a','r','e','n','t',0};
+
+    HKEY subkey;
+
+    if (!entry)
+        return;
+
+    if (RegCreateKeyExW( key, entry->id, 0, NULL, 0, KEY_WRITE, NULL, &subkey, NULL ))
+        return;
+
+    set_reg_value( subkey, HardWareKeyW, entry->hardwarekey );
+    RegSetValueExW( subkey, ProblemW,    0, REG_BINARY, (const BYTE *)entry->problem,    sizeof(entry->problem) );
+    RegSetValueExW( subkey, StatusW,     0, REG_BINARY, (const BYTE *)entry->status,     sizeof(entry->status) );
+    RegSetValueExW( subkey, AllocationW, 0, REG_BINARY, (const BYTE *)entry->allocation, sizeof(entry->allocation) );
+    RegSetValueExW( subkey, ChildW,      0, REG_BINARY, (const BYTE *)entry->child,      sizeof(entry->child) );
+    RegSetValueExW( subkey, SiblingW,    0, REG_BINARY, (const BYTE *)entry->sibling,    sizeof(entry->sibling) );
+    RegSetValueExW( subkey, ParentW,     0, REG_BINARY, (const BYTE *)entry->parent,     sizeof(entry->parent) );
+
+    RegCloseKey( subkey );
+}
 
 /* create the DynData registry keys */
 static void create_dynamic_registry_keys(void)
@@ -281,11 +375,18 @@ static void create_dynamic_registry_keys(void)
     static const WCHAR ConfigManagerW[] = {'C','o','n','f','i','g',' ','M','a','n','a','g','e','r','\\',
                                            'E','n','u','m',0};
     HKEY key;
+    int entry;
 
     if (!RegCreateKeyExW( HKEY_DYN_DATA, StatDataW, 0, NULL, 0, KEY_WRITE, NULL, &key, NULL ))
         RegCloseKey( key );
+
     if (!RegCreateKeyExW( HKEY_DYN_DATA, ConfigManagerW, 0, NULL, 0, KEY_WRITE, NULL, &key, NULL ))
+    {
+        for (entry = 0; entry < sizeof(predefined_enums) / sizeof(predefined_enums[0]); entry++)
+            add_dynamic_enum_keys( key, &predefined_enums[entry] );
+
         RegCloseKey( key );
+    }
 }
 
 /* create the platform-specific environment registry keys */
diff --git a/programs/winecfg/Makefile.in b/programs/winecfg/Makefile.in
index 4e66e04..1cf7031 100644
--- a/programs/winecfg/Makefile.in
+++ b/programs/winecfg/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	driveui.c \
 	libraries.c \
 	main.c \
+	staging.c \
 	theme.c \
 	winecfg.c \
 	x11drvdlg.c
diff --git a/programs/winecfg/drive.c b/programs/winecfg/drive.c
index 8cad14a..a740d74 100644
--- a/programs/winecfg/drive.c
+++ b/programs/winecfg/drive.c
@@ -106,7 +106,7 @@ BOOL add_drive(char letter, const char *targetpath, const char *device, const WC
                wine_dbgstr_w(label), serial, type);
 
     drives[driveIndex].letter   = toupper(letter);
-    drives[driveIndex].unixpath = strdupA(targetpath);
+    drives[driveIndex].unixpath = targetpath ? strdupA(targetpath) : NULL;
     drives[driveIndex].device   = device ? strdupA(device) : NULL;
     drives[driveIndex].label    = label ? strdupW(label) : NULL;
     drives[driveIndex].serial   = serial;
@@ -290,8 +290,7 @@ BOOL load_drives(void)
                 volname[0] = 0;
                 serial = 0;
             }
-            if (unixpath)  /* FIXME: handle unmounted drives too */
-                add_drive( root[0], unixpath, device, volname, serial, get_drive_type(root[0]) );
+            add_drive( root[0], unixpath, device, volname, serial, get_drive_type(root[0]) );
             root[0]++;
         }
         else
@@ -331,32 +330,33 @@ void apply_drive_changes(void)
         len = sizeof(*ioctl);
         if (drives[i].in_use)
         {
-            len += strlen(drives[i].unixpath) + 1;
+            if (drives[i].unixpath) len += strlen(drives[i].unixpath) + 1;
             if (drives[i].device) len += strlen(drives[i].device) + 1;
         }
         if (!(ioctl = HeapAlloc( GetProcessHeap(), 0, len ))) continue;
         ioctl->size = len;
+        ioctl->type = DRIVE_NO_ROOT_DIR;
         ioctl->letter = 'a' + i;
+        ioctl->mount_point_offset = 0;
         ioctl->device_offset = 0;
         if (drives[i].in_use)
         {
             char *ptr = (char *)(ioctl + 1);
 
             ioctl->type = drives[i].type;
-            strcpy( ptr, drives[i].unixpath );
-            ioctl->mount_point_offset = ptr - (char *)ioctl;
-            if (drives[i].device)
+            if (drives[i].unixpath)
             {
+                strcpy( ptr, drives[i].unixpath );
+                ioctl->mount_point_offset = ptr - (char *)ioctl;
                 ptr += strlen(ptr) + 1;
+            }
+
+            if (drives[i].device)
+            {
                 strcpy( ptr, drives[i].device );
                 ioctl->device_offset = ptr - (char *)ioctl;
             }
         }
-        else
-        {
-            ioctl->type = DRIVE_NO_ROOT_DIR;
-            ioctl->mount_point_offset = 0;
-        }
 
         if (DeviceIoControl( mgr, IOCTL_MOUNTMGR_DEFINE_UNIX_DRIVE, ioctl, len, NULL, 0, NULL, NULL ))
         {
diff --git a/programs/winecfg/driveui.c b/programs/winecfg/driveui.c
index 98e057b..fcd7ac3 100644
--- a/programs/winecfg/driveui.c
+++ b/programs/winecfg/driveui.c
@@ -176,14 +176,12 @@ static void enable_labelserial_box(HWND dialog, int mode)
     {
         case BOX_MODE_DEVICE:
             /* FIXME: enable device editing */
-            disable(IDC_EDIT_DEVICE);
             disable(IDC_BUTTON_BROWSE_DEVICE);
             disable(IDC_EDIT_SERIAL);
             disable(IDC_EDIT_LABEL);
             break;
 
         case BOX_MODE_NORMAL:
-            disable(IDC_EDIT_DEVICE);
             disable(IDC_BUTTON_BROWSE_DEVICE);
             enable(IDC_EDIT_SERIAL);
             enable(IDC_EDIT_LABEL);
@@ -234,7 +232,7 @@ static int fill_drives_list(HWND dialog)
         lv_insert_item(dialog, &item);
         HeapFree(GetProcessHeap(), 0, item.pszText);
 
-        path = strdupU2W(drives[i].unixpath);
+        path = strdupU2W(drives[i].unixpath ? drives[i].unixpath : "");
         lv_set_item_text(dialog, count, 1, path);
         HeapFree(GetProcessHeap(), 0, path);
 
@@ -433,7 +431,7 @@ static void update_controls(HWND dialog)
 
     /* path */
     WINE_TRACE("set path control text to '%s'\n", current_drive->unixpath);
-    path = strdupU2W(current_drive->unixpath);
+    path = strdupU2W(current_drive->unixpath ? current_drive->unixpath : "");
     set_textW(dialog, IDC_EDIT_PATH, path);
     HeapFree(GetProcessHeap(), 0, path);
 
@@ -518,11 +516,11 @@ static void on_edit_changed(HWND dialog, WORD id)
             else
             {
                 path = NULL;
-                wpath = strdupU2W("drive_c");
+                wpath = strdupU2W("");
             }
 
             HeapFree(GetProcessHeap(), 0, current_drive->unixpath);
-            current_drive->unixpath = path ? path : strdupA("drive_c");
+            current_drive->unixpath = path;
             current_drive->modified = TRUE;
 
             WINE_TRACE("set path to %s\n", current_drive->unixpath);
@@ -554,9 +552,20 @@ static void on_edit_changed(HWND dialog, WORD id)
 
         case IDC_EDIT_DEVICE:
         {
-            char *device = get_text(dialog, id);
-            /* TODO: handle device if/when it makes sense to do so.... */
-            HeapFree(GetProcessHeap(), 0, device);
+            WCHAR *wdevice = get_textW(dialog, id);
+            char *device;
+            int lenW;
+
+            HeapFree(GetProcessHeap(), 0, current_drive->device);
+
+            if ((lenW = WideCharToMultiByte(CP_UNIXCP, 0, wdevice, -1, NULL, 0, NULL, NULL)))
+            {
+                device = HeapAlloc(GetProcessHeap(), 0, lenW);
+                WideCharToMultiByte(CP_UNIXCP, 0, wdevice, -1, device, lenW, NULL, NULL);
+                current_drive->device = device;
+            }
+            else
+                current_drive->device = NULL;
             break;
         }
     }
diff --git a/programs/winecfg/libraries.c b/programs/winecfg/libraries.c
index f00449d..8e97d9e 100644
--- a/programs/winecfg/libraries.c
+++ b/programs/winecfg/libraries.c
@@ -642,6 +642,18 @@ LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
                         else
                             set_controls_from_selection(hDlg);
                         break;
+            case CBN_DBLCLK:
+                if (LOWORD(wParam) == IDC_DLLS_LIST)
+                {
+                    int index;
+                    POINT p;
+                    if (GetCursorPos(&p) && ScreenToClient((HWND)lParam, &p))
+                    {
+                        index = SendDlgItemMessageW(hDlg, IDC_DLLS_LIST, LB_ITEMFROMPOINT, 0, MAKELPARAM(p.x, p.y));
+                        if (!HIWORD(index)) on_edit_click(hDlg);
+                    }
+                }
+                break;
 		}
 		break;
 	}
diff --git a/programs/winecfg/main.c b/programs/winecfg/main.c
index b8a85fe..de209a9 100644
--- a/programs/winecfg/main.c
+++ b/programs/winecfg/main.c
@@ -58,7 +58,7 @@ PropSheetCallback (HWND hWnd, UINT uMsg, LPARAM lParam)
     return 0;
 }
 
-#define NUM_PROPERTY_PAGES 7
+#define NUM_PROPERTY_PAGES 8
 
 static INT_PTR
 doPropertySheet (HINSTANCE hInstance, HWND hOwner)
@@ -139,6 +139,16 @@ doPropertySheet (HINSTANCE hInstance, HWND hOwner)
     psp[pg].lParam = 0;
     pg++;
 
+    psp[pg].dwSize = sizeof (PROPSHEETPAGEW);
+    psp[pg].dwFlags = PSP_USETITLE;
+    psp[pg].hInstance = hInstance;
+    psp[pg].u.pszTemplate = MAKEINTRESOURCEW (IDD_STAGING);
+    psp[pg].u2.pszIcon = NULL;
+    psp[pg].pfnDlgProc = StagingDlgProc;
+    psp[pg].pszTitle =  load_string (IDS_TAB_STAGING);
+    psp[pg].lParam = 0;
+    pg++;
+
     /*
      * Fill out the (General) PROPSHEETPAGE data structure 
      * for the property sheet
diff --git a/programs/winecfg/resource.h b/programs/winecfg/resource.h
index 8604fb4..4f5a93e 100644
--- a/programs/winecfg/resource.h
+++ b/programs/winecfg/resource.h
@@ -45,6 +45,7 @@
 #define IDS_SHELL_FOLDER                16
 #define IDS_LINKS_TO                    17
 #define IDS_WINECFG_TITLE_APP           18   /* App specific title */
+#define IDS_TAB_STAGING                 19
 #define IDI_WINECFG                     100
 #define IDI_LOGO                        102
 #define IDD_ABOUTCFG                    107
@@ -54,6 +55,7 @@
 #define IDD_DLLCFG                      111
 #define IDD_DRIVECFG                    112
 #define IDD_DESKTOP_INTEGRATION         115
+#define IDD_STAGING                     116
 #define IDC_WINVER                      1012
 #define IDC_DESKTOP_WIDTH               1023
 #define IDC_DESKTOP_HEIGHT              1024
@@ -210,6 +212,11 @@
 #define IDC_SYSPARAMS_MENU_HILIGHT      8430
 #define IDC_SYSPARAMS_MENUBAR           8431
 
+/* Staging tab */
+#define IDC_ENABLE_CSMT                 9001
+#define IDC_ENABLE_VAAPI                9002
+#define IDC_ENABLE_EAX                  9003
+
 /* About tab */
 #define IDC_ABT_OWNER                8432
 #define IDC_ABT_ORG                  8433
diff --git a/programs/winecfg/winecfg.h b/programs/winecfg/winecfg.h
index 110856a..a949474 100644
--- a/programs/winecfg/winecfg.h
+++ b/programs/winecfg/winecfg.h
@@ -87,6 +87,7 @@ INT_PTR CALLBACK AppDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
 INT_PTR CALLBACK LibrariesDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AudioDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK ThemeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
+INT_PTR CALLBACK StagingDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 INT_PTR CALLBACK AboutDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
 
 /* Drive management  */
diff --git a/programs/winecfg/winecfg.rc b/programs/winecfg/winecfg.rc
index 221916b..0855074 100644
--- a/programs/winecfg/winecfg.rc
+++ b/programs/winecfg/winecfg.rc
@@ -39,6 +39,7 @@ BEGIN
     IDS_TAB_GRAPHICS        "Graphics"
     IDS_TAB_DESKTOP_INTEGRATION "Desktop Integration"
     IDS_TAB_AUDIO           "Audio"
+    IDS_TAB_STAGING         "Staging"
     IDS_TAB_ABOUT           "About"
     IDS_WINECFG_TITLE       "Wine configuration"
     IDS_WINECFG_TITLE_APP   "Wine configuration for %s"
@@ -308,6 +309,17 @@ BEGIN
     PUSHBUTTON      "B&rowse...",IDC_BROWSE_SFPATH,195,195,50,13,WS_DISABLED
 END
 
+IDD_STAGING DIALOG  0, 0, 260, 220
+STYLE WS_CHILD | WS_DISABLED
+FONT 8, "MS Shell Dlg"
+BEGIN
+    GROUPBOX    "Staging settings",IDC_STATIC,8,4,244,210
+    LTEXT       "The following settings are experimental and may break stuff!\nMake sure to reset them again in case of a problem.",IDC_STATIC,16,16,230,16
+    CONTROL     "Enable &CSMT for better graphic performance",IDC_ENABLE_CSMT,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,40,230,8
+    CONTROL     "Enable &VAAPI as backend for DXVA2 GPU decoding",IDC_ENABLE_VAAPI,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,55,230,8
+    CONTROL     "Enable Environmental Audio E&xtensions (EAX)",IDC_ENABLE_EAX,"Button",BS_AUTOCHECKBOX | WS_TABSTOP,16,70,230,8
+END
+
 LANGUAGE LANG_NEUTRAL, SUBLANG_NEUTRAL
 
 /* @makedep: winecfg.ico */
diff --git a/programs/winedbg/winedbg.rc b/programs/winedbg/winedbg.rc
index 7514f9d..11de95d 100644
--- a/programs/winedbg/winedbg.rc
+++ b/programs/winedbg/winedbg.rc
@@ -68,7 +68,7 @@ BEGIN
     EDITTEXT        IDC_CRASH_TXT, 4, 4, 392, 272, ES_MULTILINE | ES_READONLY | WS_HSCROLL | WS_VSCROLL, WS_TABSTOP
     CONTROL         "If this problem is not present under Windows and has not been reported yet, \
                      you can save the detailed information to a file using the \"Save As\" button, \
-                     then <a href=\"http://wiki.winehq.org/Bugs\">file a bug report</a> \
+                     then <a href=\"http://bugs.wine-staging.com\">file a bug report</a> \
                      and attach that file to the report.",
                     IDC_STATIC_TXT2,"SysLink",0,6,285,388,32
     DEFPUSHBUTTON   "Close", IDOK, 326, 320, 70, 16, WS_TABSTOP
diff --git a/programs/winedevice/device.c b/programs/winedevice/device.c
index 9677a82..449c7a2 100644
--- a/programs/winedevice/device.c
+++ b/programs/winedevice/device.c
@@ -61,6 +61,38 @@ static LDR_MODULE *find_ldr_module( HMODULE module )
     return NULL;
 }
 
+/* change permissions of a specific memory range, save original permissions */
+static void virtual_protect_save( void *addr, SIZE_T size, ULONG new_prot, ULONG *old_prot )
+{
+    SYSTEM_BASIC_INFORMATION info;
+    UINT i = 0;
+
+    NtQuerySystemInformation( SystemBasicInformation, &info, sizeof(info), NULL );
+    while (size)
+    {
+        SIZE_T block_size = min( size, info.PageSize - ((UINT_PTR)addr & (info.PageSize - 1)) );
+        VirtualProtect( addr, block_size, new_prot, &old_prot[i++] );
+        addr  = (void *)((char *)addr + block_size);
+        size -= block_size;
+    }
+}
+
+/* restore permissions for a specific memory range */
+static void virtual_protect_load( void *addr, SIZE_T size, ULONG *old_prot )
+{
+    SYSTEM_BASIC_INFORMATION info;
+    UINT i = 0;
+
+    NtQuerySystemInformation( SystemBasicInformation, &info, sizeof(info), NULL );
+    while (size)
+    {
+        SIZE_T block_size = min( size, info.PageSize - ((UINT_PTR)addr & (info.PageSize - 1)) );
+        VirtualProtect( addr, block_size, old_prot[i++], NULL );
+        addr  = (void *)((char *)addr + block_size);
+        size -= block_size;
+    }
+}
+
 /* load the driver module file */
 static HMODULE load_driver_module( const WCHAR *name )
 {
@@ -84,7 +116,7 @@ static HMODULE load_driver_module( const WCHAR *name )
     if (nt->OptionalHeader.SectionAlignment < info.PageSize ||
         !(nt->FileHeader.Characteristics & IMAGE_FILE_DLL))
     {
-        DWORD old;
+        DWORD old_prot[3];
         IMAGE_BASE_RELOCATION *rel, *end;
 
         if ((rel = RtlImageDirectoryEntryToData( module, TRUE, IMAGE_DIRECTORY_ENTRY_BASERELOC, &size )))
@@ -92,20 +124,24 @@ static HMODULE load_driver_module( const WCHAR *name )
             WINE_TRACE( "%s: relocating from %p to %p\n",
                         wine_dbgstr_w(name), (char *)module - delta, module );
             end = (IMAGE_BASE_RELOCATION *)((char *)rel + size);
-            while (rel < end && rel->SizeOfBlock)
+            while (rel < end - 1 && rel->SizeOfBlock)
             {
                 void *page = (char *)module + rel->VirtualAddress;
-                VirtualProtect( page, info.PageSize, PAGE_EXECUTE_READWRITE, &old );
+                /* LdrProcessRelocationBlock can access the memory range from page - (page + 0xfff + 8), so
+                 * changing permissions of a single page is not sufficient. We assume here that the minimum
+                 * page size is 0x1000, so we have to save/restore two or three pages, depending on the
+                 * virtual address. */
+                virtual_protect_save( page, 0xfff + 8, PAGE_EXECUTE_READWRITE, old_prot );
                 rel = LdrProcessRelocationBlock( page, (rel->SizeOfBlock - sizeof(*rel)) / sizeof(USHORT),
                                                  (USHORT *)(rel + 1), delta );
-                if (old != PAGE_EXECUTE_READWRITE) VirtualProtect( page, info.PageSize, old, NULL );
+                virtual_protect_load( page, 0xfff + 8, old_prot );
                 if (!rel) goto error;
             }
             /* make sure we don't try again */
             size = FIELD_OFFSET( IMAGE_NT_HEADERS, OptionalHeader ) + nt->FileHeader.SizeOfOptionalHeader;
-            VirtualProtect( nt, size, PAGE_READWRITE, &old );
+            VirtualProtect( nt, size, PAGE_READWRITE, &old_prot[0] );
             nt->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC].VirtualAddress = 0;
-            VirtualProtect( nt, size, old, NULL );
+            VirtualProtect( nt, size, old_prot[0], NULL );
         }
     }
 
diff --git a/programs/winemenubuilder/Makefile.in b/programs/winemenubuilder/Makefile.in
index 07e2702..a4e28ad 100644
--- a/programs/winemenubuilder/Makefile.in
+++ b/programs/winemenubuilder/Makefile.in
@@ -1,6 +1,7 @@
 MODULE    = winemenubuilder.exe
 APPMODE   = -mwindows -municode
 IMPORTS   = uuid windowscodecs shell32 shlwapi ole32 user32 advapi32
+EXTRADEFS = -DBINDIR="\"${bindir}\""
 
 C_SRCS = \
 	winemenubuilder.c
diff --git a/programs/winemenubuilder/winemenubuilder.c b/programs/winemenubuilder/winemenubuilder.c
index bc1540b..5e5666a 100644
--- a/programs/winemenubuilder/winemenubuilder.c
+++ b/programs/winemenubuilder/winemenubuilder.c
@@ -104,6 +104,14 @@ WINE_DEFAULT_DEBUG_CHANNEL(menubuilder);
 #define in_startmenu(csidl)   ((csidl)==CSIDL_STARTMENU || \
                                (csidl)==CSIDL_COMMON_STARTMENU)
 
+/* On linux we create all menu item entries with an absolute path to wine,
+ * in order to allow using multiple wine versions at the same time. */
+#ifdef __linux__
+    static const char wine_path[] = BINDIR "/wine";
+#else
+    static const char wine_path[] = "wine";
+#endif
+
 /* link file formats */
 
 #include "pshpack1.h"
@@ -1488,8 +1496,8 @@ static BOOL write_desktop_entry(const char *unix_link, const char *location, con
 
     fprintf(file, "[Desktop Entry]\n");
     fprintf(file, "Name=%s\n", linkname);
-    fprintf(file, "Exec=env WINEPREFIX=\"%s\" wine %s %s\n",
-            wine_get_config_dir(), path, args);
+    fprintf(file, "Exec=env WINEPREFIX=\"%s\" %s %s %s\n",
+            wine_get_config_dir(), wine_path, path, args);
     fprintf(file, "Type=Application\n");
     fprintf(file, "StartupNotify=true\n");
     if (descr && lstrlenA(descr))
@@ -2540,7 +2548,8 @@ static BOOL write_freedesktop_association_entry(const char *desktopPath, const c
         fprintf(desktop, "Type=Application\n");
         fprintf(desktop, "Name=%s\n", friendlyAppName);
         fprintf(desktop, "MimeType=%s;\n", mimeType);
-        fprintf(desktop, "Exec=env WINEPREFIX=\"%s\" wine start /ProgIDOpen %s %%f\n", wine_get_config_dir(), progId);
+        fprintf(desktop, "Exec=env WINEPREFIX=\"%s\" %s start /ProgIDOpen %s %%f\n",
+                wine_get_config_dir(), wine_path, progId);
         fprintf(desktop, "NoDisplay=true\n");
         fprintf(desktop, "StartupNotify=true\n");
         if (openWithIcon)
diff --git a/server/Makefile.in b/server/Makefile.in
index 19a4fac..0fe5cbb 100644
--- a/server/Makefile.in
+++ b/server/Makefile.in
@@ -30,6 +30,7 @@ C_SRCS = \
 	region.c \
 	registry.c \
 	request.c \
+	scheduler.c \
 	semaphore.c \
 	serial.c \
 	signal.c \
diff --git a/server/change.c b/server/change.c
index 3ac70a4..87b45f8 100644
--- a/server/change.c
+++ b/server/change.c
@@ -281,39 +281,17 @@ static struct fd *dir_get_fd( struct object *obj )
     return (struct fd *)grab_object( dir->fd );
 }
 
-static int get_dir_unix_fd( struct dir *dir )
-{
-    return get_unix_fd( dir->fd );
-}
-
 static struct security_descriptor *dir_get_sd( struct object *obj )
 {
     struct dir *dir = (struct dir *)obj;
-    int unix_fd;
-    struct stat st;
     struct security_descriptor *sd;
-    assert( obj->ops == &dir_ops );
-
-    unix_fd = get_dir_unix_fd( dir );
-
-    if (unix_fd == -1 || fstat( unix_fd, &st ) == -1)
-        return obj->sd;
+    struct fd *fd;
 
-    /* mode and uid the same? if so, no need to re-generate security descriptor */
-    if (obj->sd &&
-        (st.st_mode & (S_IRWXU|S_IRWXO)) == (dir->mode & (S_IRWXU|S_IRWXO)) &&
-        (st.st_uid == dir->uid))
-        return obj->sd;
-
-    sd = mode_to_sd( st.st_mode,
-                     security_unix_uid_to_sid( st.st_uid ),
-                     token_get_primary_group( current->process->token ));
-    if (!sd) return obj->sd;
+    assert( obj->ops == &dir_ops );
 
-    dir->mode = st.st_mode;
-    dir->uid = st.st_uid;
-    free( obj->sd );
-    obj->sd = sd;
+    fd = dir_get_fd( obj );
+    sd = get_file_sd( obj, fd, &dir->mode, &dir->uid );
+    release_object( fd );
     return sd;
 }
 
@@ -321,48 +299,15 @@ static int dir_set_sd( struct object *obj, const struct security_descriptor *sd,
                        unsigned int set_info )
 {
     struct dir *dir = (struct dir *)obj;
-    const SID *owner;
-    struct stat st;
-    mode_t mode;
-    int unix_fd;
+    struct fd *fd;
+    int ret;
 
     assert( obj->ops == &dir_ops );
 
-    unix_fd = get_dir_unix_fd( dir );
-
-    if (unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
-
-    if (set_info & OWNER_SECURITY_INFORMATION)
-    {
-        owner = sd_get_owner( sd );
-        if (!owner)
-        {
-            set_error( STATUS_INVALID_SECURITY_DESCR );
-            return 0;
-        }
-        if (!obj->sd || !security_equal_sid( owner, sd_get_owner( obj->sd ) ))
-        {
-            /* FIXME: get Unix uid and call fchown */
-        }
-    }
-    else if (obj->sd)
-        owner = sd_get_owner( obj->sd );
-    else
-        owner = token_get_user( current->process->token );
-
-    if (set_info & DACL_SECURITY_INFORMATION)
-    {
-        /* keep the bits that we don't map to access rights in the ACL */
-        mode = st.st_mode & (S_ISUID|S_ISGID|S_ISVTX);
-        mode |= sd_to_mode( sd, owner );
-
-        if (((st.st_mode ^ mode) & (S_IRWXU|S_IRWXG|S_IRWXO)) && fchmod( unix_fd, mode ) == -1)
-        {
-            file_set_error();
-            return 0;
-        }
-    }
-    return 1;
+    fd = dir_get_fd( obj );
+    ret = set_file_sd( obj, fd, &dir->mode, &dir->uid, sd, set_info );
+    release_object( fd );
+    return ret;
 }
 
 static struct change_record *get_first_change_record( struct dir *dir )
@@ -1075,7 +1020,8 @@ static int dir_add_to_existing_notify( struct dir *dir )
 
 #endif  /* USE_INOTIFY */
 
-struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode )
+struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode,
+                               const struct security_descriptor *sd )
 {
     struct dir *dir;
 
@@ -1094,6 +1040,11 @@ struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode )
     dir->uid  = ~(uid_t)0;
     set_fd_user( fd, &dir_fd_ops, &dir->obj );
 
+    if (sd) dir_set_sd( &dir->obj, sd, OWNER_SECURITY_INFORMATION |
+                                       GROUP_SECURITY_INFORMATION |
+                                       DACL_SECURITY_INFORMATION |
+                                       SACL_SECURITY_INFORMATION );
+
     dir_add_to_existing_notify( dir );
 
     return &dir->obj;
diff --git a/server/fd.c b/server/fd.c
index e3b722c..565a666c 100644
--- a/server/fd.c
+++ b/server/fd.c
@@ -164,7 +164,8 @@ struct closed_fd
 {
     struct list entry;       /* entry in inode closed list */
     int         unix_fd;     /* the unix file descriptor */
-    char        unlink[1];   /* name to unlink on close (if any) */
+    int         unlink;      /* whether to unlink on close */
+    char       *unix_name;   /* name to unlink on close, points to parent fd unix_name */
 };
 
 struct fd
@@ -1016,9 +1017,10 @@ static void inode_close_pending( struct inode *inode, int keep_unlinks )
             close( fd->unix_fd );
             fd->unix_fd = -1;
         }
-        if (!keep_unlinks || !fd->unlink[0])  /* get rid of it unless there's an unlink pending on that file */
+        if (!keep_unlinks || !fd->unlink)  /* get rid of it unless there's an unlink pending on that file */
         {
             list_remove( ptr );
+            free( fd->unix_name );
             free( fd );
         }
         ptr = next;
@@ -1048,16 +1050,17 @@ static void inode_destroy( struct object *obj )
         struct closed_fd *fd = LIST_ENTRY( ptr, struct closed_fd, entry );
         list_remove( ptr );
         if (fd->unix_fd != -1) close( fd->unix_fd );
-        if (fd->unlink[0])
+        if (fd->unlink)
         {
             /* make sure it is still the same file */
             struct stat st;
-            if (!stat( fd->unlink, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
+            if (!stat( fd->unix_name, &st ) && st.st_dev == inode->device->dev && st.st_ino == inode->ino)
             {
-                if (S_ISDIR(st.st_mode)) rmdir( fd->unlink );
-                else unlink( fd->unlink );
+                if (S_ISDIR(st.st_mode)) rmdir( fd->unix_name );
+                else unlink( fd->unix_name );
             }
         }
+        free( fd->unix_name );
         free( fd );
     }
     release_object( inode->device );
@@ -1103,7 +1106,7 @@ static void inode_add_closed_fd( struct inode *inode, struct closed_fd *fd )
     {
         list_add_head( &inode->closed, &fd->entry );
     }
-    else if (fd->unlink[0])  /* close the fd but keep the structure around for unlink */
+    else if (fd->unlink)  /* close the fd but keep the structure around for unlink */
     {
         if (fd->unix_fd != -1) close( fd->unix_fd );
         fd->unix_fd = -1;
@@ -1112,6 +1115,7 @@ static void inode_add_closed_fd( struct inode *inode, struct closed_fd *fd )
     else  /* no locks on this inode and no unlink, get rid of the fd */
     {
         if (fd->unix_fd != -1) close( fd->unix_fd );
+        free( fd->unix_name );
         free( fd );
     }
 }
@@ -1451,7 +1455,7 @@ static void fd_dump( struct object *obj, int verbose )
 {
     struct fd *fd = (struct fd *)obj;
     fprintf( stderr, "Fd unix_fd=%d user=%p options=%08x", fd->unix_fd, fd->user, fd->options );
-    if (fd->inode) fprintf( stderr, " inode=%p unlink='%s'", fd->inode, fd->closed->unlink );
+    if (fd->inode) fprintf( stderr, " inode=%p unlink=%d", fd->inode, fd->closed->unlink );
     fprintf( stderr, "\n" );
 }
 
@@ -1465,7 +1469,6 @@ static void fd_destroy( struct object *obj )
 
     if (fd->completion) release_object( fd->completion );
     remove_fd_locks( fd );
-    free( fd->unix_name );
     list_remove( &fd->inode_entry );
     if (fd->poll_index != -1) remove_poll_user( fd, fd->poll_index );
     if (fd->inode)
@@ -1476,6 +1479,7 @@ static void fd_destroy( struct object *obj )
     else  /* no inode, close it right away */
     {
         if (fd->unix_fd != -1) close( fd->unix_fd );
+        free( fd->unix_name );
     }
 }
 
@@ -1563,7 +1567,7 @@ static inline void unmount_fd( struct fd *fd )
     fd->unix_fd = -1;
     fd->no_fd_status = STATUS_VOLUME_DISMOUNTED;
     fd->closed->unix_fd = -1;
-    fd->closed->unlink[0] = 0;
+    fd->closed->unlink = 0;
 
     /* stop using Unix locks on this fd (existing locks have been removed by close) */
     fd->fs_locks = 0;
@@ -1662,7 +1666,8 @@ struct fd *dup_fd_object( struct fd *orig, unsigned int access, unsigned int sha
             goto failed;
         }
         closed->unix_fd = fd->unix_fd;
-        closed->unlink[0] = 0;
+        closed->unlink = 0;
+        closed->unix_name = fd->unix_name;
         fd->closed = closed;
         fd->inode = (struct inode *)grab_object( orig->inode );
         list_add_head( &fd->inode->open, &fd->inode_entry );
@@ -1738,9 +1743,9 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
     struct stat st;
     struct closed_fd *closed_fd;
     struct fd *fd;
-    const char *unlink_name = "";
     int root_fd = -1;
     int rw_mode;
+    int do_chmod = 0;
 
     if (((options & FILE_DELETE_ON_CLOSE) && !(access & DELETE)) ||
         ((options & FILE_DIRECTORY_FILE) && (flags & O_TRUNC)))
@@ -1752,8 +1757,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
     if (!(fd = alloc_fd_object())) return NULL;
 
     fd->options = options;
-    if (options & FILE_DELETE_ON_CLOSE) unlink_name = name;
-    if (!(closed_fd = mem_alloc( sizeof(*closed_fd) + strlen(unlink_name) )))
+    if (!(closed_fd = mem_alloc( sizeof(*closed_fd) )))
     {
         release_object( fd );
         return NULL;
@@ -1773,7 +1777,12 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
     /* create the directory if needed */
     if ((options & FILE_DIRECTORY_FILE) && (flags & O_CREAT))
     {
-        if (mkdir( name, *mode ) == -1)
+        if (mkdir( name, *mode | S_IRUSR ) != -1)
+        {
+            /* remove S_IRUSR later, after we have opened the directory */
+            do_chmod = !(*mode & S_IRUSR);
+        }
+        else
         {
             if (errno != EEXIST || (flags & O_EXCL))
             {
@@ -1801,16 +1810,37 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
             if ((access & FILE_UNIX_WRITE_ACCESS) || (flags & O_CREAT))
                 fd->unix_fd = open( name, O_RDONLY | (flags & ~(O_TRUNC | O_CREAT | O_EXCL)), *mode );
         }
+        else if (errno == EACCES)
+        {
+            /* try to change permissions temporarily to open a file descriptor */
+            if (!(access & (FILE_UNIX_WRITE_ACCESS | FILE_UNIX_READ_ACCESS | DELETE)) &&
+                !stat( name, &st ) && st.st_uid == getuid() &&
+                !chmod( name, st.st_mode | S_IRUSR ))
+            {
+                fd->unix_fd = open( name, O_RDONLY | (flags & ~(O_TRUNC | O_CREAT | O_EXCL)), *mode );
+                *mode = st.st_mode;
+                do_chmod = 1;
+            }
+            else
+            {
+                set_error( STATUS_ACCESS_DENIED );
+                goto error;
+            }
+        }
 
         if (fd->unix_fd == -1)
         {
             file_set_error();
+            if (do_chmod) chmod( name, *mode );
             goto error;
         }
     }
 
     closed_fd->unix_fd = fd->unix_fd;
-    closed_fd->unlink[0] = 0;
+    closed_fd->unlink = 0;
+    closed_fd->unix_name = fd->unix_name;
+
+    if (do_chmod) fchmod( fd->unix_fd, *mode );
     fstat( fd->unix_fd, &st );
     *mode = st.st_mode;
 
@@ -1832,6 +1862,16 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
         fd->cacheable = !inode->device->removable;
         list_add_head( &inode->open, &fd->inode_entry );
 
+        /* can't unlink files we don't have permission to access */
+        if ((options & FILE_DELETE_ON_CLOSE) && S_ISREG(st.st_mode) &&
+            !(flags & O_CREAT) && !(st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
+        {
+            /* FIXME: instead of checking for O_CREAT it should check if the file was created */
+            release_object( fd );
+            set_error( STATUS_CANNOT_DELETE );
+            return NULL;
+        }
+
         /* check directory options */
         if ((options & FILE_DIRECTORY_FILE) && !S_ISDIR(st.st_mode))
         {
@@ -1851,7 +1891,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
             set_error( err );
             return NULL;
         }
-        strcpy( closed_fd->unlink, unlink_name );
+        closed_fd->unlink = (options & FILE_DELETE_ON_CLOSE) != 0;
         if (flags & O_TRUNC)
         {
             if (S_ISDIR(st.st_mode))
@@ -1870,7 +1910,7 @@ struct fd *open_fd( struct fd *root, const char *name, int flags, mode_t *mode,
             set_error( STATUS_NOT_A_DIRECTORY );
             goto error;
         }
-        if (unlink_name[0])  /* we can't unlink special files */
+        if (options & FILE_DELETE_ON_CLOSE)  /* we can't unlink special files */
         {
             set_error( STATUS_INVALID_PARAMETER );
             goto error;
@@ -1917,6 +1957,58 @@ unsigned int get_fd_options( struct fd *fd )
     return fd->options;
 }
 
+/* set disposition for the fd */
+void set_fd_disposition( struct fd *fd, int unlink )
+{
+    struct stat st;
+    struct list *ptr;
+
+    if (fd->unix_fd == -1)
+    {
+        set_error( STATUS_INVALID_HANDLE );
+        return;
+    }
+
+    if (fstat( fd->unix_fd, &st ) == -1)
+    {
+        file_set_error();
+        return;
+    }
+
+    if (unlink && !S_ISDIR(st.st_mode) && !S_ISREG(st.st_mode))
+    {
+        /* can't unlink special files */
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+
+    if (unlink && !(st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)))
+    {
+        /* can't unlink files we don't have permission to access */
+        set_error( STATUS_CANNOT_DELETE );
+        return;
+    }
+
+    LIST_FOR_EACH( ptr, &fd->inode->open )
+    {
+        struct fd *fd_ptr = LIST_ENTRY( ptr, struct fd, inode_entry );
+        if (fd_ptr != fd)
+        {
+            if (fd_ptr->access & FILE_MAPPING_ACCESS)
+            {
+                /* can't unlink files which are mapped to memory */
+                set_error( STATUS_CANNOT_DELETE );
+                return;
+            }
+        }
+    }
+
+    if (unlink)
+        fd->closed->unlink = 1;
+    else if (!(fd->options & FILE_DELETE_ON_CLOSE))
+        fd->closed->unlink = 0;
+}
+
 /* retrieve the unix fd for an object */
 int get_unix_fd( struct fd *fd )
 {
@@ -2293,6 +2385,33 @@ DECL_HANDLER(get_handle_fd)
     }
 }
 
+/* get file descriptor to shared memory block */
+DECL_HANDLER(get_shared_memory)
+{
+    if (req->tid)
+    {
+        struct thread *thread = get_thread_from_id( req->tid );
+        if (thread)
+        {
+            if (thread->shm_fd != -1 || allocate_shared_memory( &thread->shm_fd,
+                (void **)&thread->shm, sizeof(*thread->shm) ))
+            {
+                send_client_fd( current->process, thread->shm_fd, 0 );
+            }
+            else
+                set_error( STATUS_NOT_SUPPORTED );
+            release_object( thread );
+        }
+    }
+    else
+    {
+        if (shmglobal_fd != -1)
+            send_client_fd( current->process, shmglobal_fd, 0 );
+        else
+            set_error( STATUS_NOT_SUPPORTED );
+    }
+}
+
 /* perform an ioctl on a file */
 DECL_HANDLER(ioctl)
 {
diff --git a/server/file.c b/server/file.c
index aa5ff01..04c809c 100644
--- a/server/file.c
+++ b/server/file.c
@@ -32,6 +32,7 @@
 #include <sys/time.h>
 #include <sys/types.h>
 #include <time.h>
+#include <limits.h>
 #include <unistd.h>
 #ifdef HAVE_UTIME_H
 #include <utime.h>
@@ -52,6 +53,14 @@
 #include "process.h"
 #include "security.h"
 
+/* We intentionally do not match the Samba 4 extended attribute for NT security descriptors (SDs):
+ *  1) Samba stores this information using an internal data structure (we use a flat NT SD).
+ *  2) Samba uses the attribute "security.NTACL".  This attribute is within a namespace that only
+ *     the administrator has write access to, which prohibits the user from copying the attributes
+ *     when copying a file and would require Wine to run with adminstrative privileges.
+ */
+#define WINE_XATTR_SD  XATTR_USER_PREFIX "wine.sd"
+
 struct file
 {
     struct object       obj;        /* object header */
@@ -62,6 +71,8 @@ struct file
 };
 
 static unsigned int generic_file_map_access( unsigned int access );
+static struct security_descriptor *get_xattr_sd( int fd );
+static struct security_descriptor *get_xattr_acls( int fd, const SID *user, const SID *group );
 
 static void file_dump( struct object *obj, int verbose );
 static struct fd *file_get_fd( struct object *obj );
@@ -168,7 +179,8 @@ struct file *create_file_for_fd_obj( struct fd *fd, unsigned int access, unsigne
     return file;
 }
 
-static struct object *create_file_obj( struct fd *fd, unsigned int access, mode_t mode )
+static struct object *create_file_obj( struct fd *fd, unsigned int access, mode_t mode,
+                                       const struct security_descriptor *sd )
 {
     struct file *file = alloc_object( &file_ops );
 
@@ -179,14 +191,177 @@ static struct object *create_file_obj( struct fd *fd, unsigned int access, mode_
     file->fd      = fd;
     grab_object( fd );
     set_fd_user( fd, &file_fd_ops, &file->obj );
+
+    if (sd) file_set_sd( &file->obj, sd, OWNER_SECURITY_INFORMATION |
+                                         GROUP_SECURITY_INFORMATION |
+                                         DACL_SECURITY_INFORMATION |
+                                         SACL_SECURITY_INFORMATION );
+
     return &file->obj;
 }
 
+static void set_xattr_sd( int fd, const struct security_descriptor *sd )
+{
+    char buffer[XATTR_SIZE_MAX];
+    int present, len;
+    const ACL *dacl;
+
+    /* there's no point in storing the security descriptor if there's no DACL */
+    if (!sd) return;
+    dacl = sd_get_dacl( sd, &present );
+    if (!present || !dacl) return;
+
+    len = 2 + sizeof(struct security_descriptor) + sd->owner_len +
+          sd->group_len + sd->sacl_len + sd->dacl_len;
+    if (len > XATTR_SIZE_MAX) return;
+
+    /* include the descriptor revision and resource manager control bits */
+    buffer[0] = SECURITY_DESCRIPTOR_REVISION;
+    buffer[1] = 0;
+    memcpy( &buffer[2], sd, len - 2 );
+    xattr_fset( fd, WINE_XATTR_SD, buffer, len );
+}
+
+static struct security_descriptor *inherit_sd( const struct security_descriptor *parent_sd, int is_dir )
+{
+    const DWORD inheritance_mask = INHERIT_ONLY_ACE | OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE;
+    struct security_descriptor *sd = NULL;
+    const ACL *parent_dacl;
+    int present;
+    ACL *dacl;
+
+    parent_dacl = sd_get_dacl( parent_sd, &present );
+    if (present && parent_dacl)
+    {
+        size_t dacl_size = sizeof(ACL), ace_count = 0;
+        const ACE_HEADER *parent_ace;
+        const SID *user, *group;
+        ACE_HEADER *ace;
+        char *ptr;
+        ULONG i;
+
+        /* Calculate the size of the DACL */
+        parent_ace = (const ACE_HEADER *)(parent_dacl + 1);
+        for (i = 0; i < parent_dacl->AceCount; i++, parent_ace = ace_next( parent_ace ))
+        {
+            if (!(parent_ace->AceFlags & inheritance_mask)) continue;
+
+            ace_count++;
+            dacl_size += parent_ace->AceSize;
+        }
+        if (!ace_count) return sd; /* No inheritance */
+
+        /* Fill in the security descriptor so that it is compatible with our DACL */
+        user = (const SID *)(parent_sd + 1);
+        group = (const SID *)((char *)(parent_sd + 1) + parent_sd->owner_len);
+        sd = mem_alloc( sizeof(struct security_descriptor) + parent_sd->owner_len
+                        + parent_sd->group_len + dacl_size );
+        if (!sd) return sd;
+        sd->control = SE_DACL_PRESENT;
+        sd->owner_len = parent_sd->owner_len;
+        sd->group_len = parent_sd->group_len;
+        sd->sacl_len = 0;
+        sd->dacl_len = dacl_size;
+        ptr = (char *)(sd + 1);
+        memcpy( ptr, user, sd->owner_len );
+        ptr += sd->owner_len;
+        memcpy( ptr, group, sd->group_len );
+        ptr += sd->group_len;
+        dacl = (ACL *)ptr;
+        dacl->AclRevision = ACL_REVISION;
+        dacl->Sbz1 = 0;
+        dacl->AclSize = dacl_size;
+        dacl->AceCount = ace_count;
+        dacl->Sbz2 = 0;
+        ace = (ACE_HEADER *)(dacl + 1);
+
+        /* Build the new DACL, inheriting from the parent's information */
+        parent_ace = (const ACE_HEADER *)(parent_dacl + 1);
+        for (i = 0; i < parent_dacl->AceCount; i++, parent_ace = ace_next( parent_ace ))
+        {
+            DWORD flags = parent_ace->AceFlags;
+
+            if (!(flags & inheritance_mask)) continue;
+
+            ace->AceType = parent_ace->AceType;
+            if (is_dir && (flags & CONTAINER_INHERIT_ACE))
+                flags &= ~INHERIT_ONLY_ACE;
+            else if (!is_dir && (flags & OBJECT_INHERIT_ACE))
+                flags &= ~INHERIT_ONLY_ACE;
+            else if (is_dir && (flags & OBJECT_INHERIT_ACE))
+                flags |= INHERIT_ONLY_ACE;
+            if (is_dir)
+                ace->AceFlags = flags | INHERITED_ACE;
+            else
+                ace->AceFlags = (parent_ace->AceFlags & ~inheritance_mask) | INHERITED_ACE;
+            ace->AceSize = parent_ace->AceSize;
+            memcpy( ace + 1, parent_ace + 1, parent_ace->AceSize - sizeof(ACE_HEADER));
+            ace = (ACE_HEADER *)ace_next( ace );
+        }
+    }
+    return sd;
+}
+
+static struct security_descriptor *file_get_parent_sd( struct fd *root, const char *child_name,
+                                                       int child_len, int is_dir )
+{
+    struct security_descriptor *parent_sd, *sd = NULL;
+    mode_t parent_mode = 0555;
+    char *p, *parent_name;
+    struct fd *parent_fd;
+    struct stat st;
+    int unix_fd;
+
+    if (!(parent_name = mem_alloc( child_len + 1 ))) return NULL;
+    memcpy( parent_name, child_name, child_len );
+    parent_name[child_len] = 0;
+
+    /* skip trailing slashes */
+    p = parent_name + strlen( parent_name ) - 1;
+    while (p > parent_name && *p == '/') p--;
+
+    /* remove last path component */
+    if (p == parent_name && *p == '/')
+    {
+        free(parent_name);
+        return NULL;
+    }
+    while (p > parent_name && *p != '/') p--;
+    while (p > parent_name && *p == '/') p--;
+    p[1] = 0;
+
+    parent_fd = open_fd( root, parent_name, O_NONBLOCK | O_LARGEFILE, &parent_mode,
+                         READ_CONTROL|ACCESS_SYSTEM_SECURITY,
+                         FILE_SHARE_READ|FILE_SHARE_WRITE|FILE_SHARE_DELETE,
+                         FILE_OPEN_FOR_BACKUP_INTENT );
+    free( parent_name );
+
+    if (parent_fd)
+    {
+        unix_fd = get_unix_fd( parent_fd );
+        if (unix_fd != -1)
+        {
+            parent_sd = get_xattr_sd( unix_fd );
+            if (!parent_sd && fstat( unix_fd, &st ) != -1)
+                parent_sd = get_xattr_acls( unix_fd, security_unix_uid_to_sid( st.st_uid ),
+                                            token_get_primary_group( current->process->token ) );
+            if (parent_sd)
+            {
+                sd = inherit_sd( parent_sd, is_dir );
+                free( parent_sd );
+            }
+        }
+        release_object( parent_fd );
+    }
+    return sd;
+}
+
 static struct object *create_file( struct fd *root, const char *nameptr, data_size_t len,
                                    unsigned int access, unsigned int sharing, int create,
                                    unsigned int options, unsigned int attrs,
                                    const struct security_descriptor *sd )
 {
+    struct security_descriptor *temp_sd = NULL;
     struct object *obj = NULL;
     struct fd *fd;
     int flags;
@@ -215,6 +390,10 @@ static struct object *create_file( struct fd *root, const char *nameptr, data_si
     default:                set_error( STATUS_INVALID_PARAMETER ); goto done;
     }
 
+    /* Note: inheritance of security descriptors only occurs on creation when sd is NULL */
+    if (!sd && (create == FILE_CREATE || create == FILE_OVERWRITE_IF))
+        sd = temp_sd = file_get_parent_sd( root, nameptr, len, options & FILE_DIRECTORY_FILE );
+
     if (sd)
     {
         const SID *owner = sd_get_owner( sd );
@@ -245,15 +424,16 @@ static struct object *create_file( struct fd *root, const char *nameptr, data_si
     if (!fd) goto done;
 
     if (S_ISDIR(mode))
-        obj = create_dir_obj( fd, access, mode );
+        obj = create_dir_obj( fd, access, mode, sd );
     else if (S_ISCHR(mode) && is_serial_fd( fd ))
         obj = create_serial( fd );
     else
-        obj = create_file_obj( fd, access, mode );
+        obj = create_file_obj( fd, access, mode, sd );
 
     release_object( fd );
 
 done:
+    free( temp_sd );
     free( name );
     return obj;
 }
@@ -428,37 +608,250 @@ struct security_descriptor *mode_to_sd( mode_t mode, const SID *user, const SID
     return sd;
 }
 
-static struct security_descriptor *file_get_sd( struct object *obj )
+/* Convert generic rights into standard access rights */
+static void convert_generic_sd( struct security_descriptor *sd )
 {
-    struct file *file = (struct file *)obj;
-    struct stat st;
-    int unix_fd;
+    const ACL *dacl;
+    int present;
+
+    dacl = sd_get_dacl( sd, &present );
+    if (present && dacl)
+    {
+        const ACE_HEADER *ace = (const ACE_HEADER *)(dacl + 1);
+        ULONG i;
+
+        for (i = 0; i < dacl->AceCount; i++, ace = ace_next( ace ))
+        {
+            DWORD *mask = (DWORD *)(ace + 1);
+            *mask = generic_file_map_access( *mask );
+        }
+    }
+}
+
+static struct security_descriptor *get_xattr_acls( int fd, const SID *user, const SID *group )
+{
+    int dacl_size = sizeof(ACL), n;
+    int offset, type, flags, mask, rev, ia, sa;
+    char buffer[XATTR_SIZE_MAX + 1], *p, *ptr;
     struct security_descriptor *sd;
+    ACL *dacl;
 
-    assert( obj->ops == &file_ops );
+    n = xattr_fget( fd, XATTR_USER_PREFIX "wine.acl", buffer, sizeof(buffer) - 1 );
+    if (n == -1) return NULL;
+    buffer[n] = 0; /* ensure NULL terminated buffer for string functions */
+
+    p = buffer;
+    do
+    {
+        int sub_authority_count = 0;
+
+        if (sscanf(p, "%x,%x,%x,S-%u-%d%n", &type, &flags, &mask, &rev, &ia, &offset) != 5)
+            return NULL;
+        p += offset;
+
+        while (sscanf(p, "-%u%n", &sa, &offset) == 1)
+        {
+            p += offset;
+            sub_authority_count++;
+        }
+
+        if (*p == ';') p++;
+        else if (*p) return NULL;
+
+        /* verify that the SubAuthorityCount does not exceed the maximum permitted value */
+        if (sub_authority_count > SID_MAX_SUB_AUTHORITIES)
+            continue;
+
+        switch (type)
+        {
+            case ACCESS_DENIED_ACE_TYPE:
+                dacl_size += FIELD_OFFSET(ACCESS_DENIED_ACE, SidStart) +
+                             FIELD_OFFSET(SID, SubAuthority[sub_authority_count]);
+                break;
+            case ACCESS_ALLOWED_ACE_TYPE:
+                dacl_size += FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart) +
+                             FIELD_OFFSET(SID, SubAuthority[sub_authority_count]);
+                break;
+            default:
+                continue;
+        }
+    }
+    while (*p);
+
+    n = sizeof(struct security_descriptor) +
+        FIELD_OFFSET(SID, SubAuthority[user->SubAuthorityCount]) +
+        FIELD_OFFSET(SID, SubAuthority[group->SubAuthorityCount]) +
+        dacl_size;
+
+    sd = mem_alloc( n );
+    if (!sd) return NULL;
+
+    sd->control = SE_DACL_PRESENT;
+    sd->owner_len = FIELD_OFFSET(SID, SubAuthority[user->SubAuthorityCount]);
+    sd->group_len = FIELD_OFFSET(SID, SubAuthority[group->SubAuthorityCount]);
+    sd->sacl_len = 0;
+    sd->dacl_len = dacl_size;
+
+    ptr = (char *)(sd + 1);
+    memcpy( ptr, user, sd->owner_len );
+    ptr += sd->owner_len;
+    memcpy( ptr, group, sd->group_len );
+    ptr += sd->group_len;
+
+    dacl = (ACL *)ptr;
+    dacl->AclRevision = ACL_REVISION;
+    dacl->Sbz1 = 0;
+    dacl->AclSize = dacl_size;
+    dacl->AceCount = 0;
+    dacl->Sbz2 = 0;
+
+    ptr = (char *)(dacl + 1);
+    p = buffer;
+    do
+    {
+        char sid_buffer[sizeof(SID) + sizeof(ULONG) * SID_MAX_SUB_AUTHORITIES];
+        SID *sid = (SID *)sid_buffer;
+        int sub_authority_count = 0;
+
+        if (sscanf(p, "%x,%x,%x,S-%u-%d%n", &type, &flags, &mask, &rev, &ia, &offset) != 5)
+            goto err;
+        p += offset;
+
+        while (sscanf(p, "-%u%n", &sa, &offset) == 1)
+        {
+            p += offset;
+            if (sub_authority_count < SID_MAX_SUB_AUTHORITIES)
+                sid->SubAuthority[sub_authority_count] = sa;
+            sub_authority_count++;
+        }
+
+        if (*p == ';') p++;
+        else if (*p) goto err;
+
+        if (sub_authority_count > SID_MAX_SUB_AUTHORITIES)
+            continue;
+
+        sid->Revision = rev;
+        sid->IdentifierAuthority.Value[0] = 0;
+        sid->IdentifierAuthority.Value[1] = 0;
+        sid->IdentifierAuthority.Value[2] = HIBYTE(HIWORD(ia));
+        sid->IdentifierAuthority.Value[3] = LOBYTE(HIWORD(ia));
+        sid->IdentifierAuthority.Value[4] = HIBYTE(LOWORD(ia));
+        sid->IdentifierAuthority.Value[5] = LOBYTE(LOWORD(ia));
+        sid->SubAuthorityCount = sub_authority_count;
+
+        /* Handle the specific ACE */
+        switch (type)
+        {
+            case ACCESS_DENIED_ACE_TYPE:
+                {
+                    ACCESS_DENIED_ACE *ada = (ACCESS_DENIED_ACE *)ptr;
+                    ada->Header.AceType  = type;
+                    ada->Header.AceFlags = flags;
+                    ada->Header.AceSize  = FIELD_OFFSET(ACCESS_DENIED_ACE, SidStart) +
+                                           FIELD_OFFSET(SID, SubAuthority[sid->SubAuthorityCount]);
+                    ada->Mask            = mask;
+                    memcpy( &ada->SidStart, sid, FIELD_OFFSET(SID, SubAuthority[sid->SubAuthorityCount]) );
+                }
+                break;
+            case ACCESS_ALLOWED_ACE_TYPE:
+                {
+                    ACCESS_ALLOWED_ACE *aaa = (ACCESS_ALLOWED_ACE *)ptr;
+                    aaa->Header.AceType  = type;
+                    aaa->Header.AceFlags = flags;
+                    aaa->Header.AceSize  = FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart) +
+                                           FIELD_OFFSET(SID, SubAuthority[sid->SubAuthorityCount]);
+                    aaa->Mask            = mask;
+                    memcpy( &aaa->SidStart, sid, FIELD_OFFSET(SID, SubAuthority[sid->SubAuthorityCount]) );
+                }
+                break;
+            default:
+                continue;
+        }
+
+        ptr = (char *)ace_next( (ACE_HEADER *)ptr );
+        dacl->AceCount++;
+    }
+    while (*p);
+
+    if (sd_is_valid( sd, n ))
+    {
+        convert_generic_sd( sd );
+        return sd;
+    }
+
+err:
+    free( sd );
+    return NULL;
+}
+
+static struct security_descriptor *get_xattr_sd( int fd )
+{
+    struct security_descriptor *sd;
+    char buffer[XATTR_SIZE_MAX];
+    int n;
+
+    n = xattr_fget( fd, WINE_XATTR_SD, buffer, sizeof(buffer) );
+    if (n == -1 || n < 2 + sizeof(struct security_descriptor)) return NULL;
+
+    /* validate that we can handle the descriptor */
+    if (buffer[0] != SECURITY_DESCRIPTOR_REVISION || buffer[1] != 0 ||
+            !sd_is_valid( (struct security_descriptor *)&buffer[2], n - 2 ))
+        return NULL;
+
+    sd = mem_alloc( n - 2 );
+    if (sd)
+    {
+        memcpy( sd, &buffer[2], n - 2 );
+        convert_generic_sd( sd ); /* for backwards compatibility */
+    }
+    return sd;
+}
 
-    unix_fd = get_file_unix_fd( file );
+struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode_t *mode,
+                                         uid_t *uid )
+{
+    int unix_fd = get_unix_fd( fd );
+    struct stat st;
+    struct security_descriptor *sd;
+    const SID *user, *group;
 
     if (unix_fd == -1 || fstat( unix_fd, &st ) == -1)
         return obj->sd;
 
     /* mode and uid the same? if so, no need to re-generate security descriptor */
-    if (obj->sd && (st.st_mode & (S_IRWXU|S_IRWXO)) == (file->mode & (S_IRWXU|S_IRWXO)) &&
-        (st.st_uid == file->uid))
+    if (obj->sd && (st.st_mode & (S_IRWXU|S_IRWXO)) == (*mode & (S_IRWXU|S_IRWXO)) &&
+        (st.st_uid == *uid))
         return obj->sd;
 
-    sd = mode_to_sd( st.st_mode,
-                     security_unix_uid_to_sid( st.st_uid ),
-                     token_get_primary_group( current->process->token ));
+    user = security_unix_uid_to_sid( st.st_uid );
+    group = token_get_primary_group( current->process->token );
+    sd = get_xattr_sd( unix_fd );
+    if (!sd) sd = get_xattr_acls( unix_fd, user, group );
+    if (!sd) sd = mode_to_sd( st.st_mode, user, group );
     if (!sd) return obj->sd;
 
-    file->mode = st.st_mode;
-    file->uid = st.st_uid;
+    *mode = st.st_mode;
+    *uid = st.st_uid;
     free( obj->sd );
     obj->sd = sd;
     return sd;
 }
 
+static struct security_descriptor *file_get_sd( struct object *obj )
+{
+    struct file *file = (struct file *)obj;
+    struct security_descriptor *sd;
+    struct fd *fd;
+
+    assert( obj->ops == &file_ops );
+
+    fd = file_get_fd( obj );
+    sd = get_file_sd( obj, fd, &file->mode, &file->uid );
+    release_object( fd );
+    return sd;
+}
+
 static mode_t file_access_to_mode( unsigned int access )
 {
     mode_t mode = 0;
@@ -544,54 +937,90 @@ mode_t sd_to_mode( const struct security_descriptor *sd, const SID *owner )
     return new_mode;
 }
 
-static int file_set_sd( struct object *obj, const struct security_descriptor *sd,
-                        unsigned int set_info )
+int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
+                 const struct security_descriptor *sd, unsigned int set_info )
 {
-    struct file *file = (struct file *)obj;
-    const SID *owner;
+    struct security_descriptor *new_sd;
+    int unix_fd = get_unix_fd( fd );
+    const SID *owner, *group;
     struct stat st;
-    mode_t mode;
-    int unix_fd;
+    mode_t new_mode;
 
-    assert( obj->ops == &file_ops );
-
-    unix_fd = get_file_unix_fd( file );
+    if (!set_info || unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
+    if (!obj->sd) get_file_sd( obj, fd, mode, uid );
 
-    if (unix_fd == -1 || fstat( unix_fd, &st ) == -1) return 1;
-
-    if (set_info & OWNER_SECURITY_INFORMATION)
+    /* calculate the new sd, save to a temporary variable before assigning */
+    new_sd = set_sd_from_token_internal( sd, obj->sd, set_info, current->process->token );
+    if (new_sd)
     {
-        owner = sd_get_owner( sd );
-        if (!owner)
+        /* convert generic rights into standard access rights */
+        convert_generic_sd( new_sd );
+
+        if (set_info & OWNER_SECURITY_INFORMATION)
         {
-            set_error( STATUS_INVALID_SECURITY_DESCR );
-            return 0;
+            owner = sd_get_owner( new_sd );
+            assert( owner );
+
+            if (!obj->sd || !security_equal_sid( owner, sd_get_owner( obj->sd ) ))
+            {
+                /* FIXME: get Unix uid and call fchown */
+            }
         }
-        if (!obj->sd || !security_equal_sid( owner, sd_get_owner( obj->sd ) ))
+
+        if (set_info & GROUP_SECURITY_INFORMATION)
         {
-            /* FIXME: get Unix uid and call fchown */
+            group = sd_get_group( new_sd );
+            assert( group );
+
+            if (!obj->sd || !security_equal_sid( group, sd_get_group( obj->sd ) ))
+            {
+                /* FIXME: get Unix uid and call fchown */
+            }
         }
-    }
-    else if (obj->sd)
-        owner = sd_get_owner( obj->sd );
-    else
-        owner = token_get_user( current->process->token );
 
-    /* group and sacl not supported */
+        if (set_info & DACL_SECURITY_INFORMATION)
+        {
+            owner = sd_get_owner( new_sd );
+            assert( owner );
 
-    if (set_info & DACL_SECURITY_INFORMATION)
-    {
-        /* keep the bits that we don't map to access rights in the ACL */
-        mode = st.st_mode & (S_ISUID|S_ISGID|S_ISVTX);
-        mode |= sd_to_mode( sd, owner );
+            /* keep the bits that we don't map to access rights in the ACL */
+            new_mode = st.st_mode & (S_ISUID|S_ISGID|S_ISVTX);
+            new_mode |= sd_to_mode( new_sd, owner );
 
-        if (((st.st_mode ^ mode) & (S_IRWXU|S_IRWXG|S_IRWXO)) && fchmod( unix_fd, mode ) == -1)
-        {
-            file_set_error();
-            return 0;
+            if (((st.st_mode ^ new_mode) & (S_IRWXU|S_IRWXG|S_IRWXO)) && fchmod( unix_fd, new_mode ) == -1)
+            {
+                free( new_sd );
+                file_set_error();
+                return 0;
+            }
+
+            *mode = new_mode;
         }
+
+        /* extended attributes are set after the file mode, to ensure it stays in sync */
+        set_xattr_sd( unix_fd, new_sd );
+
+        free( obj->sd );
+        obj->sd = new_sd;
+        return 1;
     }
-    return 1;
+
+    return 0;
+}
+
+static int file_set_sd( struct object *obj, const struct security_descriptor *sd,
+                        unsigned int set_info )
+{
+    struct file *file = (struct file *)obj;
+    struct fd *fd;
+    int ret;
+
+    assert( obj->ops == &file_ops );
+
+    fd = file_get_fd( obj );
+    ret = set_file_sd( obj, fd, &file->mode, &file->uid, sd, set_info );
+    release_object( fd );
+    return ret;
 }
 
 static void file_destroy( struct object *obj )
@@ -689,7 +1118,10 @@ DECL_HANDLER(create_file)
     if ((file = create_file( root_fd, name, name_len, req->access, req->sharing,
                              req->create, req->options, req->attrs, sd )))
     {
-        reply->handle = alloc_handle( current->process, file, req->access, req->attributes );
+        if (get_error() == STATUS_OBJECT_NAME_EXISTS)
+            reply->handle = alloc_handle( current->process, file, req->access, req->attributes );
+        else
+            reply->handle = alloc_handle_no_access_check( current->process, file, req->access, req->attributes );
         release_object( file );
     }
     if (root_fd) release_object( root_fd );
@@ -738,3 +1170,26 @@ DECL_HANDLER(unlock_file)
         release_object( file );
     }
 }
+
+/* set file information */
+DECL_HANDLER(set_file_info)
+{
+    struct file *file;
+
+    if ((file = get_file_obj( current->process, req->handle, DELETE )))
+    {
+        set_fd_disposition( file->fd, req->unlink );
+        release_object( file );
+        return;
+    }
+
+    if (get_error() == STATUS_OBJECT_TYPE_MISMATCH)
+    {
+        clear_error();
+        if ((file = (struct file *)get_dir_obj( current->process, req->handle, DELETE )))
+        {
+            set_fd_disposition( file->fd, req->unlink );
+            release_object( file );
+        }
+    }
+}
diff --git a/server/file.h b/server/file.h
index 85e4257..e05df97 100644
--- a/server/file.h
+++ b/server/file.h
@@ -67,6 +67,7 @@ extern struct fd *get_fd_object_for_mapping( struct fd *fd, unsigned int access,
 extern void *get_fd_user( struct fd *fd );
 extern void set_fd_user( struct fd *fd, const struct fd_ops *ops, struct object *user );
 extern unsigned int get_fd_options( struct fd *fd );
+extern void set_fd_disposition( struct fd *fd, int unlink );
 extern int get_unix_fd( struct fd *fd );
 extern int is_same_file_fd( struct fd *fd1, struct fd *fd2 );
 extern int is_fd_removable( struct fd *fd );
@@ -124,6 +125,10 @@ extern struct file *create_file_for_fd_obj( struct fd *fd, unsigned int access,
 extern void file_set_error(void);
 extern struct security_descriptor *mode_to_sd( mode_t mode, const SID *user, const SID *group );
 extern mode_t sd_to_mode( const struct security_descriptor *sd, const SID *owner );
+extern int set_file_sd( struct object *obj, struct fd *fd, mode_t *mode, uid_t *uid,
+                        const struct security_descriptor *sd, unsigned int set_info );
+extern struct security_descriptor *get_file_sd( struct object *obj, struct fd *fd, mode_t *mode,
+                                                uid_t *uid );
 
 /* file mapping functions */
 
@@ -134,11 +139,20 @@ extern obj_handle_t open_mapping_file( struct process *process, struct mapping *
 extern struct mapping *grab_mapping_unless_removable( struct mapping *mapping );
 extern int get_page_size(void);
 
+/* shared memory functions */
+
+extern int allocate_shared_memory( int *fd, void **memory, size_t size );
+extern void release_shared_memory( int fd, void *memory, size_t size );
+extern void init_shared_memory( void );
+extern shmglobal_t *shmglobal;
+extern int          shmglobal_fd;
+
 /* change notification functions */
 
 extern void do_change_notify( int unix_fd );
 extern void sigio_callback(void);
-extern struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode );
+extern struct object *create_dir_obj( struct fd *fd, unsigned int access, mode_t mode,
+                                      const struct security_descriptor *sd );
 extern struct dir *get_dir_obj( struct process *process, obj_handle_t handle, unsigned int access );
 
 /* completion */
diff --git a/server/main.c b/server/main.c
index 7aed338..313039a 100644
--- a/server/main.c
+++ b/server/main.c
@@ -44,6 +44,7 @@ int foreground = 0;
 timeout_t master_socket_timeout = 3 * -TICKS_PER_SEC;  /* master socket timeout, default is 3 seconds */
 const char *server_argv0;
 
+
 /* parse-line args */
 
 static void usage( FILE *fh )
@@ -142,9 +143,11 @@ int main( int argc, char *argv[] )
     open_master_socket();
 
     if (debug_level) fprintf( stderr, "wineserver: starting (pid=%ld)\n", (long) getpid() );
+    init_scheduler();
     init_signals();
     init_directories();
     init_registry();
+    init_shared_memory();
     main_loop();
     return 0;
 }
diff --git a/server/mapping.c b/server/mapping.c
index 64b3003..b731cc6 100644
--- a/server/mapping.c
+++ b/server/mapping.c
@@ -29,8 +29,32 @@
 #ifdef HAVE_SYS_MMAN_H
 # include <sys/mman.h>
 #endif
+#ifdef HAVE_SYS_SYSCALL_H
+# include <sys/syscall.h>
+#endif
 #include <unistd.h>
 
+#if defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
+
+/* __NR_memfd_create might not yet be available when buildservers use an old kernel */
+#ifndef __NR_memfd_create
+#ifdef __x86_64__
+#define __NR_memfd_create 319
+#else
+#define __NR_memfd_create 356
+#endif
+#endif
+
+/* the following declarations are only available in linux/fcntl.h, but not fcntl.h */
+#define F_LINUX_SPECIFIC_BASE   1024
+#define F_ADD_SEALS             (F_LINUX_SPECIFIC_BASE + 9)
+#define MFD_ALLOW_SEALING       0x0002U
+#define F_SEAL_SEAL             0x0001
+#define F_SEAL_SHRINK           0x0002
+#define F_SEAL_GROW             0x0004
+
+#endif
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -64,6 +88,15 @@ struct mapping
     enum cpu_type   cpu;             /* client CPU (for PE image mapping) */
     int             header_size;     /* size of headers (for PE image mapping) */
     client_ptr_t    base;            /* default base addr (for PE image mapping) */
+    client_ptr_t    entry;           /* entry point addr (for PE image mapping) */
+    mem_size_t      stack_reserve;   /* stack reserve (for PE image mapping) */
+    mem_size_t      stack_commit;    /* stack commit (for PE image mapping) */
+    int             subsystem;       /* subsystem (for PE image mapping) */
+    int             major_subsystem; /* major subsystem version (for PE image mapping) */
+    int             minor_subsystem; /* minor subsystem version (for PE image mapping) */
+    int             characteristics; /* image characteristics (for PE image mapping) */
+    int             dll_characteristics; /* dll characteristics (for PE image mapping) */
+    int             machine;         /* image machine type (for PE image mapping) */
     struct ranges  *committed;       /* list of committed ranges in this mapping */
     struct file    *shared_file;     /* temp file for shared PE mapping */
     struct list     shared_entry;    /* entry in global shared PE mappings list */
@@ -112,6 +145,10 @@ static struct list shared_list = LIST_INIT(shared_list);
 
 static size_t page_mask;
 
+/* global shared memory */
+shmglobal_t *shmglobal;
+int          shmglobal_fd;
+
 #define ROUND_SIZE(size)  (((size) + page_mask) & ~page_mask)
 
 
@@ -156,6 +193,52 @@ static int check_current_dir_for_exec(void)
     return (ret != MAP_FAILED);
 }
 
+/* allocates a block of shared memory */
+int allocate_shared_memory( int *fd, void **memory, size_t size )
+{
+#if defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
+    void *shm_mem;
+    int shm_fd;
+
+    shm_fd = syscall( __NR_memfd_create, "wineserver_shm", MFD_ALLOW_SEALING );
+    if (shm_fd == -1) goto err;
+    if (grow_file( shm_fd, size ))
+    {
+        if (fcntl( shm_fd, F_ADD_SEALS, F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW ) >= 0)
+        {
+            shm_mem = mmap( 0, size, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0 );
+            if (shm_mem != MAP_FAILED)
+            {
+                memset( shm_mem, 0, size );
+                *fd     = shm_fd;
+                *memory = shm_mem;
+                return 1;
+            }
+        }
+    }
+    close( shm_fd );
+err:
+#endif
+    *memory = NULL;
+    *fd = -1;
+    return 0;
+}
+
+/* releases a block of shared memory */
+void release_shared_memory( int fd, void *memory, size_t size )
+{
+#if defined(__linux__) && (defined(__i386__) || defined(__x86_64__))
+    if (memory) munmap( memory, size );
+    if (fd != -1) close( fd );
+#endif
+}
+
+/* intialize shared memory management */
+void init_shared_memory( void )
+{
+    allocate_shared_memory( &shmglobal_fd, (void **)&shmglobal, sizeof(*shmglobal) );
+}
+
 /* create a temp file for anonymous mappings */
 static int create_temp_file( file_pos_t size )
 {
@@ -430,17 +513,34 @@ static unsigned int get_image_params( struct mapping *mapping, int unix_fd, int
         return STATUS_INVALID_IMAGE_FORMAT;
     }
 
+    mapping->characteristics = nt.FileHeader.Characteristics;
+    mapping->machine         = nt.FileHeader.Machine;
+
     switch (nt.opt.hdr32.Magic)
     {
     case IMAGE_NT_OPTIONAL_HDR32_MAGIC:
         mapping->size        = ROUND_SIZE( nt.opt.hdr32.SizeOfImage );
         mapping->base        = nt.opt.hdr32.ImageBase;
         mapping->header_size = nt.opt.hdr32.SizeOfHeaders;
+        mapping->entry               = mapping->base + nt.opt.hdr32.AddressOfEntryPoint;
+        mapping->stack_reserve       = nt.opt.hdr32.SizeOfStackReserve;
+        mapping->stack_commit        = nt.opt.hdr32.SizeOfStackCommit;
+        mapping->subsystem           = nt.opt.hdr32.Subsystem;
+        mapping->major_subsystem     = nt.opt.hdr32.MajorSubsystemVersion;
+        mapping->minor_subsystem     = nt.opt.hdr32.MinorSubsystemVersion;
+        mapping->dll_characteristics = nt.opt.hdr32.DllCharacteristics;
         break;
     case IMAGE_NT_OPTIONAL_HDR64_MAGIC:
         mapping->size        = ROUND_SIZE( nt.opt.hdr64.SizeOfImage );
         mapping->base        = nt.opt.hdr64.ImageBase;
         mapping->header_size = nt.opt.hdr64.SizeOfHeaders;
+        mapping->entry               = mapping->base + nt.opt.hdr64.AddressOfEntryPoint;
+        mapping->stack_reserve       = nt.opt.hdr64.SizeOfStackReserve;
+        mapping->stack_commit        = nt.opt.hdr64.SizeOfStackCommit;
+        mapping->subsystem           = nt.opt.hdr64.Subsystem;
+        mapping->major_subsystem     = nt.opt.hdr64.MajorSubsystemVersion;
+        mapping->minor_subsystem     = nt.opt.hdr64.MinorSubsystemVersion;
+        mapping->dll_characteristics = nt.opt.hdr64.DllCharacteristics;
         break;
     }
 
@@ -490,6 +590,15 @@ static struct object *create_mapping( struct directory *root, const struct unico
                                                SACL_SECURITY_INFORMATION );
     mapping->header_size = 0;
     mapping->base        = 0;
+    mapping->entry               = 0;
+    mapping->stack_reserve       = 0;
+    mapping->stack_commit        = 0;
+    mapping->subsystem           = 0;
+    mapping->major_subsystem     = 0;
+    mapping->minor_subsystem     = 0;
+    mapping->characteristics     = 0;
+    mapping->dll_characteristics = 0;
+    mapping->machine             = 0;
     mapping->fd          = NULL;
     mapping->shared_file = NULL;
     mapping->committed   = NULL;
@@ -727,6 +836,13 @@ DECL_HANDLER(get_mapping_info)
     reply->protect     = mapping->protect;
     reply->header_size = mapping->header_size;
     reply->base        = mapping->base;
+    reply->entry               = mapping->entry;
+    reply->subsystem           = mapping->subsystem;
+    reply->major_subsystem     = mapping->major_subsystem;
+    reply->minor_subsystem     = mapping->minor_subsystem;
+    reply->characteristics     = mapping->characteristics;
+    reply->dll_characteristics = mapping->dll_characteristics;
+    reply->machine             = mapping->machine;
     reply->shared_file = 0;
     if ((fd = get_obj_fd( &mapping->obj )))
     {
diff --git a/server/named_pipe.c b/server/named_pipe.c
index 706cce8..fe4a33a 100644
--- a/server/named_pipe.c
+++ b/server/named_pipe.c
@@ -42,6 +42,10 @@
 #include <poll.h>
 #endif
 
+#ifndef SO_PEEK_OFF
+#define SO_PEEK_OFF 42
+#endif
+
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "windef.h"
@@ -49,6 +53,7 @@
 #include "winioctl.h"
 
 #include "file.h"
+#include "sock.h"
 #include "handle.h"
 #include "thread.h"
 #include "request.h"
@@ -791,14 +796,43 @@ static struct pipe_server *find_available_server( struct named_pipe *pipe )
     return NULL;
 }
 
+/* check if message mode named pipes are supported */
+static int is_messagemode_supported(void)
+{
+#ifdef __linux__
+    static const int zero = 0;
+    static int messagemode = -1;
+    int fd;
+
+    if (messagemode < 0)
+    {
+        fd = socket( PF_UNIX, SOCK_SEQPACKET, 0 );
+        messagemode = (fd != -1) && (setsockopt( fd, SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1);
+        if (fd != -1) close( fd );
+    }
+
+    return messagemode;
+#else
+    return 0;
+#endif
+}
+
+static inline int messagemode_flags( int flags )
+{
+    if (!is_messagemode_supported())
+        flags &= ~(NAMED_PIPE_MESSAGE_STREAM_WRITE | NAMED_PIPE_MESSAGE_STREAM_READ);
+    return flags;
+}
+
 static struct object *named_pipe_open_file( struct object *obj, unsigned int access,
                                             unsigned int sharing, unsigned int options )
 {
+    static const int zero = 0;
     struct named_pipe *pipe = (struct named_pipe *)obj;
     struct pipe_server *server;
     struct pipe_client *client;
     unsigned int pipe_sharing;
-    int fds[2];
+    int fds[2], type;
 
     if (!(server = find_available_server( pipe )))
     {
@@ -817,7 +851,10 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
 
     if ((client = create_pipe_client( options, pipe->flags )))
     {
-        if (!socketpair( PF_UNIX, SOCK_STREAM, 0, fds ))
+        type = ((pipe->flags & NAMED_PIPE_MESSAGE_STREAM_WRITE) && is_messagemode_supported()) ?
+               SOCK_SEQPACKET : SOCK_STREAM;
+
+        if (!socketpair( PF_UNIX, type, 0, fds ))
         {
             assert( !server->fd );
 
@@ -827,32 +864,55 @@ static struct object *named_pipe_open_file( struct object *obj, unsigned int acc
             if (is_overlapped( options )) fcntl( fds[1], F_SETFL, O_NONBLOCK );
             if (is_overlapped( server->options )) fcntl( fds[0], F_SETFL, O_NONBLOCK );
 
-            if (pipe->insize)
-            {
-                setsockopt( fds[0], SOL_SOCKET, SO_RCVBUF, &pipe->insize, sizeof(pipe->insize) );
-                setsockopt( fds[1], SOL_SOCKET, SO_RCVBUF, &pipe->insize, sizeof(pipe->insize) );
-            }
-            if (pipe->outsize)
+            /* FIXME: For message mode we don't pay attention to the provided buffer size.
+             * Linux pipes cannot dynamically adjust size, so we leave the size to the system
+             * instead of using the application provided value. Please note that this will
+             * have the effect that the application doesn't block when sending very large
+             * messages. */
+            if (type != SOCK_SEQPACKET)
             {
-                setsockopt( fds[0], SOL_SOCKET, SO_SNDBUF, &pipe->outsize, sizeof(pipe->outsize) );
-                setsockopt( fds[1], SOL_SOCKET, SO_SNDBUF, &pipe->outsize, sizeof(pipe->outsize) );
+                if (pipe->insize)
+                {
+                    setsockopt( fds[0], SOL_SOCKET, SO_RCVBUF, &pipe->insize, sizeof(pipe->insize) );
+                    setsockopt( fds[1], SOL_SOCKET, SO_RCVBUF, &pipe->insize, sizeof(pipe->insize) );
+                }
+                if (pipe->outsize)
+                {
+                    setsockopt( fds[0], SOL_SOCKET, SO_SNDBUF, &pipe->outsize, sizeof(pipe->outsize) );
+                    setsockopt( fds[1], SOL_SOCKET, SO_SNDBUF, &pipe->outsize, sizeof(pipe->outsize) );
+                }
             }
 
-            client->fd = create_anonymous_fd( &pipe_client_fd_ops, fds[1], &client->obj, options );
-            server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
-            if (client->fd && server->fd)
+            if (type != SOCK_SEQPACKET || (setsockopt( fds[0], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1 &&
+                                           setsockopt( fds[1], SOL_SOCKET, SO_PEEK_OFF, &zero, sizeof(zero) ) != -1))
             {
-                allow_fd_caching( client->fd );
-                allow_fd_caching( server->fd );
-                fd_copy_completion( server->ioctl_fd, server->fd );
-                if (server->state == ps_wait_open)
-                    fd_async_wake_up( server->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
-                set_server_state( server, ps_connected_server );
-                server->client = client;
-                client->server = server;
+            #ifdef __linux__
+                fcntl( fds[0], F_SETSIG, messagemode_flags( server->pipe_flags ) );
+                fcntl( fds[1], F_SETSIG, messagemode_flags( client->pipe_flags ) );
+            #endif
+
+                client->fd = create_anonymous_fd( &pipe_client_fd_ops, fds[1], &client->obj, options );
+                server->fd = create_anonymous_fd( &pipe_server_fd_ops, fds[0], &server->obj, server->options );
+                if (client->fd && server->fd)
+                {
+                    allow_fd_caching( client->fd );
+                    allow_fd_caching( server->fd );
+                    fd_copy_completion( server->ioctl_fd, server->fd );
+                    if (server->state == ps_wait_open)
+                        fd_async_wake_up( server->ioctl_fd, ASYNC_TYPE_WAIT, STATUS_SUCCESS );
+                    set_server_state( server, ps_connected_server );
+                    server->client = client;
+                    client->server = server;
+                }
+                else
+                {
+                    release_object( client );
+                    client = NULL;
+                }
             }
             else
             {
+                sock_set_error();
                 release_object( client );
                 client = NULL;
             }
@@ -952,6 +1012,7 @@ DECL_HANDLER(create_named_pipe)
         return;
     }
 
+    reply->flags = messagemode_flags(req->flags);
     reply->handle = 0;
 
     if (!objattr_is_valid( objattr, get_req_data_size() ))
@@ -1051,6 +1112,9 @@ DECL_HANDLER(set_named_pipe_info)
 {
     struct pipe_server *server;
     struct pipe_client *client = NULL;
+#ifdef __linux__
+    int unix_fd;
+#endif
 
     server = get_pipe_server_obj( current->process, req->handle, FILE_WRITE_ATTRIBUTES );
     if (!server)
@@ -1073,10 +1137,20 @@ DECL_HANDLER(set_named_pipe_info)
     else if (client)
     {
         client->pipe_flags = server->pipe->flags | req->flags;
+    #ifdef __linux__
+        if (client->fd && (unix_fd = get_unix_fd( client->fd )) != -1)
+            fcntl( unix_fd, F_SETSIG, messagemode_flags( client->pipe_flags ) );
+        clear_error();
+    #endif
     }
     else
     {
         server->pipe_flags = server->pipe->flags | req->flags;
+    #ifdef __linux__
+        if (server->fd && (unix_fd = get_unix_fd( server->fd )) != -1)
+            fcntl( unix_fd, F_SETSIG, messagemode_flags( server->pipe_flags ) );
+        clear_error();
+    #endif
     }
 
     if (client)
diff --git a/server/object.c b/server/object.c
index 965c11c..d04fdb9 100644
--- a/server/object.c
+++ b/server/object.c
@@ -425,8 +425,9 @@ struct security_descriptor *default_get_sd( struct object *obj )
     return obj->sd;
 }
 
-int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
-                                unsigned int set_info, struct token *token )
+struct security_descriptor *set_sd_from_token_internal( const struct security_descriptor *sd,
+                                                        const struct security_descriptor *old_sd,
+                                                        unsigned int set_info, struct token *token )
 {
     struct security_descriptor new_sd, *new_sd_ptr;
     int present;
@@ -434,8 +435,6 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     const ACL *sacl, *dacl;
     char *ptr;
 
-    if (!set_info) return 1;
-
     new_sd.control = sd->control & ~SE_SELF_RELATIVE;
 
     if (set_info & OWNER_SECURITY_INFORMATION && sd->owner_len)
@@ -443,10 +442,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
         owner = sd_get_owner( sd );
         new_sd.owner_len = sd->owner_len;
     }
-    else if (obj->sd && obj->sd->owner_len)
+    else if (old_sd && old_sd->owner_len)
     {
-        owner = sd_get_owner( obj->sd );
-        new_sd.owner_len = obj->sd->owner_len;
+        owner = sd_get_owner( old_sd );
+        new_sd.owner_len = old_sd->owner_len;
     }
     else if (token)
     {
@@ -460,10 +459,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
         group = sd_get_group( sd );
         new_sd.group_len = sd->group_len;
     }
-    else if (obj->sd && obj->sd->group_len)
+    else if (old_sd && old_sd->group_len)
     {
-        group = sd_get_group( obj->sd );
-        new_sd.group_len = obj->sd->group_len;
+        group = sd_get_group( old_sd );
+        new_sd.group_len = old_sd->group_len;
     }
     else if (token)
     {
@@ -478,10 +477,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
         new_sd.sacl_len = sd->sacl_len;
     else
     {
-        if (obj->sd) sacl = sd_get_sacl( obj->sd, &present );
+        if (old_sd) sacl = sd_get_sacl( old_sd, &present );
 
-        if (obj->sd && present)
-            new_sd.sacl_len = obj->sd->sacl_len;
+        if (old_sd && present)
+            new_sd.sacl_len = old_sd->sacl_len;
         else
             new_sd.sacl_len = 0;
     }
@@ -492,10 +491,10 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
         new_sd.dacl_len = sd->dacl_len;
     else
     {
-        if (obj->sd) dacl = sd_get_dacl( obj->sd, &present );
+        if (old_sd) dacl = sd_get_dacl( old_sd, &present );
 
-        if (obj->sd && present)
-            new_sd.dacl_len = obj->sd->dacl_len;
+        if (old_sd && present)
+            new_sd.dacl_len = old_sd->dacl_len;
         else if (token)
         {
             dacl = token_get_default_dacl( token );
@@ -506,7 +505,7 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
 
     ptr = mem_alloc( sizeof(new_sd) + new_sd.owner_len + new_sd.group_len +
                      new_sd.sacl_len + new_sd.dacl_len );
-    if (!ptr) return 0;
+    if (!ptr) return NULL;
     new_sd_ptr = (struct security_descriptor*)ptr;
 
     memcpy( ptr, &new_sd, sizeof(new_sd) );
@@ -519,9 +518,25 @@ int set_sd_defaults_from_token( struct object *obj, const struct security_descri
     ptr += new_sd.sacl_len;
     memcpy( ptr, dacl, new_sd.dacl_len );
 
-    free( obj->sd );
-    obj->sd = new_sd_ptr;
-    return 1;
+    return new_sd_ptr;
+}
+
+int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
+                                unsigned int set_info, struct token *token )
+{
+    struct security_descriptor *new_sd;
+
+    if (!set_info) return 1;
+
+    new_sd = set_sd_from_token_internal( sd, obj->sd, set_info, token );
+    if (new_sd)
+    {
+        free( obj->sd );
+        obj->sd = new_sd;
+        return 1;
+    }
+
+    return 0;
 }
 
 /** Set the security descriptor using the current primary token for defaults. */
diff --git a/server/object.h b/server/object.h
index 72b52ee..1444d74 100644
--- a/server/object.h
+++ b/server/object.h
@@ -140,6 +140,9 @@ extern struct fd *no_get_fd( struct object *obj );
 extern unsigned int no_map_access( struct object *obj, unsigned int access );
 extern struct security_descriptor *default_get_sd( struct object *obj );
 extern int default_set_sd( struct object *obj, const struct security_descriptor *sd, unsigned int set_info );
+extern struct security_descriptor *set_sd_from_token_internal( const struct security_descriptor *sd,
+                                                               const struct security_descriptor *old_sd,
+                                                               unsigned int set_info, struct token *token );
 extern int set_sd_defaults_from_token( struct object *obj, const struct security_descriptor *sd,
                                        unsigned int set_info, struct token *token );
 extern struct object *no_lookup_name( struct object *obj, struct unicode_str *name, unsigned int attributes );
diff --git a/server/process.c b/server/process.c
index 569a8fe..75c9c7a 100644
--- a/server/process.c
+++ b/server/process.c
@@ -62,6 +62,7 @@ static int shutdown_stage;  /* current stage in the shutdown process */
 static void process_dump( struct object *obj, int verbose );
 static int process_signaled( struct object *obj, struct wait_queue_entry *entry );
 static unsigned int process_map_access( struct object *obj, unsigned int access );
+static struct security_descriptor *process_get_sd( struct object *obj );
 static void process_poll_event( struct fd *fd, int event );
 static void process_destroy( struct object *obj );
 static void terminate_process( struct process *process, struct thread *skip, int exit_code );
@@ -78,7 +79,7 @@ static const struct object_ops process_ops =
     no_signal,                   /* signal */
     no_get_fd,                   /* get_fd */
     process_map_access,          /* map_access */
-    default_get_sd,              /* get_sd */
+    process_get_sd,              /* get_sd */
     default_set_sd,              /* set_sd */
     no_lookup_name,              /* lookup_name */
     no_open_file,                /* open_file */
@@ -140,6 +141,7 @@ static void job_dump( struct object *obj, int verbose );
 static struct object_type *job_get_type( struct object *obj );
 static int job_signaled( struct object *obj, struct wait_queue_entry *entry );
 static unsigned int job_map_access( struct object *obj, unsigned int access );
+static int job_close_handle( struct object *, struct process *process, obj_handle_t handle );
 static void job_destroy( struct object *obj );
 
 struct job
@@ -170,7 +172,7 @@ static const struct object_ops job_ops =
     default_set_sd,                /* set_sd */
     no_lookup_name,                /* lookup_name */
     no_open_file,                  /* open_file */
-    no_close_handle,               /* close_handle */
+    job_close_handle,              /* close_handle */
     job_destroy                    /* destroy */
 };
 
@@ -287,6 +289,20 @@ static void terminate_job( struct job *job, int exit_code )
     wake_up( &job->obj, 0 );
 }
 
+static int job_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
+{
+    struct job *job = (struct job *)obj;
+    assert( obj->ops == &job_ops );
+
+    /* If this is the last handle and JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE is set,
+     * then terminate all associcated processes. We can't use the refcount because
+     * processes have a reference to the job object. */
+    if (obj->handle_count == 1 && (job->limit_flags & JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE))
+        terminate_job( job, 0 );
+
+    return 1;
+}
+
 static void job_destroy( struct object *obj )
 {
     struct job *job = (struct job *)obj;
@@ -445,6 +461,7 @@ void shutdown_master_socket(void)
 /* final cleanup once we are sure a process is really dead */
 static void process_died( struct process *process )
 {
+    process->is_terminated = 1;
     if (debug_level) fprintf( stderr, "%04x: *process killed*\n", process->id );
     if (!process->is_system)
     {
@@ -501,6 +518,7 @@ struct thread *create_process( int fd, struct thread *parent_thread, int inherit
     process->is_system       = 0;
     process->debug_children  = 0;
     process->is_terminating  = 0;
+    process->is_terminated   = 0;
     process->job             = NULL;
     process->console         = NULL;
     process->startup_state   = STARTUP_IN_PROGRESS;
@@ -640,6 +658,53 @@ static unsigned int process_map_access( struct object *obj, unsigned int access
     return access & ~(GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE | GENERIC_ALL);
 }
 
+static struct security_descriptor *process_get_sd( struct object *obj )
+{
+    static struct security_descriptor *key_default_sd;
+
+    if (obj->sd) return obj->sd;
+
+    if (!key_default_sd)
+    {
+        size_t users_sid_len = security_sid_len( security_domain_users_sid );
+        size_t admins_sid_len = security_sid_len( security_builtin_admins_sid );
+        size_t dacl_len = sizeof(ACL) + 2 * offsetof( ACCESS_ALLOWED_ACE, SidStart )
+                          + users_sid_len + admins_sid_len;
+        ACCESS_ALLOWED_ACE *aaa;
+        ACL *dacl;
+
+        key_default_sd = mem_alloc( sizeof(*key_default_sd) + admins_sid_len + users_sid_len
+                                    + dacl_len );
+        key_default_sd->control   = SE_DACL_PRESENT;
+        key_default_sd->owner_len = admins_sid_len;
+        key_default_sd->group_len = users_sid_len;
+        key_default_sd->sacl_len  = 0;
+        key_default_sd->dacl_len  = dacl_len;
+        memcpy( key_default_sd + 1, security_builtin_admins_sid, admins_sid_len );
+        memcpy( (char *)(key_default_sd + 1) + admins_sid_len, security_domain_users_sid, users_sid_len );
+
+        dacl = (ACL *)((char *)(key_default_sd + 1) + admins_sid_len + users_sid_len);
+        dacl->AclRevision = ACL_REVISION;
+        dacl->Sbz1 = 0;
+        dacl->AclSize = dacl_len;
+        dacl->AceCount = 2;
+        dacl->Sbz2 = 0;
+        aaa = (ACCESS_ALLOWED_ACE *)(dacl + 1);
+        aaa->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
+        aaa->Header.AceFlags = INHERIT_ONLY_ACE | CONTAINER_INHERIT_ACE;
+        aaa->Header.AceSize = offsetof( ACCESS_ALLOWED_ACE, SidStart ) + users_sid_len;
+        aaa->Mask = GENERIC_READ;
+        memcpy( &aaa->SidStart, security_domain_users_sid, users_sid_len );
+        aaa = (ACCESS_ALLOWED_ACE *)((char *)aaa + aaa->Header.AceSize);
+        aaa->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
+        aaa->Header.AceFlags = 0;
+        aaa->Header.AceSize = offsetof( ACCESS_ALLOWED_ACE, SidStart ) + admins_sid_len;
+        aaa->Mask = PROCESS_ALL_ACCESS;
+        memcpy( &aaa->SidStart, security_builtin_admins_sid, admins_sid_len );
+    }
+    return key_default_sd;
+}
+
 static void process_poll_event( struct fd *fd, int event )
 {
     struct process *process = get_fd_user( fd );
@@ -1065,6 +1130,7 @@ DECL_HANDLER(new_process)
     struct process *process;
     struct process *parent = current->process;
     int socket_fd = thread_get_inflight_fd( current, req->socket_fd );
+    const struct security_descriptor *process_sd = NULL, *thread_sd = NULL;
 
     if (socket_fd == -1)
     {
@@ -1120,7 +1186,7 @@ DECL_HANDLER(new_process)
         goto done;
     }
 
-    info->data_size = get_req_data_size();
+    info->data_size = min( get_req_data_size(), req->info_size + req->env_size );
     info->info_size = min( req->info_size, info->data_size );
 
     if (req->info_size < sizeof(*info->data))
@@ -1161,6 +1227,34 @@ DECL_HANDLER(new_process)
 #undef FIXUP_LEN
     }
 
+    if (get_req_data_size() > req->info_size + req->env_size)
+    {
+        data_size_t sd_size, pos = req->info_size + req->env_size;
+
+        /* verify process sd */
+        if ((sd_size = min( get_req_data_size() - pos, req->process_sd_size )))
+        {
+            process_sd = (const struct security_descriptor *)((const char *)get_req_data() + pos);
+            if (!sd_is_valid( process_sd, sd_size ))
+            {
+                set_error( STATUS_INVALID_SECURITY_DESCR );
+                goto done;
+            }
+            pos += sd_size;
+        }
+
+        /* verify thread sd */
+        if ((sd_size = get_req_data_size() - pos))
+        {
+            thread_sd = (const struct security_descriptor *)((const char *)get_req_data() + pos);
+            if (!sd_is_valid( thread_sd, sd_size ))
+            {
+                set_error( STATUS_INVALID_SECURITY_DESCR );
+                goto done;
+            }
+        }
+    }
+
     if (!(thread = create_process( socket_fd, current, req->inherit_all ))) goto done;
     process = thread->process;
     process->debug_children = (req->create_flags & DEBUG_PROCESS)
@@ -1219,6 +1313,25 @@ DECL_HANDLER(new_process)
     reply->phandle = alloc_handle( parent, process, req->process_access, req->process_attr );
     reply->thandle = alloc_handle( parent, thread, req->thread_access, req->thread_attr );
 
+    if (process_sd)
+    {
+        default_set_sd( &process->obj, process_sd,
+                        OWNER_SECURITY_INFORMATION |
+                        GROUP_SECURITY_INFORMATION |
+                        DACL_SECURITY_INFORMATION |
+                        SACL_SECURITY_INFORMATION );
+    }
+
+    if (thread_sd)
+    {
+        set_sd_defaults_from_token( &thread->obj, thread_sd,
+                                    OWNER_SECURITY_INFORMATION |
+                                    GROUP_SECURITY_INFORMATION |
+                                    DACL_SECURITY_INFORMATION |
+                                    SACL_SECURITY_INFORMATION,
+                                    process->token );
+    }
+
  done:
     release_object( info );
 }
@@ -1297,7 +1410,10 @@ DECL_HANDLER(open_process)
     reply->handle = 0;
     if (process)
     {
-        reply->handle = alloc_handle( current->process, process, req->access, req->attributes );
+        if (!process->is_terminated)
+            reply->handle = alloc_handle( current->process, process, req->access, req->attributes );
+        else
+            set_error( STATUS_INVALID_PARAMETER );
         release_object( process );
     }
 }
diff --git a/server/process.h b/server/process.h
index 59625f0..ae83b0e 100644
--- a/server/process.h
+++ b/server/process.h
@@ -76,6 +76,7 @@ struct process
     unsigned int         is_system:1;     /* is it a system process? */
     unsigned int         debug_children:1;/* also debug all child processes */
     unsigned int         is_terminating:1;/* is process terminating? */
+    unsigned int         is_terminated:1; /* is process terminated? */
     struct job          *job;             /* job object ascoicated with this process */
     struct list          job_entry;       /* list entry for job object */
     struct list          locks;           /* list of file locks owned by the process */
diff --git a/server/protocol.def b/server/protocol.def
index 54501e8..48ff9e3 100644
--- a/server/protocol.def
+++ b/server/protocol.def
@@ -69,6 +69,21 @@ struct request_max_size
 #define FIRST_USER_HANDLE 0x0020  /* first possible value for low word of user handle */
 #define LAST_USER_HANDLE  0xffef  /* last possible value for low word of user handle */
 
+/* wineserver global shared memory block */
+typedef struct
+{
+    unsigned int last_input_time;       /* last input time */
+    unsigned int foreground_wnd_epoch;  /* counter to invalidate foreground window */
+} shmglobal_t;
+
+/* wineserver local shared memory block */
+typedef struct
+{
+    int             queue_bits;     /* queue wake bits */
+    user_handle_t   input_focus;    /* focus window */
+    user_handle_t   input_capture;  /* capture window */
+    user_handle_t   input_active;   /* active window */
+} shmlocal_t;
 
 /* debug event data */
 typedef union
@@ -672,8 +687,12 @@ struct rawinput_device
     unsigned int thread_attr;    /* attributes for thread object */
     cpu_type_t   cpu;            /* CPU that the new process will use */
     data_size_t  info_size;      /* size of startup info */
+    data_size_t  env_size;       /* size of the environment */
+    data_size_t  process_sd_size;/* size of the process security descriptor */
     VARARG(info,startup_info,info_size); /* startup information */
-    VARARG(env,unicode_str);     /* environment for new process */
+    VARARG(env,unicode_str,env_size);                       /* environment for new process */
+    VARARG(process_sd,security_descriptor,process_sd_size); /* security descriptor to set on the process */
+    VARARG(thread_sd,security_descriptor);                  /* security descriptor to set on the thread */
 @REPLY
     obj_handle_t info;           /* new process info handle */
     process_id_t pid;            /* process id */
@@ -790,6 +809,17 @@ struct rawinput_device
 #define SET_PROCESS_INFO_AFFINITY 0x02
 
 
+/* Retrieve information about thread times */
+@REQ(get_thread_times)
+    obj_handle_t handle;        /* thread handle */
+@REPLY
+    timeout_t    creation_time; /* thread creation time */
+    timeout_t    exit_time;     /* thread exit time */
+    int          unix_pid;      /* thread native pid */
+    int          unix_tid;      /* thread native pid */
+@END
+
+
 /* Retrieve information about a thread */
 @REQ(get_thread_info)
     obj_handle_t handle;        /* thread handle */
@@ -1150,6 +1180,12 @@ enum server_fd_type
 };
 
 
+/* Get file descriptor for shared memory */
+@REQ(get_shared_memory)
+    thread_id_t tid;            /* thread id or 0 */
+@END
+
+
 /* Flush a file buffers */
 @REQ(flush_file)
     obj_handle_t handle;        /* handle to the file */
@@ -1179,6 +1215,12 @@ enum server_fd_type
 @END
 
 
+/* Set file information */
+@REQ(set_file_info)
+    obj_handle_t handle;        /* handle to the file */
+    int          unlink;        /* whether to unlink file on close */
+@END
+
 /* Create a socket */
 @REQ(create_socket)
     unsigned int access;        /* wanted access rights */
@@ -1209,6 +1251,12 @@ enum server_fd_type
 @END
 
 
+/* Mark a socket to be reused after "closed" */
+@REQ(reuse_socket)
+    obj_handle_t handle;       /* handle to the socket */
+@END
+
+
 /* Set socket event parameters */
 @REQ(set_socket_event)
     obj_handle_t  handle;        /* handle to the socket */
@@ -1239,6 +1287,7 @@ enum server_fd_type
     int family;                 /* family, see socket manpage */
     int type;                   /* type, see socket manpage */
     int protocol;               /* protocol, see socket manpage */
+    timeout_t connect_time;     /* time the socket was connected (relative) */
 @END
 
 
@@ -1620,6 +1669,13 @@ enum char_info_mode
     int          protect;       /* protection flags */
     int          header_size;   /* header size (for VPROT_IMAGE mapping) */
     client_ptr_t base;          /* default base addr (for VPROT_IMAGE mapping) */
+    client_ptr_t entry;         /* entry point addr (for PE image mapping) */
+    short int    subsystem;     /* subsystem (for PE image mapping) */
+    short int    major_subsystem; /* major subsystem version (for PE image mapping) */
+    short int    minor_subsystem; /* minor subsystem version (for PE image mapping) */
+    short int    characteristics; /* image characteristics (for PE image mapping) */
+    short int    dll_characteristics; /* dll characteristics (for PE image mapping) */
+    short int    machine;       /* image machine type (for PE image mapping) */
     obj_handle_t mapping;       /* duplicate mapping handle unless removable */
     obj_handle_t shared_file;   /* shared mapping file handle */
 @END
@@ -2293,6 +2349,7 @@ enum message_type
     unsigned int   flags;
     VARARG(objattr,object_attributes); /* object attributes */
 @REPLY
+    unsigned int   flags;
     obj_handle_t   handle;       /* handle to the pipe */
 @END
 
diff --git a/server/ptrace.c b/server/ptrace.c
index cb436b6..fb29b5a 100644
--- a/server/ptrace.c
+++ b/server/ptrace.c
@@ -531,7 +531,7 @@ void get_selector_entry( struct thread *thread, int entry, unsigned int *base,
 
 
 #if defined(linux) && (defined(HAVE_SYS_USER_H) || defined(HAVE_ASM_USER_H)) \
-    && (defined(__i386__) || defined(__x86_64__))
+    && (defined(__i386__) || defined(__x86_64__)) && !defined(EXAGEAR_COMPAT)
 
 #ifdef HAVE_SYS_USER_H
 #include <sys/user.h>
diff --git a/server/queue.c b/server/queue.c
index 3a321cd..be4fe02 100644
--- a/server/queue.c
+++ b/server/queue.c
@@ -99,6 +99,7 @@ struct thread_input
 {
     struct object          obj;           /* object header */
     struct desktop        *desktop;       /* desktop that this thread input belongs to */
+    struct list            queues;        /* list of all queues this input belongs to */
     user_handle_t          focus;         /* focus window */
     user_handle_t          capture;       /* capture window */
     user_handle_t          active;        /* active window */
@@ -111,17 +112,20 @@ struct thread_input
     user_handle_t          cursor;        /* current cursor */
     int                    cursor_count;  /* cursor show count */
     struct list            msg_list;      /* list of hardware messages */
+    int                    lock_count;    /* lock counter for keystate */
     unsigned char          keystate[256]; /* state of each key */
 };
 
 struct msg_queue
 {
     struct object          obj;             /* object header */
+    struct thread         *thread;          /* reference to the thread owning the queue */
     struct fd             *fd;              /* optional file descriptor to poll */
     unsigned int           wake_bits;       /* wakeup bits */
     unsigned int           wake_mask;       /* wakeup mask */
     unsigned int           changed_bits;    /* changed wakeup bits */
     unsigned int           changed_mask;    /* changed wakeup mask */
+    int                    keystate_locked; /* keystate is locked */
     int                    paint_count;     /* pending paint messages count */
     int                    hotkey_count;    /* pending hotkey messages count */
     int                    quit_message;    /* is there a pending quit message? */
@@ -136,8 +140,10 @@ struct msg_queue
     lparam_t               next_timer_id;   /* id for the next timer with a 0 window */
     struct timeout_user   *timeout;         /* timeout for next timer to expire */
     struct thread_input   *input;           /* thread input descriptor */
+    struct list            input_entry;     /* entry in input->queues */
     struct hook_table     *hooks;           /* hook table */
     timeout_t              last_get_msg;    /* time of last get message call */
+    unsigned int           ignore_post_msg; /* ignore post messages newer than this unique id */
 };
 
 struct hotkey
@@ -249,6 +255,8 @@ static struct thread_input *create_thread_input( struct thread *thread )
         input->move_size    = 0;
         input->cursor       = 0;
         input->cursor_count = 0;
+        input->lock_count   = 0;
+        list_init( &input->queues );
         list_init( &input->msg_list );
         set_caret_window( input, 0 );
         memset( input->keystate, 0, sizeof(input->keystate) );
@@ -262,6 +270,25 @@ static struct thread_input *create_thread_input( struct thread *thread )
     return input;
 }
 
+/* synchronize the input state with the shared memory */
+static void update_shm_thread_input( struct thread_input *input )
+{
+    struct msg_queue *queue;
+
+    /* the loop doesn't matter, usually it should only have one or a few entries */
+    LIST_FOR_EACH_ENTRY( queue, &input->queues, struct msg_queue, input_entry )
+    {
+        shmlocal_t *shm;
+        if (!queue->thread) return;
+        if ((shm = queue->thread->shm))
+        {
+            shm->input_active  = input->active;
+            shm->input_focus   = input->focus;
+            shm->input_capture = input->capture;
+        }
+    }
+}
+
 /* create a message queue object */
 static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_input *input )
 {
@@ -278,10 +305,12 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
     if ((queue = alloc_object( &msg_queue_ops )))
     {
         queue->fd              = NULL;
+        queue->thread          = thread;
         queue->wake_bits       = 0;
         queue->wake_mask       = 0;
         queue->changed_bits    = 0;
         queue->changed_mask    = 0;
+        queue->keystate_locked = 0;
         queue->paint_count     = 0;
         queue->hotkey_count    = 0;
         queue->quit_message    = 0;
@@ -290,8 +319,10 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
         queue->next_timer_id   = 0x7fff;
         queue->timeout         = NULL;
         queue->input           = (struct thread_input *)grab_object( input );
+        list_add_tail( &input->queues, &queue->input_entry );
         queue->hooks           = NULL;
         queue->last_get_msg    = current_time;
+        queue->ignore_post_msg = 0;
         list_init( &queue->send_result );
         list_init( &queue->callback_result );
         list_init( &queue->pending_timers );
@@ -300,7 +331,11 @@ static struct msg_queue *create_msg_queue( struct thread *thread, struct thread_
 
         thread->queue = queue;
     }
-    if (new_input) release_object( new_input );
+    if (new_input)
+    {
+        update_shm_thread_input( new_input );
+        release_object( new_input );
+    }
     return queue;
 }
 
@@ -309,6 +344,7 @@ void free_msg_queue( struct thread *thread )
 {
     remove_thread_hooks( thread );
     if (!thread->queue) return;
+    thread->queue->thread = NULL;
     release_object( thread->queue );
     thread->queue = NULL;
 }
@@ -325,11 +361,16 @@ static int assign_thread_input( struct thread *thread, struct thread_input *new_
     }
     if (queue->input)
     {
+        if (queue->keystate_locked) queue->input->lock_count--;
         queue->input->cursor_count -= queue->cursor_count;
+        list_remove( &queue->input_entry );
         release_object( queue->input );
+        queue->keystate_locked = 0;
     }
     queue->input = (struct thread_input *)grab_object( new_input );
+    list_add_tail( &new_input->queues, &queue->input_entry );
     new_input->cursor_count += queue->cursor_count;
+    update_shm_thread_input( new_input );
     return 1;
 }
 
@@ -362,7 +403,7 @@ static void set_cursor_pos( struct desktop *desktop, int x, int y )
 }
 
 /* set the cursor clip rectangle */
-static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect )
+static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect, int do_clip )
 {
     rectangle_t top_rect;
     int x, y;
@@ -381,7 +422,7 @@ static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect
     else desktop->cursor.clip = top_rect;
 
     if (desktop->cursor.clip_msg)
-        post_desktop_message( desktop, desktop->cursor.clip_msg, rect != NULL, 0 );
+        post_desktop_message( desktop, desktop->cursor.clip_msg, rect != NULL, do_clip );
 
     /* warp the mouse to be inside the clip rect */
     x = min( max( desktop->cursor.x, desktop->cursor.clip.left ), desktop->cursor.clip.right-1 );
@@ -393,8 +434,9 @@ static void set_clip_rectangle( struct desktop *desktop, const rectangle_t *rect
 static void set_foreground_input( struct desktop *desktop, struct thread_input *input )
 {
     if (desktop->foreground_input == input) return;
-    set_clip_rectangle( desktop, NULL );
+    set_clip_rectangle( desktop, NULL, 1 );
     desktop->foreground_input = input;
+    if (shmglobal) interlocked_xchg_add( (int *)&shmglobal->foreground_wnd_epoch, 1 );
 }
 
 /* get the hook table for a given thread */
@@ -419,11 +461,21 @@ static inline int is_signaled( struct msg_queue *queue )
     return ((queue->wake_bits & queue->wake_mask) || (queue->changed_bits & queue->changed_mask));
 }
 
+/* synchronize the queue state with the shared memory */
+static inline void update_shm_queue_bits( struct msg_queue *queue )
+{
+    shmlocal_t *shm;
+    if (!queue->thread) return;
+    if ((shm = queue->thread->shm))
+        shm->queue_bits = queue->wake_bits;
+}
+
 /* set some queue bits */
 static inline void set_queue_bits( struct msg_queue *queue, unsigned int bits )
 {
     queue->wake_bits |= bits;
     queue->changed_bits |= bits;
+    update_shm_queue_bits( queue );
     if (is_signaled( queue )) wake_up( &queue->obj, 0 );
 }
 
@@ -432,6 +484,7 @@ static inline void clear_queue_bits( struct msg_queue *queue, unsigned int bits
 {
     queue->wake_bits &= ~bits;
     queue->changed_bits &= ~bits;
+    update_shm_queue_bits( queue );
 }
 
 /* check whether msg is a keyboard message */
@@ -479,13 +532,21 @@ static inline struct msg_queue *get_current_queue(void)
 }
 
 /* get a (pseudo-)unique id to tag hardware messages */
-static inline unsigned int get_unique_id(void)
+static inline unsigned int get_unique_hw_id(void)
 {
     static unsigned int id;
     if (!++id) id = 1;  /* avoid an id of 0 */
     return id;
 }
 
+/* get unique increasing id to tag post messages */
+static inline unsigned int get_unique_post_id(void)
+{
+    static unsigned int id;
+    if (!++id) id = 1;
+    return id;
+}
+
 /* try to merge a message with the last in the list; return 1 if successful */
 static int merge_message( struct thread_input *input, const struct message *msg )
 {
@@ -772,6 +833,7 @@ static int get_posted_message( struct msg_queue *queue, user_handle_t win,
     {
         if (!match_window( win, msg->win )) continue;
         if (!check_msg_filter( msg->msg, first, last )) continue;
+        if (queue->ignore_post_msg && (int)(msg->unique_id - queue->ignore_post_msg) >= 0) continue;
         goto found; /* found one */
     }
     return 0;
@@ -970,7 +1032,9 @@ static void msg_queue_destroy( struct object *obj )
         free( timer );
     }
     if (queue->timeout) remove_timeout_user( queue->timeout );
+    if (queue->keystate_locked) queue->input->lock_count--;
     queue->input->cursor_count -= queue->cursor_count;
+    list_remove( &queue->input_entry );
     release_object( queue->input );
     if (queue->hooks) release_object( queue->hooks );
     if (queue->fd) release_object( queue->fd );
@@ -997,6 +1061,7 @@ static void thread_input_destroy( struct object *obj )
 {
     struct thread_input *input = (struct thread_input *)obj;
 
+    assert( list_empty(&input->queues) );
     empty_msg_list( &input->msg_list );
     if (input->desktop)
     {
@@ -1012,10 +1077,16 @@ static inline void thread_input_cleanup_window( struct msg_queue *queue, user_ha
 
     if (window == input->focus) input->focus = 0;
     if (window == input->capture) input->capture = 0;
-    if (window == input->active) input->active = 0;
+    if (window == input->active)
+    {
+        input->active = 0;
+        if (shmglobal && input->desktop->foreground_input == input)
+            interlocked_xchg_add( (int *)&shmglobal->foreground_wnd_epoch, 1 );
+    }
     if (window == input->menu_owner) input->menu_owner = 0;
     if (window == input->move_size) input->move_size = 0;
     if (window == input->caret) set_caret_window( input, 0 );
+    update_shm_thread_input( input );
 }
 
 /* check if the specified window can be set in the input data of a given queue */
@@ -1215,9 +1286,9 @@ static void set_input_key_state( unsigned char *keystate, unsigned char key, int
     else keystate[key] &= ~0x80;
 }
 
-/* update the input key state for a keyboard message */
-static void update_input_key_state( struct desktop *desktop, unsigned char *keystate,
-                                    const struct message *msg )
+/* update the key state for a keyboard message */
+static void update_key_state( struct desktop *desktop, unsigned char *keystate,
+                              const struct message *msg )
 {
     unsigned char key;
     int down = 0;
@@ -1279,6 +1350,25 @@ static void update_input_key_state( struct desktop *desktop, unsigned char *keys
     }
 }
 
+/* synchronizes the thread input key state with the desktop */
+static void synchronize_input_key_state( struct thread_input *input )
+{
+    if (!input->lock_count)
+    {
+        unsigned char *keystate = input->keystate;
+        unsigned int i;
+        for (i = 0; i < 256; i++)
+            keystate[i] = input->desktop->keystate[i] & ~0x40;
+    }
+}
+
+/* update the thread input key state for a keyboard message */
+static void update_input_key_state( struct thread_input *input, const struct message *msg )
+{
+    synchronize_input_key_state( input );
+    update_key_state( input->desktop, input->keystate, msg );
+}
+
 /* release the hardware message currently being processed by the given thread */
 static void release_hardware_message( struct msg_queue *queue, unsigned int hw_id,
                                       int remove )
@@ -1309,7 +1399,7 @@ static void release_hardware_message( struct msg_queue *queue, unsigned int hw_i
         }
         if (clr_bit) clear_queue_bits( queue, clr_bit );
 
-        update_input_key_state( input->desktop, input->keystate, msg );
+        update_input_key_state( input, msg );
         list_remove( &msg->entry );
         free_message( msg );
     }
@@ -1341,6 +1431,7 @@ found:
     msg->msg       = WM_HOTKEY;
     msg->wparam    = hotkey->id;
     msg->lparam    = ((hotkey->vkey & 0xffff) << 16) | modifiers;
+    msg->unique_id = get_unique_post_id();
 
     free( msg->data );
     msg->data      = NULL;
@@ -1430,7 +1521,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     unsigned int msg_code;
     struct hardware_msg_data *data = msg->data;
 
-    update_input_key_state( desktop, desktop->keystate, msg );
+    update_key_state( desktop, desktop->keystate, msg );
     last_input_time = get_tick_count();
     if (msg->msg != WM_MOUSEMOVE) always_queue = 1;
 
@@ -1473,7 +1564,7 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     win = find_hardware_message_window( desktop, input, msg, &msg_code, &thread );
     if (!win || !thread)
     {
-        if (input) update_input_key_state( input->desktop, input->keystate, msg );
+        if (input) update_input_key_state( input, msg );
         free_message( msg );
         return;
     }
@@ -1486,6 +1577,15 @@ static void queue_hardware_message( struct desktop *desktop, struct message *msg
     else
     {
         msg->unique_id = 0;  /* will be set once we return it to the app */
+
+        /* lock the keystate on the first hardware message */
+        if (!thread->queue->keystate_locked)
+        {
+            synchronize_input_key_state( input );
+            input->lock_count++;
+            thread->queue->keystate_locked = 1;
+        }
+
         list_add_tail( &input->msg_list, &msg->entry );
         set_queue_bits( thread->queue, get_hardware_msg_bit(msg) );
     }
@@ -1911,7 +2011,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
         if (!win || !win_thread)
         {
             /* no window at all, remove it */
-            update_input_key_state( input->desktop, input->keystate, msg );
+            update_input_key_state( input, msg );
             list_remove( &msg->entry );
             free_message( msg );
             continue;
@@ -1927,7 +2027,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
             else
             {
                 /* for another thread input, drop it */
-                update_input_key_state( input->desktop, input->keystate, msg );
+                update_input_key_state( input, msg );
                 list_remove( &msg->entry );
                 free_message( msg );
             }
@@ -1944,7 +2044,7 @@ static int get_hardware_message( struct thread *thread, unsigned int hw_id, user
             continue;
         }
         /* now we can return it */
-        if (!msg->unique_id) msg->unique_id = get_unique_id();
+        if (!msg->unique_id) msg->unique_id = get_unique_hw_id();
         reply->type   = MSG_HARDWARE;
         reply->win    = win;
         reply->msg    = msg_code;
@@ -2049,6 +2149,7 @@ void post_message( user_handle_t win, unsigned int message, lparam_t wparam, lpa
         msg->result    = NULL;
         msg->data      = NULL;
         msg->data_size = 0;
+        msg->unique_id = get_unique_post_id();
 
         list_add_tail( &thread->queue->msg_list[POST_MESSAGE], &msg->entry );
         set_queue_bits( thread->queue, QS_POSTMESSAGE|QS_ALLPOSTMESSAGE );
@@ -2263,6 +2364,7 @@ DECL_HANDLER(send_message)
             set_queue_bits( recv_queue, QS_SENDMESSAGE );
             break;
         case MSG_POSTED:
+            msg->unique_id = get_unique_post_id();
             list_add_tail( &recv_queue->msg_list[POST_MESSAGE], &msg->entry );
             set_queue_bits( recv_queue, QS_POSTMESSAGE|QS_ALLPOSTMESSAGE );
             if (msg->msg == WM_HOTKEY)
@@ -2357,6 +2459,13 @@ DECL_HANDLER(get_message)
     queue->last_get_msg = current_time;
     if (!filter) filter = QS_ALLINPUT;
 
+    /* no longer lock the keystate if we have processed all input */
+    if (queue->keystate_locked && !(queue->wake_bits & QS_ALLINPUT))
+    {
+        queue->input->lock_count--;
+        queue->keystate_locked = 0;
+    }
+
     /* first check for sent messages */
     if ((ptr = list_head( &queue->msg_list[SEND_MESSAGE] )))
     {
@@ -2392,7 +2501,7 @@ DECL_HANDLER(get_message)
     if ((filter & QS_INPUT) &&
         filter_contains_hw_range( req->get_first, req->get_last ) &&
         get_hardware_message( current, req->hw_id, get_win, req->get_first, req->get_last, req->flags, reply ))
-        return;
+        goto found_msg;
 
     /* now check for WM_PAINT */
     if ((filter & QS_PAINT) &&
@@ -2405,7 +2514,7 @@ DECL_HANDLER(get_message)
         reply->wparam = 0;
         reply->lparam = 0;
         reply->time   = get_tick_count();
-        return;
+        goto found_msg;
     }
 
     /* now check for timer */
@@ -2421,13 +2530,20 @@ DECL_HANDLER(get_message)
         reply->time   = get_tick_count();
         if (!(req->flags & PM_NOYIELD) && current->process->idle_event)
             set_event( current->process->idle_event );
-        return;
+        goto found_msg;
     }
 
     if (get_win == -1 && current->process->idle_event) set_event( current->process->idle_event );
     queue->wake_mask = req->wake_mask;
     queue->changed_mask = req->changed_mask;
     set_error( STATUS_PENDING );  /* FIXME */
+    return;
+
+found_msg:
+    if (req->flags & PM_REMOVE)
+        queue->ignore_post_msg = 0;
+    else if (!queue->ignore_post_msg)
+        queue->ignore_post_msg = get_unique_post_id();
 }
 
 
@@ -2445,7 +2561,10 @@ DECL_HANDLER(reply_message)
 DECL_HANDLER(accept_hardware_message)
 {
     if (current->queue)
+    {
         release_hardware_message( current->queue, req->hw_id, req->remove );
+        if (req->remove) current->queue->ignore_post_msg = 0;
+    }
     else
         set_error( STATUS_ACCESS_DENIED );
 }
@@ -2796,13 +2915,33 @@ DECL_HANDLER(get_key_state)
     }
     else
     {
+        unsigned char *keystate;
         if (!(thread = get_thread_from_id( req->tid ))) return;
         if (thread->queue)
         {
-            if (req->key >= 0) reply->state = thread->queue->input->keystate[req->key & 0xff];
+            if (req->key >= 0)
+            {
+                /* synchronize with desktop keystate, but _only_ if req->key is given */
+                synchronize_input_key_state( thread->queue->input );
+                reply->state = thread->queue->input->keystate[req->key & 0xff];
+            }
             set_reply_data( thread->queue->input->keystate, size );
+            release_object( thread );
+            return;
         }
         release_object( thread );
+
+        /* fallback to desktop keystate */
+        if (!(desktop = get_thread_desktop( current, 0 ))) return;
+        if (req->key >= 0)
+            reply->state = desktop->keystate[req->key & 0xff] & ~0x40;
+        if ((keystate = set_reply_data_size( size )))
+        {
+            unsigned int i;
+            for (i = 0; i < size; i++)
+                keystate[i] = desktop->keystate[i] & ~0x40;
+        }
+        release_object( desktop );
     }
 }
 
@@ -2870,6 +3009,7 @@ DECL_HANDLER(set_focus_window)
     {
         reply->previous = queue->input->focus;
         queue->input->focus = get_user_full_handle( req->handle );
+        update_shm_thread_input( queue->input );
     }
 }
 
@@ -2886,6 +3026,9 @@ DECL_HANDLER(set_active_window)
         {
             reply->previous = queue->input->active;
             queue->input->active = get_user_full_handle( req->handle );
+            update_shm_thread_input( queue->input );
+            if (shmglobal && queue->input->desktop->foreground_input == queue->input)
+                interlocked_xchg_add( (int *)&shmglobal->foreground_wnd_epoch, 1 );
         }
         else set_error( STATUS_INVALID_HANDLE );
     }
@@ -2912,6 +3055,7 @@ DECL_HANDLER(set_capture_window)
         input->capture = get_user_full_handle( req->handle );
         input->menu_owner = (req->flags & CAPTURE_MENU) ? input->capture : 0;
         input->move_size = (req->flags & CAPTURE_MOVESIZE) ? input->capture : 0;
+        update_shm_thread_input( input );
         reply->full_handle = input->capture;
     }
 }
@@ -3023,7 +3167,7 @@ DECL_HANDLER(set_cursor)
         if (req->clip_msg && get_top_window_owner(desktop) == current->process)
             desktop->cursor.clip_msg = req->clip_msg;
 
-        set_clip_rectangle( desktop, (req->flags & SET_CURSOR_NOCLIP) ? NULL : &req->clip );
+        set_clip_rectangle( desktop, (req->flags & SET_CURSOR_NOCLIP) ? NULL : &req->clip, 0 );
     }
 
     reply->new_x       = input->desktop->cursor.x;
diff --git a/server/request.h b/server/request.h
index f94235f..ce98eb1 100644
--- a/server/request.h
+++ b/server/request.h
@@ -116,6 +116,7 @@ DECL_HANDLER(terminate_process);
 DECL_HANDLER(terminate_thread);
 DECL_HANDLER(get_process_info);
 DECL_HANDLER(set_process_info);
+DECL_HANDLER(get_thread_times);
 DECL_HANDLER(get_thread_info);
 DECL_HANDLER(set_thread_info);
 DECL_HANDLER(get_dll_info);
@@ -149,12 +150,15 @@ DECL_HANDLER(open_file_object);
 DECL_HANDLER(alloc_file_handle);
 DECL_HANDLER(get_handle_unix_name);
 DECL_HANDLER(get_handle_fd);
+DECL_HANDLER(get_shared_memory);
 DECL_HANDLER(flush_file);
 DECL_HANDLER(lock_file);
 DECL_HANDLER(unlock_file);
+DECL_HANDLER(set_file_info);
 DECL_HANDLER(create_socket);
 DECL_HANDLER(accept_socket);
 DECL_HANDLER(accept_into_socket);
+DECL_HANDLER(reuse_socket);
 DECL_HANDLER(set_socket_event);
 DECL_HANDLER(get_socket_event);
 DECL_HANDLER(get_socket_info);
@@ -384,6 +388,7 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_terminate_thread,
     (req_handler)req_get_process_info,
     (req_handler)req_set_process_info,
+    (req_handler)req_get_thread_times,
     (req_handler)req_get_thread_info,
     (req_handler)req_set_thread_info,
     (req_handler)req_get_dll_info,
@@ -417,12 +422,15 @@ static const req_handler req_handlers[REQ_NB_REQUESTS] =
     (req_handler)req_alloc_file_handle,
     (req_handler)req_get_handle_unix_name,
     (req_handler)req_get_handle_fd,
+    (req_handler)req_get_shared_memory,
     (req_handler)req_flush_file,
     (req_handler)req_lock_file,
     (req_handler)req_unlock_file,
+    (req_handler)req_set_file_info,
     (req_handler)req_create_socket,
     (req_handler)req_accept_socket,
     (req_handler)req_accept_into_socket,
+    (req_handler)req_reuse_socket,
     (req_handler)req_set_socket_event,
     (req_handler)req_get_socket_event,
     (req_handler)req_get_socket_info,
@@ -677,7 +685,9 @@ C_ASSERT( FIELD_OFFSET(struct new_process_request, thread_access) == 36 );
 C_ASSERT( FIELD_OFFSET(struct new_process_request, thread_attr) == 40 );
 C_ASSERT( FIELD_OFFSET(struct new_process_request, cpu) == 44 );
 C_ASSERT( FIELD_OFFSET(struct new_process_request, info_size) == 48 );
-C_ASSERT( sizeof(struct new_process_request) == 56 );
+C_ASSERT( FIELD_OFFSET(struct new_process_request, env_size) == 52 );
+C_ASSERT( FIELD_OFFSET(struct new_process_request, process_sd_size) == 56 );
+C_ASSERT( sizeof(struct new_process_request) == 64 );
 C_ASSERT( FIELD_OFFSET(struct new_process_reply, info) == 8 );
 C_ASSERT( FIELD_OFFSET(struct new_process_reply, pid) == 12 );
 C_ASSERT( FIELD_OFFSET(struct new_process_reply, phandle) == 16 );
@@ -751,6 +761,13 @@ C_ASSERT( FIELD_OFFSET(struct set_process_info_request, mask) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_process_info_request, priority) == 20 );
 C_ASSERT( FIELD_OFFSET(struct set_process_info_request, affinity) == 24 );
 C_ASSERT( sizeof(struct set_process_info_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_times_request, handle) == 12 );
+C_ASSERT( sizeof(struct get_thread_times_request) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, creation_time) == 8 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, exit_time) == 16 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, unix_pid) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_thread_times_reply, unix_tid) == 28 );
+C_ASSERT( sizeof(struct get_thread_times_reply) == 32 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_thread_info_request, tid_in) == 16 );
 C_ASSERT( sizeof(struct get_thread_info_request) == 24 );
@@ -949,6 +966,8 @@ C_ASSERT( FIELD_OFFSET(struct get_handle_fd_reply, cacheable) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_handle_fd_reply, access) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_handle_fd_reply, options) == 20 );
 C_ASSERT( sizeof(struct get_handle_fd_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_shared_memory_request, tid) == 12 );
+C_ASSERT( sizeof(struct get_shared_memory_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct flush_file_request, handle) == 12 );
 C_ASSERT( sizeof(struct flush_file_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct flush_file_reply, event) == 8 );
@@ -966,6 +985,9 @@ C_ASSERT( FIELD_OFFSET(struct unlock_file_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct unlock_file_request, offset) == 16 );
 C_ASSERT( FIELD_OFFSET(struct unlock_file_request, count) == 24 );
 C_ASSERT( sizeof(struct unlock_file_request) == 32 );
+C_ASSERT( FIELD_OFFSET(struct set_file_info_request, handle) == 12 );
+C_ASSERT( FIELD_OFFSET(struct set_file_info_request, unlink) == 16 );
+C_ASSERT( sizeof(struct set_file_info_request) == 24 );
 C_ASSERT( FIELD_OFFSET(struct create_socket_request, access) == 12 );
 C_ASSERT( FIELD_OFFSET(struct create_socket_request, attributes) == 16 );
 C_ASSERT( FIELD_OFFSET(struct create_socket_request, family) == 20 );
@@ -984,6 +1006,8 @@ C_ASSERT( sizeof(struct accept_socket_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct accept_into_socket_request, lhandle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct accept_into_socket_request, ahandle) == 16 );
 C_ASSERT( sizeof(struct accept_into_socket_request) == 24 );
+C_ASSERT( FIELD_OFFSET(struct reuse_socket_request, handle) == 12 );
+C_ASSERT( sizeof(struct reuse_socket_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_socket_event_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct set_socket_event_request, mask) == 16 );
 C_ASSERT( FIELD_OFFSET(struct set_socket_event_request, event) == 20 );
@@ -1003,7 +1027,8 @@ C_ASSERT( sizeof(struct get_socket_info_request) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_socket_info_reply, family) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_socket_info_reply, type) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_socket_info_reply, protocol) == 16 );
-C_ASSERT( sizeof(struct get_socket_info_reply) == 24 );
+C_ASSERT( FIELD_OFFSET(struct get_socket_info_reply, connect_time) == 24 );
+C_ASSERT( sizeof(struct get_socket_info_reply) == 32 );
 C_ASSERT( FIELD_OFFSET(struct enable_socket_event_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct enable_socket_event_request, mask) == 16 );
 C_ASSERT( FIELD_OFFSET(struct enable_socket_event_request, sstate) == 20 );
@@ -1186,9 +1211,16 @@ C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, size) == 8 );
 C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, protect) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, header_size) == 20 );
 C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, base) == 24 );
-C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, mapping) == 32 );
-C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, shared_file) == 36 );
-C_ASSERT( sizeof(struct get_mapping_info_reply) == 40 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, entry) == 32 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, subsystem) == 40 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, major_subsystem) == 42 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, minor_subsystem) == 44 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, characteristics) == 46 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, dll_characteristics) == 48 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, machine) == 50 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, mapping) == 52 );
+C_ASSERT( FIELD_OFFSET(struct get_mapping_info_reply, shared_file) == 56 );
+C_ASSERT( sizeof(struct get_mapping_info_reply) == 64 );
 C_ASSERT( FIELD_OFFSET(struct get_mapping_committed_range_request, handle) == 12 );
 C_ASSERT( FIELD_OFFSET(struct get_mapping_committed_range_request, offset) == 16 );
 C_ASSERT( sizeof(struct get_mapping_committed_range_request) == 24 );
@@ -1543,7 +1575,8 @@ C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, insize) == 36 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, timeout) == 40 );
 C_ASSERT( FIELD_OFFSET(struct create_named_pipe_request, flags) == 48 );
 C_ASSERT( sizeof(struct create_named_pipe_request) == 56 );
-C_ASSERT( FIELD_OFFSET(struct create_named_pipe_reply, handle) == 8 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_reply, flags) == 8 );
+C_ASSERT( FIELD_OFFSET(struct create_named_pipe_reply, handle) == 12 );
 C_ASSERT( sizeof(struct create_named_pipe_reply) == 16 );
 C_ASSERT( FIELD_OFFSET(struct get_named_pipe_info_request, handle) == 12 );
 C_ASSERT( sizeof(struct get_named_pipe_info_request) == 16 );
diff --git a/server/security.h b/server/security.h
index 855f2e7..01bf637 100644
--- a/server/security.h
+++ b/server/security.h
@@ -47,6 +47,7 @@ extern const PSID security_local_user_sid;
 extern const PSID security_local_system_sid;
 extern const PSID security_builtin_users_sid;
 extern const PSID security_builtin_admins_sid;
+extern const PSID security_domain_users_sid;
 
 
 /* token functions */
diff --git a/server/sock.c b/server/sock.c
index 823c846..c3e0ec5 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -61,6 +61,7 @@
 
 #include "process.h"
 #include "file.h"
+#include "sock.h"
 #include "handle.h"
 #include "thread.h"
 #include "request.h"
@@ -86,6 +87,7 @@
 #define FD_CLOSE                   0x00000020
 
 /* internal per-socket flags */
+#define FD_WINE_REUSE              0x08000000
 #define FD_WINE_LISTENING          0x10000000
 #define FD_WINE_NONBLOCKING        0x20000000
 #define FD_WINE_CONNECTED          0x40000000
@@ -135,10 +137,10 @@ static obj_handle_t sock_ioctl( struct fd *fd, ioctl_code_t code, const async_da
 static void sock_queue_async( struct fd *fd, const async_data_t *data, int type, int count );
 static void sock_reselect_async( struct fd *fd, struct async_queue *queue );
 static void sock_cancel_async( struct fd *fd, struct process *process, struct thread *thread, client_ptr_t iosb );
+static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle );
 
 static int sock_get_ntstatus( int err );
 static int sock_get_error( int err );
-static void sock_set_error(void);
 
 static const struct object_ops sock_ops =
 {
@@ -156,7 +158,7 @@ static const struct object_ops sock_ops =
     default_set_sd,               /* set_sd */
     no_lookup_name,               /* lookup_name */
     no_open_file,                 /* open_file */
-    fd_close_handle,              /* close_handle */
+    sock_close_handle,            /* close_handle */
     sock_destroy                  /* destroy */
 };
 
@@ -558,6 +560,8 @@ obj_handle_t sock_ioctl( struct fd *fd, ioctl_code_t code, const async_data_t *a
             close_handle( current->process, wait_handle );
             return 0;
         }
+        if ((sock->state & FD_WINE_NONBLOCKING) && !blocking)
+            set_error( STATUS_CANT_WAIT );
         return wait_handle;
     default:
         set_error( STATUS_NOT_SUPPORTED );
@@ -627,6 +631,47 @@ static struct fd *sock_get_fd( struct object *obj )
     return (struct fd *)grab_object( sock->fd );
 }
 
+static int init_sockfd( int family, int type, int protocol )
+{
+    int sockfd;
+
+    sockfd = socket( family, type, protocol );
+    if (debug_level)
+        fprintf(stderr,"socket(%d,%d,%d)=%d\n",family,type,protocol,sockfd);
+    if (sockfd == -1)
+    {
+        sock_set_error();
+        return sockfd;
+    }
+    fcntl(sockfd, F_SETFL, O_NONBLOCK); /* make socket nonblocking */
+    return sockfd;
+}
+
+static int sock_close_handle( struct object *obj, struct process *process, obj_handle_t handle )
+{
+    struct sock *sock = (struct sock *)obj;
+
+    assert( obj->ops == &sock_ops );
+    if (!fd_close_handle( obj, process, handle ))
+        return FALSE;
+
+    if (sock->state & FD_WINE_REUSE)
+    {
+        struct fd *fd;
+        int sockfd;
+
+        if ((sockfd = init_sockfd( sock->family, sock->type, sock->proto )) == -1)
+            return TRUE;
+        if (!(fd = create_anonymous_fd( &sock_fd_ops, sockfd, &sock->obj, get_fd_options(sock->fd) )))
+            return TRUE;
+        shutdown( get_unix_fd(sock->fd), SHUT_RDWR );
+        release_object( sock->fd );
+        sock->fd = fd;
+        return FALSE;
+    }
+    return TRUE;
+}
+
 static void sock_destroy( struct object *obj )
 {
     struct sock *sock = (struct sock *)obj;
@@ -678,15 +723,8 @@ static struct object *create_socket( int family, int type, int protocol, unsigne
     struct sock *sock;
     int sockfd;
 
-    sockfd = socket( family, type, protocol );
-    if (debug_level)
-        fprintf(stderr,"socket(%d,%d,%d)=%d\n",family,type,protocol,sockfd);
-    if (sockfd == -1)
-    {
-        sock_set_error();
+    if ((sockfd = init_sockfd( family, type, protocol )) == -1)
         return NULL;
-    }
-    fcntl(sockfd, F_SETFL, O_NONBLOCK); /* make socket nonblocking */
     if (!(sock = alloc_object( &sock_ops )))
     {
         close( sockfd );
@@ -956,7 +994,7 @@ static int sock_get_ntstatus( int err )
 }
 
 /* set the last error depending on errno */
-static void sock_set_error(void)
+void sock_set_error(void)
 {
     set_error( sock_get_ntstatus( errno ) );
 }
@@ -1283,6 +1321,17 @@ DECL_HANDLER(accept_into_socket)
     release_object( sock );
 }
 
+/* mark a socket to be recreated on close */
+DECL_HANDLER(reuse_socket)
+{
+    struct sock *sock;
+
+    if (!(sock = (struct sock *)get_handle_obj( current->process, req->handle,
+                                                FILE_WRITE_ATTRIBUTES, &sock_ops))) return;
+    sock->state |= FD_WINE_REUSE;
+    release_object( &sock->obj );
+}
+
 /* set socket event parameters */
 DECL_HANDLER(set_socket_event)
 {
@@ -1407,6 +1456,7 @@ DECL_HANDLER(get_socket_info)
     reply->family   = sock->family;
     reply->type     = sock->type;
     reply->protocol = sock->proto;
+    reply->connect_time = -(current_time - sock->connect_time);
 
     release_object( &sock->obj );
 }
diff --git a/server/thread.c b/server/thread.c
index 906b79d..36bb636 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -194,6 +194,8 @@ static inline void init_thread_structure( struct thread *thread )
     thread->suspend         = 0;
     thread->desktop_users   = 0;
     thread->token           = NULL;
+    thread->shm_fd          = -1;
+    thread->shm             = NULL;
 
     thread->creation_time = current_time;
     thread->exit_time     = 0;
@@ -295,6 +297,8 @@ static void cleanup_thread( struct thread *thread )
             thread->inflight[i].client = thread->inflight[i].server = -1;
         }
     }
+    release_shared_memory( thread->shm_fd, thread->shm, sizeof(*thread->shm) );
+
     thread->req_data = NULL;
     thread->reply_data = NULL;
     thread->request_fd = NULL;
@@ -303,6 +307,9 @@ static void cleanup_thread( struct thread *thread )
     thread->context = NULL;
     thread->suspend_context = NULL;
     thread->desktop = 0;
+    thread->shm_fd = -1;
+    thread->shm = NULL;
+
 }
 
 /* destroy a thread when its refcount is 0 */
@@ -482,7 +489,10 @@ static void set_thread_info( struct thread *thread,
         if ((req->priority >= min && req->priority <= max) ||
             req->priority == THREAD_PRIORITY_IDLE ||
             req->priority == THREAD_PRIORITY_TIME_CRITICAL)
+        {
             thread->priority = req->priority;
+            set_scheduler_priority( thread );
+        }
         else
             set_error( STATUS_INVALID_PARAMETER );
     }
@@ -601,6 +611,7 @@ static int wait_on( const select_op_t *select_op, unsigned int count, struct obj
     wait->count   = count;
     wait->flags   = flags;
     wait->select  = select_op->op;
+    wait->cookie  = 0;
     wait->user    = NULL;
     wait->timeout = timeout;
     wait->abandoned = 0;
@@ -719,7 +730,7 @@ int wake_thread( struct thread *thread )
         cookie = thread->wait->cookie;
         if (debug_level) fprintf( stderr, "%04x: *wakeup* signaled=%d\n", thread->id, signaled );
         end_wait( thread );
-        if (send_thread_wakeup( thread, cookie, signaled ) == -1) /* error */
+        if (cookie && send_thread_wakeup( thread, cookie, signaled ) == -1) /* error */
         {
             if (!count) count = -1;
             break;
@@ -749,7 +760,7 @@ int wake_thread_queue_entry( struct wait_queue_entry *entry )
     if (debug_level) fprintf( stderr, "%04x: *wakeup* signaled=%d\n", thread->id, signaled );
     end_wait( thread );
 
-    if (send_thread_wakeup( thread, cookie, signaled ) != -1)
+    if (!cookie || send_thread_wakeup( thread, cookie, signaled ) != -1)
         wake_thread( thread );  /* check other waits too */
 
     return 1;
@@ -768,6 +779,8 @@ static void thread_timeout( void *ptr )
 
     if (debug_level) fprintf( stderr, "%04x: *wakeup* signaled=TIMEOUT\n", thread->id );
     end_wait( thread );
+
+    assert( cookie );
     if (send_thread_wakeup( thread, cookie, STATUS_TIMEOUT ) == -1) return;
     /* check if other objects have become signaled in the meantime */
     wake_thread( thread );
@@ -1354,6 +1367,22 @@ DECL_HANDLER(open_thread)
     }
 }
 
+/* fetch information about thread times */
+DECL_HANDLER(get_thread_times)
+{
+    struct thread *thread;
+
+    if ((thread = get_thread_from_handle( req->handle, THREAD_QUERY_INFORMATION )))
+    {
+        reply->creation_time  = thread->creation_time;
+        reply->exit_time      = thread->exit_time;
+        reply->unix_pid       = thread->unix_pid;
+        reply->unix_tid       = thread->unix_tid;
+
+        release_object( thread );
+    }
+}
+
 /* fetch information about a thread */
 DECL_HANDLER(get_thread_info)
 {
@@ -1429,6 +1458,12 @@ DECL_HANDLER(select)
         set_error( STATUS_INVALID_PARAMETER );
         return;
     }
+    if (!req->cookie)
+    {
+        set_error( STATUS_INVALID_PARAMETER );
+        return;
+    }
+
     op_size = min( get_req_data_size() - sizeof(*result), sizeof(select_op) );
     memset( &select_op, 0, sizeof(select_op) );
     memcpy( &select_op, result + 1, op_size );
diff --git a/server/thread.h b/server/thread.h
index 996d95b..c03dff5 100644
--- a/server/thread.h
+++ b/server/thread.h
@@ -87,6 +87,8 @@ struct thread
     timeout_t              creation_time; /* Thread creation time */
     timeout_t              exit_time;     /* Thread exit time */
     struct token          *token;         /* security token associated with this thread */
+    int                    shm_fd;        /* file descriptor for thread local shared memory */
+    shmlocal_t            *shm;           /* thread local shared memory pointer */
 };
 
 struct thread_snapshot
@@ -145,4 +147,9 @@ static inline void set_win32_error( unsigned int err ) { set_error( 0xc0010000 |
 
 static inline thread_id_t get_thread_id( struct thread *thread ) { return thread->id; }
 
+/* scheduler functions */
+
+extern void init_scheduler( void );
+extern void set_scheduler_priority( struct thread *thread );
+
 #endif  /* __WINE_SERVER_THREAD_H */
diff --git a/server/token.c b/server/token.c
index c235ece..e57cbc6 100644
--- a/server/token.c
+++ b/server/token.c
@@ -91,6 +91,13 @@ static const struct /* same fields as struct SID */
     SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
     DWORD SubAuthority[2];
 } builtin_users_sid = { SID_REVISION, 2, { SECURITY_NT_AUTHORITY }, { SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_USERS } };
+static const struct /* same fields as struct SID */
+{
+    BYTE Revision;
+    BYTE SubAuthorityCount;
+    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
+    DWORD SubAuthority[5];
+} domain_users_sid = { SID_REVISION, 5, { SECURITY_NT_AUTHORITY }, { SECURITY_NT_NON_UNIQUE, 0, 0, 0, DOMAIN_GROUP_RID_USERS } };
 
 const PSID security_world_sid = (PSID)&world_sid;
 static const PSID security_local_sid = (PSID)&local_sid;
@@ -100,6 +107,7 @@ const PSID security_local_system_sid = (PSID)&local_system_sid;
 const PSID security_local_user_sid = (PSID)&local_user_sid;
 const PSID security_builtin_admins_sid = (PSID)&builtin_admins_sid;
 const PSID security_builtin_users_sid = (PSID)&builtin_users_sid;
+const PSID security_domain_users_sid = (PSID)&domain_users_sid;
 
 static luid_t prev_luid_value = { 1000, 0 };
 
diff --git a/server/trace.c b/server/trace.c
index 20895b1..4449089 100644
--- a/server/trace.c
+++ b/server/trace.c
@@ -1108,8 +1108,12 @@ static void dump_new_process_request( const struct new_process_request *req )
     fprintf( stderr, ", thread_attr=%08x", req->thread_attr );
     dump_cpu_type( ", cpu=", &req->cpu );
     fprintf( stderr, ", info_size=%u", req->info_size );
+    fprintf( stderr, ", env_size=%u", req->env_size );
+    fprintf( stderr, ", process_sd_size=%u", req->process_sd_size );
     dump_varargs_startup_info( ", info=", min(cur_size,req->info_size) );
-    dump_varargs_unicode_str( ", env=", cur_size );
+    dump_varargs_unicode_str( ", env=", min(cur_size,req->env_size) );
+    dump_varargs_security_descriptor( ", process_sd=", min(cur_size,req->process_sd_size) );
+    dump_varargs_security_descriptor( ", thread_sd=", cur_size );
 }
 
 static void dump_new_process_reply( const struct new_process_reply *req )
@@ -1238,6 +1242,19 @@ static void dump_set_process_info_request( const struct set_process_info_request
     dump_uint64( ", affinity=", &req->affinity );
 }
 
+static void dump_get_thread_times_request( const struct get_thread_times_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
+static void dump_get_thread_times_reply( const struct get_thread_times_reply *req )
+{
+    dump_timeout( " creation_time=", &req->creation_time );
+    dump_timeout( ", exit_time=", &req->exit_time );
+    fprintf( stderr, ", unix_pid=%d", req->unix_pid );
+    fprintf( stderr, ", unix_tid=%d", req->unix_tid );
+}
+
 static void dump_get_thread_info_request( const struct get_thread_info_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -1635,6 +1652,11 @@ static void dump_get_handle_fd_reply( const struct get_handle_fd_reply *req )
     fprintf( stderr, ", options=%08x", req->options );
 }
 
+static void dump_get_shared_memory_request( const struct get_shared_memory_request *req )
+{
+    fprintf( stderr, " tid=%04x", req->tid );
+}
+
 static void dump_flush_file_request( const struct flush_file_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -1667,6 +1689,12 @@ static void dump_unlock_file_request( const struct unlock_file_request *req )
     dump_uint64( ", count=", &req->count );
 }
 
+static void dump_set_file_info_request( const struct set_file_info_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, ", unlink=%d", req->unlink );
+}
+
 static void dump_create_socket_request( const struct create_socket_request *req )
 {
     fprintf( stderr, " access=%08x", req->access );
@@ -1700,6 +1728,11 @@ static void dump_accept_into_socket_request( const struct accept_into_socket_req
     fprintf( stderr, ", ahandle=%04x", req->ahandle );
 }
 
+static void dump_reuse_socket_request( const struct reuse_socket_request *req )
+{
+    fprintf( stderr, " handle=%04x", req->handle );
+}
+
 static void dump_set_socket_event_request( const struct set_socket_event_request *req )
 {
     fprintf( stderr, " handle=%04x", req->handle );
@@ -1734,6 +1767,7 @@ static void dump_get_socket_info_reply( const struct get_socket_info_reply *req
     fprintf( stderr, " family=%d", req->family );
     fprintf( stderr, ", type=%d", req->type );
     fprintf( stderr, ", protocol=%d", req->protocol );
+    dump_timeout( ", connect_time=", &req->connect_time );
 }
 
 static void dump_enable_socket_event_request( const struct enable_socket_event_request *req )
@@ -2067,6 +2101,13 @@ static void dump_get_mapping_info_reply( const struct get_mapping_info_reply *re
     fprintf( stderr, ", protect=%d", req->protect );
     fprintf( stderr, ", header_size=%d", req->header_size );
     dump_uint64( ", base=", &req->base );
+    dump_uint64( ", entry=", &req->entry );
+    fprintf( stderr, ", subsystem=%d", req->subsystem );
+    fprintf( stderr, ", major_subsystem=%d", req->major_subsystem );
+    fprintf( stderr, ", minor_subsystem=%d", req->minor_subsystem );
+    fprintf( stderr, ", characteristics=%d", req->characteristics );
+    fprintf( stderr, ", dll_characteristics=%d", req->dll_characteristics );
+    fprintf( stderr, ", machine=%d", req->machine );
     fprintf( stderr, ", mapping=%04x", req->mapping );
     fprintf( stderr, ", shared_file=%04x", req->shared_file );
 }
@@ -2773,7 +2814,8 @@ static void dump_create_named_pipe_request( const struct create_named_pipe_reque
 
 static void dump_create_named_pipe_reply( const struct create_named_pipe_reply *req )
 {
-    fprintf( stderr, " handle=%04x", req->handle );
+    fprintf( stderr, " flags=%08x", req->flags );
+    fprintf( stderr, ", handle=%04x", req->handle );
 }
 
 static void dump_get_named_pipe_info_request( const struct get_named_pipe_info_request *req )
@@ -4156,6 +4198,7 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_terminate_thread_request,
     (dump_func)dump_get_process_info_request,
     (dump_func)dump_set_process_info_request,
+    (dump_func)dump_get_thread_times_request,
     (dump_func)dump_get_thread_info_request,
     (dump_func)dump_set_thread_info_request,
     (dump_func)dump_get_dll_info_request,
@@ -4189,12 +4232,15 @@ static const dump_func req_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_alloc_file_handle_request,
     (dump_func)dump_get_handle_unix_name_request,
     (dump_func)dump_get_handle_fd_request,
+    (dump_func)dump_get_shared_memory_request,
     (dump_func)dump_flush_file_request,
     (dump_func)dump_lock_file_request,
     (dump_func)dump_unlock_file_request,
+    (dump_func)dump_set_file_info_request,
     (dump_func)dump_create_socket_request,
     (dump_func)dump_accept_socket_request,
     (dump_func)dump_accept_into_socket_request,
+    (dump_func)dump_reuse_socket_request,
     (dump_func)dump_set_socket_event_request,
     (dump_func)dump_get_socket_event_request,
     (dump_func)dump_get_socket_info_request,
@@ -4421,6 +4467,7 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_terminate_thread_reply,
     (dump_func)dump_get_process_info_reply,
     NULL,
+    (dump_func)dump_get_thread_times_reply,
     (dump_func)dump_get_thread_info_reply,
     NULL,
     (dump_func)dump_get_dll_info_reply,
@@ -4454,13 +4501,16 @@ static const dump_func reply_dumpers[REQ_NB_REQUESTS] = {
     (dump_func)dump_alloc_file_handle_reply,
     (dump_func)dump_get_handle_unix_name_reply,
     (dump_func)dump_get_handle_fd_reply,
+    NULL,
     (dump_func)dump_flush_file_reply,
     (dump_func)dump_lock_file_reply,
     NULL,
+    NULL,
     (dump_func)dump_create_socket_reply,
     (dump_func)dump_accept_socket_reply,
     NULL,
     NULL,
+    NULL,
     (dump_func)dump_get_socket_event_reply,
     (dump_func)dump_get_socket_info_reply,
     NULL,
@@ -4686,6 +4736,7 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "terminate_thread",
     "get_process_info",
     "set_process_info",
+    "get_thread_times",
     "get_thread_info",
     "set_thread_info",
     "get_dll_info",
@@ -4719,12 +4770,15 @@ static const char * const req_names[REQ_NB_REQUESTS] = {
     "alloc_file_handle",
     "get_handle_unix_name",
     "get_handle_fd",
+    "get_shared_memory",
     "flush_file",
     "lock_file",
     "unlock_file",
+    "set_file_info",
     "create_socket",
     "accept_socket",
     "accept_into_socket",
+    "reuse_socket",
     "set_socket_event",
     "get_socket_event",
     "get_socket_info",
diff --git a/tools/Makefile.in b/tools/Makefile.in
index 0f652f0..3ef2484 100644
--- a/tools/Makefile.in
+++ b/tools/Makefile.in
@@ -18,13 +18,15 @@ UPDATE_DESKTOP_DATABASE = update-desktop-database
 all: wineapploader
 
 make_xftmpl$(EXEEXT): make_xftmpl.o
-	$(CC) $(CFLAGS) -o $@ make_xftmpl.o $(LIBPORT) $(LDFLAGS)
+	@$(CC) $(CFLAGS) -o $@ make_xftmpl.o $(LIBPORT) $(LDFLAGS)
+	@echo "[CC] $@"
 
 .PHONY: install install-lib install-dev uninstall
 
 install install-lib::
-	$(INSTALL_DATA) $(srcdir)/wine.desktop $(DESTDIR)$(datadir)/applications/wine.desktop
+	@$(INSTALL_DATA) $(srcdir)/wine.desktop $(DESTDIR)$(datadir)/applications/wine.desktop
 	-$(UPDATE_DESKTOP_DATABASE)
+	@echo "[install-lib] $@"
 
 install install-dev:: install-man-pages
 	$(INSTALL_SCRIPT) $(srcdir)/winemaker $(DESTDIR)$(bindir)/winemaker
diff --git a/tools/make_makefiles b/tools/make_makefiles
index f0b40c0..46b8389 100755
--- a/tools/make_makefiles
+++ b/tools/make_makefiles
@@ -257,7 +257,7 @@ sub parse_makefile($)
         while (/\\$/) { chop; $_ .= <MAKE>; chomp; }  # merge continued lines
         next if (/^\s*$/);
 
-        if (/^\s*(MODULE|IMPORTLIB|TESTDLL|PARENTSRC|APPMODE)\s*=\s*(.*)/)
+        if (/^\s*(MODULE|IMPORTLIB|TESTDLL|RESOURCE|PARENTSRC|APPMODE)\s*=\s*(.*)/)
         {
             my $var = $1;
             $make{$var} = $2;
@@ -476,6 +476,13 @@ sub update_makefiles(@)
             (my $dir = $file) =~ s/^(.*)\/Makefile/$1/;
             push @lines, "WINE_CONFIG_TEST($dir$flag_args)\n";
         }
+        elsif (defined($make{"RESOURCE"}))  # test resource
+        {
+            die "MODULE should not be defined in $file" if defined $make{"MODULE"};
+            die "STATICLIB should not be defined in $file" if defined $make{"STATICLIB"};
+            (my $dir = $file) =~ s/^(.*)\/Makefile/$1/;
+            push @lines, "WINE_CONFIG_RESOURCE($dir$flag_args)\n";
+        }
         elsif (defined($make{"MODULE"}) && $make{"MODULE"} =~ /\.a$/)  # import lib
         {
             die "MODULE should not be defined as static lib in $file" unless $file =~ /^dlls\//;
diff --git a/tools/makedep.c b/tools/makedep.c
index 54aab45..71372c9 100644
--- a/tools/makedep.c
+++ b/tools/makedep.c
@@ -161,8 +161,10 @@ struct makefile
     const char     *top_src_dir;
     const char     *top_obj_dir;
     const char     *parent_dir;
+    const char     *parent_spec;
     const char     *module;
     const char     *testdll;
+    const char     *resource;
     const char     *staticlib;
     const char     *importlib;
     int             use_msvcrt;
@@ -466,6 +468,30 @@ static char *get_extension( char *filename )
 
 
 /*******************************************************************
+ *         prepend_extension
+ */
+static char *prepend_extension( const char *name, const char *prepend, const char *new_ext )
+{
+    int name_len, prepend_len = strlen(prepend);
+    const char *ext;
+    char *ret;
+
+    ext = strrchr( name, '.' );
+    if (ext && strchr(ext, '/')) ext = NULL;
+    name_len = ext ? (ext - name) : strlen( name );
+
+    if (!ext) ext = new_ext;
+    if (!ext) ext = "";
+
+    ret = xmalloc( name_len + prepend_len + strlen(ext) + 1 );
+    memcpy( ret, name, name_len );
+    memcpy( ret + name_len, prepend, prepend_len );
+    strcpy( ret + name_len + prepend_len, ext );
+    return ret;
+}
+
+
+/*******************************************************************
  *         replace_extension
  */
 static char *replace_extension( const char *name, const char *old_ext, const char *new_ext )
@@ -1480,7 +1506,7 @@ static char *get_make_variable( struct makefile *make, const char *name )
  */
 static char *get_expanded_make_variable( struct makefile *make, const char *name )
 {
-    char *p, *end, *var, *expand, *tmp;
+    char *p, *end, *var, *expand, *tmp = NULL;
 
     expand = get_make_variable( make, name );
     if (!expand) return NULL;
@@ -1747,6 +1773,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
     struct strarray subdirs = empty_strarray;
     struct strarray phony_targets = empty_strarray;
     struct strarray all_targets = get_expanded_make_var_array( make, "PROGRAMS" );
+    struct strarray resource_dlls = get_expanded_make_var_array( make, "RC_DLLS" );
 
     for (i = 0; i < linguas.count; i++)
         strarray_add( &mo_files, strmake( "%s/%s.mo", top_obj_dir_path( make, "po" ), linguas.str[i] ));
@@ -1816,7 +1843,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             strarray_add( &res_files, strmake( "%s.res", obj ));
             output( "%s.res: %s %s\n", obj_dir_path( make, obj ),
                     tools_path( make, "wrc" ), source->filename );
-            output( "\t%s -o $@", tools_path( make, "wrc" ) );
+            output( "\t@%s -o $@", tools_path( make, "wrc" ) );
             if (make->is_win16) output_filename( "-m16" );
             else output_filenames( target_flags );
             output_filename( "--nostdinc" );
@@ -1829,6 +1856,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
                 output_filename( strmake( "--po-dir=%s", top_obj_dir_path( make, "po" )));
                 output_filename( source->filename );
                 output( "\n" );
+                output( "\t@echo [WRC] $@\n" );
                 output( "%s.res:", obj_dir_path( make, obj ));
                 output_filenames( mo_files );
                 output( "\n" );
@@ -1838,6 +1866,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             {
                 output_filename( source->filename );
                 output( "\n" );
+                output( "\t@echo [WRC] $@\n" );
             }
             output( "%s.res:", obj_dir_path( make, obj ));
         }
@@ -1878,7 +1907,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             if (source->file->flags & FLAG_IDL_PROXY) strarray_add( &dlldata_files, source->name );
             output_filenames_obj_dir( make, targets );
             output( ": %s\n", tools_path( make, "widl" ));
-            output( "\t%s -o $@", tools_path( make, "widl" ) );
+            output( "\t@%s -o $@", tools_path( make, "widl" ) );
             output_filenames( target_flags );
             output_filenames( includes );
             output_filenames( make->define_args );
@@ -1886,6 +1915,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames( get_expanded_make_var_array( make, "EXTRAIDLFLAGS" ));
             output_filename( source->filename );
             output( "\n" );
+            output( "\t@echo [WIDL] $@\n" );
             output_filenames_obj_dir( make, targets );
             output( ": %s", source->filename );
         }
@@ -1980,7 +2010,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         }
         else
         {
-            int need_cross = make->testdll ||
+            int need_cross = make->testdll || make->resource ||
                 (source->file->flags & FLAG_C_IMPLIB) ||
                 (make->module && make->staticlib);
 
@@ -1990,11 +2020,11 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             if (source->file->flags & FLAG_C_IMPLIB) strarray_add( &implib_objs, strmake( "%s.o", obj ));
             strarray_add( &object_files, strmake( "%s.o", obj ));
             output( "%s.o: %s\n", obj_dir_path( make, obj ), source->filename );
-            output( "\t$(CC) -c -o $@ %s", source->filename );
+            output( "\t@$(CC) -c -o $@ %s", source->filename );
             output_filenames( includes );
             output_filenames( make->define_args );
             output_filenames( extradefs );
-            if (make->module || make->staticlib || make->testdll)
+            if (make->module || make->staticlib || make->testdll || make->resource)
             {
                 output_filenames( dll_flags );
                 if (make->use_msvcrt) output_filenames( msvcrt_flags );
@@ -2003,11 +2033,12 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames( cpp_flags );
             output_filename( "$(CFLAGS)" );
             output( "\n" );
+            output( "\t@echo [CC] %s\n", source->filename);
             if (crosstarget && need_cross)
             {
                 strarray_add( &crossobj_files, strmake( "%s.cross.o", obj ));
                 output( "%s.cross.o: %s\n", obj_dir_path( make, obj ), source->filename );
-                output( "\t$(CROSSCC) -c -o $@ %s", source->filename );
+                output( "\t@$(CROSSCC) -c -o $@ %s", source->filename );
                 output_filenames( includes );
                 output_filenames( make->define_args );
                 output_filenames( extradefs );
@@ -2015,6 +2046,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
                 output_filenames( cpp_flags );
                 output_filename( "$(CFLAGS)" );
                 output( "\n" );
+              output( "\t@echo [CROSSCC] %s\n", source->filename);
             }
             if (make->testdll && !strcmp( ext, "c" ) && !(source->file->flags & FLAG_GENERATED))
             {
@@ -2043,7 +2075,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output( "%s: %s", obj_dir_path( make, "rsrc.pot" ), tools_path( make, "wrc" ) );
         output_filenames( po_files );
         output( "\n" );
-        output( "\t%s -O pot -o $@", tools_path( make, "wrc" ));
+        output( "\t@%s -O pot -o $@", tools_path( make, "wrc" ));
         if (make->is_win16) output_filename( "-m16" );
         else output_filenames( target_flags );
         output_filename( "--nostdinc" );
@@ -2051,6 +2083,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( make->define_args );
         output_filenames( po_files );
         output( "\n" );
+      output( "\t@echo [WRC] $@\n" );
         strarray_add( &clean_files, "rsrc.pot" );
     }
 
@@ -2059,9 +2092,10 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output( "%s: %s", obj_dir_path( make, "msg.pot" ), tools_path( make, "wmc" ));
         output_filenames( mc_files );
         output( "\n" );
-        output( "\t%s -O pot -o $@", tools_path( make, "wmc" ));
+        output( "\t@%s -O pot -o $@", tools_path( make, "wmc" ));
         output_filenames( mc_files );
         output( "\n" );
+        output( "\t@echo [WMC] $@\n" );
         strarray_add( &clean_files, "msg.pot" );
     }
 
@@ -2069,9 +2103,76 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
     {
         output( "%s: %s %s\n", obj_dir_path( make, "dlldata.c" ),
                 tools_path( make, "widl" ), src_dir_path( make, "Makefile.in" ));
-        output( "\t%s --dlldata-only -o $@", tools_path( make, "widl" ));
+        output( "\t@%s --dlldata-only -o $@", tools_path( make, "widl" ));
         output_filenames( dlldata_files );
         output( "\n" );
+        output( "\t@echo [WIDL] $@\n" );        
+    }
+
+    /* rules for resource dlls, call Makefile in subdirectory */
+
+    if (resource_dlls.count)
+    {
+        for (i = 0; i < resource_dlls.count; i++)
+        {
+            output( "%s/Makefile: dummy\n", resource_dlls.str[i] );
+            output( "\t@cd %s && $(MAKE) %s/Makefile\n", make->top_obj_dir,
+                    base_dir_path( make, resource_dlls.str[i] ) );
+        }
+
+        for (i = 0; i < resource_dlls.count; i++)
+        {
+            output( "%s/%s%s: %s/Makefile dummy\n", resource_dlls.str[i],
+                    resource_dlls.str[i], dll_ext, resource_dlls.str[i] );
+            output( "\t@cd %s && $(MAKE) %s%s\n", resource_dlls.str[i],
+                    resource_dlls.str[i], dll_ext );
+        }
+
+        output( "%s:", obj_dir_path( make, "resource_dlls.o" ));
+        for (i = 0; i < resource_dlls.count; i++)
+            output( " %s/%s%s", resource_dlls.str[i], resource_dlls.str[i], dll_ext );
+        output( "\n" );
+        output( "\t(" );
+        for (i = 0; i < resource_dlls.count; i++)
+        {
+            if (i != 0) output( "; \\\n  " );
+            output( "echo \"%s RCDATA %s/%s%s\"", resource_dlls.str[i],
+                    resource_dlls.str[i], resource_dlls.str[i], dll_ext );
+        }
+        output( ") | %s -o $@\n", tools_path( make, "wrc" ) );
+        strarray_add( &clean_files, "resource_dlls.o" );
+        strarray_add( &object_files, "resource_dlls.o" );
+
+        if (crosstarget && (make->testdll || (make->module && make->staticlib)))
+        {
+            for (i = 0; i < resource_dlls.count; i++)
+            {
+                char *name = prepend_extension( resource_dlls.str[i], "_crossres", ".dll" );
+                output( "%s/%s: %s/Makefile dummy\n", resource_dlls.str[i], name, resource_dlls.str[i] );
+                output( "\t@cd %s && $(MAKE) %s\n", resource_dlls.str[i], name );
+                free( name );
+            }
+
+            output( "%s:", obj_dir_path( make, "resource_dlls.cross.o" ));
+            for (i = 0; i < resource_dlls.count; i++)
+            {
+                char *name = prepend_extension( resource_dlls.str[i], "_crossres", ".dll" );
+                output( " %s/%s", resource_dlls.str[i], name );
+                free( name );
+            }
+            output( "\n" );
+            output( "\t(" );
+            for (i = 0; i < resource_dlls.count; i++)
+            {
+                char *name = prepend_extension( resource_dlls.str[i], "_crossres", ".dll" );
+                if (i != 0) output( "; \\\n  " );
+                output( "echo \"%s RCDATA %s/%s\"", resource_dlls.str[i], resource_dlls.str[i], name );
+                free( name );
+            }
+            output( ") | %s -o $@\n", tools_path( make, "wrc" ) );
+            strarray_add( &clean_files, "resource_dlls.cross.o" );
+            strarray_add( &crossobj_files, "resource_dlls.cross.o" );
+        }
     }
 
     if (make->module && !make->staticlib)
@@ -2081,7 +2182,13 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         char *spec_file = NULL;
 
         if (!make->appmode.count)
-            spec_file = src_dir_path( make, replace_extension( make->module, ".dll", ".spec" ));
+        {
+            if (!make->parent_spec)
+                spec_file = src_dir_path( make, replace_extension( make->module, ".dll", ".spec" ));
+            else
+                spec_file = src_dir_path( make, make->parent_spec );
+        }
+
         for (i = 0; i < make->delayimports.count; i++)
             strarray_add( &all_libs, strmake( "-l%s", make->delayimports.str[i] ));
         for (i = 0; i < make->imports.count; i++)
@@ -2108,7 +2215,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames_obj_dir( make, object_files );
         output_filenames_obj_dir( make, res_files );
         output( "\n" );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2124,6 +2231,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
 
         if (spec_file && make->importlib)
         {
@@ -2256,7 +2364,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         strarray_add( &all_targets, strmake( "%s%s", testmodule, dll_ext ));
         strarray_add( &clean_files, strmake( "%s%s", stripped, dll_ext ));
         output( "%s%s:\n", obj_dir_path( make, testmodule ), dll_ext );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2267,8 +2375,9 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
         output( "%s%s:\n", obj_dir_path( make, stripped ), dll_ext );
-        output( "\t%s -o $@", tools_path( make, "winegcc" ));
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
         output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
         if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
         output_filenames( target_flags );
@@ -2280,6 +2389,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         output_filenames( all_libs );
         output_filename( "$(LDFLAGS)" );
         output( "\n" );
+        output( "\t@echo [WINEGCC] $@\n" );
         output( "%s%s %s%s:", obj_dir_path( make, testmodule ), dll_ext,
                 obj_dir_path( make, stripped ), dll_ext );
         output_filenames_obj_dir( make, object_files );
@@ -2302,7 +2412,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames_obj_dir( make, crossobj_files );
             output_filenames_obj_dir( make, res_files );
             output( "\n" );
-            output( "\t%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
+            output( "\t@%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
             output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
             if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
             output_filename( "--lib-suffix=.cross.a" );
@@ -2311,6 +2421,7 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
             output_filenames( all_libs );
             output_filename( "$(LDFLAGS)" );
             output( "\n" );
+            output( "\t@echo [WINEGCC] $@\n" );
             strarray_add( &phony_targets, obj_dir_path( make, "crosstest" ));
             if (make->obj_dir) output( "crosstest: %s\n", obj_dir_path( make, "crosstest" ));
         }
@@ -2331,6 +2442,84 @@ static struct strarray output_sources( struct makefile *make, struct strarray *t
         *testlist_files = strarray_replace_extension( &ok_files, ".ok", "" );
     }
 
+    if (make->resource)
+    {
+        char *extra_wine_flags = get_expanded_make_variable( make, "WINEFLAGS" );
+        char *extra_cross_flags = get_expanded_make_variable( make, "CROSSFLAGS" );
+        struct strarray all_libs = empty_strarray;
+        char *module_path = obj_dir_path( make, make->resource );
+        char *spec_file = NULL;
+
+        if (!make->appmode.count)
+            spec_file = src_dir_path( make, replace_extension( make->resource, ".dll", ".spec" ));
+        for (i = 0; i < make->imports.count; i++)
+            strarray_add( &all_libs, strmake( "-l%s", make->imports.str[i] ));
+        strarray_addall( &all_libs, get_expanded_make_var_array( make, "LIBS" ));
+
+        if (*dll_ext)
+        {
+            strarray_add( &all_targets, strmake( "%s%s", make->resource, dll_ext ));
+            strarray_add( &all_targets, strmake( "%s.fake", make->resource ));
+            output( "%s%s %s.fake:", module_path, dll_ext, module_path );
+        }
+        else
+        {
+            strarray_add( &all_targets, make->resource );
+            output( "%s:", module_path );
+        }
+        if (spec_file) output_filename( spec_file );
+        output_filenames_obj_dir( make, object_files );
+        output_filenames_obj_dir( make, res_files );
+        output( "\n" );
+        output( "\t@%s -o $@", tools_path( make, "winegcc" ));
+        output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
+        if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
+        output_filenames( target_flags );
+        output_filenames( unwind_flags );
+        if (spec_file)
+        {
+            output( " -shared %s", spec_file );
+            output_filenames( make->extradllflags );
+        }
+        else output_filenames( make->appmode );
+        if (extra_wine_flags) output( " %s", extra_wine_flags );
+        output_filenames_obj_dir( make, object_files );
+        output_filenames_obj_dir( make, res_files );
+        output_filenames( all_libs );
+        output_filename( "$(LDFLAGS)" );
+        output( "\n" );
+        output("\t@echo [WINEGCC] %s\n", spec_file);
+
+        if (crosstarget)
+        {
+            char *crossres = prepend_extension( make->resource, "_crossres", ".dll" );
+
+            strarray_add( &clean_files, crossres );
+            output( "%s:", obj_dir_path( make, crossres ));
+            output_filenames_obj_dir( make, crossobj_files );
+            output_filenames_obj_dir( make, res_files );
+            output( "\n" );
+            output( "\t%s -o $@ -b %s", tools_path( make, "winegcc" ), crosstarget );
+            output_filename( strmake( "-B%s", tools_dir_path( make, "winebuild" )));
+            if (tools_dir) output_filename( strmake( "--sysroot=%s", top_obj_dir_path( make, "" )));
+            output_filename( "--lib-suffix=.cross.a" );
+            if (spec_file)
+            {
+                output( " -shared %s", spec_file );
+                output_filenames( make->extradllflags );
+            }
+            else output_filenames( make->appmode );
+            if (extra_cross_flags) output( " %s", extra_cross_flags );
+            output_filenames_obj_dir( make, crossobj_files );
+            output_filenames_obj_dir( make, res_files );
+            output_filenames( all_libs );
+            output_filename( "$(LDFLAGS)" );
+            output( "\n" );
+            strarray_add( &phony_targets, obj_dir_path( make, "crosstest" ));
+            if (make->obj_dir) output( "crosstest: %s\n", obj_dir_path( make, "crosstest" ));
+        }
+    }
+
     if (all_targets.count)
     {
         output( "all:" );
@@ -2597,8 +2786,10 @@ static void update_makefile( const char *path )
     strarray_set_value( &make->vars, "srcdir", src_dir_path( make, "" ));
 
     make->parent_dir    = get_expanded_make_variable( make, "PARENTSRC" );
+    make->parent_spec   = get_expanded_make_variable( make, "PARENTSPEC" );
     make->module        = get_expanded_make_variable( make, "MODULE" );
     make->testdll       = get_expanded_make_variable( make, "TESTDLL" );
+    make->resource      = get_expanded_make_variable( make, "RESOURCE" );
     make->staticlib     = get_expanded_make_variable( make, "STATICLIB" );
     make->importlib     = get_expanded_make_variable( make, "IMPORTLIB" );
 
diff --git a/tools/winebuild/spec32.c b/tools/winebuild/spec32.c
index 98060b5..0f4fdbc 100644
--- a/tools/winebuild/spec32.c
+++ b/tools/winebuild/spec32.c
@@ -529,8 +529,8 @@ void output_module( DLLSPEC *spec )
              spec->characteristics );
     output( "\t.short 0x%04x\n",          /* Magic */
              get_ptr_size() == 8 ? IMAGE_NT_OPTIONAL_HDR64_MAGIC : IMAGE_NT_OPTIONAL_HDR32_MAGIC );
-    output( "\t.byte 0\n" );              /* MajorLinkerVersion */
-    output( "\t.byte 0\n" );              /* MinorLinkerVersion */
+    output( "\t.byte 7\n" );              /* MajorLinkerVersion */
+    output( "\t.byte 10\n" );             /* MinorLinkerVersion */
     output( "\t.long 0\n" );              /* SizeOfCode */
     output( "\t.long 0\n" );              /* SizeOfInitializedData */
     output( "\t.long 0\n" );              /* SizeOfUninitializedData */
@@ -710,8 +710,8 @@ void output_fake_module( DLLSPEC *spec )
     put_word( get_ptr_size() == 8 ?
               IMAGE_NT_OPTIONAL_HDR64_MAGIC :
               IMAGE_NT_OPTIONAL_HDR32_MAGIC );       /* Magic */
-    put_byte(  0 );                                  /* MajorLinkerVersion */
-    put_byte(  0 );                                  /* MinorLinkerVersion */
+    put_byte(  7 );                                  /* MajorLinkerVersion */
+    put_byte(  10 );                                 /* MinorLinkerVersion */
     put_dword( text_size );                          /* SizeOfCode */
     put_dword( 0 );                                  /* SizeOfInitializedData */
     put_dword( 0 );                                  /* SizeOfUninitializedData */
