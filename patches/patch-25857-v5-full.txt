From 1b16663f2324e343e13a4cc568a3762dbfe366d1 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Tue, 8 Mar 2016 20:36:46 +0300
Subject: [v5 01/12] d3dx9: Add test for preshader in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/tests/effect.c | 879 +++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 879 insertions(+)

diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index 13467ed..d0dbbe0 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -22,6 +22,8 @@
 #include "wine/test.h"
 #include "d3dx9.h"
 
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof(*arr))
+
 /* helper functions */
 static BOOL compare_float(FLOAT f, FLOAT g, UINT ulps)
 {
@@ -3008,6 +3010,882 @@ static void test_effect_states(IDirect3DDevice9 *device)
     ok(value == 3, "Got result %u, expected %u.\n", value, 1);
 }
 
+/*
+ * fxc.exe /Tfx_2_0
+ */
+#if 0
+float4 g_Pos1;
+float4 g_Pos2;
+float4 g_Selector[2] = {{0, 0, 0, 0}, {10, 10, 10, 10}};
+
+float4 opvect1 = {0.0, -0.0, -2.2, 3.402823466e+38F};
+float4 opvect2 = {1.0, 2.0, -3.0, 4.0};
+float4 opvect3 = {0.0, -0.0, -2.2, 3.402823466e+38F};
+
+int4 g_iVect = {4, 3, 2, 1};
+
+vertexshader vs_arr[3] =
+{
+    asm
+    {
+        vs_1_0
+        def c0, 1, 1, 1, 1
+        mov oPos, c0
+    },
+    asm
+    {
+        vs_1_1
+        def c0, 2, 2, 2, 2
+        mov oPos, c0
+    },
+    asm
+    {
+        vs_2_0
+        def c0, 3, 3, 3, 3
+        mov oPos, c0
+    }
+};
+
+row_major float4x3 m4x3row = {{11, 12, 13}, {21, 22, 23}, {31, 32, 33}, {41, 42, 43}};
+row_major float3x4 m3x4row = {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}};
+column_major float4x3 m4x3column = {{11, 12, 13},{21, 22, 23},{31, 32, 33},{41, 42, 43}};
+column_major float3x4 m3x4column = {{11, 12, 13, 14}, {21, 22, 23, 24}, {31, 32, 33, 34}};
+row_major float2x2 m2x2row = {{11, 12}, {21, 22}};
+column_major float2x2 m2x2column = {{11, 12}, {21, 22}};
+row_major float2x3 m2x3row = {{11, 12, 13}, {21, 22, 23}};
+column_major float2x3 m2x3column = {{11, 12, 13}, {21, 22, 23}};
+row_major float3x2 m3x2row = {{11, 12}, {21, 22}, {31, 32}};
+column_major float3x2 m3x2column = {{11, 12}, {21, 22}, {31, 32}};
+
+row_major bool2x3 mb2x3row = {{true, false, true}, {false, true, true}};
+column_major bool2x3 mb2x3column = {{true, false, true}, {false, true, true}};
+
+struct test_struct
+{
+    float3 v1;
+    float fv;
+    float4 v2;
+};
+
+test_struct ts1[1] = {{{9, 10, 11}, 12, {13, 14, 15, 16}}};
+test_struct ts2[2] = {{{0, 0, 0}, 0, {0, 0, 0, 0}}, {{1, 2, 3}, 4, {5, 6, 7, 8}}};
+
+float arr1[1] = {91};
+float arr2[2] = {92, 93};
+
+struct VS_OUTPUT
+{
+    float4 Position   : POSITION;
+    float2 TextureUV  : TEXCOORD0;
+    float4 Diffuse    : COLOR0;
+};
+VS_OUTPUT RenderSceneVS(float4 vPos : POSITION,
+                        float3 vNormal : NORMAL,
+                        float2 vTexCoord0 : TEXCOORD0,
+                        uniform int nNumLights,
+                        uniform bool bTexture)
+{
+    VS_OUTPUT Output;
+
+    if (g_Selector[1].y > float4(0.5, 0.5, 0.5, 0.5).y)
+        Output.Position = -g_Pos1 * 2 - float4(-4, -5, -6, -7);
+    else
+        Output.Position = -g_Pos2 * 3 - float4(-4, -5, -6, -7);
+    Output.TextureUV = float2(0, 0);
+    Output.Diffuse = 0;
+    Output.Diffuse.xyz = mul(vPos, m4x3column);
+    Output.Diffuse += mul(vPos, m3x4column);
+    Output.Diffuse += mul(vPos, m3x4row);
+    Output.Diffuse.xyz += mul(vPos, m4x3row);
+    Output.Diffuse += mul(vPos, ts1[0].fv);
+    Output.Diffuse += mul(vPos, ts1[0].v2);
+    Output.Diffuse += mul(vPos, ts2[1].fv);
+    Output.Diffuse += mul(vPos, ts2[1].v2);
+    Output.Diffuse += mul(vPos, arr1[0]);
+    Output.Diffuse += mul(vPos, arr2[1]);
+    return Output;
+}
+
+struct PS_OUTPUT
+{
+    float4 RGBColor : COLOR0;  // Pixel color
+};
+PS_OUTPUT RenderScenePS( VS_OUTPUT In, uniform bool2x3 mb)
+{
+    PS_OUTPUT Output;
+
+    Output.RGBColor = In.Diffuse;
+    Output.RGBColor.xy += mul(In.Diffuse, m2x2row);
+    Output.RGBColor.xy += mul(In.Diffuse, m2x2column);
+    Output.RGBColor.xy += mul(In.Diffuse, m3x2row);
+    Output.RGBColor.xy += mul(In.Diffuse, m3x2column);
+    Output.RGBColor.xyz += mul(In.Diffuse, m2x3row);
+    Output.RGBColor.xyz += mul(In.Diffuse, m2x3column);
+    if (mb[1][1])
+    {
+        Output.RGBColor += sin(Output.RGBColor);
+        Output.RGBColor += cos(Output.RGBColor);
+        Output.RGBColor.xyz += mul(Output.RGBColor, m2x3column);
+        Output.RGBColor.xyz += mul(Output.RGBColor, m2x3row);
+        Output.RGBColor.xy += mul(Output.RGBColor, m3x2column);
+        Output.RGBColor.xy += mul(Output.RGBColor, m3x2row);
+    }
+    return Output;
+}
+
+technique tech0
+{
+    pass p0
+    {
+        VertexShader = compile vs_3_0 RenderSceneVS(1, true);
+        PixelShader  = compile ps_3_0 RenderScenePS(mb2x3row);
+
+        LightEnable[0] = TRUE;
+        LightEnable[1] = TRUE;
+        LightEnable[2] = TRUE;
+        LightEnable[3] = TRUE;
+        LightEnable[4] = TRUE;
+        LightEnable[5] = TRUE;
+        LightEnable[6] = TRUE;
+        LightEnable[7] = TRUE;
+        LightType[0] = POINT;
+        LightType[1] = POINT;
+        LightType[2] = POINT;
+        LightType[3] = POINT;
+        LightType[4] = POINT;
+        LightType[5] = POINT;
+        LightType[6] = POINT;
+        LightType[7] = POINT;
+        LightDiffuse[0] = 1 / opvect1;
+        LightDiffuse[1] = rsqrt(opvect1);
+        LightDiffuse[2] = opvect1 * opvect2;
+        LightDiffuse[3] = opvect1 + opvect2;
+        LightDiffuse[4] = float4(opvect1 < opvect2);
+        LightDiffuse[5] = float4(opvect1 >= opvect2);
+        LightDiffuse[6] = -opvect1;
+        LightDiffuse[7] = rcp(opvect1);
+
+        LightAmbient[0] = frac(opvect1);
+        LightAmbient[1] = min(opvect1, opvect2);
+        LightAmbient[2] = max(opvect1, opvect2);
+        LightAmbient[3] = sin(opvect1);
+        LightAmbient[4] = cos(opvect1);
+        LightAmbient[5] = 1e-2 / opvect1;
+        LightAmbient[6] = float4(0, dot(opvect1, opvect2), dot(opvect2, opvect2), 0);
+        LightAmbient[7] = opvect1 + 1e-12 * opvect2 - opvect3;
+    }
+    pass p1
+    {
+        VertexShader = vs_arr[g_iVect.z];
+    }
+}
+#endif
+static const DWORD test_effect_preshader_effect_blob[] =
+{
+    0xfeff0901, 0x00000c30, 0x00000000, 0x00000003, 0x00000001, 0x00000030, 0x00000000, 0x00000000,
+    0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000007, 0x6f505f67,
+    0x00003173, 0x00000003, 0x00000001, 0x00000068, 0x00000000, 0x00000000, 0x00000004, 0x00000001,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000007, 0x6f505f67, 0x00003273, 0x00000003,
+    0x00000001, 0x000000b0, 0x00000000, 0x00000002, 0x00000004, 0x00000001, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x41200000, 0x41200000, 0x41200000, 0x41200000, 0x0000000b, 0x65535f67,
+    0x7463656c, 0x0000726f, 0x00000003, 0x00000001, 0x000000ec, 0x00000000, 0x00000000, 0x00000004,
+    0x00000001, 0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x00000008, 0x6576706f, 0x00317463,
+    0x00000003, 0x00000001, 0x00000124, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x3f800000,
+    0x40000000, 0xc0400000, 0x40800000, 0x00000008, 0x6576706f, 0x00327463, 0x00000003, 0x00000001,
+    0x0000015c, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x80000000, 0xc00ccccd,
+    0x7f7fffff, 0x00000008, 0x6576706f, 0x00337463, 0x00000002, 0x00000001, 0x00000194, 0x00000000,
+    0x00000000, 0x00000004, 0x00000001, 0x00000004, 0x00000003, 0x00000002, 0x00000001, 0x00000008,
+    0x56695f67, 0x00746365, 0x00000010, 0x00000004, 0x000001c0, 0x00000000, 0x00000003, 0x00000001,
+    0x00000002, 0x00000003, 0x00000007, 0x615f7376, 0x00007272, 0x00000003, 0x00000002, 0x00000218,
+    0x00000000, 0x00000000, 0x00000004, 0x00000003, 0x41300000, 0x41400000, 0x41500000, 0x41a80000,
+    0x41b00000, 0x41b80000, 0x41f80000, 0x42000000, 0x42040000, 0x42240000, 0x42280000, 0x422c0000,
+    0x00000008, 0x3378346d, 0x00776f72, 0x00000003, 0x00000002, 0x00000270, 0x00000000, 0x00000000,
+    0x00000003, 0x00000004, 0x41300000, 0x41400000, 0x41500000, 0x41600000, 0x41a80000, 0x41b00000,
+    0x41b80000, 0x41c00000, 0x41f80000, 0x42000000, 0x42040000, 0x42080000, 0x00000008, 0x3478336d,
+    0x00776f72, 0x00000003, 0x00000002, 0x000002c8, 0x00000000, 0x00000000, 0x00000004, 0x00000003,
+    0x41300000, 0x41400000, 0x41500000, 0x41a80000, 0x41b00000, 0x41b80000, 0x41f80000, 0x42000000,
+    0x42040000, 0x42240000, 0x42280000, 0x422c0000, 0x0000000b, 0x3378346d, 0x756c6f63, 0x00006e6d,
+    0x00000003, 0x00000002, 0x00000324, 0x00000000, 0x00000000, 0x00000003, 0x00000004, 0x41300000,
+    0x41400000, 0x41500000, 0x41600000, 0x41a80000, 0x41b00000, 0x41b80000, 0x41c00000, 0x41f80000,
+    0x42000000, 0x42040000, 0x42080000, 0x0000000b, 0x3478336d, 0x756c6f63, 0x00006e6d, 0x00000003,
+    0x00000002, 0x00000360, 0x00000000, 0x00000000, 0x00000002, 0x00000002, 0x41300000, 0x41400000,
+    0x41a80000, 0x41b00000, 0x00000008, 0x3278326d, 0x00776f72, 0x00000003, 0x00000002, 0x00000398,
+    0x00000000, 0x00000000, 0x00000002, 0x00000002, 0x41300000, 0x41400000, 0x41a80000, 0x41b00000,
+    0x0000000b, 0x3278326d, 0x756c6f63, 0x00006e6d, 0x00000003, 0x00000002, 0x000003dc, 0x00000000,
+    0x00000000, 0x00000002, 0x00000003, 0x41300000, 0x41400000, 0x41500000, 0x41a80000, 0x41b00000,
+    0x41b80000, 0x00000008, 0x3378326d, 0x00776f72, 0x00000003, 0x00000002, 0x0000041c, 0x00000000,
+    0x00000000, 0x00000002, 0x00000003, 0x41300000, 0x41400000, 0x41500000, 0x41a80000, 0x41b00000,
+    0x41b80000, 0x0000000b, 0x3378326d, 0x756c6f63, 0x00006e6d, 0x00000003, 0x00000002, 0x00000460,
+    0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x41300000, 0x41400000, 0x41a80000, 0x41b00000,
+    0x41f80000, 0x42000000, 0x00000008, 0x3278336d, 0x00776f72, 0x00000003, 0x00000002, 0x000004a0,
+    0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x41300000, 0x41400000, 0x41a80000, 0x41b00000,
+    0x41f80000, 0x42000000, 0x0000000b, 0x3278336d, 0x756c6f63, 0x00006e6d, 0x00000001, 0x00000002,
+    0x000004e4, 0x00000000, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000000, 0x00000001,
+    0x00000000, 0x00000001, 0x00000001, 0x00000009, 0x7832626d, 0x776f7233, 0x00000000, 0x00000001,
+    0x00000002, 0x00000528, 0x00000000, 0x00000000, 0x00000002, 0x00000003, 0x00000001, 0x00000000,
+    0x00000001, 0x00000000, 0x00000001, 0x00000001, 0x0000000c, 0x7832626d, 0x6c6f6333, 0x006e6d75,
+    0x00000000, 0x00000005, 0x000005c4, 0x00000000, 0x00000001, 0x00000003, 0x00000003, 0x00000001,
+    0x000005cc, 0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x00000003, 0x00000000, 0x000005d4,
+    0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00000003, 0x00000001, 0x000005dc, 0x00000000,
+    0x00000000, 0x00000004, 0x00000001, 0x41100000, 0x41200000, 0x41300000, 0x41400000, 0x41500000,
+    0x41600000, 0x41700000, 0x41800000, 0x00000004, 0x00317374, 0x00000003, 0x00003176, 0x00000003,
+    0x00007666, 0x00000003, 0x00003276, 0x00000000, 0x00000005, 0x00000690, 0x00000000, 0x00000002,
+    0x00000003, 0x00000003, 0x00000001, 0x00000698, 0x00000000, 0x00000000, 0x00000003, 0x00000001,
+    0x00000003, 0x00000000, 0x000006a0, 0x00000000, 0x00000000, 0x00000001, 0x00000001, 0x00000003,
+    0x00000001, 0x000006a8, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x3f800000, 0x40000000,
+    0x40400000, 0x40800000, 0x40a00000, 0x40c00000, 0x40e00000, 0x41000000, 0x00000004, 0x00327374,
+    0x00000003, 0x00003176, 0x00000003, 0x00007666, 0x00000003, 0x00003276, 0x00000003, 0x00000000,
+    0x000006d0, 0x00000000, 0x00000001, 0x00000001, 0x00000001, 0x42b60000, 0x00000005, 0x31727261,
+    0x00000000, 0x00000003, 0x00000000, 0x00000700, 0x00000000, 0x00000002, 0x00000001, 0x00000001,
+    0x42b80000, 0x42ba0000, 0x00000005, 0x32727261, 0x00000000, 0x00000004, 0x00000010, 0x00000004,
+    0x00000000, 0x00000000, 0x00000000, 0x00000005, 0x0000000f, 0x00000004, 0x00000000, 0x00000000,
+    0x00000000, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000001, 0x00000002, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000001,
+    0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000,
+    0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000,
+    0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002,
+    0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000,
+    0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003,
+    0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004,
+    0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000,
+    0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000,
+    0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002,
+    0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000,
+    0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000003,
+    0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004, 0x00000001, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000003, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000004,
+    0x00000001, 0x00000003, 0x00003070, 0x00000006, 0x00000010, 0x00000004, 0x00000000, 0x00000000,
+    0x00000000, 0x00000003, 0x00003170, 0x00000006, 0x68636574, 0x00000030, 0x00000018, 0x00000001,
+    0x00000008, 0x00000007, 0x00000004, 0x00000020, 0x00000000, 0x00000000, 0x0000003c, 0x00000058,
+    0x00000000, 0x00000000, 0x00000074, 0x00000090, 0x00000000, 0x00000000, 0x000000c0, 0x000000dc,
+    0x00000000, 0x00000000, 0x000000f8, 0x00000114, 0x00000000, 0x00000000, 0x00000130, 0x0000014c,
+    0x00000000, 0x00000000, 0x00000168, 0x00000184, 0x00000000, 0x00000000, 0x000001a0, 0x000001b4,
+    0x00000000, 0x00000000, 0x000001cc, 0x000001e8, 0x00000000, 0x00000000, 0x00000224, 0x00000240,
+    0x00000000, 0x00000000, 0x0000027c, 0x00000298, 0x00000000, 0x00000000, 0x000002d8, 0x000002f4,
+    0x00000000, 0x00000000, 0x00000334, 0x00000350, 0x00000000, 0x00000000, 0x0000036c, 0x00000388,
+    0x00000000, 0x00000000, 0x000003a8, 0x000003c4, 0x00000000, 0x00000000, 0x000003e8, 0x00000404,
+    0x00000000, 0x00000000, 0x0000042c, 0x00000448, 0x00000000, 0x00000000, 0x0000046c, 0x00000488,
+    0x00000000, 0x00000000, 0x000004b0, 0x000004cc, 0x00000000, 0x00000000, 0x000004f4, 0x00000510,
+    0x00000000, 0x00000000, 0x00000538, 0x000005a4, 0x00000000, 0x00000000, 0x000005e4, 0x00000650,
+    0x00000000, 0x00000000, 0x000006b0, 0x000006cc, 0x00000000, 0x00000000, 0x000006dc, 0x000006f8,
+    0x00000000, 0x00000000, 0x00000c24, 0x00000000, 0x00000002, 0x00000bfc, 0x00000000, 0x00000022,
+    0x00000092, 0x00000000, 0x00000710, 0x0000070c, 0x00000093, 0x00000000, 0x00000728, 0x00000724,
+    0x00000091, 0x00000000, 0x00000740, 0x0000073c, 0x00000091, 0x00000001, 0x00000760, 0x0000075c,
+    0x00000091, 0x00000002, 0x00000780, 0x0000077c, 0x00000091, 0x00000003, 0x000007a0, 0x0000079c,
+    0x00000091, 0x00000004, 0x000007c0, 0x000007bc, 0x00000091, 0x00000005, 0x000007e0, 0x000007dc,
+    0x00000091, 0x00000006, 0x00000800, 0x000007fc, 0x00000091, 0x00000007, 0x00000820, 0x0000081c,
+    0x00000084, 0x00000000, 0x00000840, 0x0000083c, 0x00000084, 0x00000001, 0x00000860, 0x0000085c,
+    0x00000084, 0x00000002, 0x00000880, 0x0000087c, 0x00000084, 0x00000003, 0x000008a0, 0x0000089c,
+    0x00000084, 0x00000004, 0x000008c0, 0x000008bc, 0x00000084, 0x00000005, 0x000008e0, 0x000008dc,
+    0x00000084, 0x00000006, 0x00000900, 0x000008fc, 0x00000084, 0x00000007, 0x00000920, 0x0000091c,
+    0x00000085, 0x00000000, 0x0000094c, 0x0000093c, 0x00000085, 0x00000001, 0x00000978, 0x00000968,
+    0x00000085, 0x00000002, 0x000009a4, 0x00000994, 0x00000085, 0x00000003, 0x000009d0, 0x000009c0,
+    0x00000085, 0x00000004, 0x000009fc, 0x000009ec, 0x00000085, 0x00000005, 0x00000a28, 0x00000a18,
+    0x00000085, 0x00000006, 0x00000a54, 0x00000a44, 0x00000085, 0x00000007, 0x00000a80, 0x00000a70,
+    0x00000087, 0x00000000, 0x00000aac, 0x00000a9c, 0x00000087, 0x00000001, 0x00000ad8, 0x00000ac8,
+    0x00000087, 0x00000002, 0x00000b04, 0x00000af4, 0x00000087, 0x00000003, 0x00000b30, 0x00000b20,
+    0x00000087, 0x00000004, 0x00000b5c, 0x00000b4c, 0x00000087, 0x00000005, 0x00000b88, 0x00000b78,
+    0x00000087, 0x00000006, 0x00000bb4, 0x00000ba4, 0x00000087, 0x00000007, 0x00000be0, 0x00000bd0,
+    0x00000c1c, 0x00000000, 0x00000001, 0x00000092, 0x00000000, 0x00000c08, 0x00000c04, 0x00000003,
+    0x00000013, 0x00000001, 0x0000002c, 0xfffe0101, 0x00000051, 0xa00f0000, 0x3f800000, 0x3f800000,
+    0x3f800000, 0x3f800000, 0x00000001, 0xc00f0000, 0xa0e40000, 0x0000ffff, 0x00000002, 0x0000002c,
+    0xfffe0101, 0x00000051, 0xa00f0000, 0x40000000, 0x40000000, 0x40000000, 0x40000000, 0x00000001,
+    0xc00f0000, 0xa0e40000, 0x0000ffff, 0x00000003, 0x0000002c, 0xfffe0200, 0x05000051, 0xa00f0000,
+    0x40400000, 0x40400000, 0x40400000, 0x40400000, 0x02000001, 0xc00f0000, 0xa0e40000, 0x0000ffff,
+    0x00000000, 0x00000001, 0xffffffff, 0x00000000, 0x00000002, 0x000000e8, 0x00000008, 0x615f7376,
+    0x00007272, 0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b, 0x46580200, 0x00000001,
+    0x0000001c, 0x00000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001, 0x00000038, 0x00000048,
+    0x56695f67, 0x00746365, 0x00020001, 0x00040001, 0x00000001, 0x00000000, 0x40800000, 0x40400000,
+    0x40000000, 0x3f800000, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c,
+    0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe,
+    0x54494c43, 0x00000000, 0x000cfffe, 0x434c5846, 0x00000001, 0x10000001, 0x00000001, 0x00000000,
+    0x00000002, 0x00000002, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff,
+    0x00000000, 0x00000000, 0xffffffff, 0x00000021, 0x00000000, 0x00000248, 0x46580200, 0x003efffe,
+    0x42415443, 0x0000001c, 0x000000c3, 0x46580200, 0x00000003, 0x0000001c, 0x20000100, 0x000000c0,
+    0x00000058, 0x00000002, 0x00000001, 0x00000060, 0x00000070, 0x00000080, 0x00010002, 0x00000001,
+    0x00000088, 0x00000098, 0x000000a8, 0x00020002, 0x00000001, 0x000000b0, 0x00000070, 0x6576706f,
+    0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd,
+    0x7f7fffff, 0x6576706f, 0x00327463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x3f800000,
+    0x40000000, 0xc0400000, 0x40800000, 0x6576706f, 0x00337463, 0x00030001, 0x00040001, 0x00000001,
+    0x00000000, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0022fffe, 0x54494c43,
+    0x00000010, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x812dea11, 0x3d719799, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x002dfffe, 0x434c5846, 0x00000004, 0xa0500004, 0x00000002, 0x00000000, 0x00000001,
+    0x0000000c, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000007, 0x00000000, 0x20400004,
+    0x00000002, 0x00000000, 0x00000007, 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000,
+    0x00000007, 0x00000004, 0x10100004, 0x00000001, 0x00000000, 0x00000002, 0x00000008, 0x00000000,
+    0x00000007, 0x00000000, 0x20400004, 0x00000002, 0x00000000, 0x00000007, 0x00000000, 0x00000000,
+    0x00000007, 0x00000004, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff,
+    0x00000000, 0x00000000, 0xffffffff, 0x00000020, 0x00000000, 0x000001f0, 0x46580200, 0x0033fffe,
+    0x42415443, 0x0000001c, 0x00000097, 0x46580200, 0x00000002, 0x0000001c, 0x20000100, 0x00000094,
+    0x00000044, 0x00000002, 0x00000001, 0x0000004c, 0x0000005c, 0x0000006c, 0x00010002, 0x00000001,
+    0x00000074, 0x00000084, 0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x6576706f, 0x00327463, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x3f800000, 0x40000000, 0xc0400000, 0x40800000, 0x4d007874, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072,
+    0x392e3932, 0x332e3235, 0x00313131, 0x001afffe, 0x54494c43, 0x0000000c, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x002afffe, 0x434c5846,
+    0x00000004, 0x50000004, 0x00000002, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000002,
+    0x00000004, 0x00000000, 0x00000004, 0x00000001, 0x50000004, 0x00000002, 0x00000000, 0x00000002,
+    0x00000004, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000004, 0x00000002, 0x10000001,
+    0x00000001, 0x00000000, 0x00000001, 0x00000008, 0x00000000, 0x00000004, 0x00000000, 0x10000001,
+    0x00000001, 0x00000000, 0x00000001, 0x00000008, 0x00000000, 0x00000004, 0x00000003, 0xf0f0f0f0,
+    0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x0000001f, 0x00000000, 0x000001a8,
+    0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b, 0x46580200, 0x00000001, 0x0000001c,
+    0x20000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001, 0x00000038, 0x00000048, 0x6576706f,
+    0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd,
+    0x7f7fffff, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0012fffe, 0x54494c43,
+    0x00000008, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x47ae147b, 0x3f847ae1, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x002ffffe, 0x434c5846, 0x00000005, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000000, 0x00000000, 0x00000007, 0x00000000, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000001, 0x00000000, 0x00000007, 0x00000001, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000002, 0x00000000, 0x00000007, 0x00000002, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000003, 0x00000000, 0x00000007, 0x00000003, 0xa0500004, 0x00000002, 0x00000000, 0x00000001,
+    0x00000004, 0x00000000, 0x00000007, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0,
+    0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x0000001e, 0x00000000, 0x000000dc,
+    0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b, 0x46580200, 0x00000001, 0x0000001c,
+    0x20000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001, 0x00000038, 0x00000048, 0x6576706f,
+    0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd,
+    0x7f7fffff, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43,
+    0x00000000, 0x000cfffe, 0x434c5846, 0x00000001, 0x10900004, 0x00000001, 0x00000000, 0x00000002,
+    0x00000000, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000,
+    0x00000000, 0xffffffff, 0x0000001d, 0x00000000, 0x000000dc, 0x46580200, 0x0024fffe, 0x42415443,
+    0x0000001c, 0x0000005b, 0x46580200, 0x00000001, 0x0000001c, 0x20000100, 0x00000058, 0x00000030,
+    0x00000002, 0x00000001, 0x00000038, 0x00000048, 0x6576706f, 0x00317463, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x4d007874, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072,
+    0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x000cfffe, 0x434c5846,
+    0x00000001, 0x10800004, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000004,
+    0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x0000001c,
+    0x00000000, 0x00000124, 0x46580200, 0x0033fffe, 0x42415443, 0x0000001c, 0x00000097, 0x46580200,
+    0x00000002, 0x0000001c, 0x20000100, 0x00000094, 0x00000044, 0x00000002, 0x00000001, 0x0000004c,
+    0x0000005c, 0x0000006c, 0x00010002, 0x00000001, 0x00000074, 0x00000084, 0x6576706f, 0x00317463,
+    0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff,
+    0x6576706f, 0x00327463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x3f800000, 0x40000000,
+    0xc0400000, 0x40800000, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c,
+    0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe,
+    0x54494c43, 0x00000000, 0x000ffffe, 0x434c5846, 0x00000001, 0x20100004, 0x00000002, 0x00000000,
+    0x00000002, 0x00000000, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000004, 0x00000000,
+    0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x0000001b, 0x00000000,
+    0x00000124, 0x46580200, 0x0033fffe, 0x42415443, 0x0000001c, 0x00000097, 0x46580200, 0x00000002,
+    0x0000001c, 0x20000100, 0x00000094, 0x00000044, 0x00000002, 0x00000001, 0x0000004c, 0x0000005c,
+    0x0000006c, 0x00010002, 0x00000001, 0x00000074, 0x00000084, 0x6576706f, 0x00317463, 0x00030001,
+    0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x6576706f,
+    0x00327463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x3f800000, 0x40000000, 0xc0400000,
+    0x40800000, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43,
+    0x00000000, 0x000ffffe, 0x434c5846, 0x00000001, 0x20000004, 0x00000002, 0x00000000, 0x00000002,
+    0x00000000, 0x00000000, 0x00000002, 0x00000004, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0,
+    0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x0000001a, 0x00000000, 0x000000dc,
+    0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b, 0x46580200, 0x00000001, 0x0000001c,
+    0x20000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001, 0x00000038, 0x00000048, 0x6576706f,
+    0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd,
+    0x7f7fffff, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43,
+    0x00000000, 0x000cfffe, 0x434c5846, 0x00000001, 0x10400004, 0x00000001, 0x00000000, 0x00000002,
+    0x00000000, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000,
+    0x00000000, 0xffffffff, 0x00000019, 0x00000000, 0x0000013c, 0x46580200, 0x0024fffe, 0x42415443,
+    0x0000001c, 0x0000005b, 0x46580200, 0x00000001, 0x0000001c, 0x20000100, 0x00000058, 0x00000030,
+    0x00000002, 0x00000001, 0x00000038, 0x00000048, 0x6576706f, 0x00317463, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x4d007874, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072,
+    0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x0024fffe, 0x434c5846,
+    0x00000004, 0x10300001, 0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000004,
+    0x00000000, 0x10300001, 0x00000001, 0x00000000, 0x00000002, 0x00000001, 0x00000000, 0x00000004,
+    0x00000001, 0x10300001, 0x00000001, 0x00000000, 0x00000002, 0x00000002, 0x00000000, 0x00000004,
+    0x00000002, 0x10300001, 0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000000, 0x00000004,
+    0x00000003, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x00000018,
+    0x00000000, 0x000000dc, 0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b, 0x46580200,
+    0x00000001, 0x0000001c, 0x20000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001, 0x00000038,
+    0x00000048, 0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000,
+    0x80000000, 0xc00ccccd, 0x7f7fffff, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820,
+    0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131,
+    0x0002fffe, 0x54494c43, 0x00000000, 0x000cfffe, 0x434c5846, 0x00000001, 0x10100004, 0x00000001,
+    0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f,
+    0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x00000017, 0x00000000, 0x00000124, 0x46580200,
+    0x0033fffe, 0x42415443, 0x0000001c, 0x00000097, 0x46580200, 0x00000002, 0x0000001c, 0x20000100,
+    0x00000094, 0x00000044, 0x00000002, 0x00000001, 0x0000004c, 0x0000005c, 0x0000006c, 0x00010002,
+    0x00000001, 0x00000074, 0x00000084, 0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001,
+    0x00000000, 0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x6576706f, 0x00327463, 0x00030001,
+    0x00040001, 0x00000001, 0x00000000, 0x3f800000, 0x40000000, 0xc0400000, 0x40800000, 0x4d007874,
+    0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x000ffffe,
+    0x434c5846, 0x00000001, 0x20300004, 0x00000002, 0x00000000, 0x00000002, 0x00000000, 0x00000000,
+    0x00000002, 0x00000004, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff,
+    0x00000000, 0x00000000, 0xffffffff, 0x00000016, 0x00000000, 0x00000124, 0x46580200, 0x0033fffe,
+    0x42415443, 0x0000001c, 0x00000097, 0x46580200, 0x00000002, 0x0000001c, 0x20000100, 0x00000094,
+    0x00000044, 0x00000002, 0x00000001, 0x0000004c, 0x0000005c, 0x0000006c, 0x00010002, 0x00000001,
+    0x00000074, 0x00000084, 0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x6576706f, 0x00327463, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x3f800000, 0x40000000, 0xc0400000, 0x40800000, 0x4d007874, 0x6f726369,
+    0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072,
+    0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x000ffffe, 0x434c5846,
+    0x00000001, 0x20200004, 0x00000002, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000002,
+    0x00000004, 0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000,
+    0x00000000, 0xffffffff, 0x00000015, 0x00000000, 0x00000124, 0x46580200, 0x0033fffe, 0x42415443,
+    0x0000001c, 0x00000097, 0x46580200, 0x00000002, 0x0000001c, 0x20000100, 0x00000094, 0x00000044,
+    0x00000002, 0x00000001, 0x0000004c, 0x0000005c, 0x0000006c, 0x00010002, 0x00000001, 0x00000074,
+    0x00000084, 0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000,
+    0x80000000, 0xc00ccccd, 0x7f7fffff, 0x6576706f, 0x00327463, 0x00030001, 0x00040001, 0x00000001,
+    0x00000000, 0x3f800000, 0x40000000, 0xc0400000, 0x40800000, 0x4d007874, 0x6f726369, 0x74666f73,
+    0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932,
+    0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x000ffffe, 0x434c5846, 0x00000001,
+    0x20400004, 0x00000002, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000002, 0x00000004,
+    0x00000000, 0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000,
+    0xffffffff, 0x00000014, 0x00000000, 0x00000124, 0x46580200, 0x0033fffe, 0x42415443, 0x0000001c,
+    0x00000097, 0x46580200, 0x00000002, 0x0000001c, 0x20000100, 0x00000094, 0x00000044, 0x00000002,
+    0x00000001, 0x0000004c, 0x0000005c, 0x0000006c, 0x00010002, 0x00000001, 0x00000074, 0x00000084,
+    0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000,
+    0xc00ccccd, 0x7f7fffff, 0x6576706f, 0x00327463, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x3f800000, 0x40000000, 0xc0400000, 0x40800000, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820,
+    0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235,
+    0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x000ffffe, 0x434c5846, 0x00000001, 0x20500004,
+    0x00000002, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000002, 0x00000004, 0x00000000,
+    0x00000004, 0x00000000, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff,
+    0x00000013, 0x00000000, 0x0000013c, 0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b,
+    0x46580200, 0x00000001, 0x0000001c, 0x20000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001,
+    0x00000038, 0x00000048, 0x6576706f, 0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x00000000, 0x80000000, 0xc00ccccd, 0x7f7fffff, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820,
+    0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235,
+    0x00313131, 0x0002fffe, 0x54494c43, 0x00000000, 0x0024fffe, 0x434c5846, 0x00000004, 0x10700001,
+    0x00000001, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x10700001,
+    0x00000001, 0x00000000, 0x00000002, 0x00000001, 0x00000000, 0x00000004, 0x00000001, 0x10700001,
+    0x00000001, 0x00000000, 0x00000002, 0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x10700001,
+    0x00000001, 0x00000000, 0x00000002, 0x00000003, 0x00000000, 0x00000004, 0x00000003, 0xf0f0f0f0,
+    0x0f0f0f0f, 0x0000ffff, 0x00000000, 0x00000000, 0xffffffff, 0x00000012, 0x00000000, 0x0000013c,
+    0x46580200, 0x0024fffe, 0x42415443, 0x0000001c, 0x0000005b, 0x46580200, 0x00000001, 0x0000001c,
+    0x20000100, 0x00000058, 0x00000030, 0x00000002, 0x00000001, 0x00000038, 0x00000048, 0x6576706f,
+    0x00317463, 0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x00000000, 0x80000000, 0xc00ccccd,
+    0x7f7fffff, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461,
+    0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x0002fffe, 0x54494c43,
+    0x00000000, 0x0024fffe, 0x434c5846, 0x00000004, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000001, 0x00000000, 0x00000004, 0x00000001, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000002, 0x00000000, 0x00000004, 0x00000002, 0x10300001, 0x00000001, 0x00000000, 0x00000002,
+    0x00000003, 0x00000000, 0x00000004, 0x00000003, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x00000000,
+    0x00000000, 0xffffffff, 0x00000001, 0x00000000, 0x00000724, 0xffff0300, 0x00a5fffe, 0x42415443,
+    0x0000001c, 0x0000025f, 0xffff0300, 0x00000007, 0x0000001c, 0x20000000, 0x00000258, 0x000000a8,
+    0x00080002, 0x00000002, 0x000000b4, 0x000000c4, 0x000000e4, 0x00060002, 0x00000002, 0x000000ec,
+    0x000000fc, 0x0000011c, 0x00000002, 0x00000003, 0x00000128, 0x00000138, 0x00000168, 0x000a0002,
+    0x00000002, 0x00000170, 0x00000180, 0x000001a0, 0x000c0002, 0x00000002, 0x000001ac, 0x000001bc,
+    0x000001dc, 0x00030002, 0x00000003, 0x000001e4, 0x000001f4, 0x00000224, 0x00000000, 0x00000005,
+    0x00000230, 0x00000240, 0x3278326d, 0x756c6f63, 0xab006e6d, 0x00030003, 0x00020002, 0x00000001,
+    0x00000000, 0x41300000, 0x41a80000, 0x00000000, 0x00000000, 0x41400000, 0x41b00000, 0x00000000,
+    0x00000000, 0x3278326d, 0x00776f72, 0x00030002, 0x00020002, 0x00000001, 0x00000000, 0x41300000,
+    0x41400000, 0x00000000, 0x00000000, 0x41a80000, 0x41b00000, 0x00000000, 0x00000000, 0x3378326d,
+    0x756c6f63, 0xab006e6d, 0x00030003, 0x00030002, 0x00000001, 0x00000000, 0x41300000, 0x41a80000,
+    0x00000000, 0x00000000, 0x41400000, 0x41b00000, 0x00000000, 0x00000000, 0x41500000, 0x41b80000,
+    0x00000000, 0x00000000, 0x3378326d, 0x00776f72, 0x00030002, 0x00030002, 0x00000001, 0x00000000,
+    0x41300000, 0x41400000, 0x41500000, 0x00000000, 0x41a80000, 0x41b00000, 0x41b80000, 0x00000000,
+    0x3278336d, 0x756c6f63, 0xab006e6d, 0x00030003, 0x00020003, 0x00000001, 0x00000000, 0x41300000,
+    0x41a80000, 0x41f80000, 0x00000000, 0x41400000, 0x41b00000, 0x42000000, 0x00000000, 0x3278336d,
+    0x00776f72, 0x00030002, 0x00020003, 0x00000001, 0x00000000, 0x41300000, 0x41400000, 0x00000000,
+    0x00000000, 0x41a80000, 0x41b00000, 0x00000000, 0x00000000, 0x41f80000, 0x42000000, 0x00000000,
+    0x00000000, 0x7832626d, 0x776f7233, 0xababab00, 0x00010002, 0x00030002, 0x00000001, 0x00000000,
+    0xffffffff, 0x00000000, 0xffffffff, 0x00000000, 0xffffffff, 0xffffffff, 0x335f7370, 0x4d00305f,
+    0x6f726369, 0x74666f73, 0x29522820, 0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970,
+    0x2e392072, 0x392e3932, 0x332e3235, 0x00313131, 0x05000051, 0xa00f000e, 0x3d2aaaa4, 0xbf000000,
+    0x3f800000, 0xbe22f983, 0x05000051, 0xa00f000f, 0x00000000, 0x3e22f983, 0x3e800000, 0xbab609ba,
+    0x05000051, 0xa00f0010, 0x40c90fdb, 0xc0490fdb, 0xb4878163, 0x37cfb5a1, 0x0200001f, 0x8000000a,
+    0x900f0000, 0x03000005, 0x80030000, 0xa0e40007, 0x90550000, 0x04000004, 0x80030000, 0x90000000,
+    0xa0e40006, 0x80e40000, 0x03000002, 0x80030000, 0x80e40000, 0x90e40000, 0x02000001, 0x80010001,
+    0xa000000f, 0x0400005a, 0x80010002, 0x90e40000, 0xa0e40008, 0x80000001, 0x0400005a, 0x80020002,
+    0x90e40000, 0xa0e40009, 0x80000001, 0x03000002, 0x80030000, 0x80e40000, 0x80e40002, 0x03000005,
+    0x800c0000, 0xa0440004, 0x90550000, 0x04000004, 0x800c0000, 0x90000000, 0xa0440003, 0x80e40000,
+    0x04000004, 0x800c0000, 0x90aa0000, 0xa0440005, 0x80e40000, 0x03000002, 0x80030000, 0x80ee0000,
+    0x80e40000, 0x03000008, 0x80010002, 0x90e40000, 0xa0e4000c, 0x03000008, 0x80020002, 0x90e40000,
+    0xa0e4000d, 0x03000002, 0x80030000, 0x80e40000, 0x80e40002, 0x03000005, 0x800e0001, 0xa090000b,
+    0x90550000, 0x04000004, 0x800e0001, 0x90000000, 0xa090000a, 0x80e40001, 0x02000001, 0x80040000,
+    0x90aa0000, 0x03000002, 0x80070000, 0x80e40000, 0x80f90001, 0x0400005a, 0x80010002, 0x90e40000,
+    0xa0e40000, 0x80000001, 0x0400005a, 0x80020002, 0x90e40000, 0xa0e40001, 0x80000001, 0x0400005a,
+    0x80040002, 0x90e40000, 0xa0e40002, 0x80000001, 0x03000002, 0x80070000, 0x80e40000, 0x80e40002,
+    0x01000028, 0xe0e40804, 0x02000001, 0x80080000, 0x90ff0000, 0x04000004, 0x800f0002, 0x80e40000,
+    0xa055000f, 0xa0aa000f, 0x02000013, 0x800f0002, 0x80e40002, 0x04000004, 0x800f0002, 0x80e40002,
+    0xa0000010, 0xa0550010, 0x03000005, 0x800f0002, 0x80e40002, 0x80e40002, 0x04000004, 0x800f0003,
+    0x80e40002, 0xa0aa0010, 0xa0ff0010, 0x04000004, 0x800f0003, 0x80e40002, 0x80e40003, 0xa0ff000f,
+    0x04000004, 0x800f0003, 0x80e40002, 0x80e40003, 0xa000000e, 0x04000004, 0x800f0003, 0x80e40002,
+    0x80e40003, 0xa055000e, 0x04000004, 0x800f0002, 0x80e40002, 0x80e40003, 0x80e40000, 0x03000002,
+    0x800f0002, 0x80e40002, 0xa0aa000e, 0x04000004, 0x800f0003, 0x80e40002, 0xa1ff000e, 0xa155000e,
+    0x02000013, 0x800f0003, 0x80e40003, 0x04000004, 0x800f0003, 0x80e40003, 0xa0000010, 0xa0550010,
+    0x03000005, 0x800f0003, 0x80e40003, 0x80e40003, 0x04000004, 0x800f0004, 0x80e40003, 0xa0aa0010,
+    0xa0ff0010, 0x04000004, 0x800f0004, 0x80e40003, 0x80e40004, 0xa0ff000f, 0x04000004, 0x800f0004,
+    0x80e40003, 0x80e40004, 0xa000000e, 0x04000004, 0x800f0004, 0x80e40003, 0x80e40004, 0xa055000e,
+    0x04000004, 0x800f0002, 0x80e40003, 0x80e40004, 0x80e40002, 0x03000002, 0x800f0002, 0x80e40002,
+    0xa0aa000e, 0x0400005a, 0x80010003, 0x80e40002, 0xa0e40000, 0x80000001, 0x0400005a, 0x80020003,
+    0x80e40002, 0xa0e40001, 0x80000001, 0x0400005a, 0x80040003, 0x80e40002, 0xa0e40002, 0x80000001,
+    0x03000002, 0x80070001, 0x80e40002, 0x80e40003, 0x03000005, 0x80070002, 0x80550001, 0xa0e4000b,
+    0x04000004, 0x80070002, 0x80000001, 0xa0e4000a, 0x80e40002, 0x03000002, 0x80070001, 0x80e40001,
+    0x80e40002, 0x03000008, 0x80010002, 0x80e40001, 0xa0e4000c, 0x03000008, 0x80020002, 0x80e40001,
+    0xa0e4000d, 0x03000002, 0x80030001, 0x80e40001, 0x80e40002, 0x03000005, 0x80030002, 0x80550001,
+    0xa0e40004, 0x04000004, 0x80030002, 0x80000001, 0xa0e40003, 0x80e40002, 0x04000004, 0x80030002,
+    0x80aa0001, 0xa0e40005, 0x80e40002, 0x03000002, 0x80030800, 0x80e40001, 0x80e40002, 0x02000001,
+    0x80040800, 0x80aa0001, 0x02000001, 0x80080800, 0x80ff0002, 0x0000002a, 0x02000001, 0x80070800,
+    0x80e40000, 0x02000001, 0x80080800, 0x90ff0000, 0x0000002b, 0x0000ffff, 0x00000000, 0x00000000,
+    0xffffffff, 0x00000000, 0x00000000, 0x0000098c, 0xfffe0300, 0x00ebfffe, 0x42415443, 0x0000001c,
+    0x00000377, 0xfffe0300, 0x00000008, 0x0000001c, 0x20000000, 0x00000370, 0x000000bc, 0x00190002,
+    0x00000001, 0x000000c4, 0x000000d4, 0x000000e4, 0x00170002, 0x00000002, 0x000000ec, 0x000000fc,
+    0x0000011c, 0x000a0002, 0x00000004, 0x00000128, 0x00000138, 0x00000178, 0x000e0002, 0x00000003,
+    0x00000180, 0x00000190, 0x000001c0, 0x00110002, 0x00000003, 0x000001cc, 0x000001dc, 0x0000020c,
+    0x00060002, 0x00000004, 0x00000214, 0x00000224, 0x00000264, 0x00140002, 0x00000003, 0x000002bc,
+    0x000002cc, 0x000002fc, 0x00000002, 0x00000006, 0x00000300, 0x00000310, 0x31727261, 0xababab00,
+    0x00030000, 0x00010001, 0x00000001, 0x00000000, 0x42b60000, 0x00000000, 0x00000000, 0x00000000,
+    0x32727261, 0xababab00, 0x00030000, 0x00010001, 0x00000002, 0x00000000, 0x42b80000, 0x00000000,
+    0x00000000, 0x00000000, 0x42ba0000, 0x00000000, 0x00000000, 0x00000000, 0x3478336d, 0x756c6f63,
+    0xab006e6d, 0x00030003, 0x00040003, 0x00000001, 0x00000000, 0x41300000, 0x41a80000, 0x41f80000,
+    0x00000000, 0x41400000, 0x41b00000, 0x42000000, 0x00000000, 0x41500000, 0x41b80000, 0x42040000,
+    0x00000000, 0x41600000, 0x41c00000, 0x42080000, 0x00000000, 0x3478336d, 0x00776f72, 0x00030002,
+    0x00040003, 0x00000001, 0x00000000, 0x41300000, 0x41400000, 0x41500000, 0x41600000, 0x41a80000,
+    0x41b00000, 0x41b80000, 0x41c00000, 0x41f80000, 0x42000000, 0x42040000, 0x42080000, 0x3378346d,
+    0x756c6f63, 0xab006e6d, 0x00030003, 0x00030004, 0x00000001, 0x00000000, 0x41300000, 0x41a80000,
+    0x41f80000, 0x42240000, 0x41400000, 0x41b00000, 0x42000000, 0x42280000, 0x41500000, 0x41b80000,
+    0x42040000, 0x422c0000, 0x3378346d, 0x00776f72, 0x00030002, 0x00030004, 0x00000001, 0x00000000,
+    0x41300000, 0x41400000, 0x41500000, 0x00000000, 0x41a80000, 0x41b00000, 0x41b80000, 0x00000000,
+    0x41f80000, 0x42000000, 0x42040000, 0x00000000, 0x42240000, 0x42280000, 0x422c0000, 0x00000000,
+    0x00317374, 0xab003176, 0x00030001, 0x00030001, 0x00000001, 0x00000000, 0xab007666, 0x00030000,
+    0x00010001, 0x00000001, 0x00000000, 0xab003276, 0x00030001, 0x00040001, 0x00000001, 0x00000000,
+    0x00000268, 0x0000026c, 0x0000027c, 0x00000280, 0x00000290, 0x00000294, 0x00000005, 0x00080001,
+    0x00030001, 0x000002a4, 0x41100000, 0x41200000, 0x41300000, 0x00000000, 0x41400000, 0x00000000,
+    0x00000000, 0x00000000, 0x41500000, 0x41600000, 0x41700000, 0x41800000, 0x00327374, 0x00000005,
+    0x00080001, 0x00030002, 0x000002a4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x3f800000,
+    0x40000000, 0x40400000, 0x00000000, 0x40800000, 0x00000000, 0x00000000, 0x00000000, 0x40a00000,
+    0x40c00000, 0x40e00000, 0x41000000, 0x335f7376, 0x4d00305f, 0x6f726369, 0x74666f73, 0x29522820,
+    0x534c4820, 0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235,
+    0x00313131, 0x00ecfffe, 0x53455250, 0x46580201, 0x0043fffe, 0x42415443, 0x0000001c, 0x000000d7,
+    0x46580201, 0x00000003, 0x0000001c, 0x20000100, 0x000000d4, 0x00000058, 0x00020002, 0x00000001,
+    0x00000060, 0x00000070, 0x00000080, 0x00030002, 0x00000001, 0x00000088, 0x00000070, 0x00000098,
+    0x00000002, 0x00000002, 0x000000a4, 0x000000b4, 0x6f505f67, 0xab003173, 0x00030001, 0x00040001,
+    0x00000001, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x6f505f67, 0xab003273,
+    0x00030001, 0x00040001, 0x00000001, 0x00000000, 0x65535f67, 0x7463656c, 0xab00726f, 0x00030001,
+    0x00040001, 0x00000002, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x41200000,
+    0x41200000, 0x41200000, 0x41200000, 0x4d007874, 0x6f726369, 0x74666f73, 0x29522820, 0x534c4820,
+    0x6853204c, 0x72656461, 0x6d6f4320, 0x656c6970, 0x2e392072, 0x392e3932, 0x332e3235, 0x00313131,
+    0x000cfffe, 0x49535250, 0x0000001a, 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000,
+    0x00000001, 0x0000001a, 0x00000001, 0x00000000, 0x00000000, 0x0032fffe, 0x54494c43, 0x00000018,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+    0x00000000, 0x3fe00000, 0x00000000, 0xc0000000, 0x00000000, 0xc0080000, 0x00000000, 0x00000000,
+    0x00000000, 0x40100000, 0x00000000, 0x40140000, 0x00000000, 0x40180000, 0x00000000, 0x401c0000,
+    0x0064fffe, 0x434c5846, 0x00000009, 0xa0500004, 0x00000002, 0x00000000, 0x00000001, 0x00000011,
+    0x00000000, 0x00000002, 0x00000008, 0x00000000, 0x00000007, 0x00000000, 0x20400004, 0x00000002,
+    0x00000000, 0x00000007, 0x00000000, 0x00000000, 0x00000001, 0x00000014, 0x00000000, 0x00000007,
+    0x00000004, 0xa0500004, 0x00000002, 0x00000000, 0x00000001, 0x00000012, 0x00000000, 0x00000002,
+    0x0000000c, 0x00000000, 0x00000007, 0x00000000, 0x20400004, 0x00000002, 0x00000000, 0x00000007,
+    0x00000000, 0x00000000, 0x00000001, 0x00000014, 0x00000000, 0x00000007, 0x00000008, 0x10100004,
+    0x00000001, 0x00000000, 0x00000007, 0x00000008, 0x00000000, 0x00000007, 0x00000000, 0x20400004,
+    0x00000002, 0x00000000, 0x00000007, 0x00000000, 0x00000000, 0x00000007, 0x00000004, 0x00000000,
+    0x00000007, 0x0000000c, 0xa0200001, 0x00000002, 0x00000000, 0x00000001, 0x00000010, 0x00000000,
+    0x00000002, 0x00000005, 0x00000000, 0x00000007, 0x00000000, 0xa0500004, 0x00000002, 0x00000000,
+    0x00000007, 0x00000000, 0x00000000, 0x00000007, 0x0000000c, 0x00000000, 0x00000007, 0x00000004,
+    0x20400004, 0x00000002, 0x00000000, 0x00000007, 0x00000004, 0x00000000, 0x00000007, 0x00000008,
+    0x00000000, 0x00000004, 0x00000068, 0xf0f0f0f0, 0x0f0f0f0f, 0x0000ffff, 0x05000051, 0xa00f001b,
+    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x0200001f, 0x80000000, 0x900f0000, 0x0200001f,
+    0x80000000, 0xe00f0000, 0x0200001f, 0x80000005, 0xe0030001, 0x0200001f, 0x8000000a, 0xe00f0002,
+    0x03000009, 0x80010000, 0x90e40000, 0xa0e40011, 0x03000009, 0x80020000, 0x90e40000, 0xa0e40012,
+    0x03000009, 0x80040000, 0x90e40000, 0xa0e40013, 0x03000008, 0x80010001, 0x90e40000, 0xa0e4000a,
+    0x03000008, 0x80020001, 0x90e40000, 0xa0e4000b, 0x03000008, 0x80040001, 0x90e40000, 0xa0e4000c,
+    0x03000008, 0x80080001, 0x90e40000, 0xa0e4000d, 0x02000001, 0x80080000, 0xa000001b, 0x03000002,
+    0x800f0000, 0x80e40000, 0x80e40001, 0x03000005, 0x800f0001, 0xa0e4000f, 0x90550000, 0x04000004,
+    0x800f0001, 0x90000000, 0xa0e4000e, 0x80e40001, 0x04000004, 0x800f0001, 0x90aa0000, 0xa0e40010,
+    0x80e40001, 0x03000002, 0x800f0000, 0x80e40000, 0x80e40001, 0x03000005, 0x80070001, 0xa0e40007,
+    0x90550000, 0x04000004, 0x80070001, 0x90000000, 0xa0e40006, 0x80e40001, 0x04000004, 0x80070001,
+    0x90aa0000, 0xa0e40008, 0x80e40001, 0x04000004, 0x80070001, 0x90ff0000, 0xa0e40009, 0x80e40001,
+    0x03000002, 0x80070000, 0x80e40000, 0x80e40001, 0x04000004, 0x800f0000, 0x90e40000, 0xa0000015,
+    0x80e40000, 0x03000009, 0x80010001, 0x90e40000, 0xa0e40016, 0x03000002, 0x800f0000, 0x80e40000,
+    0x80000001, 0x04000004, 0x800f0000, 0x90e40000, 0xa0000004, 0x80e40000, 0x03000009, 0x80010001,
+    0x90e40000, 0xa0e40005, 0x03000002, 0x800f0000, 0x80e40000, 0x80000001, 0x04000004, 0x800f0000,
+    0x90e40000, 0xa0000019, 0x80e40000, 0x04000004, 0xe00f0002, 0x90e40000, 0xa0000018, 0x80e40000,
+    0x02000001, 0xe00f0000, 0xa0e4001a, 0x02000001, 0xe0030001, 0xa000001b, 0x0000ffff,
+};
+#define TEST_EFFECT_PRESHADER_VSHADER_POS 1035
+#define TEST_EFFECT_PRESHADER_VSHADER_LEN 13
+
+static void test_effect_preshader(IDirect3DDevice9 *device)
+{
+    static const D3DXVECTOR4 test_effect_preshader_fconstsv[] =
+    {
+        {0.0f,   0.0f,  0.0f,  0.0f},
+        {0.0f,   0.0f,  0.0f,  0.0f},
+        {0.0f,   0.0f,  0.0f,  0.0f},
+        {1.0f,   2.0f,  3.0f,  0.0f},
+        {4.0f,   0.0f,  0.0f,  0.0f},
+        {5.0f,   6.0f,  7.0f,  8.0f},
+        {11.0f, 12.0f, 13.0f,  0.0f},
+        {21.0f, 22.0f, 23.0f,  0.0f},
+        {31.0f, 32.0f, 33.0f,  0.0f},
+        {41.0f, 42.0f, 43.0f,  0.0f},
+        {11.0f, 21.0f, 31.0f,  0.0f},
+        {12.0f, 22.0f, 32.0f,  0.0f},
+        {13.0f, 23.0f, 33.0f,  0.0f},
+        {14.0f, 24.0f, 34.0f,  0.0f},
+        {11.0f, 12.0f, 13.0f, 14.0f},
+        {21.0f, 22.0f, 23.0f, 24.0f},
+        {31.0f, 32.0f, 33.0f, 34.0f},
+        {11.0f, 21.0f, 31.0f, 41.0f},
+        {12.0f, 22.0f, 32.0f, 42.0f},
+        {13.0f, 23.0f, 33.0f, 43.0f},
+        {9.0f,  10.0f, 11.0f,  0.0f},
+        {12.0f,  0.0f,  0.0f,  0.0f},
+        {13.0f, 14.0f, 15.0f, 16.0f},
+        {92.0f,  0.0f,  0.0f,  0.0f},
+        {93.0f,  0.0f,  0.0f,  0.0f},
+        {91.0f,  0.0f,  0.0f,  0.0f},
+        {4.0f,   5.0f,  6.0f,  7.0f}
+    };
+    static const D3DXVECTOR4 test_effect_preshader_fconstsp[] =
+    {
+        {11.0f, 21.0f,  0.0f, 0.0f},
+        {12.0f, 22.0f,  0.0f, 0.0f},
+        {13.0f, 23.0f,  0.0f, 0.0f},
+        {11.0f, 12.0f,  0.0f, 0.0f},
+        {21.0f, 22.0f,  0.0f, 0.0f},
+        {31.0f, 32.0f,  0.0f, 0.0f},
+        {11.0f, 12.0f,  0.0f, 0.0f},
+        {21.0f, 22.0f,  0.0f, 0.0f},
+        {11.0f, 21.0f,  0.0f, 0.0f},
+        {12.0f, 22.0f,  0.0f, 0.0f},
+        {11.0f, 12.0f, 13.0f, 0.0f},
+        {21.0f, 22.0f, 23.0f, 0.0f},
+        {11.0f, 21.0f, 31.0f, 0.0f},
+        {12.0f, 22.0f, 32.0f, 0.0f}
+    };
+    static const BOOL test_effect_preshader_bconsts[] =
+    {
+        TRUE, FALSE, TRUE, FALSE, TRUE, FALSE
+    };
+    static const struct
+    {
+        const char *comment;
+        BOOL todo[4];
+        unsigned int result[4];
+    }
+    test_effect_preshader_op_results[] =
+    {
+        {"1 / op", { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0xff800000, 0xbee8ba2e, 0x00200000}},
+#if __x86_64__
+        {"rsq",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0x7f800000, 0x3f2c985d, 0x1f800000}},
+#else
+        {"rsq",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0x7f800000, 0x3f2c985c, 0x1f800001}},
+#endif
+        {"mul",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0x40d33334, 0x7f800000}},
+        {"add",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x40000000, 0xc0a66666, 0x7f7fffff}},
+        {"lt",     {FALSE, FALSE,  TRUE, FALSE}, {0x3f800000, 0x3f800000, 0x00000000, 0x00000000}},
+        {"ge",     { TRUE,  TRUE, FALSE,  TRUE}, {0x00000000, 0x00000000, 0x3f800000, 0x3f800000}},
+        {"neg",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x80000000, 0x00000000, 0x400ccccd, 0xff7fffff}},
+        {"rcp",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0xff800000, 0xbee8ba2e, 0x00200000}},
+        {"frac",   {FALSE, FALSE,  TRUE, FALSE}, {0x00000000, 0x00000000, 0x3f4ccccc, 0x00000000}},
+        {"min",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0xc0400000, 0x40800000}},
+        {"max",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x40000000, 0xc00ccccd, 0x7f7fffff}},
+#if __x86_64__
+        {"sin",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0xbf4ef99e, 0xbf0599b3}},
+        {"cos",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x3f800000, 0xbf16a803, 0x3f5a5f96}},
+#else
+        {"sin",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0xbf4ef99e, 0x3f792dc4}},
+        {"cos",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x3f800000, 0xbf16a803, 0xbe6acefc}},
+#endif
+        {"den mul",{ TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0xff800000, 0xbb94f209, 0x000051ec}},
+        {"dot",    {FALSE,  TRUE,  TRUE, FALSE}, {0x00000000, 0x7f800000, 0x41f00000, 0x00000000}},
+#if __x86_64__
+        {"prec",   { TRUE,  TRUE,  TRUE, FALSE}, {0x2b8cbccc, 0x2c0cbccc, 0xac531800, 0x00000000}}
+#else
+        {"prec",   { TRUE,  TRUE, FALSE, FALSE}, {0x2b8cbccc, 0x2c0cbccc, 0x00000000, 0x00000000}}
+#endif
+    };
+    #define TEST_EFFECT_PRES_NFLOATV ARRAY_SIZE(test_effect_preshader_fconstsv)
+    #define TEST_EFFECT_PRES_NFLOATP ARRAY_SIZE(test_effect_preshader_fconstsp)
+    #define TEST_EFFECT_PRES_NFLOATMAX (TEST_EFFECT_PRES_NFLOATV > TEST_EFFECT_PRES_NFLOATP ? \
+            TEST_EFFECT_PRES_NFLOATV : TEST_EFFECT_PRES_NFLOATP)
+    #define TEST_EFFECT_PRES_NBOOL ARRAY_SIZE(test_effect_preshader_bconsts)
+    #define TEST_EFFECT_PRES_NOPTESTS ARRAY_SIZE(test_effect_preshader_op_results)
+
+    static const D3DXVECTOR4 fvect1 = {28.0f, 29.0f, 30.0f, 31.0f};
+    static const D3DXVECTOR4 fvect2 = {0.0f, 0.0f, 1.0f, 0.0f};
+    static const D3DXVECTOR4 fvect_empty = {-9999.0f, -9999.0f, -9999.0f, -9999.0f};
+    HRESULT hr;
+    ID3DXEffect *effect;
+    D3DXHANDLE par;
+    unsigned int npasses;
+    BOOL bval;
+    D3DLIGHT9 light;
+    D3DXVECTOR4 fdata[TEST_EFFECT_PRES_NFLOATMAX];
+    BOOL bdata[TEST_EFFECT_PRES_NBOOL];
+    IDirect3DVertexShader9 *vshader;
+    void *byte_code;
+    unsigned int byte_code_size;
+    unsigned int i, j;
+    D3DCAPS9 caps;
+
+    hr = IDirect3DDevice9_GetDeviceCaps(device, &caps);
+    ok(SUCCEEDED(hr), "Failed to get device caps, hr %#x.\n", hr);
+    if (caps.VertexShaderVersion < D3DVS_VERSION(3, 0)
+            || caps.PixelShaderVersion < D3DPS_VERSION(3, 0))
+    {
+        skip("Test requires VS >= 3 and PS >= 3, skipping.\n");
+        return;
+    }
+
+    hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
+            NULL, NULL, 0, NULL, &effect, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    for (i = 0; i < 256; ++i)
+    {
+        hr = IDirect3DDevice9_SetVertexShaderConstantF(device, i, &fvect_empty.x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    }
+    for (i = 0; i < 224; ++i)
+    {
+        hr = IDirect3DDevice9_SetPixelShaderConstantF(device, i, &fvect_empty.x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    }
+    bval = FALSE;
+    for (i = 0; i < 16; ++i)
+    {
+        hr = IDirect3DDevice9_SetPixelShaderConstantB(device, i, &bval, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    }
+
+    hr = effect->lpVtbl->Begin(effect, &npasses, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    par = effect->lpVtbl->GetParameterByName(effect, NULL, "g_Pos2");
+    ok(par != NULL, "GetParameterByName failed.\n");
+
+    hr = effect->lpVtbl->SetVector(effect, par, &fvect1);
+    ok(hr == D3D_OK, "SetVector failed, hr %#x.\n", hr);
+
+    hr = effect->lpVtbl->BeginPass(effect, 0);
+    todo_wine ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 0, &fdata[0].x, TEST_EFFECT_PRES_NFLOATV);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    todo_wine ok(!memcmp(fdata, test_effect_preshader_fconstsv, sizeof(test_effect_preshader_fconstsv)),
+            "Vertex shader float constants do not match.\n");
+    for (i = TEST_EFFECT_PRES_NFLOATV; i < 256; ++i)
+    {
+        hr = IDirect3DDevice9_GetVertexShaderConstantF(device, i, &fdata[0].x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+        ok(!memcmp(fdata, &fvect_empty, sizeof(fvect_empty)),
+                "Vertex shader float constants do not match.\n");
+    }
+    hr = IDirect3DDevice9_GetPixelShaderConstantF(device, 0, &fdata[0].x, TEST_EFFECT_PRES_NFLOATP);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    todo_wine ok(!memcmp(fdata, test_effect_preshader_fconstsp, sizeof(test_effect_preshader_fconstsp)),
+            "Pixel shader float constants do not match.\n");
+    for (i = TEST_EFFECT_PRES_NFLOATP; i < 224; ++i)
+    {
+        hr = IDirect3DDevice9_GetPixelShaderConstantF(device, i, &fdata[0].x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+        ok(!memcmp(fdata, &fvect_empty, sizeof(fvect_empty)),
+                "Vertex shader float constants do not match.\n");
+    }
+
+    hr = IDirect3DDevice9_GetPixelShaderConstantB(device, 0, bdata, TEST_EFFECT_PRES_NBOOL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    for (i = 0; i < TEST_EFFECT_PRES_NBOOL; ++i)
+        todo_wine_if(!bdata[i] != !test_effect_preshader_bconsts[i])
+        ok(!bdata[i] == !test_effect_preshader_bconsts[i],
+                "Pixel shader boolean constants do not match.\n");
+    for (; i < 16; ++i)
+    {
+        hr = IDirect3DDevice9_GetPixelShaderConstantB(device, i, &bval, 1);
+        ok(hr == D3D_OK && !bval, "Got result %#x, boolean register value %u.\n", hr, bval);
+    }
+
+    for (i = 0; i < TEST_EFFECT_PRES_NOPTESTS; ++i)
+    {
+        unsigned int *v;
+
+        hr = IDirect3DDevice9_GetLight(device, i % 8, &light);
+        v = i < 8 ? (unsigned int *)&light.Diffuse : (unsigned int *)&light.Ambient;
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+        for (j = 0; j < 4; ++j)
+            todo_wine_if(test_effect_preshader_op_results[i].todo[j])
+            ok(v[j] == test_effect_preshader_op_results[i].result[j],
+                    "Operation %s, component %u, expected %#x, got %#x (%g).\n",
+                    test_effect_preshader_op_results[i].comment, j,
+                    test_effect_preshader_op_results[i].result[j], v[j], ((float *)v)[j]);
+    }
+
+    hr = effect->lpVtbl->EndPass(effect);
+
+    par = effect->lpVtbl->GetParameterByName(effect, NULL, "g_iVect");
+    ok(par != NULL, "GetParameterByName failed.\n");
+    hr = effect->lpVtbl->SetVector(effect, par, &fvect2);
+    ok(hr == D3D_OK, "SetVector failed, hr %#x.\n", hr);
+    hr = effect->lpVtbl->BeginPass(effect, 1);
+    todo_wine ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetVertexShader(device, &vshader);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(!!vshader, "Got NULL vshader.\n");
+
+    hr = IDirect3DVertexShader9_GetFunction(vshader, NULL, &byte_code_size);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    byte_code = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, byte_code_size);
+    hr = IDirect3DVertexShader9_GetFunction(vshader, byte_code, &byte_code_size);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(byte_code_size > 1, "Got unexpected byte code size %u.\n", byte_code_size);
+    todo_wine ok(!memcmp(byte_code,
+            &test_effect_preshader_effect_blob[TEST_EFFECT_PRESHADER_VSHADER_POS +
+            TEST_EFFECT_PRESHADER_VSHADER_LEN], byte_code_size),
+            "Incorrect shader selected.\n");
+    HeapFree(GetProcessHeap(), 0, byte_code);
+    IDirect3DVertexShader9_Release(vshader);
+
+    hr = IDirect3DDevice9_SetVertexShader(device, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = effect->lpVtbl->SetVector(effect, par, &fvect1);
+    ok(hr == D3D_OK, "SetVector failed, hr %#x.\n", hr);
+    hr = effect->lpVtbl->CommitChanges(effect);
+    todo_wine ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = IDirect3DDevice9_GetVertexShader(device, &vshader);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(!vshader, "Incorrect shader selected.\n");
+
+    hr = effect->lpVtbl->EndPass(effect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = effect->lpVtbl->End(effect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    effect->lpVtbl->Release(effect);
+}
+
 START_TEST(effect)
 {
     HWND wnd;
@@ -3048,6 +3926,7 @@ START_TEST(effect)
     test_effect_variable_names(device);
     test_effect_compilation_errors(device);
     test_effect_states(device);
+    test_effect_preshader(device);
 
     count = IDirect3DDevice9_Release(device);
     ok(count == 0, "The device was not properly freed: refcount %u\n", count);
-- 
2.5.5

From 31573fbd53063f2604be9fd0994baf76b3e95db1 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Tue, 8 Mar 2016 20:56:14 +0300
Subject: [v5 02/12] d3dx9: Introduce preshaders in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/Makefile.in     |  1 +
 dlls/d3dx9_36/d3dx9_private.h | 36 +++++++++++++++++++
 dlls/d3dx9_36/effect.c        | 80 ++++++++++++++++++++++++++-----------------
 dlls/d3dx9_36/preshader.c     | 41 ++++++++++++++++++++++
 4 files changed, 126 insertions(+), 32 deletions(-)
 create mode 100644 dlls/d3dx9_36/preshader.c

diff --git a/dlls/d3dx9_36/Makefile.in b/dlls/d3dx9_36/Makefile.in
index 95e3045..83f7d1c 100644
--- a/dlls/d3dx9_36/Makefile.in
+++ b/dlls/d3dx9_36/Makefile.in
@@ -11,6 +11,7 @@ C_SRCS = \
 	line.c \
 	math.c \
 	mesh.c \
+	preshader.c \
 	render.c \
 	shader.c \
 	skin.c \
diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index bc9581d..5ba93ac 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -108,4 +108,40 @@ const char *debug_d3dxparameter_registerset(D3DXREGISTER_SET r) DECLSPEC_HIDDEN;
 void set_number(void *outdata, D3DXPARAMETER_TYPE outtype,
         const void *indata, D3DXPARAMETER_TYPE intype) DECLSPEC_HIDDEN;
 
+struct d3dx_param_eval;
+
+struct d3dx_parameter
+{
+    char *name;
+    char *semantic;
+    void *data;
+    D3DXPARAMETER_CLASS class;
+    D3DXPARAMETER_TYPE  type;
+    UINT rows;
+    UINT columns;
+    UINT element_count;
+    UINT annotation_count;
+    UINT member_count;
+    DWORD flags;
+    UINT bytes;
+    DWORD object_id;
+
+    D3DXHANDLE handle;
+
+    struct d3dx_parameter *annotations;
+    struct d3dx_parameter *members;
+
+    struct d3dx_parameter *referenced_param;
+    struct d3dx_param_eval *param_eval;
+};
+
+struct d3dx9_base_effect;
+
+struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
+        struct d3dx_parameter *parameter, const char *name) DECLSPEC_HIDDEN;
+
+HRESULT d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte_code,
+        unsigned int byte_code_size, D3DXPARAMETER_TYPE type, struct d3dx_param_eval **peval) DECLSPEC_HIDDEN;
+void d3dx_free_param_eval(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
+
 #endif /* __WINE_D3DX9_PRIVATE_H */
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 8f82784..964139f 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -94,30 +94,6 @@ enum STATE_TYPE
     ST_ARRAY_SELECTOR,
 };
 
-struct d3dx_parameter
-{
-    char *name;
-    char *semantic;
-    void *data;
-    D3DXPARAMETER_CLASS class;
-    D3DXPARAMETER_TYPE  type;
-    UINT rows;
-    UINT columns;
-    UINT element_count;
-    UINT annotation_count;
-    UINT member_count;
-    DWORD flags;
-    UINT bytes;
-    DWORD object_id;
-
-    D3DXHANDLE handle;
-
-    struct d3dx_parameter *annotations;
-    struct d3dx_parameter *members;
-
-    struct d3dx_parameter *referenced_param;
-};
-
 struct d3dx_object
 {
     UINT size;
@@ -206,8 +182,6 @@ struct ID3DXEffectCompilerImpl
     struct d3dx9_base_effect base_effect;
 };
 
-static struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
-        struct d3dx_parameter *parameter, const char *name);
 static struct d3dx_parameter *get_annotation_by_name(UINT count, struct d3dx_parameter *parameters,
         const char *name);
 static HRESULT d3dx9_parse_state(struct d3dx9_base_effect *base, struct d3dx_state *state,
@@ -535,6 +509,12 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
     TRACE("Free parameter %p, name %s, type %s, child %s\n", param, param->name,
             debug_d3dxparameter_type(param->type), child ? "yes" : "no");
 
+    if (param->param_eval)
+    {
+        d3dx_free_param_eval(param->param_eval);
+        param->param_eval = NULL;
+    }
+
     if (param->annotations)
     {
         for (i = 0; i < param->annotation_count; ++i)
@@ -886,7 +866,7 @@ static struct d3dx_parameter *get_annotation_by_name(UINT count, struct d3dx_par
     return NULL;
 }
 
-static struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
+struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
         struct d3dx_parameter *parameter, const char *name)
 {
     UINT i, count, length;
@@ -5419,6 +5399,7 @@ static HRESULT d3dx9_parse_array_selector(struct d3dx9_base_effect *base, struct
     DWORD string_size;
     struct d3dx_object *object = &base->objects[param->object_id];
     char *ptr = object->data;
+    HRESULT ret;
 
     TRACE("Parsing array entry selection state for parameter %p.\n", param);
 
@@ -5435,9 +5416,30 @@ static HRESULT d3dx9_parse_array_selector(struct d3dx9_base_effect *base, struct
     }
     TRACE("Unknown DWORD: 0x%.8x.\n", *(DWORD *)(ptr + string_size));
 
-    FIXME("Parse preshader.\n");
+    d3dx_create_param_eval(base, (DWORD *)(ptr + string_size) + 1, object->size - (string_size + 1),
+            D3DXPT_INT, &param->param_eval);
+    ret = D3D_OK;
+    param = param->referenced_param;
+    if (param->type == D3DXPT_VERTEXSHADER || param->type == D3DXPT_PIXELSHADER)
+    {
+        unsigned int i;
 
-    return D3D_OK;
+        for (i = 0; i < param->element_count; i++)
+        {
+            if (param->members[i].type != param->type)
+            {
+                FIXME("Unexpected member parameter type %u, expected %u.\n", param->members[i].type, param->type);
+                return D3DXERR_INVALIDDATA;
+            }
+            if (!param->members[i].param_eval)
+            {
+                TRACE("Creating preshader for object %u.\n", param->members[i].object_id);
+                object = &base->objects[param->members[i].object_id];
+                d3dx_create_param_eval(base, object->data, object->size, param->type, &param->members[i].param_eval);
+            }
+        }
+    }
+    return ret;
 }
 
 static HRESULT d3dx9_parse_resource(struct d3dx9_base_effect *base, const char *data, const char **ptr)
@@ -5543,7 +5545,11 @@ static HRESULT d3dx9_parse_resource(struct d3dx9_base_effect *base, const char *
                         return hr;
 
                     if (object->data)
-                        hr = d3dx9_create_object(base, object);
+                    {
+                        if (FAILED(hr = d3dx9_create_object(base, object)))
+                            return hr;
+                        d3dx_create_param_eval(base, object->data, object->size, param->type, &param->param_eval);
+                    }
                     break;
 
                 case D3DXPT_BOOL:
@@ -5551,7 +5557,9 @@ static HRESULT d3dx9_parse_resource(struct d3dx9_base_effect *base, const char *
                 case D3DXPT_FLOAT:
                 case D3DXPT_STRING:
                     state->type = ST_FXLC;
-                    hr = d3dx9_copy_data(&base->objects[param->object_id], ptr);
+                    if (FAILED(hr = d3dx9_copy_data(&base->objects[param->object_id], ptr)))
+                        return hr;
+                    d3dx_create_param_eval(base, object->data, object->size, param->type, &param->param_eval);
                     break;
 
                 default:
@@ -5569,7 +5577,15 @@ static HRESULT d3dx9_parse_resource(struct d3dx9_base_effect *base, const char *
             param->referenced_param = get_parameter_by_name(base, NULL, object->data);
             if (param->referenced_param)
             {
-                TRACE("Mapping to parameter %p.\n", param->referenced_param);
+                struct d3dx_parameter *refpar = param->referenced_param;
+
+                TRACE("Mapping to parameter %p, having object id %u.\n", refpar, refpar->object_id);
+                if (refpar->type == D3DXPT_VERTEXSHADER || refpar->type == D3DXPT_PIXELSHADER)
+                {
+                    struct d3dx_object *refobj = &base->objects[refpar->object_id];
+
+                    d3dx_create_param_eval(base, refobj->data, refobj->size, refpar->type, &refpar->param_eval);
+                }
             }
             else
             {
diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
new file mode 100644
index 0000000..d865fd0
--- /dev/null
+++ b/dlls/d3dx9_36/preshader.c
@@ -0,0 +1,41 @@
+/*
+ * Copyright 2016 Paul Gofman
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#include "d3dx9_private.h"
+
+#include <float.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
+
+HRESULT d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte_code, unsigned int byte_code_size,
+        D3DXPARAMETER_TYPE type, struct d3dx_param_eval **peval_out)
+{
+    FIXME("stub, base_effect %p, byte_code %p, byte_code_size %u, type %u, peval_out %p.\n",
+            base_effect, byte_code, byte_code_size, type, peval_out);
+
+    *peval_out = NULL;
+    return E_NOTIMPL;
+}
+
+void d3dx_free_param_eval(struct d3dx_param_eval *peval)
+{
+    FIXME("stub, peval %p.\n", peval);
+}
-- 
2.5.5

From f69eed43fa3a906cf1c6c6bcee790a8ff38a96f5 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Mon, 21 Mar 2016 16:28:29 +0300
Subject: [v5 03/12] d3dx9: Implement preshader parsing.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/d3dx9_private.h |  56 ++++-
 dlls/d3dx9_36/preshader.c     | 518 +++++++++++++++++++++++++++++++++++++++++-
 2 files changed, 570 insertions(+), 4 deletions(-)

diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index 5ba93ac..c3c8cb4 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -108,7 +108,61 @@ const char *debug_d3dxparameter_registerset(D3DXREGISTER_SET r) DECLSPEC_HIDDEN;
 void set_number(void *outdata, D3DXPARAMETER_TYPE outtype,
         const void *indata, D3DXPARAMETER_TYPE intype) DECLSPEC_HIDDEN;
 
-struct d3dx_param_eval;
+struct d3dx_parameter;
+
+enum PRES_REG_TABLES
+{
+    PRES_REGTAB_NONE,
+    PRES_REGTAB_IMMED, /* immediate double constants from CLIT */
+    PRES_REGTAB_CONST,
+    PRES_REGTAB_VERTEX, /* not used */
+    PRES_REGTAB_OCONST,
+    PRES_REGTAB_OBCONST,
+    PRES_REGTAB_OICONST,
+    PRES_REGTAB_REG,
+    PRES_REGTAB_MAX,
+    PRES_REGTAB_FIRST = PRES_REGTAB_IMMED,
+    PRES_REGTAB_LAST = PRES_REGTAB_REG,
+};
+
+struct d3dx_const_tab
+{
+    unsigned int input_count;
+    D3DXCONSTANT_DESC *inputs;
+    struct d3dx_parameter **inputs_param;
+    ID3DXConstantTable *ctab;
+    /* TODO: do not keep input constant structure
+       (use it only at the parse stage) */
+    const enum PRES_REG_TABLES *regset2table;
+};
+
+struct d3dx_regstore
+{
+    void *tables[PRES_REGTAB_MAX];
+    unsigned int table_sizes[PRES_REGTAB_MAX]; /* registers count */
+    unsigned int *table_value_set[PRES_REGTAB_MAX];
+};
+
+struct d3dx_pres_ins;
+
+struct d3dx_preshader
+{
+    struct d3dx_regstore regs;
+
+    unsigned int ins_count;
+    struct d3dx_pres_ins *ins;
+
+    struct d3dx_const_tab inputs;
+};
+
+
+struct d3dx_param_eval
+{
+    D3DXPARAMETER_TYPE param_type;
+
+    struct d3dx_preshader pres;
+    struct d3dx_const_tab shader_inputs;
+};
 
 struct d3dx_parameter
 {
diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index d865fd0..99a418f 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -25,17 +25,529 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
+enum PRES_OPS
+{
+    PRESHADER_OP_NOP,
+    PRESHADER_OP_MOV,
+    PRESHADER_OP_MAX_ENUM
+};
+
+typedef float (*pres_op_func)(float *args, int ncomp);
+
+static float pres_mov(float *args, int ncomp) {return args[0];}
+
+#define PRES_OPCODE_MASK 0x7ff00000
+#define PRES_OPCODE_SHIFT 20
+#define PRES_SCALAR_FLAG 0x80000000
+#define PRES_NCOMP_MASK  0x0000ffff
+
+#define FOURCC_PRES 0x53455250
+#define FOURCC_CLIT 0x54494c43
+#define FOURCC_FXLC 0x434c5846
+#define FOURCC_PRSI 0x49535250
+#define PRES_SIGN 0x46580000
+
+struct op_info
+{
+    unsigned int opcode;
+    char mnem[8];
+    unsigned int input_count;
+    BOOL func_all_comps;
+    pres_op_func func;
+};
+
+static struct op_info pres_op_info[] =
+{
+    {0x000, "nop", 0, 0, NULL    }, /* PRESHADER_OP_NOP */
+    {0x100, "mov", 1, 0, pres_mov}, /* PRESHADER_OP_MOV */
+};
+
+enum PRES_VALUE_TYPE
+{
+    PRES_VT_FLOAT,
+    PRES_VT_DOUBLE,
+    PRES_VT_INT,
+    PRES_VT_BOOL
+};
+
+static const struct
+{
+    unsigned int component_size;
+    unsigned int reg_component_count;
+    enum PRES_VALUE_TYPE type;
+}
+table_info[] =
+{
+    {0, 0},
+    {sizeof(double), 1, PRES_VT_DOUBLE}, /* PRES_REGTAB_IMMED */
+    {sizeof(float),  4, PRES_VT_FLOAT }, /* PRES_REGTAB_CONST */
+    {sizeof(float),  4, PRES_VT_FLOAT }, /* PRES_REGTAB_VERTEX */
+    {sizeof(float),  4, PRES_VT_FLOAT }, /* PRES_REGTAB_OCONST */
+    {sizeof(BOOL),   1, PRES_VT_BOOL  }, /* PRES_REGTAB_OBCONST */
+    {sizeof(int),    4, PRES_VT_INT,  }, /* PRES_REGTAB_OICONST */
+    /* TODO: use double precision for 64 bit */
+    {sizeof(float),  4, PRES_VT_FLOAT }  /* PRES_REGTAB_REG */
+};
+
+#define OFFSET2REG(table, offset) ((offset) / table_info[table].reg_component_count)
+
+static const enum PRES_REG_TABLES pres_regset2table[] =
+{
+    PRES_REGTAB_OBCONST,  /* D3DXRS_BOOL */
+    PRES_REGTAB_OICONST,  /* D3DXRS_INT4 */
+    PRES_REGTAB_CONST,    /* D3DXRS_FLOAT4 */
+    PRES_REGTAB_NONE,     /* D3DXRS_SAMPLER */
+};
+
+static const enum PRES_REG_TABLES shad_regset2table[] =
+{
+    PRES_REGTAB_OBCONST,  /* D3DXRS_BOOL */
+    PRES_REGTAB_OICONST,  /* D3DXRS_INT4 */
+    PRES_REGTAB_OCONST,   /* D3DXRS_FLOAT4 */
+    PRES_REGTAB_NONE,     /* D3DXRS_SAMPLER */
+};
+
+struct d3dx_pres_operand
+{
+    enum PRES_REG_TABLES table;
+    /* offset is component index, not register index, e. g.
+       offset for component c3.y is 13 (3 * 4 + 1) */
+    unsigned int offset;
+};
+
+struct d3dx_pres_ins
+{
+    enum PRES_OPS op;
+    /* first input argument is scalar,
+       scalar component is propagated */
+    BOOL scalar_op;
+    unsigned int component_count;
+    struct d3dx_pres_operand inputs[3];
+    struct d3dx_pres_operand output;
+};
+
+#define PRES_BITMASK_BLOCK_SIZE (sizeof(unsigned int) * 8)
+
+static HRESULT regstore_alloc_table(struct d3dx_regstore *rs, unsigned int table)
+{
+    unsigned int sz;
+
+    sz = rs->table_sizes[table] * table_info[table].reg_component_count * table_info[table].component_size;
+    if (sz)
+    {
+        rs->tables[table] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sz);
+        rs->table_value_set[table] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(*rs->table_value_set[table]) *
+                    ((rs->table_sizes[table] + PRES_BITMASK_BLOCK_SIZE - 1) / PRES_BITMASK_BLOCK_SIZE));
+        if (!rs->tables[table] || !rs->table_value_set[table])
+            return E_OUTOFMEMORY;
+    }
+    return D3D_OK;
+}
+
+static void regstore_free_tables(struct d3dx_regstore *rs)
+{
+    unsigned int i;
+
+    for (i = PRES_REGTAB_FIRST; i <= PRES_REGTAB_LAST; ++i)
+    {
+        if (rs->tables[i])
+            HeapFree(GetProcessHeap(), 0, rs->tables[i]);
+        if (rs->table_value_set[i])
+            HeapFree(GetProcessHeap(), 0, rs->table_value_set[i]);
+    }
+}
+
+static void regstore_set_values(struct d3dx_regstore *rs, unsigned int table, void *data,
+        unsigned int start_offset, unsigned int count)
+{
+    unsigned int reg_idx;
+
+    if (!count)
+        return;
+
+    memcpy((BYTE *)rs->tables[table] + start_offset * table_info[table].component_size,
+        data, count * table_info[table].component_size);
+    for (reg_idx = OFFSET2REG(table, start_offset); reg_idx <= OFFSET2REG(table, start_offset + count - 1);
+            ++reg_idx)
+        rs->table_value_set[table][reg_idx / PRES_BITMASK_BLOCK_SIZE] |=
+                1u << (reg_idx % PRES_BITMASK_BLOCK_SIZE);
+}
+
+static void dump_bytecode(void *data, unsigned int size)
+{
+    unsigned int *bytecode = (unsigned int *)data;
+    unsigned int i, j, n;
+
+    size /= 4;
+    i = 0;
+    while (i < size)
+    {
+        n = min(size - i, 8);
+        for (j = 0; j < n; ++j)
+            TRACE("0x%08x,", bytecode[i + j]);
+        i += n;
+        TRACE("\n");
+    }
+}
+
+static unsigned int *find_bytecode_comment(unsigned int *ptr, unsigned int fourcc)
+{
+    while ((*ptr & 0xffff) == 0xfffe)
+    {
+        if (*(ptr + 1) == fourcc)
+            return ptr + 2;
+        ptr += 1 + (*ptr >> 16);
+    }
+    return NULL;
+}
+
+static unsigned int *parse_pres_arg(unsigned int *ptr, struct d3dx_pres_operand *opr)
+{
+    if (*ptr)
+    {
+        FIXME("Relative addressing not supported yet, word %#x.\n", *ptr);
+        return NULL;
+    }
+    ptr++;
+
+    if (*ptr < PRES_REGTAB_FIRST || *ptr > PRES_REGTAB_LAST || *ptr == PRES_REGTAB_VERTEX)
+    {
+        FIXME("Unsupported argument table %#x.\n", *ptr);
+        return NULL;
+    }
+    opr->table = *ptr;
+    ++ptr;
+    opr->offset = *ptr;
+    ++ptr;
+
+    if (opr->table == PRES_REGTAB_OBCONST)
+        opr->offset /= 4;
+    return ptr;
+}
+
+static unsigned int *parse_pres_ins(unsigned int *ptr, struct d3dx_pres_ins *ins)
+{
+    unsigned int ins_code, ins_raw;
+    unsigned int input_count;
+    unsigned int i;
+
+    ins_raw = *ptr;
+    ins_code = (ins_raw & PRES_OPCODE_MASK) >> PRES_OPCODE_SHIFT;
+    ins->component_count = ins_raw & PRES_NCOMP_MASK;
+    ins->scalar_op = !!(ins_raw & PRES_SCALAR_FLAG);
+
+    if (ins->component_count < 1 || ins->component_count > 4)
+    {
+        FIXME("Unsupported number of components %u.\n", ins->component_count);
+        return NULL;
+    }
+    ++ptr;
+    input_count = *ptr++;
+    for (i = 0; i < PRESHADER_OP_MAX_ENUM; ++i)
+        if (ins_code == pres_op_info[i].opcode)
+            break;
+    if (i == PRESHADER_OP_MAX_ENUM)
+    {
+        FIXME("Unknown opcode %#x, raw %#x.\n", ins_code, ins_raw);
+        return NULL;
+    }
+    ins->op = i;
+    if (input_count != pres_op_info[i].input_count)
+    {
+        FIXME("Actual input args %u, expected %u, instruction %s.\n", input_count,
+                pres_op_info[i].input_count, pres_op_info[i].mnem);
+        return NULL;
+    }
+    for (i = 0; i < input_count; ++i)
+    {
+        ptr = parse_pres_arg(ptr, &ins->inputs[i]);
+        if (!ptr)
+            return NULL;
+    }
+    ptr = parse_pres_arg(ptr, &ins->output);
+    return ptr;
+}
+
+static HRESULT get_constants_desc(unsigned int *byte_code, struct d3dx_const_tab *out, struct d3dx9_base_effect *base)
+{
+    ID3DXConstantTable *ctab;
+    D3DXCONSTANT_DESC *cdesc;
+    struct d3dx_parameter **inputs_param;
+    D3DXCONSTANTTABLE_DESC desc;
+    HRESULT hr;
+    D3DXHANDLE hc;
+    unsigned int i;
+    unsigned int count;
+
+    out->inputs = cdesc = NULL;
+    out->ctab = NULL;
+    out->inputs_param = NULL;
+    out->input_count = 0;
+    inputs_param = NULL;
+    hr = D3DXGetShaderConstantTable(byte_code, &ctab);
+    if (FAILED(hr) || !ctab)
+    {
+        TRACE("Could not get CTAB data, hr %#x.\n", hr);
+        /* returning OK, shaders and preshaders without CTAB are valid */
+        return D3D_OK;
+    }
+    hr = ID3DXConstantTable_GetDesc(ctab, &desc);
+    if (FAILED(hr))
+    {
+        FIXME("Could not get CTAB desc, hr %#x.\n", hr);
+        goto err_out;
+    }
+
+    cdesc = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cdesc) * desc.Constants);
+    inputs_param = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*inputs_param) * desc.Constants);
+    for (i = 0; i < desc.Constants; ++i)
+    {
+        hc = ID3DXConstantTable_GetConstant(ctab, NULL, i);
+        if (!hc)
+        {
+            FIXME("Null constant handle.\n");
+            goto err_out;
+        }
+        count = 1;
+        hr = ID3DXConstantTable_GetConstantDesc(ctab, hc, &cdesc[i], &count);
+        if (FAILED(hr))
+        {
+            FIXME("Could not get constant desc, hr %#x.\n", hr);
+            goto err_out;
+        }
+        inputs_param[i] = get_parameter_by_name(base, NULL, cdesc[i].Name);
+        if (cdesc[i].Class == D3DXPC_OBJECT)
+            TRACE("Object %s, parameter %p.\n", cdesc[i].Name, inputs_param[i]);
+        else if (!inputs_param[i])
+            ERR("Could not find parameter %s in effect.\n", cdesc[i].Name);
+    }
+    out->input_count = desc.Constants;
+    out->inputs = cdesc;
+    out->inputs_param = inputs_param;
+    out->ctab = ctab;
+    return D3D_OK;
+
+err_out:
+    if (cdesc)
+        HeapFree(GetProcessHeap(), 0, cdesc);
+    if (inputs_param)
+        HeapFree(GetProcessHeap(), 0, inputs_param);
+    if (ctab)
+        ID3DXConstantTable_Release(ctab);
+    return hr;
+}
+
+static void update_table_sizes_consts(unsigned int *table_sizes, struct d3dx_const_tab *ctab)
+{
+    unsigned int i, table, max_offset;
+
+    for (i = 0; i < ctab->input_count; ++i)
+    {
+        max_offset = ctab->inputs[i].RegisterIndex + ctab->inputs[i].RegisterCount;
+        table = ctab->regset2table[ctab->inputs[i].RegisterSet];
+        table_sizes[table] = max(table_sizes[table], max_offset);
+    }
+}
+
+static HRESULT parse_preshader(struct d3dx_preshader *pres, unsigned int *ptr, struct d3dx9_base_effect *base)
+{
+    unsigned int *p;
+    unsigned int i, j, const_count, max_offset;
+    double *dconst;
+    HRESULT hr;
+    unsigned int saved_word;
+
+    TRACE("Preshader version %#x.\n", *ptr & 0xffff);
+
+    p = find_bytecode_comment(ptr + 1, FOURCC_CLIT);
+    if (p)
+    {
+        const_count = *p;
+        dconst = (double *)(p + 1);
+    }
+    else
+    {
+        const_count = 0;
+        dconst = NULL;
+    }
+    TRACE("%u double constants.\n", const_count);
+
+    p = find_bytecode_comment(ptr + 1, FOURCC_FXLC);
+    if (!p)
+    {
+        WARN("Could not find preshader code.\n");
+        return D3D_OK;
+    }
+
+    pres->ins_count = *p;
+    TRACE("%u instructions.\n", pres->ins_count);
+    ++p;
+    pres->ins = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pres->ins) * pres->ins_count);
+    for (i = 0; i < pres->ins_count; ++i)
+    {
+        p = parse_pres_ins(p, &pres->ins[i]);
+        if (!p)
+            return D3DXERR_INVALIDDATA;
+    }
+
+    saved_word = *ptr;
+    *ptr = 0xfffe0000;
+    hr = get_constants_desc(ptr, &pres->inputs, base);
+    *ptr = saved_word;
+    if (FAILED(hr))
+        return hr;
+
+    pres->inputs.regset2table = pres_regset2table;
+
+    pres->regs.table_sizes[PRES_REGTAB_IMMED] = const_count;
+
+    for (i = 0; i < pres->ins_count; ++i)
+    {
+        unsigned int table;
+
+        for (j = 0; j < pres_op_info[pres->ins[i].op].input_count; ++j)
+        {
+            table = pres->ins[i].inputs[j].table;
+            max_offset = OFFSET2REG(table, pres->ins[i].inputs[j].offset + pres->ins[i].component_count - 1);
+            pres->regs.table_sizes[table] = max(pres->regs.table_sizes[table], max_offset + 1);
+        }
+        table = pres->ins[i].output.table;
+        max_offset = OFFSET2REG(table, pres->ins[i].output.offset + pres->ins[i].component_count - 1);
+        pres->regs.table_sizes[table] = max(pres->regs.table_sizes[table], max_offset + 1);
+    }
+    update_table_sizes_consts(pres->regs.table_sizes, &pres->inputs);
+    if (FAILED(regstore_alloc_table(&pres->regs, PRES_REGTAB_IMMED)))
+        return E_OUTOFMEMORY;
+    regstore_set_values(&pres->regs, PRES_REGTAB_IMMED, dconst, 0, const_count);
+
+    return D3D_OK;
+}
+
 HRESULT d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte_code, unsigned int byte_code_size,
         D3DXPARAMETER_TYPE type, struct d3dx_param_eval **peval_out)
 {
-    FIXME("stub, base_effect %p, byte_code %p, byte_code_size %u, type %u, peval_out %p.\n",
+    struct d3dx_param_eval *peval;
+    HRESULT hr;
+    unsigned int *ptr;
+    unsigned int i;
+    BOOL shader;
+
+    TRACE("base_effect %p, byte_code %p, byte_code_size %u, type %u, peval_out %p.\n",
             base_effect, byte_code, byte_code_size, type, peval_out);
 
+    if (!byte_code)
+    {
+        *peval_out = NULL;
+        return D3DERR_INVALIDCALL;
+    }
+
+    peval = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*peval));
+    if (!peval)
+    {
+        hr = E_OUTOFMEMORY;
+        goto err_out;
+    }
+
+    peval->param_type = type;
+    switch (type)
+    {
+        case D3DXPT_VERTEXSHADER:
+        case D3DXPT_PIXELSHADER:
+            shader = TRUE;
+            break;
+        default:
+            shader = FALSE;
+            break;
+    }
+    peval->shader_inputs.regset2table = shad_regset2table;
+
+    ptr = (unsigned int *)byte_code;
+    if (shader)
+    {
+        if ((*ptr & 0xfffe0000) != 0xfffe0000)
+        {
+            FIXME("Invalid shader signature %#x.\n", *ptr);
+            hr = D3DXERR_INVALIDDATA;
+            goto err_out;
+        }
+        TRACE("Shader version %#x.\n", *ptr & 0xffff);
+
+        hr = get_constants_desc(ptr, &peval->shader_inputs, base_effect);
+        if (FAILED(hr))
+        {
+            FIXME("Could not get shader constant table, hr %#x.\n", hr);
+            goto err_out;
+        }
+        update_table_sizes_consts(peval->pres.regs.table_sizes, &peval->shader_inputs);
+        ptr++;
+        ptr = find_bytecode_comment(ptr, FOURCC_PRES);
+        if (!ptr)
+            TRACE("No preshader found.\n");
+    }
+    if (ptr)
+    {
+        hr = parse_preshader(&peval->pres, ptr, base_effect);
+        if (FAILED(hr))
+        {
+            FIXME("Failed parsing preshader, byte code for analysis follows.\n");
+            dump_bytecode(byte_code, byte_code_size);
+            goto err_out;
+        }
+    }
+
+    for (i = PRES_REGTAB_IMMED + 1; i <= PRES_REGTAB_LAST; ++i)
+    {
+        TRACE("table_sizes[%u] %u.\n", i, peval->pres.regs.table_sizes[i]);
+        if (FAILED(regstore_alloc_table(&peval->pres.regs, i)))
+        {
+            hr = E_OUTOFMEMORY;
+            goto err_out;
+        }
+    }
+
+    if (TRACE_ON(d3dx))
+        dump_bytecode(byte_code, byte_code_size);
+
+    *peval_out = peval;
+    TRACE("retval %u, *peval_out %p.\n", D3D_OK, *peval_out);
+    return D3D_OK;
+
+err_out:
+    FIXME("Error creating parameter evaluator.\n");
+    d3dx_free_param_eval(peval);
     *peval_out = NULL;
-    return E_NOTIMPL;
+    TRACE("retval %u, *peval_out %p.\n", hr, *peval_out);
+    return hr;
+}
+
+static void d3dx_free_const_tab(struct d3dx_const_tab *ctab)
+{
+    if (ctab->inputs)
+        HeapFree(GetProcessHeap(), 0, ctab->inputs);
+    if (ctab->inputs_param)
+        HeapFree(GetProcessHeap(), 0, ctab->inputs_param);
+    if (ctab->ctab)
+        ID3DXConstantTable_Release(ctab->ctab);
+}
+
+static void d3dx_free_preshader(struct d3dx_preshader *pres)
+{
+    if (pres->ins)
+        HeapFree(GetProcessHeap(), 0, pres->ins);
+
+    regstore_free_tables(&pres->regs);
+    d3dx_free_const_tab(&pres->inputs);
 }
 
 void d3dx_free_param_eval(struct d3dx_param_eval *peval)
 {
-    FIXME("stub, peval %p.\n", peval);
+    TRACE("peval %p.\n", peval);
+
+    if (!peval)
+        return;
+
+    d3dx_free_preshader(&peval->pres);
+    d3dx_free_const_tab(&peval->shader_inputs);
+    HeapFree(GetProcessHeap(), 0, peval);
 }
-- 
2.5.5

From 79c22fe7c714928c09567011dbb0b6ce9e9f3266 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Mon, 21 Mar 2016 16:30:02 +0300
Subject: [v5 04/12] d3dx9: Implement preshaders disassembly dump.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/preshader.c | 73 ++++++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 72 insertions(+), 1 deletion(-)

diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index 99a418f..79fdc5e 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -89,6 +89,11 @@ table_info[] =
     {sizeof(float),  4, PRES_VT_FLOAT }  /* PRES_REGTAB_REG */
 };
 
+static const char *table_symbol[] =
+{
+    "(null)", "imm", "c", "v", "oc", "ob", "oi", "r"
+};
+
 #define OFFSET2REG(table, offset) ((offset) / table_info[table].reg_component_count)
 
 static const enum PRES_REG_TABLES pres_regset2table[] =
@@ -350,6 +355,65 @@ static void update_table_sizes_consts(unsigned int *table_sizes, struct d3dx_con
     }
 }
 
+static void dump_arg(struct d3dx_regstore *rs, struct d3dx_pres_operand *arg, int component_count)
+{
+    static const char *xyzw_str = "xyzw";
+    unsigned int i, table;
+
+    table = arg->table;
+    if (table == PRES_REGTAB_IMMED)
+    {
+        TRACE("(");
+        for (i = 0; i < component_count; ++i)
+            TRACE(i < component_count - 1 ? "%.16e, " : "%.16e",
+                    ((double *)rs->tables[PRES_REGTAB_IMMED])[arg->offset + i]);
+        TRACE(")");
+    }
+    else
+    {
+        TRACE("%s%u.", table_symbol[table], OFFSET2REG(table, arg->offset));
+        for (i = 0; i < component_count; ++i)
+            TRACE("%c", xyzw_str[(arg->offset + i) % 4]);
+    }
+}
+
+static void dump_registers(struct d3dx_const_tab *ctab)
+{
+    unsigned int table, i;
+
+    for (i = 0; i < ctab->input_count; ++i)
+    {
+        table = ctab->regset2table[ctab->inputs[i].RegisterSet];
+        TRACE("//   %-12s %s%-4u %u\n", ctab->inputs_param[i] ? ctab->inputs_param[i]->name : "(nil)",
+                table_symbol[table], ctab->inputs[i].RegisterIndex, ctab->inputs[i].RegisterCount);
+    }
+}
+
+static void dump_ins(struct d3dx_regstore *rs, struct d3dx_pres_ins *ins)
+{
+    unsigned int i;
+
+    TRACE("    %s ", pres_op_info[ins->op].mnem);
+    dump_arg(rs, &ins->output, pres_op_info[ins->op].func_all_comps ? 1 : ins->component_count);
+    for (i = 0; i < pres_op_info[ins->op].input_count; ++i)
+    {
+        TRACE(", ");
+        dump_arg(rs, &ins->inputs[i], ins->scalar_op && !i ? 1 : ins->component_count);
+    }
+    TRACE("\n");
+}
+
+static void dump_preshader(struct d3dx_preshader *pres)
+{
+    unsigned int i;
+
+    TRACE("// Preshader registers:\n");
+    dump_registers(&pres->inputs);
+    TRACE("    preshader\n");
+    for (i = 0; i < pres->ins_count; ++i)
+        dump_ins(&pres->regs, &pres->ins[i]);
+}
+
 static HRESULT parse_preshader(struct d3dx_preshader *pres, unsigned int *ptr, struct d3dx9_base_effect *base)
 {
     unsigned int *p;
@@ -507,8 +571,15 @@ HRESULT d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte
     }
 
     if (TRACE_ON(d3dx))
+    {
         dump_bytecode(byte_code, byte_code_size);
-
+        dump_preshader(&peval->pres);
+        if (shader)
+        {
+            TRACE("// Shader registers:\n");
+            dump_registers(&peval->shader_inputs);
+        }
+    }
     *peval_out = peval;
     TRACE("retval %u, *peval_out %p.\n", D3D_OK, *peval_out);
     return D3D_OK;
-- 
2.5.5

From 4942b6116fba326bea3ab343c10db7283876596e Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Wed, 9 Mar 2016 15:30:35 +0300
Subject: [v5 05/12] d3dx9: Implement fxlc constants (expressions) in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/d3dx9_private.h |   2 +
 dlls/d3dx9_36/effect.c        |  76 +++++++-----
 dlls/d3dx9_36/preshader.c     | 280 ++++++++++++++++++++++++++++++++++++++++++
 dlls/d3dx9_36/tests/effect.c  |   4 +-
 4 files changed, 329 insertions(+), 33 deletions(-)

diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index c3c8cb4..27b6978 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -197,5 +197,7 @@ struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
 HRESULT d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte_code,
         unsigned int byte_code_size, D3DXPARAMETER_TYPE type, struct d3dx_param_eval **peval) DECLSPEC_HIDDEN;
 void d3dx_free_param_eval(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
+HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval,
+        struct d3dx_parameter *param, void **param_value) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_D3DX9_PRIVATE_H */
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 964139f..232fc37 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -2493,13 +2493,19 @@ static HRESULT d3dx9_base_effect_set_array_range(struct d3dx9_base_effect *base,
 static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
         struct d3dx_state *state, void **param_value, struct d3dx_parameter **out_param)
 {
-    struct d3dx_parameter *param;
-    param = state->parameter.referenced_param ? state->parameter.referenced_param : &state->parameter;
+    struct d3dx_parameter *param = &state->parameter;
+
+    *param_value = param->data;
+    *out_param = param;
 
     switch (state->type)
     {
         case ST_CONSTANT:
+            *param_value = param->data;
+            *out_param = param;
+            return D3D_OK;
         case ST_PARAMETER:
+            param = param->referenced_param;
             *param_value = param->data;
             *out_param = param;
             return D3D_OK;
@@ -2507,8 +2513,16 @@ static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct
             FIXME("Array selector.\n");
             break;
         case ST_FXLC:
-            FIXME("FXLC not supported yet.\n");
-            break;
+            if (param->param_eval)
+            {
+                *out_param = param;
+                return d3dx_evaluate_parameter(param->param_eval, param, param_value);
+            }
+            else
+            {
+                FIXME("No preshader for FXLC parameter.\n");
+                break;
+            }
     }
     *param_value = NULL;
     *out_param = NULL;
@@ -2524,19 +2538,19 @@ static void d3dx9_set_light_parameter(enum LIGHT_TYPE op, D3DLIGHT9 *light, void
     }
     light_tbl[] =
     {
-       {FIELD_OFFSET(D3DLIGHT9, Type),         "LC_TYPE"},
-       {FIELD_OFFSET(D3DLIGHT9, Diffuse),      "LT_DIFFUSE"},
-       {FIELD_OFFSET(D3DLIGHT9, Specular),     "LT_SPECULAR"},
-       {FIELD_OFFSET(D3DLIGHT9, Ambient),      "LT_AMBIENT"},
-       {FIELD_OFFSET(D3DLIGHT9, Position),     "LT_POSITION"},
-       {FIELD_OFFSET(D3DLIGHT9, Direction),    "LT_DIRECTION"},
-       {FIELD_OFFSET(D3DLIGHT9, Range),        "LT_RANGE"},
-       {FIELD_OFFSET(D3DLIGHT9, Falloff),      "LT_FALLOFF"},
-       {FIELD_OFFSET(D3DLIGHT9, Attenuation0), "LT_ATTENUATION0"},
-       {FIELD_OFFSET(D3DLIGHT9, Attenuation1), "LT_ATTENUATION1"},
-       {FIELD_OFFSET(D3DLIGHT9, Attenuation2), "LT_ATTENUATION2"},
-       {FIELD_OFFSET(D3DLIGHT9, Theta),        "LT_THETA"},
-       {FIELD_OFFSET(D3DLIGHT9, Phi),          "LT_PHI"}
+        {FIELD_OFFSET(D3DLIGHT9, Type),         "LC_TYPE"},
+        {FIELD_OFFSET(D3DLIGHT9, Diffuse),      "LT_DIFFUSE"},
+        {FIELD_OFFSET(D3DLIGHT9, Specular),     "LT_SPECULAR"},
+        {FIELD_OFFSET(D3DLIGHT9, Ambient),      "LT_AMBIENT"},
+        {FIELD_OFFSET(D3DLIGHT9, Position),     "LT_POSITION"},
+        {FIELD_OFFSET(D3DLIGHT9, Direction),    "LT_DIRECTION"},
+        {FIELD_OFFSET(D3DLIGHT9, Range),        "LT_RANGE"},
+        {FIELD_OFFSET(D3DLIGHT9, Falloff),      "LT_FALLOFF"},
+        {FIELD_OFFSET(D3DLIGHT9, Attenuation0), "LT_ATTENUATION0"},
+        {FIELD_OFFSET(D3DLIGHT9, Attenuation1), "LT_ATTENUATION1"},
+        {FIELD_OFFSET(D3DLIGHT9, Attenuation2), "LT_ATTENUATION2"},
+        {FIELD_OFFSET(D3DLIGHT9, Theta),        "LT_THETA"},
+        {FIELD_OFFSET(D3DLIGHT9, Phi),          "LT_PHI"}
     };
     switch (op)
     {
@@ -2550,8 +2564,8 @@ static void d3dx9_set_light_parameter(enum LIGHT_TYPE op, D3DLIGHT9 *light, void
         {
             D3DCOLORVALUE c = *(D3DCOLORVALUE *)value;
 
-            TRACE("%s (%f %f %f %f).\n", light_tbl[op].name, c.r, c.g, c.b, c.a);
-            *(D3DCOLORVALUE *)((char *)light + light_tbl[op].offset) = c;
+            TRACE("%s (%.8e %.8e %.8e %.8e).\n", light_tbl[op].name, c.r, c.g, c.b, c.a);
+            *(D3DCOLORVALUE *)((BYTE *)light + light_tbl[op].offset) = c;
             break;
         }
         case LT_POSITION:
@@ -2559,8 +2573,8 @@ static void d3dx9_set_light_parameter(enum LIGHT_TYPE op, D3DLIGHT9 *light, void
         {
             D3DVECTOR v = *(D3DVECTOR *)value;
 
-            TRACE("%s (%f %f %f).\n", light_tbl[op].name, v.x, v.y, v.z);
-            *(D3DVECTOR *)((char *)light + light_tbl[op].offset) = v;
+            TRACE("%s (%.8e %.8e %.8e).\n", light_tbl[op].name, v.x, v.y, v.z);
+            *(D3DVECTOR *)((BYTE *)light + light_tbl[op].offset) = v;
             break;
         }
         case LT_RANGE:
@@ -2572,8 +2586,8 @@ static void d3dx9_set_light_parameter(enum LIGHT_TYPE op, D3DLIGHT9 *light, void
         case LT_PHI:
         {
             float v = *(float *)value;
-            TRACE("%s %f.\n", light_tbl[op].name, v);
-            *(float *)((char *)light + light_tbl[op].offset) = v;
+            TRACE("%s %.8e.\n", light_tbl[op].name, v);
+            *(float *)((BYTE *)light + light_tbl[op].offset) = v;
             break;
         }
         default:
@@ -2591,11 +2605,11 @@ static void d3dx9_set_material_parameter(enum MATERIAL_TYPE op, D3DMATERIAL9 *ma
     }
     material_tbl[] =
     {
-       {FIELD_OFFSET(D3DMATERIAL9, Diffuse),  "MT_DIFFUSE"},
-       {FIELD_OFFSET(D3DMATERIAL9, Ambient),  "MT_AMBIENT"},
-       {FIELD_OFFSET(D3DMATERIAL9, Specular), "MT_SPECULAR"},
-       {FIELD_OFFSET(D3DMATERIAL9, Emissive), "MT_EMISSIVE"},
-       {FIELD_OFFSET(D3DMATERIAL9, Power),    "MT_POWER"}
+        {FIELD_OFFSET(D3DMATERIAL9, Diffuse),  "MT_DIFFUSE"},
+        {FIELD_OFFSET(D3DMATERIAL9, Ambient),  "MT_AMBIENT"},
+        {FIELD_OFFSET(D3DMATERIAL9, Specular), "MT_SPECULAR"},
+        {FIELD_OFFSET(D3DMATERIAL9, Emissive), "MT_EMISSIVE"},
+        {FIELD_OFFSET(D3DMATERIAL9, Power),    "MT_POWER"}
     };
 
     switch (op)
@@ -2604,7 +2618,7 @@ static void d3dx9_set_material_parameter(enum MATERIAL_TYPE op, D3DMATERIAL9 *ma
         {
             float v = *(float *)value;
 
-            TRACE("%s %f.\n", material_tbl[op].name, v);
+            TRACE("%s %.8e.\n", material_tbl[op].name, v);
             material->Power = v;
             break;
         }
@@ -2615,8 +2629,8 @@ static void d3dx9_set_material_parameter(enum MATERIAL_TYPE op, D3DMATERIAL9 *ma
         {
             D3DCOLORVALUE c = *(D3DCOLORVALUE *)value;
 
-            TRACE("%s, value (%f %f %f %f).\n", material_tbl[op].name, c.r, c.g, c.b, c.a);
-            *(D3DCOLORVALUE *)((char *)material + material_tbl[op].offset) = c;
+            TRACE("%s, value (%.8e %.8e %.8e %.8e).\n", material_tbl[op].name, c.r, c.g, c.b, c.a);
+            *(D3DCOLORVALUE *)((BYTE *)material + material_tbl[op].offset) = c;
             break;
         }
         default:
diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index 79fdc5e..ac6796c 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -179,6 +179,45 @@ static void regstore_set_values(struct d3dx_regstore *rs, unsigned int table, vo
                 1u << (reg_idx % PRES_BITMASK_BLOCK_SIZE);
 }
 
+static unsigned int regstore_is_val_set_reg(struct d3dx_regstore *rs, unsigned int table, unsigned int reg_idx)
+{
+    return rs->table_value_set[table][reg_idx / PRES_BITMASK_BLOCK_SIZE] &
+            (1ul << (reg_idx % PRES_BITMASK_BLOCK_SIZE));
+}
+
+static float regstore_get_float(struct d3dx_regstore *rs, unsigned int table, unsigned int offset)
+{
+    BYTE *p;
+
+    p = (BYTE *)rs->tables[table] + table_info[table].component_size * offset;
+    switch (table_info[table].type)
+    {
+        case PRES_VT_FLOAT : return *(float *)p;
+        case PRES_VT_DOUBLE: return *(double *)p;
+        case PRES_VT_INT   : return *(int *)p;
+        case PRES_VT_BOOL  : return *(BOOL *)p ? 1.0f : 0.0f;
+        default: return NAN;
+    }
+}
+
+static void regstore_set_float(struct d3dx_regstore *rs, unsigned int table, unsigned int offset, float v)
+{
+    BYTE *p;
+    unsigned int reg_idx;
+
+    p = (BYTE *)rs->tables[table] + table_info[table].component_size * offset;
+    switch (table_info[table].type)
+    {
+        case PRES_VT_FLOAT : *(float *)p = v; break;
+        case PRES_VT_DOUBLE: *(double *)p = v; break;
+        case PRES_VT_INT   : *(int *)p = roundf(v); break;
+        case PRES_VT_BOOL  : *(BOOL *)p = !!v; break;
+    }
+    reg_idx = OFFSET2REG(table, offset);
+    rs->table_value_set[table][reg_idx / PRES_BITMASK_BLOCK_SIZE] |=
+            1ul << (reg_idx % PRES_BITMASK_BLOCK_SIZE);
+}
+
 static void dump_bytecode(void *data, unsigned int size)
 {
     unsigned int *bytecode = (unsigned int *)data;
@@ -622,3 +661,244 @@ void d3dx_free_param_eval(struct d3dx_param_eval *peval)
     d3dx_free_const_tab(&peval->shader_inputs);
     HeapFree(GetProcessHeap(), 0, peval);
 }
+
+static HRESULT set_constants_param(struct d3dx_regstore *rs, struct d3dx_const_tab *const_tab,
+        D3DXHANDLE hc, struct d3dx_parameter *param)
+{
+    ID3DXConstantTable *ctab = const_tab->ctab;
+    D3DXCONSTANT_DESC desc;
+    unsigned int const_count, param_count, i, j, n, table, start_offset;
+    unsigned int nminor, nmajor, major_stride, inp_ind;
+    BOOL transpose, get_element;
+
+    ID3DXConstantTable_GetConstantDesc(ctab, hc, &desc, &const_count);
+
+    if (param->element_count)
+    {
+        param_count = param->element_count;
+        const_count = desc.Elements;
+        get_element = TRUE;
+    }
+    else
+    {
+        if (desc.Elements > 1)
+        {
+            FIXME("Unexpected number of constant elements %u.\n", desc.Elements);
+            return D3DERR_INVALIDCALL;
+        }
+        param_count = param->member_count;
+        const_count = desc.StructMembers;
+        get_element = FALSE;
+    }
+    if (const_count != param_count)
+    {
+        FIXME("Number of elements or struct members differs between parameter and constant.\n");
+        return D3DERR_INVALIDCALL;
+    }
+    if (const_count)
+    {
+        HRESULT hr, ret;
+        D3DXHANDLE hc_element;
+
+        ret = D3D_OK;
+        for (i = 0; i < const_count; ++i)
+        {
+            if (get_element)
+                hc_element = ID3DXConstantTable_GetConstantElement(ctab, hc, i);
+            else
+                hc_element = ID3DXConstantTable_GetConstant(ctab, hc, i);
+            if (!hc_element)
+            {
+                FIXME("Could not get constant.\n");
+                hr = D3DERR_INVALIDCALL;
+            }
+            else
+                hr = set_constants_param(rs, const_tab, hc_element, &param->members[i]);
+            if (FAILED(hr))
+                ret = hr;
+        }
+        return ret;
+    }
+
+    transpose = (desc.Class == D3DXPC_MATRIX_COLUMNS && param->class == D3DXPC_MATRIX_ROWS) ||
+            (param->class == D3DXPC_MATRIX_COLUMNS && desc.Class == D3DXPC_MATRIX_ROWS);
+    if (desc.Class == D3DXPC_MATRIX_COLUMNS)
+    {
+        nmajor = param->columns;
+        nminor = param->rows;
+    }
+    else
+    {
+        nmajor = param->rows;
+        nminor = param->columns;
+    }
+
+    TRACE("Constant %s, rows %u, columns %u, class %u, bytes %u.\n",
+            debugstr_a(desc.Name), desc.Rows, desc.Columns, desc.Class, desc.Bytes);
+    TRACE("Parameter %s, rows %u, columns %u, class %u, flags %#x, bytes %u, transpose %#x.\n",
+            debugstr_a(param->name), param->rows, param->columns, param->class,
+            param->flags, param->bytes, transpose);
+
+    table = const_tab->regset2table[desc.RegisterSet];
+    start_offset = desc.RegisterIndex * table_info[table].reg_component_count;
+    major_stride = max(nminor, table_info[table].reg_component_count);
+    n = min(nmajor * major_stride,
+            desc.RegisterCount * table_info[table].reg_component_count + major_stride - 1) / major_stride;
+    for (i = 0; i < n; ++i)
+    {
+        for (j = 0; j < nminor; ++j)
+        {
+            unsigned int out;
+            unsigned int *in;
+            unsigned int offset;
+
+            offset = start_offset + i * major_stride + j;
+            if (offset / table_info[table].reg_component_count >= rs->table_sizes[table])
+            {
+                if (table_info[table].reg_component_count != 1)
+                    FIXME("Output offset exceeds table size, name %s, component %u.\n", desc.Name, i);
+                break;
+            }
+            if (transpose)
+                inp_ind = i + j * nmajor;
+            else
+                inp_ind = i * nminor + j;
+            if (inp_ind * sizeof(unsigned int) >= param->bytes)
+            {
+                WARN("Parameter data is too short, name %s, component %u.\n", desc.Name, i);
+                break;
+            }
+
+            in = (unsigned int *)param->data + inp_ind;
+            /* TODO: store data transfer / convert operation instead of performing an operation
+                from here, to move this to parsing stage */
+            switch (table_info[table].type)
+            {
+                case PRES_VT_FLOAT: set_number(&out, D3DXPT_FLOAT, in, param->type); break;
+                case PRES_VT_INT: set_number(&out, D3DXPT_INT, in, param->type); break;
+                case PRES_VT_BOOL: set_number(&out, D3DXPT_BOOL, in, param->type); break;
+                default:
+                    FIXME("Unexpected type %#x.\n", table_info[table].type);
+                    break;
+            }
+            regstore_set_values(rs, table, &out, offset, 1);
+        }
+    }
+
+    return D3D_OK;
+}
+
+static HRESULT set_constants(struct d3dx_regstore *rs, struct d3dx_const_tab *const_tab)
+{
+    unsigned int i;
+    HRESULT hr, ret;
+    D3DXHANDLE hc;
+
+    ret = D3D_OK;
+    for (i = 0; i < const_tab->input_count; ++i)
+    {
+        if (!const_tab->inputs_param[i] || const_tab->inputs_param[i]->class == D3DXPC_OBJECT)
+            continue;
+        hc = ID3DXConstantTable_GetConstant(const_tab->ctab, NULL, i);
+        if (!hc)
+        {
+            FIXME("Could not get constant.\n");
+            hr = D3DERR_INVALIDCALL;
+        }
+        else
+            hr = set_constants_param(rs, const_tab, hc, const_tab->inputs_param[i]);
+        if (FAILED(hr))
+            ret = hr;
+    }
+    return ret;
+}
+
+static float exec_get_arg(struct d3dx_regstore *rs, struct d3dx_pres_ins *ins,
+        struct d3dx_pres_operand *opr, unsigned int comp)
+{
+    if (!regstore_is_val_set_reg(rs, opr->table, (opr->offset + comp) / table_info[opr->table].reg_component_count))
+    {
+        WARN("Using uninitialized input ");
+        dump_arg(rs, opr, comp);
+        TRACE(".\n");
+        dump_ins(rs, ins);
+    }
+    return regstore_get_float(rs, opr->table, opr->offset + comp);
+}
+
+static void exec_set_arg(struct d3dx_regstore *rs, struct d3dx_pres_operand *opr, unsigned int comp, float res)
+{
+    regstore_set_float(rs, opr->table, opr->offset + comp, res);
+}
+
+#define ARGS_ARRAY_SIZE 8
+static HRESULT execute_preshader(struct d3dx_preshader *pres)
+{
+    unsigned int i, j, k;
+    float args[ARGS_ARRAY_SIZE];
+    float res;
+
+    for (i = 0; i < pres->ins_count; ++i)
+    {
+        struct d3dx_pres_ins *ins;
+        struct op_info *oi;
+
+        ins = &pres->ins[i];
+        oi = &pres_op_info[ins->op];
+        if (oi->func_all_comps)
+        {
+            if (oi->input_count * ins->component_count > ARGS_ARRAY_SIZE)
+            {
+                FIXME("Too many arguments (%u) for one instruction.\n", oi->input_count * ins->component_count);
+                return E_FAIL;
+            }
+            for (k = 0; k < oi->input_count; ++k)
+                for (j = 0; j < ins->component_count; ++j)
+                    args[k * ins->component_count + j] = exec_get_arg(&pres->regs, ins, &ins->inputs[k],
+                            ins->scalar_op && !k ? 0 : j);
+            res = oi->func(args, ins->component_count);
+
+            /* only 'dot' instruction currently falls here */
+            exec_set_arg(&pres->regs, &ins->output, 0, res);
+        }
+        else
+        {
+            for (j = 0; j < ins->component_count; ++j)
+            {
+                for (k = 0; k < oi->input_count; ++k)
+                    args[k] = exec_get_arg(&pres->regs, ins, &ins->inputs[k], ins->scalar_op && !k ? 0 : j);
+                res = oi->func(args, ins->component_count);
+                exec_set_arg(&pres->regs, &ins->output, j, res);
+            }
+        }
+    }
+    return D3D_OK;
+}
+
+HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval, struct d3dx_parameter *param, void **param_value)
+{
+    HRESULT hr;
+    unsigned int i;
+    unsigned int elements, elements_param, elements_table;
+    float *oc;
+
+    TRACE("peval %p, param %p, param_value %p.\n", peval, param, param_value);
+
+    hr = set_constants(&peval->pres.regs, &peval->pres.inputs);
+    if (FAILED(hr))
+        return hr;
+
+    hr = execute_preshader(&peval->pres);
+    if (FAILED(hr))
+        return hr;
+
+    elements_table = table_info[PRES_REGTAB_OCONST].reg_component_count
+            * peval->pres.regs.table_sizes[PRES_REGTAB_OCONST];
+    elements_param = param->bytes / sizeof(unsigned int);
+    elements = min(elements_table, elements_param);
+    *param_value = param->data;
+    oc = (float *)peval->pres.regs.tables[PRES_REGTAB_OCONST];
+    for (i = 0; i < elements; ++i)
+        set_number((unsigned int *)(*param_value) + i, param->type, oc + i, D3DXPT_FLOAT);
+    return D3D_OK;
+}
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index d0dbbe0..0dcb073 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -2917,7 +2917,7 @@ static void test_effect_states(IDirect3DDevice9 *device)
     ok(!memcmp(mat.m, test_mat.m, sizeof(mat)), "World matrix does not match.\n");
 
     hr = effect->lpVtbl->BeginPass(effect, 0);
-    todo_wine ok(hr == D3D_OK, "Got result %x, expected 0 (D3D_OK).\n", hr);
+    ok(hr == D3D_OK, "Got result %x, expected 0 (D3D_OK).\n", hr);
 
     hr = IDirect3DDevice9_GetTransform(device, D3DTS_WORLDMATRIX(1), &mat);
     ok(hr == D3D_OK, "Got result %x, expected 0 (D3D_OK).\n", hr);
@@ -2925,7 +2925,7 @@ static void test_effect_states(IDirect3DDevice9 *device)
 
     hr = IDirect3DDevice9_GetTransform(device, D3DTS_VIEW, &mat);
     ok(hr == D3D_OK, "Got result %x, expected 0 (D3D_OK).\n", hr);
-    todo_wine ok(!memcmp(mat.m, test_mat_camera.m, sizeof(mat)), "View matrix does not match.\n");
+    ok(!memcmp(mat.m, test_mat_camera.m, sizeof(mat)), "View matrix does not match.\n");
 
     hr = IDirect3DDevice9_GetRenderState(device, D3DRS_BLENDOP, &value);
     ok(hr == D3D_OK, "Got result %x, expected 0 (D3D_OK).\n", hr);
-- 
2.5.5

From 52af8fdfed18f25ebfec922d4f5acab9ec6878d7 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Wed, 9 Mar 2016 15:59:16 +0300
Subject: [v5 06/12] d3dx9: Add basic opcodes to preshader.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/preshader.c    | 60 ++++++++++++++++++++++++++++++++++++++++++++
 dlls/d3dx9_36/tests/effect.c | 42 +++++++++++++++----------------
 2 files changed, 81 insertions(+), 21 deletions(-)

diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index ac6796c..fec9de4 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -29,12 +29,58 @@ enum PRES_OPS
 {
     PRESHADER_OP_NOP,
     PRESHADER_OP_MOV,
+    PRESHADER_OP_ADD,
+    PRESHADER_OP_MUL,
+    PRESHADER_OP_DOT,
+    PRESHADER_OP_NEG,
+    PRESHADER_OP_RCP,
+    PRESHADER_OP_LT,
+    PRESHADER_OP_FRC,
+    PRESHADER_OP_MIN,
+    PRESHADER_OP_MAX,
+    PRESHADER_OP_GE,
+    PRESHADER_OP_CMP,
+    PRESHADER_OP_SIN,
+    PRESHADER_OP_COS,
+    PRESHADER_OP_RSQ,
     PRESHADER_OP_MAX_ENUM
 };
 
 typedef float (*pres_op_func)(float *args, int ncomp);
 
 static float pres_mov(float *args, int ncomp) {return args[0];}
+static float pres_add(float *args, int ncomp) {return args[0] + args[1];}
+static float pres_mul(float *args, int ncomp) {return args[0] * args[1];}
+static float pres_dot(float *args, int ncomp)
+{
+    int i;
+    double sum;
+
+    sum = 0.0f;
+    for (i = 0; i < ncomp; i++)
+        sum += args[i] * args[i + ncomp];
+    return sum;
+}
+static float pres_neg(float *args, int ncomp) {return -args[0];}
+static float pres_rcp(float *args, int ncomp) {return 1.0f / args[0];}
+static float pres_lt(float *args, int ncomp)  {return args[0] < args[1] ? 1.0f : 0.0f;}
+static float pres_ge(float *args, int ncomp)  {return args[0] >= args[1] ? 1.0f : 0.0f;}
+static float pres_frc(float *args, int ncomp) {return args[0] - floorf(args[0]);}
+static float pres_min(float *args, int ncomp) {return fminf(args[0], args[1]);}
+static float pres_max(float *args, int ncomp) {return fmaxf(args[0], args[1]);}
+static float pres_cmp(float *args, int ncomp) {return args[0] < 0.0f ? args[2] : args[1];}
+static float pres_sin(float *args, int ncomp) {return sin(args[0]);}
+static float pres_cos(float *args, int ncomp) {return cos(args[0]);}
+static float pres_rsq(float *args, int ncomp)
+{
+float v;
+
+    v = fabsf(args[0]);
+    if (v == 0.0f)
+        return INFINITY;
+    else
+        return 1.0f / sqrt(v);
+}
 
 #define PRES_OPCODE_MASK 0x7ff00000
 #define PRES_OPCODE_SHIFT 20
@@ -60,6 +106,20 @@ static struct op_info pres_op_info[] =
 {
     {0x000, "nop", 0, 0, NULL    }, /* PRESHADER_OP_NOP */
     {0x100, "mov", 1, 0, pres_mov}, /* PRESHADER_OP_MOV */
+    {0x204, "add", 2, 0, pres_add}, /* PRESHADER_OP_ADD */
+    {0x205, "mul", 2, 0, pres_mul}, /* PRESHADER_OP_MUL */
+    {0x500, "dot", 2, 1, pres_dot}, /* PRESHADER_OP_DOT */
+    {0x101, "neg", 1, 0, pres_neg}, /* PRESHADER_OP_NEG */
+    {0x103, "rcp", 1, 0, pres_rcp}, /* PRESHADER_OP_RCP */
+    {0x202, "lt",  2, 0, pres_lt }, /* PRESHADER_OP_LT  */
+    {0x104, "frc", 1, 0, pres_frc}, /* PRESHADER_OP_FRC */
+    {0x200, "min", 2, 0, pres_min}, /* PRESHADER_OP_MIN */
+    {0x201, "max", 2, 0, pres_max}, /* PRESHADER_OP_MAX */
+    {0x203, "ge",  2, 0, pres_ge }, /* PRESHADER_OP_GE  */
+    {0x300, "cmp", 3, 0, pres_cmp}, /* PRESHADER_OP_CMP */
+    {0x108, "sin", 1, 0, pres_sin}, /* PRESHADER_OP_SIN */
+    {0x109, "cos", 1, 0, pres_cos}, /* PRESHADER_OP_COS */
+    {0x107, "rsq", 1, 0, pres_rsq}, /* PRESHADER_OP_RSQ */
 };
 
 enum PRES_VALUE_TYPE
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index 0dcb073..5547208 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -3695,34 +3695,34 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     }
     test_effect_preshader_op_results[] =
     {
-        {"1 / op", { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0xff800000, 0xbee8ba2e, 0x00200000}},
+        {"1 / op", {FALSE, FALSE, FALSE, FALSE}, {0x7f800000, 0xff800000, 0xbee8ba2e, 0x00200000}},
 #if __x86_64__
-        {"rsq",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0x7f800000, 0x3f2c985d, 0x1f800000}},
+        {"rsq",    {FALSE, FALSE, FALSE, FALSE}, {0x7f800000, 0x7f800000, 0x3f2c985d, 0x1f800000}},
 #else
-        {"rsq",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0x7f800000, 0x3f2c985c, 0x1f800001}},
+        {"rsq",    {FALSE, FALSE,  TRUE,  TRUE}, {0x7f800000, 0x7f800000, 0x3f2c985c, 0x1f800001}},
 #endif
-        {"mul",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0x40d33334, 0x7f800000}},
-        {"add",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x40000000, 0xc0a66666, 0x7f7fffff}},
-        {"lt",     {FALSE, FALSE,  TRUE, FALSE}, {0x3f800000, 0x3f800000, 0x00000000, 0x00000000}},
-        {"ge",     { TRUE,  TRUE, FALSE,  TRUE}, {0x00000000, 0x00000000, 0x3f800000, 0x3f800000}},
-        {"neg",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x80000000, 0x00000000, 0x400ccccd, 0xff7fffff}},
-        {"rcp",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0xff800000, 0xbee8ba2e, 0x00200000}},
-        {"frac",   {FALSE, FALSE,  TRUE, FALSE}, {0x00000000, 0x00000000, 0x3f4ccccc, 0x00000000}},
-        {"min",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0xc0400000, 0x40800000}},
-        {"max",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x40000000, 0xc00ccccd, 0x7f7fffff}},
+        {"mul",    {FALSE, FALSE, FALSE, FALSE}, {0x00000000, 0x80000000, 0x40d33334, 0x7f800000}},
+        {"add",    {FALSE, FALSE, FALSE, FALSE}, {0x3f800000, 0x40000000, 0xc0a66666, 0x7f7fffff}},
+        {"lt",     {FALSE, FALSE, FALSE, FALSE}, {0x3f800000, 0x3f800000, 0x00000000, 0x00000000}},
+        {"ge",     {FALSE, FALSE, FALSE, FALSE}, {0x00000000, 0x00000000, 0x3f800000, 0x3f800000}},
+        {"neg",    {FALSE, FALSE, FALSE, FALSE}, {0x80000000, 0x00000000, 0x400ccccd, 0xff7fffff}},
+        {"rcp",    {FALSE, FALSE, FALSE, FALSE}, {0x7f800000, 0xff800000, 0xbee8ba2e, 0x00200000}},
+        {"frac",   {FALSE, FALSE, FALSE, FALSE}, {0x00000000, 0x00000000, 0x3f4ccccc, 0x00000000}},
+        {"min",    {FALSE, FALSE, FALSE, FALSE}, {0x00000000, 0x80000000, 0xc0400000, 0x40800000}},
+        {"max",    {FALSE, FALSE, FALSE, FALSE}, {0x3f800000, 0x40000000, 0xc00ccccd, 0x7f7fffff}},
 #if __x86_64__
-        {"sin",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0xbf4ef99e, 0xbf0599b3}},
-        {"cos",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x3f800000, 0xbf16a803, 0x3f5a5f96}},
+        {"sin",    {FALSE, FALSE, FALSE, FALSE}, {0x00000000, 0x80000000, 0xbf4ef99e, 0xbf0599b3}},
+        {"cos",    {FALSE, FALSE, FALSE, FALSE}, {0x3f800000, 0x3f800000, 0xbf16a803, 0x3f5a5f96}},
 #else
-        {"sin",    {FALSE,  TRUE,  TRUE,  TRUE}, {0x00000000, 0x80000000, 0xbf4ef99e, 0x3f792dc4}},
-        {"cos",    { TRUE,  TRUE,  TRUE,  TRUE}, {0x3f800000, 0x3f800000, 0xbf16a803, 0xbe6acefc}},
+        {"sin",    {FALSE, FALSE, FALSE,  TRUE}, {0x00000000, 0x80000000, 0xbf4ef99e, 0x3f792dc4}},
+        {"cos",    {FALSE, FALSE, FALSE,  TRUE}, {0x3f800000, 0x3f800000, 0xbf16a803, 0xbe6acefc}},
 #endif
-        {"den mul",{ TRUE,  TRUE,  TRUE,  TRUE}, {0x7f800000, 0xff800000, 0xbb94f209, 0x000051ec}},
-        {"dot",    {FALSE,  TRUE,  TRUE, FALSE}, {0x00000000, 0x7f800000, 0x41f00000, 0x00000000}},
+        {"den mul",{FALSE, FALSE, FALSE, FALSE}, {0x7f800000, 0xff800000, 0xbb94f209, 0x000051ec}},
+        {"dot",    {FALSE, FALSE, FALSE, FALSE}, {0x00000000, 0x7f800000, 0x41f00000, 0x00000000}},
 #if __x86_64__
-        {"prec",   { TRUE,  TRUE,  TRUE, FALSE}, {0x2b8cbccc, 0x2c0cbccc, 0xac531800, 0x00000000}}
+        {"prec",   {FALSE, FALSE,  TRUE, FALSE}, {0x2b8cbccc, 0x2c0cbccc, 0xac531800, 0x00000000}}
 #else
-        {"prec",   { TRUE,  TRUE, FALSE, FALSE}, {0x2b8cbccc, 0x2c0cbccc, 0x00000000, 0x00000000}}
+        {"prec",   {FALSE, FALSE, FALSE, FALSE}, {0x2b8cbccc, 0x2c0cbccc, 0x00000000, 0x00000000}}
 #endif
     };
     #define TEST_EFFECT_PRES_NFLOATV ARRAY_SIZE(test_effect_preshader_fconstsv)
@@ -3789,7 +3789,7 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     ok(hr == D3D_OK, "SetVector failed, hr %#x.\n", hr);
 
     hr = effect->lpVtbl->BeginPass(effect, 0);
-    todo_wine ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
 
     hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 0, &fdata[0].x, TEST_EFFECT_PRES_NFLOATV);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
-- 
2.5.5

From 96f46470eef7a9de308efd026a107cac73163219 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Tue, 8 Mar 2016 21:05:53 +0300
Subject: [v5 07/12] d3dx9: Implement array selectors in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/effect.c       | 89 +++++++++++++++++++++++++++-----------------
 dlls/d3dx9_36/tests/effect.c |  6 +--
 2 files changed, 58 insertions(+), 37 deletions(-)

diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 232fc37..b98022c 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -2510,8 +2510,38 @@ static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct
             *out_param = param;
             return D3D_OK;
         case ST_ARRAY_SELECTOR:
-            FIXME("Array selector.\n");
-            break;
+        {
+            struct d3dx_parameter array_idx_par;
+            unsigned int array_idx;
+            unsigned int *idx_value;
+            HRESULT hr;
+
+            if (!param->param_eval)
+            {
+                FIXME("Preshader structure is null.\n");
+                return D3DERR_INVALIDCALL;
+            }
+            memset(&array_idx_par, 0, sizeof(array_idx_par));
+            array_idx_par.data = &array_idx;
+            array_idx_par.type = D3DXPT_INT;
+            array_idx_par.bytes = sizeof(array_idx);
+            array_idx_par.rows = array_idx_par.columns = 1;
+            if (FAILED(hr = d3dx_evaluate_parameter(param->param_eval, &array_idx_par, (void **)&idx_value)))
+                return hr;
+
+            param = param->referenced_param;
+            TRACE("Array index %u.\n", *idx_value);
+            if (*idx_value >= param->element_count)
+            {
+                ERR("Computed array index %u is out of bound %u.\n", *idx_value, param->element_count);
+                return D3DERR_INVALIDCALL;
+            }
+            param = &param->members[*idx_value];
+
+            *param_value = param->data;
+            *out_param = param;
+            return D3D_OK;
+        }
         case ST_FXLC:
             if (param->param_eval)
             {
@@ -2657,15 +2687,15 @@ HRESULT d3dx_set_shader_const_state(IDirect3DDevice9 *device, enum SHADER_CONSTA
         {D3DXPT_BOOL,  sizeof(BOOL),      "SCT_PSBOOL"},
         {D3DXPT_INT,   sizeof(int) * 4,   "SCT_PSINT"},
     };
-    UINT nelem;
+    unsigned int element_count;
 
     if (op < 0 || op > SCT_PSINT)
     {
         FIXME("Unknown op %u.\n", op);
         return D3DERR_INVALIDCALL;
     }
-    nelem = param->bytes / const_tbl[op].elem_size;
-    TRACE("%s, index %u, %u elements.\n", const_tbl[op].name, index, nelem);
+    element_count = param->bytes / const_tbl[op].elem_size;
+    TRACE("%s, index %u, element_count %u.\n", const_tbl[op].name, index, element_count);
     if (param->type != const_tbl[op].type)
     {
         FIXME("Unexpected param type %u.\n", param->type);
@@ -2680,17 +2710,17 @@ HRESULT d3dx_set_shader_const_state(IDirect3DDevice9 *device, enum SHADER_CONSTA
     switch (op)
     {
         case SCT_VSFLOAT:
-            return IDirect3DDevice9_SetVertexShaderConstantF(device, index, (const float *)value_ptr, nelem);
+            return IDirect3DDevice9_SetVertexShaderConstantF(device, index, (const float *)value_ptr, element_count);
         case SCT_VSBOOL:
-            return IDirect3DDevice9_SetVertexShaderConstantB(device, index, (const BOOL *)value_ptr, nelem);
+            return IDirect3DDevice9_SetVertexShaderConstantB(device, index, (const BOOL *)value_ptr, element_count);
         case SCT_VSINT:
-            return IDirect3DDevice9_SetVertexShaderConstantI(device, index, (const int *)value_ptr, nelem);
+            return IDirect3DDevice9_SetVertexShaderConstantI(device, index, (const int *)value_ptr, element_count);
         case SCT_PSFLOAT:
-            return IDirect3DDevice9_SetPixelShaderConstantF(device, index, (const float *)value_ptr, nelem);
+            return IDirect3DDevice9_SetPixelShaderConstantF(device, index, (const float *)value_ptr, element_count);
         case SCT_PSBOOL:
-            return IDirect3DDevice9_SetPixelShaderConstantB(device, index, (const BOOL *)value_ptr, nelem);
+            return IDirect3DDevice9_SetPixelShaderConstantB(device, index, (const BOOL *)value_ptr, element_count);
         case SCT_PSINT:
-            return IDirect3DDevice9_SetPixelShaderConstantI(device, index, (const int *)value_ptr, nelem);
+            return IDirect3DDevice9_SetPixelShaderConstantI(device, index, (const int *)value_ptr, element_count);
     }
     return D3D_OK;
 }
@@ -2704,9 +2734,10 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
     HRESULT hr;
 
     TRACE("operation %u, index %u, type %u.\n", state->operation, state->index, state->type);
-    hr = d3dx9_get_param_value_ptr(effect, pass, state, &param_value, &param);
-    if (FAILED(hr))
-        return hr;
+    if (FAILED(hr = d3dx9_get_param_value_ptr(effect, pass, state, &param_value, &param)))
+        /* Native d3dx returns OK from BeginPass or Commit involving out of bound array
+            access, and does not touch affected state. */
+        return D3D_OK;
 
     switch (state_table[state->operation].class)
     {
@@ -2742,8 +2773,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
             ret = D3D_OK;
             for (i = 0; i < sampler->state_count; i++)
             {
-                hr = d3dx9_apply_state(effect, pass, &sampler->states[i], state->index);
-                if (FAILED(hr))
+                if (FAILED(hr = d3dx9_apply_state(effect, pass, &sampler->states[i], state->index)))
                     ret = hr;
             }
             return ret;
@@ -2759,15 +2789,13 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
         }
         case SC_VERTEXSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DVertexShader9 **)param_value);
-            hr = IDirect3DDevice9_SetVertexShader(device, *(IDirect3DVertexShader9 **)param_value);
-            if (FAILED(hr))
+            if (FAILED(hr = IDirect3DDevice9_SetVertexShader(device, *(IDirect3DVertexShader9 **)param_value)))
                 ERR("Could not set vertex shader, hr %#x.\n", hr);
             FIXME("Not executing preshader and not setting constants.\n");
             return hr;
         case SC_PIXELSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DPixelShader9 **)param_value);
-            hr = IDirect3DDevice9_SetPixelShader(device, *(IDirect3DPixelShader9 **)param_value);
-            if (FAILED(hr))
+            if (FAILED(hr = IDirect3DDevice9_SetPixelShader(device, *(IDirect3DPixelShader9 **)param_value)))
                 ERR("Could not set pixel shader, hr %#x.\n", hr);
             FIXME("Not executing preshader and not setting constants.\n");
             return hr;
@@ -2784,8 +2812,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
 
             TRACE("%s, index %u, op %u.\n", state_table[state->operation].name, state->index,
                     state_table[state->operation].op);
-            hr = IDirect3DDevice9_GetLight(device, state->index, &light);
-            if (FAILED(hr))
+            if (FAILED(hr = IDirect3DDevice9_GetLight(device, state->index, &light)))
             {
                 WARN("Could not get light, hr %#x.\n", hr);
                 memset(&light, 0, sizeof(light));
@@ -2799,8 +2826,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
 
             TRACE("%s, index %u, op %u.\n", state_table[state->operation].name, state->index,
                     state_table[state->operation].op);
-            hr = IDirect3DDevice9_GetMaterial(device, &material);
-            if (FAILED(hr))
+            if (FAILED(hr = IDirect3DDevice9_GetMaterial(device, &material)))
             {
                 WARN("Could not get material, hr %#x.\n", hr);
                 memset(&material, 0, sizeof(material));
@@ -2835,8 +2861,7 @@ static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3
     {
         HRESULT hr;
 
-        hr = d3dx9_apply_state(effect, pass, &pass->states[i], -1);
-        if (FAILED(hr))
+        if (FAILED(hr = d3dx9_apply_state(effect, pass, &pass->states[i], -1)))
         {
             WARN("Error applying state, hr %#x.\n", hr);
             ret = hr;
@@ -3520,17 +3545,14 @@ static HRESULT WINAPI ID3DXEffectImpl_Begin(ID3DXEffect *iface, UINT *passes, DW
 
             if (!technique->saved_state)
             {
-                hr = IDirect3DDevice9_BeginStateBlock(effect->device);
-                if (FAILED(hr))
+                if (FAILED(hr = IDirect3DDevice9_BeginStateBlock(effect->device)))
                     ERR("BeginStateBlock failed, hr %#x.\n", hr);
                 for (i = 0; i < technique->pass_count; i++)
                     d3dx9_apply_pass_states(effect, &technique->passes[i]);
-                hr = IDirect3DDevice9_EndStateBlock(effect->device, &technique->saved_state);
-                if (FAILED(hr))
+                if (FAILED(hr = IDirect3DDevice9_EndStateBlock(effect->device, &technique->saved_state)))
                     ERR("EndStateBlock failed, hr %#x.\n", hr);
             }
-            hr = IDirect3DStateBlock9_Capture(technique->saved_state);
-            if (FAILED(hr))
+            if (FAILED(hr = IDirect3DStateBlock9_Capture(technique->saved_state)))
                 ERR("StateBlock Capture failed, hr %#x.\n", hr);
         }
 
@@ -3616,8 +3638,7 @@ static HRESULT WINAPI ID3DXEffectImpl_End(ID3DXEffect *iface)
 
         if (technique && technique->saved_state)
         {
-            hr = IDirect3DStateBlock9_Apply(technique->saved_state);
-            if (FAILED(hr))
+            if (FAILED(hr = IDirect3DStateBlock9_Apply(technique->saved_state)))
                 ERR("State block apply failed, hr %#x.\n", hr);
         }
         else
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index 5547208..6ae3f99 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -3848,7 +3848,7 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     hr = effect->lpVtbl->SetVector(effect, par, &fvect2);
     ok(hr == D3D_OK, "SetVector failed, hr %#x.\n", hr);
     hr = effect->lpVtbl->BeginPass(effect, 1);
-    todo_wine ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
 
     hr = IDirect3DDevice9_GetVertexShader(device, &vshader);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
@@ -3860,7 +3860,7 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     hr = IDirect3DVertexShader9_GetFunction(vshader, byte_code, &byte_code_size);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
     ok(byte_code_size > 1, "Got unexpected byte code size %u.\n", byte_code_size);
-    todo_wine ok(!memcmp(byte_code,
+    ok(!memcmp(byte_code,
             &test_effect_preshader_effect_blob[TEST_EFFECT_PRESHADER_VSHADER_POS +
             TEST_EFFECT_PRESHADER_VSHADER_LEN], byte_code_size),
             "Incorrect shader selected.\n");
@@ -3873,7 +3873,7 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     hr = effect->lpVtbl->SetVector(effect, par, &fvect1);
     ok(hr == D3D_OK, "SetVector failed, hr %#x.\n", hr);
     hr = effect->lpVtbl->CommitChanges(effect);
-    todo_wine ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
     hr = IDirect3DDevice9_GetVertexShader(device, &vshader);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
     ok(!vshader, "Incorrect shader selected.\n");
-- 
2.5.5

From 057ec1dcb7e45d497b7b758bd9de9b909c42aefd Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Tue, 8 Mar 2016 21:08:45 +0300
Subject: [v5 08/12] d3dx9: Implement setting named shader constants in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/d3dx9_private.h |  2 ++
 dlls/d3dx9_36/effect.c        | 58 +++++++++++++++++++++++++++----
 dlls/d3dx9_36/preshader.c     | 80 +++++++++++++++++++++++++++++++++++++++++--
 dlls/d3dx9_36/tests/effect.c  |  4 +--
 4 files changed, 134 insertions(+), 10 deletions(-)

diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index 27b6978..a1e52e7 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -199,5 +199,7 @@ HRESULT d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte
 void d3dx_free_param_eval(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
 HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval,
         struct d3dx_parameter *param, void **param_value) DECLSPEC_HIDDEN;
+HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device,
+        struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_D3DX9_PRIVATE_H */
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index b98022c..f78feed 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -2726,7 +2726,51 @@ HRESULT d3dx_set_shader_const_state(IDirect3DDevice9 *device, enum SHADER_CONSTA
 }
 
 static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
-        struct d3dx_state *state, int parent_index)
+        struct d3dx_state *state, unsigned int parent_index);
+
+HRESULT d3dx_set_shader_const_fxlc(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
+        struct d3dx_parameter *param, unsigned int vs)
+{
+    IDirect3DDevice9 *device = effect->device;
+    HRESULT hr, ret;
+    struct d3dx_parameter **params;
+    D3DXCONSTANT_DESC *cdesc;
+    unsigned int parameters_count;
+    unsigned int i, j;
+
+    if (!param->param_eval)
+    {
+        FIXME("Preshader structure is null.\n");
+        return D3DERR_INVALIDCALL;
+    }
+    if (FAILED(hr = d3dx_param_eval_set_shader_constants(device, param->param_eval)))
+        return hr;
+    params = param->param_eval->shader_inputs.inputs_param;
+    cdesc = param->param_eval->shader_inputs.inputs;
+    parameters_count = param->param_eval->shader_inputs.input_count;
+    ret = D3D_OK;
+    for (i = 0; i < parameters_count; i++)
+    {
+        if (params[i] && params[i]->class == D3DXPC_OBJECT && params[i]->type == D3DXPT_SAMPLER)
+        {
+            struct d3dx_sampler *sampler;
+
+            sampler = (struct d3dx_sampler *)params[i]->data;
+            TRACE("sampler %s, register index %u, state count %u.\n", params[i]->name,
+                    cdesc[i].RegisterIndex, sampler->state_count);
+            for (j = 0; j < sampler->state_count; j++)
+            {
+                if (FAILED(hr = d3dx9_apply_state(effect, pass, &sampler->states[j],
+                        cdesc[i].RegisterIndex + (vs ? D3DVERTEXTEXTURESAMPLER0 : 0))))
+                    ret = hr;
+            }
+        }
+    }
+    return ret;
+}
+
+static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
+        struct d3dx_state *state, unsigned int parent_index)
 {
     IDirect3DDevice9 *device = effect->device;
     struct d3dx_parameter *param;
@@ -2752,7 +2796,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
         {
             UINT unit;
 
-            unit = parent_index == -1 ? state->index : parent_index;
+            unit = parent_index == ~0u ? state->index : parent_index;
             TRACE("%s, unit %u, value %p.\n", state_table[state->operation].name, unit,
                     *(IDirect3DBaseTexture9 **)param_value);
             return IDirect3DDevice9_SetTexture(device, unit, *(IDirect3DBaseTexture9 **)param_value);
@@ -2782,7 +2826,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
         {
             UINT sampler;
 
-            sampler = parent_index == -1 ? state->index : parent_index;
+            sampler = parent_index == ~0u ? state->index : parent_index;
             TRACE("%s, sampler %u, value %u.\n", state_table[state->operation].name, sampler, *(DWORD *)param_value);
             return IDirect3DDevice9_SetSamplerState(device, sampler, state_table[state->operation].op,
                     *(DWORD *)param_value);
@@ -2791,13 +2835,15 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DVertexShader9 **)param_value);
             if (FAILED(hr = IDirect3DDevice9_SetVertexShader(device, *(IDirect3DVertexShader9 **)param_value)))
                 ERR("Could not set vertex shader, hr %#x.\n", hr);
-            FIXME("Not executing preshader and not setting constants.\n");
+            else if (*(IDirect3DVertexShader9 **)param_value)
+                hr = d3dx_set_shader_const_fxlc(effect, pass, param, 1);
             return hr;
         case SC_PIXELSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DPixelShader9 **)param_value);
             if (FAILED(hr = IDirect3DDevice9_SetPixelShader(device, *(IDirect3DPixelShader9 **)param_value)))
                 ERR("Could not set pixel shader, hr %#x.\n", hr);
-            FIXME("Not executing preshader and not setting constants.\n");
+            else if (*(IDirect3DPixelShader9 **)param_value)
+                hr = d3dx_set_shader_const_fxlc(effect, pass, param, 0);
             return hr;
         case SC_TRANSFORM:
             TRACE("%s, state %u.\n", state_table[state->operation].name, state->index);
@@ -2861,7 +2907,7 @@ static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3
     {
         HRESULT hr;
 
-        if (FAILED(hr = d3dx9_apply_state(effect, pass, &pass->states[i], -1)))
+        if (FAILED(hr = d3dx9_apply_state(effect, pass, &pass->states[i], ~0u)))
         {
             WARN("Error applying state, hr %#x.\n", hr);
             ret = hr;
diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index fec9de4..1770046 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -242,7 +242,7 @@ static void regstore_set_values(struct d3dx_regstore *rs, unsigned int table, vo
 static unsigned int regstore_is_val_set_reg(struct d3dx_regstore *rs, unsigned int table, unsigned int reg_idx)
 {
     return rs->table_value_set[table][reg_idx / PRES_BITMASK_BLOCK_SIZE] &
-            (1ul << (reg_idx % PRES_BITMASK_BLOCK_SIZE));
+            (1u << (reg_idx % PRES_BITMASK_BLOCK_SIZE));
 }
 
 static float regstore_get_float(struct d3dx_regstore *rs, unsigned int table, unsigned int offset)
@@ -275,7 +275,19 @@ static void regstore_set_float(struct d3dx_regstore *rs, unsigned int table, uns
     }
     reg_idx = OFFSET2REG(table, offset);
     rs->table_value_set[table][reg_idx / PRES_BITMASK_BLOCK_SIZE] |=
-            1ul << (reg_idx % PRES_BITMASK_BLOCK_SIZE);
+            1u << (reg_idx % PRES_BITMASK_BLOCK_SIZE);
+}
+
+static void regstore_reset_table(struct d3dx_regstore *rs, unsigned int table)
+{
+    unsigned int sz;
+
+    sz = rs->table_sizes[table] * table_info[table].reg_component_count * table_info[table].component_size;
+
+    memset(rs->tables[table], 0, sz);
+    memset(rs->table_value_set[table], 0,
+            sizeof(*rs->table_value_set[table]) *
+            ((rs->table_sizes[table] + PRES_BITMASK_BLOCK_SIZE - 1) / PRES_BITMASK_BLOCK_SIZE));
 }
 
 static void dump_bytecode(void *data, unsigned int size)
@@ -962,3 +974,67 @@ HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval, struct d3dx_param
         set_number((unsigned int *)(*param_value) + i, param->type, oc + i, D3DXPT_FLOAT);
     return D3D_OK;
 }
+
+HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device, struct d3dx_param_eval *peval)
+{
+    HRESULT hr, res;
+    struct d3dx_preshader *pres = &peval->pres;
+    struct d3dx_regstore *rs = &pres->regs;
+
+    TRACE("device %p, peval %p, param_type %u.\n", device, peval, peval->param_type);
+
+    if (FAILED(hr = set_constants(rs, &pres->inputs)))
+        return hr;
+    if (FAILED(hr = execute_preshader(pres)))
+        return hr;
+    if (FAILED(hr = set_constants(rs, &peval->shader_inputs)))
+        return hr;
+
+    #define SET_TABLE(table, func_suff, type) \
+        { \
+            unsigned int is, n; \
+            \
+            is = 0; \
+            while (is < rs->table_sizes[table]) \
+            {\
+                n = 0; \
+                while (is < rs->table_sizes[table] && !regstore_is_val_set_reg(rs, table, is)) \
+                    is++; \
+                while (is + n < rs->table_sizes[table] && regstore_is_val_set_reg(rs, table, is + n)) \
+                    n++; \
+                if (!n) \
+                    continue; \
+                TRACE("setting %u consts at %u.\n", n, is); \
+                hr = IDirect3DDevice9_##func_suff(device, is, \
+                        (const type *)rs->tables[table] + is * table_info[table].reg_component_count, n); \
+                if (FAILED(hr)) \
+                { \
+                    ERR(#func_suff " failed, hr %#x.\n", hr); \
+                    res = hr; \
+                } \
+                is += n; \
+            } \
+            regstore_reset_table(rs, table); \
+        }
+    res = D3D_OK;
+    if (peval->param_type == D3DXPT_VERTEXSHADER)
+    {
+        SET_TABLE(PRES_REGTAB_OCONST, SetVertexShaderConstantF, float);
+        SET_TABLE(PRES_REGTAB_OICONST, SetVertexShaderConstantI, int);
+        SET_TABLE(PRES_REGTAB_OBCONST, SetVertexShaderConstantB, BOOL);
+    }
+    else if (peval->param_type == D3DXPT_PIXELSHADER)
+    {
+        SET_TABLE(PRES_REGTAB_OCONST, SetPixelShaderConstantF, float);
+        SET_TABLE(PRES_REGTAB_OICONST, SetPixelShaderConstantI, int);
+        SET_TABLE(PRES_REGTAB_OBCONST, SetPixelShaderConstantB, BOOL);
+    }
+    else
+    {
+        FIXME("Unexpected parameter type %u.\n", peval->param_type);
+        return D3DERR_INVALIDCALL;
+    }
+    #undef SET_TABLE
+
+    return res;
+}
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index 6ae3f99..fc9696d 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -3793,7 +3793,7 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
 
     hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 0, &fdata[0].x, TEST_EFFECT_PRES_NFLOATV);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
-    todo_wine ok(!memcmp(fdata, test_effect_preshader_fconstsv, sizeof(test_effect_preshader_fconstsv)),
+    ok(!memcmp(fdata, test_effect_preshader_fconstsv, sizeof(test_effect_preshader_fconstsv)),
             "Vertex shader float constants do not match.\n");
     for (i = TEST_EFFECT_PRES_NFLOATV; i < 256; ++i)
     {
@@ -3804,7 +3804,7 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     }
     hr = IDirect3DDevice9_GetPixelShaderConstantF(device, 0, &fdata[0].x, TEST_EFFECT_PRES_NFLOATP);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
-    todo_wine ok(!memcmp(fdata, test_effect_preshader_fconstsp, sizeof(test_effect_preshader_fconstsp)),
+    ok(!memcmp(fdata, test_effect_preshader_fconstsp, sizeof(test_effect_preshader_fconstsp)),
             "Pixel shader float constants do not match.\n");
     for (i = TEST_EFFECT_PRES_NFLOATP; i < 224; ++i)
     {
-- 
2.5.5

From 9f888110bfa45656f5e00f8ce533e11306f70c7f Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Mon, 21 Mar 2016 18:13:18 +0300
Subject: [v5 09/12] d3dx9: Add 'exp' preshader opcode.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/preshader.c    |  3 +++
 dlls/d3dx9_36/tests/effect.c | 48 ++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 51 insertions(+)

diff --git a/dlls/d3dx9_36/preshader.c b/dlls/d3dx9_36/preshader.c
index 1770046..70c00c8 100644
--- a/dlls/d3dx9_36/preshader.c
+++ b/dlls/d3dx9_36/preshader.c
@@ -43,6 +43,7 @@ enum PRES_OPS
     PRESHADER_OP_SIN,
     PRESHADER_OP_COS,
     PRESHADER_OP_RSQ,
+    PRESHADER_OP_EXP,
     PRESHADER_OP_MAX_ENUM
 };
 
@@ -81,6 +82,7 @@ float v;
     else
         return 1.0f / sqrt(v);
 }
+static float pres_exp(float *args, int ncomp) {return pow(2.0, args[0]);}
 
 #define PRES_OPCODE_MASK 0x7ff00000
 #define PRES_OPCODE_SHIFT 20
@@ -120,6 +122,7 @@ static struct op_info pres_op_info[] =
     {0x108, "sin", 1, 0, pres_sin}, /* PRESHADER_OP_SIN */
     {0x109, "cos", 1, 0, pres_cos}, /* PRESHADER_OP_COS */
     {0x107, "rsq", 1, 0, pres_rsq}, /* PRESHADER_OP_RSQ */
+    {0x105, "exp", 1, 0, pres_exp}, /* PRESHADER_OP_EXP */
 };
 
 enum PRES_VALUE_TYPE
diff --git a/dlls/d3dx9_36/tests/effect.c b/dlls/d3dx9_36/tests/effect.c
index fc9696d..f192f41 100644
--- a/dlls/d3dx9_36/tests/effect.c
+++ b/dlls/d3dx9_36/tests/effect.c
@@ -3634,6 +3634,9 @@ static const DWORD test_effect_preshader_effect_blob[] =
 #define TEST_EFFECT_PRESHADER_VSHADER_POS 1035
 #define TEST_EFFECT_PRESHADER_VSHADER_LEN 13
 
+#define TEST_EFFECT_PRESHADER_OP0_POS 2468
+#define TEST_EFFECT_PRESHADER_OP0_INS_SIZE 8
+
 static void test_effect_preshader(IDirect3DDevice9 *device)
 {
     static const D3DXVECTOR4 test_effect_preshader_fconstsv[] =
@@ -3886,6 +3889,50 @@ static void test_effect_preshader(IDirect3DDevice9 *device)
     effect->lpVtbl->Release(effect);
 }
 
+static void test_effect_preshader_ops(IDirect3DDevice9 *device)
+{
+    DWORD test_effect_blob[ARRAY_SIZE(test_effect_preshader_effect_blob)];
+    HRESULT hr;
+    ID3DXEffect *effect;
+    D3DLIGHT9 light;
+    unsigned int i, npasses;
+    unsigned int *v;
+    unsigned int expected_result[4];
+
+    /* test 'exp' opcode */
+    memcpy(test_effect_blob, test_effect_preshader_effect_blob, sizeof test_effect_blob);
+    for (i = 0; i < 4; i++)
+        test_effect_blob[TEST_EFFECT_PRESHADER_OP0_POS + i * TEST_EFFECT_PRESHADER_OP0_INS_SIZE] =
+                0x10500001;
+
+    hr = D3DXCreateEffect(device, test_effect_blob, sizeof(test_effect_blob),
+            NULL, NULL, 0, NULL, &effect, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect->lpVtbl->Begin(effect, &npasses, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect->lpVtbl->BeginPass(effect, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetLight(device, 0, &light);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    v = (unsigned int *)&light.Diffuse;
+    expected_result[0] = 0x3f800000;
+    expected_result[1] = 0x3f800000;
+    expected_result[2] = 0x3e5edc66;
+    expected_result[3] = 0x7f800000;
+    for (i = 0; i < 4; ++i)
+        ok(v[i] == expected_result[i],
+                "Operation exp, component %u, expected %#x (%g), got %#x (%g).\n",
+                i, expected_result[i], ((float *)expected_result)[i], v[i], ((float *)v)[i]);
+
+
+    hr = effect->lpVtbl->EndPass(effect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect->lpVtbl->End(effect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    effect->lpVtbl->Release(effect);
+}
+
 START_TEST(effect)
 {
     HWND wnd;
@@ -3927,6 +3974,7 @@ START_TEST(effect)
     test_effect_compilation_errors(device);
     test_effect_states(device);
     test_effect_preshader(device);
+    test_effect_preshader_ops(device);
 
     count = IDirect3DDevice9_Release(device);
     ok(count == 0, "The device was not properly freed: refcount %u\n", count);
-- 
2.5.5

From e8b4daed909c3d2e352643e4dd23bc77f54a939b Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Sat, 5 Mar 2016 22:18:50 +0300
Subject: [v5 10/12] d3dx9: OnLostDevice temp changes

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/effect.c | 23 ++++++++++++++++-------
 1 file changed, 16 insertions(+), 7 deletions(-)

diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index f78feed..851de64 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -3719,20 +3719,29 @@ static HRESULT WINAPI ID3DXEffectImpl_GetDevice(ID3DXEffect *iface, struct IDire
 
 static HRESULT WINAPI ID3DXEffectImpl_OnLostDevice(ID3DXEffect* iface)
 {
-    struct ID3DXEffectImpl *This = impl_from_ID3DXEffect(iface);
+    struct ID3DXEffectImpl *effect = impl_from_ID3DXEffect(iface);
+    unsigned int i;
+    struct d3dx_technique * technique;
 
-    FIXME("(%p)->(): stub\n", This);
+    TRACE("iface %p.\n", iface);
 
-    return E_NOTIMPL;
+    for (i = 0; i < effect->base_effect.technique_count; i++)
+    {
+        technique = &effect->base_effect.techniques[i];
+        if (technique->saved_state)
+        {
+            IDirect3DStateBlock9_Release(technique->saved_state);
+            technique->saved_state = NULL;
+        }
+    }
+    return D3D_OK;
 }
 
 static HRESULT WINAPI ID3DXEffectImpl_OnResetDevice(ID3DXEffect* iface)
 {
-    struct ID3DXEffectImpl *This = impl_from_ID3DXEffect(iface);
-
-    FIXME("(%p)->(): stub\n", This);
+    TRACE("iface %p.\n", iface);
 
-    return E_NOTIMPL;
+    return D3D_OK;
 }
 
 static HRESULT WINAPI ID3DXEffectImpl_SetStateManager(ID3DXEffect *iface, ID3DXEffectStateManager *manager)
-- 
2.5.5

From 4f9efeab44b293a1d02c4a97782bfa05a1892e20 Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Sun, 6 Mar 2016 02:45:08 +0300
Subject: [v5 11/12] d3dx9: Implement IsParameterUsed method in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/effect.c | 88 ++++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 86 insertions(+), 2 deletions(-)

diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 851de64..292074a 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -3557,15 +3557,99 @@ static HRESULT WINAPI ID3DXEffectImpl_FindNextValidTechnique(ID3DXEffect* iface,
     return E_NOTIMPL;
 }
 
+typedef BOOL (*walk_parameter_tree_func)(void *data, struct d3dx_parameter *param);
+static BOOL walk_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass, struct d3dx_state *state,
+        walk_parameter_tree_func par_func, void *data);
+
+static BOOL walk_parameter_tree(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
+        struct d3dx_parameter *param, walk_parameter_tree_func par_func, void *data)
+{
+    unsigned int i;
+
+    if (par_func(data, param))
+        return TRUE;
+
+    if (param->class == D3DXPC_OBJECT && param->type == D3DXPT_SAMPLER)
+    {
+        struct d3dx_sampler *sampler;
+
+        sampler = (struct d3dx_sampler *)param->data;
+        for (i = 0; i < sampler->state_count; i++)
+            if (walk_state(effect, pass, &sampler->states[i], par_func, data))
+                return TRUE;
+        return FALSE;
+    }
+
+    if (param->element_count)
+    {
+        for (i = 0; i < param->element_count; i++)
+            if (walk_parameter_tree(effect, pass, &param->members[i], par_func, data)) return TRUE;
+        return FALSE;
+    }
+    for (i = 0; i < param->member_count; i++)
+        if (walk_parameter_tree(effect, pass, &param->members[i], par_func, data)) return TRUE;
+    return FALSE;
+}
+
+static BOOL walk_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass, struct d3dx_state *state,
+        walk_parameter_tree_func par_func, void *data)
+{
+    void *param_value;
+    struct d3dx_parameter *par;
+    unsigned int k, npars;
+    struct d3dx_parameter **pars;
+
+    d3dx9_get_param_value_ptr(effect, pass, state, &param_value, &par);
+    if (walk_parameter_tree(effect, pass, par, par_func, data))
+        return TRUE;
+
+    if (par->param_eval)
+    {
+        pars = par->param_eval->shader_inputs.inputs_param;
+        npars = par->param_eval->shader_inputs.input_count;
+        for (k = 0; k < npars; k++)
+            if (walk_parameter_tree(effect, pass, pars[k], par_func, data))
+                return TRUE;
+
+        pars = par->param_eval->pres.inputs.inputs_param;
+        npars = par->param_eval->pres.inputs.input_count;
+        for (k = 0; k < npars; k++)
+            if (walk_parameter_tree(effect, pass, pars[k], par_func, data))
+                return TRUE;
+    }
+    return FALSE;
+}
+
+BOOL compare_par_ptr(void *par_comp, struct d3dx_parameter *param)
+{
+    return par_comp == (void *)param;
+}
+
 static BOOL WINAPI ID3DXEffectImpl_IsParameterUsed(ID3DXEffect* iface, D3DXHANDLE parameter, D3DXHANDLE technique)
 {
     struct ID3DXEffectImpl *effect = impl_from_ID3DXEffect(iface);
+    unsigned int i, j;
     struct d3dx_parameter *param = get_valid_parameter(&effect->base_effect, parameter);
+    struct d3dx_technique *tech = get_valid_technique(&effect->base_effect, technique);
+    struct d3dx_pass *pass;
 
-    FIXME("iface %p, parameter %p, technique %p stub.\n", iface, parameter, technique);
+    TRACE("iface %p, parameter %p, technique %p.\n", iface, parameter, technique);
     TRACE("param %p (%s).\n", param, param ? debugstr_a(param->name) : "");
 
-    return TRUE;
+    for (i = 0; i < tech->pass_count; i++)
+    {
+        pass = &tech->passes[i];
+        for (j = 0; j < pass->state_count; j++)
+        {
+            if (walk_state(effect, pass, &pass->states[j], compare_par_ptr, param))
+            {
+                TRACE("technique %p, parameter %s, TRUE.\n", tech, param->name);
+                return TRUE;
+            }
+        }
+    }
+    TRACE("technique %p, parameter %s, FALSE.\n", tech, param->name);
+    return FALSE;
 }
 
 static HRESULT WINAPI ID3DXEffectImpl_Begin(ID3DXEffect *iface, UINT *passes, DWORD flags)
-- 
2.5.5

From 972433e431ad75b74343dd153db00b472d098cac Mon Sep 17 00:00:00 2001
From: Paul Gofman <gofmanp@gmail.com>
Date: Mon, 7 Mar 2016 19:22:09 +0300
Subject: [v5 12/12] d3dx9: Implement shared parameters in effect.

Signed-off-by: Paul Gofman <gofmanp@gmail.com>
---
 dlls/d3dx9_36/d3dx9_private.h |   3 +
 dlls/d3dx9_36/effect.c        | 258 +++++++++++++++++++++++++++++++++---------
 2 files changed, 209 insertions(+), 52 deletions(-)

diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index a1e52e7..3988e18 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -187,6 +187,9 @@ struct d3dx_parameter
 
     struct d3dx_parameter *referenced_param;
     struct d3dx_param_eval *param_eval;
+
+    struct d3dx_parameter *shared_param;
+    UINT shared_refcount;
 };
 
 struct d3dx9_base_effect;
diff --git a/dlls/d3dx9_36/effect.c b/dlls/d3dx9_36/effect.c
index 292074a..bcf6d59 100644
--- a/dlls/d3dx9_36/effect.c
+++ b/dlls/d3dx9_36/effect.c
@@ -29,6 +29,8 @@
 
 #define INITIAL_PARAM_TABLE_SIZE 16
 
+#define PARAMETER_FLAG_SHARED 1
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
 enum STATE_CLASS
@@ -156,6 +158,7 @@ struct d3dx9_base_effect
     struct d3dx_object *objects;
 
     struct param_table param_table;
+    struct ID3DXEffectPoolImpl *pool;
 };
 
 struct ID3DXEffectImpl
@@ -174,6 +177,16 @@ struct ID3DXEffectImpl
     DWORD flags;
 };
 
+struct ID3DXEffectPoolImpl
+{
+    ID3DXEffectPool ID3DXEffectPool_iface;
+    LONG ref;
+
+    unsigned int parameter_count;
+    unsigned int table_size;
+    struct d3dx_parameter **parameters;
+};
+
 struct ID3DXEffectCompilerImpl
 {
     ID3DXEffectCompiler ID3DXEffectCompiler_iface;
@@ -186,7 +199,7 @@ static struct d3dx_parameter *get_annotation_by_name(UINT count, struct d3dx_par
         const char *name);
 static HRESULT d3dx9_parse_state(struct d3dx9_base_effect *base, struct d3dx_state *state,
         const char *data, const char **ptr, struct d3dx_object *objects);
-static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL child);
+static void free_parameter(struct ID3DXEffectPoolImpl *pool, struct d3dx_parameter *param, BOOL element, BOOL child);
 
 static const struct
 {
@@ -481,9 +494,9 @@ static struct d3dx_parameter *get_valid_parameter(struct d3dx9_base_effect *base
     return get_parameter_by_name(base, NULL, parameter);
 }
 
-static void free_state(struct d3dx_state *state)
+static void free_state(struct ID3DXEffectPoolImpl *pool, struct d3dx_state *state)
 {
-    free_parameter(&state->parameter, FALSE, FALSE);
+    free_parameter(pool, &state->parameter, FALSE, FALSE);
 }
 
 static void free_object(struct d3dx_object *object)
@@ -491,24 +504,29 @@ static void free_object(struct d3dx_object *object)
     HeapFree(GetProcessHeap(), 0, object->data);
 }
 
-static void free_sampler(struct d3dx_sampler *sampler)
+static void free_sampler(struct ID3DXEffectPoolImpl *pool, struct d3dx_sampler *sampler)
 {
     UINT i;
 
     for (i = 0; i < sampler->state_count; ++i)
     {
-        free_state(&sampler->states[i]);
+        free_state(pool, &sampler->states[i]);
     }
     HeapFree(GetProcessHeap(), 0, sampler->states);
 }
 
-static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL child)
+static BOOL d3dx_pool_release_shared_parameter(struct ID3DXEffectPoolImpl *pool, struct d3dx_parameter *param);
+
+static void free_parameter(struct ID3DXEffectPoolImpl *pool, struct d3dx_parameter *param, BOOL element, BOOL child)
 {
     unsigned int i;
 
     TRACE("Free parameter %p, name %s, type %s, child %s\n", param, param->name,
             debug_d3dxparameter_type(param->type), child ? "yes" : "no");
 
+    if (d3dx_pool_release_shared_parameter(pool, param))
+        return ;
+
     if (param->param_eval)
     {
         d3dx_free_param_eval(param->param_eval);
@@ -518,7 +536,7 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
     if (param->annotations)
     {
         for (i = 0; i < param->annotation_count; ++i)
-            free_parameter(&param->annotations[i], FALSE, FALSE);
+            free_parameter(pool, &param->annotations[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, param->annotations);
         param->annotations = NULL;
     }
@@ -528,7 +546,7 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
         unsigned int count = param->element_count ? param->element_count : param->member_count;
 
         for (i = 0; i < count; ++i)
-            free_parameter(&param->members[i], param->element_count != 0, TRUE);
+            free_parameter(pool, &param->members[i], param->element_count != 0, TRUE);
         HeapFree(GetProcessHeap(), 0, param->members);
         param->members = NULL;
     }
@@ -556,7 +574,7 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
             case D3DXPT_SAMPLER2D:
             case D3DXPT_SAMPLER3D:
             case D3DXPT_SAMPLERCUBE:
-                free_sampler((struct d3dx_sampler *)param->data);
+                free_sampler(pool, (struct d3dx_sampler *)param->data);
                 break;
 
             default:
@@ -578,7 +596,7 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
     }
 }
 
-static void free_pass(struct d3dx_pass *pass)
+static void free_pass(struct ID3DXEffectPoolImpl *pool, struct d3dx_pass *pass)
 {
     unsigned int i;
 
@@ -590,7 +608,7 @@ static void free_pass(struct d3dx_pass *pass)
     if (pass->annotations)
     {
         for (i = 0; i < pass->annotation_count; ++i)
-            free_parameter(&pass->annotations[i], FALSE, FALSE);
+            free_parameter(pool, &pass->annotations[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, pass->annotations);
         pass->annotations = NULL;
     }
@@ -598,7 +616,7 @@ static void free_pass(struct d3dx_pass *pass)
     if (pass->states)
     {
         for (i = 0; i < pass->state_count; ++i)
-            free_state(&pass->states[i]);
+            free_state(pool, &pass->states[i]);
         HeapFree(GetProcessHeap(), 0, pass->states);
         pass->states = NULL;
     }
@@ -607,7 +625,7 @@ static void free_pass(struct d3dx_pass *pass)
     pass->name = NULL;
 }
 
-static void free_technique(struct d3dx_technique *technique)
+static void free_technique(struct ID3DXEffectPoolImpl *pool, struct d3dx_technique *technique)
 {
     unsigned int i;
 
@@ -625,7 +643,7 @@ static void free_technique(struct d3dx_technique *technique)
     if (technique->annotations)
     {
         for (i = 0; i < technique->annotation_count; ++i)
-            free_parameter(&technique->annotations[i], FALSE, FALSE);
+            free_parameter(pool, &technique->annotations[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, technique->annotations);
         technique->annotations = NULL;
     }
@@ -633,7 +651,7 @@ static void free_technique(struct d3dx_technique *technique)
     if (technique->passes)
     {
         for (i = 0; i < technique->pass_count; ++i)
-            free_pass(&technique->passes[i]);
+            free_pass(pool, &technique->passes[i]);
         HeapFree(GetProcessHeap(), 0, technique->passes);
         technique->passes = NULL;
     }
@@ -653,7 +671,7 @@ static void d3dx9_base_effect_cleanup(struct d3dx9_base_effect *base)
     if (base->parameters)
     {
         for (i = 0; i < base->parameter_count; ++i)
-            free_parameter(&base->parameters[i], FALSE, FALSE);
+            free_parameter(base->pool, &base->parameters[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, base->parameters);
         base->parameters = NULL;
     }
@@ -661,7 +679,7 @@ static void d3dx9_base_effect_cleanup(struct d3dx9_base_effect *base)
     if (base->techniques)
     {
         for (i = 0; i < base->technique_count; ++i)
-            free_technique(&base->techniques[i]);
+            free_technique(base->pool, &base->techniques[i]);
         HeapFree(GetProcessHeap(), 0, base->techniques);
         base->techniques = NULL;
     }
@@ -2916,6 +2934,98 @@ static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3
     return ret;
 }
 
+static BOOL d3dx_pool_get_shared_parameter(struct ID3DXEffectPoolImpl *pool, struct d3dx_parameter *param,
+        struct d3dx_parameter **shared_param)
+{
+    unsigned int i;
+    BOOL ret;
+
+    *shared_param = NULL;
+    if (!(param->flags & PARAMETER_FLAG_SHARED) || !pool)
+        return FALSE;
+
+    for (i = 0; i < pool->parameter_count; i++)
+        if (pool->parameters[i] && !strcmp(param->name, pool->parameters[i]->name))
+            break;
+    if (i == pool->parameter_count)
+    {
+        if (pool->parameter_count >= pool->table_size)
+        {
+            struct d3dx_parameter ** new_alloc;
+            unsigned int new_size;
+
+            if (!pool->table_size)
+            {
+                new_size = INITIAL_PARAM_TABLE_SIZE;
+                new_alloc = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pool->parameters) * new_size);
+                if (!new_alloc)
+                {
+                    ERR("Out of memory.\n");
+                    return FALSE;
+                }
+            }
+            else
+            {
+                new_size = pool->table_size * 2;
+                new_alloc = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pool->parameters, sizeof(*pool->parameters) * new_size);
+                if (!new_alloc)
+                {
+                    ERR("Out of memory.\n");
+                    return FALSE;
+                }
+            }
+            pool->parameters = new_alloc;
+            pool->table_size = new_size;
+        }
+        pool->parameters[i] = HeapAlloc(GetProcessHeap(), 0, sizeof(struct d3dx_parameter));
+        *pool->parameters[i] = *param;
+
+        pool->parameters[i]->shared_refcount = 0;
+        pool->parameter_count++;
+        ret = FALSE;
+    }
+    else
+        ret = TRUE;
+    pool->parameters[i]->shared_refcount++;
+    *shared_param = pool->parameters[i];
+    TRACE("name %s, parameter idx %u, handle %p, new refcount %u.\n", param->name, i,
+            pool->parameters[i]->handle, pool->parameters[i]->shared_refcount);
+    return ret;
+}
+
+static BOOL d3dx_pool_release_shared_parameter(struct ID3DXEffectPoolImpl *pool, struct d3dx_parameter *param)
+{
+    struct d3dx_parameter *pshared = param->shared_param;
+
+    TRACE("pool %p, param %p.\n", pool, param);
+
+    if (pool && pshared)
+    {
+        TRACE("pshared %p, refcount %u.\n", pshared, pshared->shared_refcount);
+        if (!--pshared->shared_refcount)
+        {
+            unsigned int i;
+
+            for (i = 0; i < pool->parameter_count; i++)
+                if (pool->parameters[i] == pshared)
+                    break;
+            if (i == pool->parameter_count)
+                FIXME("Shared parameter not found in pool.\n");
+            else
+                pool->parameters[i] = NULL;
+            pshared->flags = 0;
+            free_parameter(pool, pshared, FALSE, FALSE);
+        }
+        return TRUE;
+    }
+    return FALSE;
+}
+
+static inline struct ID3DXEffectPoolImpl *impl_from_ID3DXEffectPool(ID3DXEffectPool *iface)
+{
+    return CONTAINING_RECORD(iface, struct ID3DXEffectPoolImpl, ID3DXEffectPool_iface);
+}
+
 static inline struct ID3DXEffectImpl *impl_from_ID3DXEffect(ID3DXEffect *iface)
 {
     return CONTAINING_RECORD(iface, struct ID3DXEffectImpl, ID3DXEffect_iface);
@@ -3622,7 +3732,8 @@ static BOOL walk_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass, s
 
 BOOL compare_par_ptr(void *par_comp, struct d3dx_parameter *param)
 {
-    return par_comp == (void *)param;
+    return par_comp == (void *)param ||
+            par_comp == (void *)param->shared_param;
 }
 
 static BOOL WINAPI ID3DXEffectImpl_IsParameterUsed(ID3DXEffect* iface, D3DXHANDLE parameter, D3DXHANDLE technique)
@@ -4719,7 +4830,7 @@ err_out:
 
     for (i = 0; i < sampler->state_count; ++i)
     {
-        free_state(&sampler->states[i]);
+        free_state(base->pool, &sampler->states[i]);
     }
     HeapFree(GetProcessHeap(), 0, sampler->states);
     sampler->states = NULL;
@@ -4992,6 +5103,34 @@ static void sync_param_handles(struct d3dx9_base_effect *base)
         table->table[i]->handle = (D3DXHANDLE)&table->table[i];
 }
 
+BOOL add_param_to_table_func(void *base_effect, struct d3dx_parameter *param)
+{
+    add_param_to_table((struct d3dx9_base_effect *)base_effect, param);
+    return FALSE;
+}
+
+static void sync_shared_parameters(struct d3dx9_base_effect *base)
+{
+    unsigned int i;
+
+    if (!base->pool) return ;
+
+    for (i = 0; i < base->parameter_count; i++)
+        if (base->parameters[i].flags & PARAMETER_FLAG_SHARED)
+        {
+            struct d3dx_parameter *shared_param;
+
+            if (d3dx_pool_get_shared_parameter(base->pool, &base->parameters[i], &shared_param))
+            {
+                /* parameter found in shared table */
+                free_parameter(base->pool, &base->parameters[i], FALSE, FALSE);
+            }
+            base->parameters[i] = *shared_param;
+            walk_parameter_tree(base->effect, NULL, &base->parameters[i], add_param_to_table_func, base);
+            base->parameters[i].shared_param = shared_param;
+        }
+}
+
 static HRESULT d3dx9_parse_effect_typedef(struct d3dx9_base_effect *base, struct d3dx_parameter *param,
 	const char *data, const char **ptr, struct d3dx_parameter *parent, UINT flags)
 {
@@ -5126,7 +5265,8 @@ static HRESULT d3dx9_parse_effect_typedef(struct d3dx9_base_effect *base, struct
         {
             *ptr = save_ptr;
 
-            add_param_to_table(base, &param->members[i]);
+            if (!(flags & PARAMETER_FLAG_SHARED))
+                add_param_to_table(base, &param->members[i]);
             hr = d3dx9_parse_effect_typedef(base, &param->members[i], data, ptr, param, flags);
             if (hr != D3D_OK)
             {
@@ -5151,7 +5291,8 @@ static HRESULT d3dx9_parse_effect_typedef(struct d3dx9_base_effect *base, struct
 
         for (i = 0; i < param->member_count; ++i)
         {
-            add_param_to_table(base, &param->members[i]);
+            if (!(flags & PARAMETER_FLAG_SHARED))
+                add_param_to_table(base, &param->members[i]);
             hr = d3dx9_parse_effect_typedef(base, &param->members[i], data, ptr, NULL, flags);
             if (hr != D3D_OK)
             {
@@ -5171,7 +5312,7 @@ err_out:
         unsigned int count = param->element_count ? param->element_count : param->member_count;
 
         for (i = 0; i < count; ++i)
-            free_parameter(&param->members[i], param->element_count != 0, TRUE);
+            free_parameter(base->pool, &param->members[i], param->element_count != 0, TRUE);
         HeapFree(GetProcessHeap(), 0, param->members);
         param->members = NULL;
     }
@@ -5256,7 +5397,7 @@ static HRESULT d3dx9_parse_state(struct d3dx9_base_effect *base, struct d3dx_sta
 
 err_out:
 
-    free_parameter(&state->parameter, FALSE, FALSE);
+    free_parameter(base->pool, &state->parameter, FALSE, FALSE);
 
     return hr;
 }
@@ -5309,7 +5450,8 @@ static HRESULT d3dx9_parse_effect_parameter(struct d3dx9_base_effect *base, stru
 
         for (i = 0; i < param->annotation_count; ++i)
         {
-            add_param_to_table(base, &param->annotations[i]);
+            if (!(param->flags & PARAMETER_FLAG_SHARED))
+                add_param_to_table(base, &param->annotations[i]);
             hr = d3dx9_parse_effect_annotation(base, &param->annotations[i], data, ptr, objects);
             if (hr != D3D_OK)
             {
@@ -5326,7 +5468,7 @@ err_out:
     if (param->annotations)
     {
         for (i = 0; i < param->annotation_count; ++i)
-            free_parameter(&param->annotations[i], FALSE, FALSE);
+            free_parameter(base->pool, &param->annotations[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, param->annotations);
         param->annotations = NULL;
     }
@@ -5412,7 +5554,7 @@ err_out:
     if (pass->annotations)
     {
         for (i = 0; i < pass->annotation_count; ++i)
-            free_parameter(&pass->annotations[i], FALSE, FALSE);
+            free_parameter(base->pool, &pass->annotations[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, pass->annotations);
         pass->annotations = NULL;
     }
@@ -5421,7 +5563,7 @@ err_out:
     {
         for (i = 0; i < pass->state_count; ++i)
         {
-            free_state(&states[i]);
+            free_state(base->pool, &states[i]);
         }
         HeapFree(GetProcessHeap(), 0, states);
     }
@@ -5508,7 +5650,7 @@ err_out:
     if (technique->passes)
     {
         for (i = 0; i < technique->pass_count; ++i)
-            free_pass(&technique->passes[i]);
+            free_pass(base->pool, &technique->passes[i]);
         HeapFree(GetProcessHeap(), 0, technique->passes);
         technique->passes = NULL;
     }
@@ -5516,7 +5658,7 @@ err_out:
     if (technique->annotations)
     {
         for (i = 0; i < technique->annotation_count; ++i)
-            free_parameter(&technique->annotations[i], FALSE, FALSE);
+            free_parameter(base->pool, &technique->annotations[i], FALSE, FALSE);
         HeapFree(GetProcessHeap(), 0, technique->annotations);
         technique->annotations = NULL;
     }
@@ -5822,7 +5964,8 @@ static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *da
 
         for (i = 0; i < base->parameter_count; ++i)
         {
-            add_param_to_table(base, &base->parameters[i]);
+            if (!(base->parameters[i].flags & PARAMETER_FLAG_SHARED))
+                add_param_to_table(base, &base->parameters[i]);
             hr = d3dx9_parse_effect_parameter(base, &base->parameters[i], data, &ptr, base->objects);
             if (hr != D3D_OK)
             {
@@ -5832,6 +5975,8 @@ static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *da
         }
     }
 
+    sync_shared_parameters(base);
+
     if (base->technique_count)
     {
         base->techniques = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
@@ -5899,7 +6044,7 @@ err_out:
     if (base->techniques)
     {
         for (i = 0; i < base->technique_count; ++i)
-            free_technique(&base->techniques[i]);
+            free_technique(base->pool, &base->techniques[i]);
         HeapFree(GetProcessHeap(), 0, base->techniques);
         base->techniques = NULL;
     }
@@ -5908,7 +6053,7 @@ err_out:
     {
         for (i = 0; i < base->parameter_count; ++i)
         {
-            free_parameter(&base->parameters[i], FALSE, FALSE);
+            free_parameter(base->pool, &base->parameters[i], FALSE, FALSE);
         }
         HeapFree(GetProcessHeap(), 0, base->parameters);
         base->parameters = NULL;
@@ -5929,16 +6074,17 @@ err_out:
 
 static HRESULT d3dx9_base_effect_init(struct d3dx9_base_effect *base,
         const char *data, SIZE_T data_size, const D3D_SHADER_MACRO *defines, ID3DInclude *include,
-        UINT eflags, ID3DBlob **errors, struct ID3DXEffectImpl *effect)
+        UINT eflags, ID3DBlob **errors, struct ID3DXEffectImpl *effect, struct ID3DXEffectPoolImpl *pool)
 {
     DWORD tag, offset;
     const char *ptr = data;
     HRESULT hr;
     ID3DBlob *bytecode = NULL, *temp_errors = NULL;
 
-    TRACE("base %p, data %p, data_size %lu, effect %p\n", base, data, data_size, effect);
+    TRACE("base %p, data %p, data_size %lu, effect %p, pool %p\n", base, data, data_size, effect, pool);
 
     base->effect = effect;
+    base->pool = pool;
 
     read_dword(&ptr, &tag);
     TRACE("Tag: %x\n", tag);
@@ -5996,9 +6142,13 @@ static HRESULT d3dx9_effect_init(struct ID3DXEffectImpl *effect, struct IDirect3
         UINT eflags, ID3DBlob **error_messages, struct ID3DXEffectPool *pool)
 {
     HRESULT hr;
+    struct ID3DXEffectPoolImpl *pool_impl = NULL;
 
     TRACE("effect %p, device %p, data %p, data_size %lu, pool %p\n", effect, device, data, data_size, pool);
 
+    if (pool)
+        pool_impl = impl_from_ID3DXEffectPool(pool);
+
     effect->ID3DXEffect_iface.lpVtbl = &ID3DXEffect_Vtbl;
     effect->ref = 1;
 
@@ -6009,7 +6159,7 @@ static HRESULT d3dx9_effect_init(struct ID3DXEffectImpl *effect, struct IDirect3
     effect->device = device;
 
     if (FAILED(hr = d3dx9_base_effect_init(&effect->base_effect, data, data_size, defines, include,
-            eflags, error_messages, effect)))
+            eflags, error_messages, effect, pool_impl)))
     {
         FIXME("Failed to parse effect, hr %#x.\n", hr);
         free_effect(effect);
@@ -6096,7 +6246,7 @@ static HRESULT d3dx9_effect_compiler_init(struct ID3DXEffectCompilerImpl *compil
     compiler->ref = 1;
 
     if (FAILED(hr = d3dx9_base_effect_init(&compiler->base_effect, data, data_size, defines,
-            include, eflags, error_messages, NULL)))
+            include, eflags, error_messages, NULL, NULL)))
     {
         FIXME("Failed to parse effect, hr %#x.\n", hr);
         free_effect_compiler(compiler);
@@ -6141,17 +6291,6 @@ HRESULT WINAPI D3DXCreateEffectCompiler(const char *srcdata, UINT srcdatalen, co
     return D3D_OK;
 }
 
-struct ID3DXEffectPoolImpl
-{
-    ID3DXEffectPool ID3DXEffectPool_iface;
-    LONG ref;
-};
-
-static inline struct ID3DXEffectPoolImpl *impl_from_ID3DXEffectPool(ID3DXEffectPool *iface)
-{
-    return CONTAINING_RECORD(iface, struct ID3DXEffectPoolImpl, ID3DXEffectPool_iface);
-}
-
 /*** IUnknown methods ***/
 static HRESULT WINAPI ID3DXEffectPoolImpl_QueryInterface(ID3DXEffectPool *iface, REFIID riid, void **object)
 {
@@ -6179,16 +6318,31 @@ static ULONG WINAPI ID3DXEffectPoolImpl_AddRef(ID3DXEffectPool *iface)
     return InterlockedIncrement(&This->ref);
 }
 
+void free_effect_pool(struct ID3DXEffectPoolImpl *pool)
+{
+    unsigned int i;
+
+    for (i = 0; i < pool->parameter_count; ++i)
+        if (pool->parameters[i])
+        {
+            free_parameter(pool, pool->parameters[i], FALSE, FALSE);
+            pool->parameters[i] = NULL;
+        }
+    HeapFree(GetProcessHeap(), 0, pool->parameters);
+    pool->parameters = NULL;
+
+    HeapFree(GetProcessHeap(), 0, pool);
+}
+
 static ULONG WINAPI ID3DXEffectPoolImpl_Release(ID3DXEffectPool *iface)
 {
-    struct ID3DXEffectPoolImpl *This = impl_from_ID3DXEffectPool(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    struct ID3DXEffectPoolImpl *pool = impl_from_ID3DXEffectPool(iface);
+    ULONG ref = InterlockedDecrement(&pool->ref);
 
-    TRACE("(%p)->(): Release from %u\n", This, ref + 1);
+    TRACE("(%p)->(): Release from %u\n", pool, ref + 1);
 
     if (!ref)
-        HeapFree(GetProcessHeap(), 0, This);
-
+        free_effect_pool(pool);
     return ref;
 }
 
-- 
2.5.5
