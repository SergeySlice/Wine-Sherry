 dlls/d3dx9_36/d3dx9_private.h |  5 ++++
 dlls/d3dx9_36/effect.c        | 69 +++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 74 insertions(+)
--- a/dlls/d3dx9_36/d3dx9_private.h	
+++ a/dlls/d3dx9_36/d3dx9_private.h	
@@ -176,6 +176,8 @@ struct d3dx_param_eval
     struct d3dx_const_tab shader_inputs;
 };
 
+#define PARAMETER_FLAG_DIRTY 0x1u
+
 struct d3dx_parameter
 {
     char *name;
@@ -190,6 +192,7 @@ struct d3dx_parameter
     UINT member_count;
     DWORD flags;
     UINT bytes;
+    DWORD rt_flags;
     DWORD object_id;
 
     D3DXHANDLE handle;
@@ -199,6 +202,8 @@ struct d3dx_parameter
 
     struct d3dx_parameter *referenced_param;
     struct d3dx_param_eval *param_eval;
+
+    DWORD *dirty_flag_ptr;
 };
 
 struct d3dx9_base_effect;
--- a/dlls/d3dx9_36/effect.c	
+++ a/dlls/d3dx9_36/effect.c	
@@ -1316,6 +1316,46 @@ static D3DXHANDLE d3dx9_base_effect_get_annotation_by_name(struct d3dx9_base_eff
     return NULL;
 }
 
+static BOOL walk_parameter_tree(struct d3dx_parameter *param, walk_parameter_dep_func param_func,
+        void *data)
+{
+    unsigned int i;
+    unsigned int member_count;
+
+    if (param_func(data, param))
+        return TRUE;
+
+    member_count = param->element_count ? param->element_count : param->member_count;
+    for (i = 0; i < member_count; ++i)
+    {
+        if (walk_parameter_tree(&param->members[i], param_func, data))
+            return TRUE;
+    }
+    return FALSE;
+}
+
+static BOOL param_member_set_dirty(void *bytes_remaining, struct d3dx_parameter *param)
+{
+    unsigned int *bytes = (unsigned int *)bytes_remaining;
+
+    if (!*bytes)
+        return TRUE;
+    *param->dirty_flag_ptr |= PARAMETER_FLAG_DIRTY;
+    if (!param->element_count && !param->member_count)
+        *bytes -= param->bytes;
+    return FALSE;
+}
+
+static void set_dirty_with_members(struct d3dx_parameter *param, unsigned int bytes)
+{
+    walk_parameter_tree(param, param_member_set_dirty, &bytes);
+}
+
+static void set_dirty(struct d3dx_parameter *param)
+{
+    *param->dirty_flag_ptr |= PARAMETER_FLAG_DIRTY;
+}
+
 static HRESULT d3dx9_base_effect_set_value(struct d3dx9_base_effect *base,
         D3DXHANDLE parameter, const void *data, UINT bytes)
 {
@@ -1364,6 +1404,7 @@ static HRESULT d3dx9_base_effect_set_value(struct d3dx9_base_effect *base,
             case D3DXPT_FLOAT:
                 TRACE("Copy %u bytes\n", param->bytes);
                 memcpy(param->data, data, param->bytes);
+                set_dirty_with_members(param, param->bytes);
                 break;
 
             default:
@@ -1450,6 +1491,7 @@ static HRESULT d3dx9_base_effect_set_bool(struct d3dx9_base_effect *base, D3DXHA
     if (param && !param->element_count && param->rows == 1 && param->columns == 1)
     {
         set_number(param->data, param->type, &b, D3DXPT_BOOL);
+        set_dirty(param);
         return D3D_OK;
     }
 
@@ -1495,6 +1537,7 @@ static HRESULT d3dx9_base_effect_set_bool_array(struct d3dx9_base_effect *base,
                     /* don't crop the input, use D3DXPT_INT instead of D3DXPT_BOOL */
                     set_number((DWORD *)param->data + i, param->type, &b[i], D3DXPT_INT);
                 }
+                set_dirty_with_members(param, size * sizeof(DWORD));
                 return D3D_OK;
 
             case D3DXPC_OBJECT:
@@ -1545,6 +1588,7 @@ static HRESULT d3dx9_base_effect_set_int(struct d3dx9_base_effect *base, D3DXHAN
         if (param->rows == 1 && param->columns == 1)
         {
             set_number(param->data, param->type, &n, D3DXPT_INT);
+            set_dirty(param);
             return D3D_OK;
         }
 
@@ -1564,6 +1608,7 @@ static HRESULT d3dx9_base_effect_set_int(struct d3dx9_base_effect *base, D3DXHAN
             {
                 ((FLOAT *)param->data)[3] = ((n & 0xff000000) >> 24) * INT_FLOAT_MULTI_INVERSE;
             }
+            set_dirty(param);
             return D3D_OK;
         }
     }
@@ -1631,6 +1676,7 @@ static HRESULT d3dx9_base_effect_set_int_array(struct d3dx9_base_effect *base,
                 {
                     set_number((DWORD *)param->data + i, param->type, &n[i], D3DXPT_INT);
                 }
+                set_dirty_with_members(param, size * sizeof(DWORD));
                 return D3D_OK;
 
             case D3DXPC_OBJECT:
@@ -1679,6 +1725,7 @@ static HRESULT d3dx9_base_effect_set_float(struct d3dx9_base_effect *base, D3DXH
     if (param && !param->element_count && param->rows == 1 && param->columns == 1)
     {
         set_number((DWORD *)param->data, param->type, &f, D3DXPT_FLOAT);
+        set_dirty(param);
         return D3D_OK;
     }
 
@@ -1723,6 +1770,7 @@ static HRESULT d3dx9_base_effect_set_float_array(struct d3dx9_base_effect *base,
                 {
                     set_number((DWORD *)param->data + i, param->type, &f[i], D3DXPT_FLOAT);
                 }
+                set_dirty_with_members(param, size * sizeof(DWORD));
                 return D3D_OK;
 
             case D3DXPC_OBJECT:
@@ -1777,6 +1825,7 @@ static HRESULT d3dx9_base_effect_set_vector(struct d3dx9_base_effect *base,
         {
             case D3DXPC_SCALAR:
             case D3DXPC_VECTOR:
+                set_dirty(param);
                 if (param->type == D3DXPT_INT && param->bytes == 4)
                 {
                     DWORD tmp;
@@ -1870,6 +1919,7 @@ static HRESULT d3dx9_base_effect_set_vector_array(struct d3dx9_base_effect *base
         switch (param->class)
         {
             case D3DXPC_VECTOR:
+                set_dirty_with_members(param, count * param->columns * sizeof(DWORD));
                 if (param->type == D3DXPT_FLOAT)
                 {
                     if (param->columns == 4)
@@ -1956,6 +2006,7 @@ static HRESULT d3dx9_base_effect_set_matrix(struct d3dx9_base_effect *base,
         {
             case D3DXPC_MATRIX_ROWS:
                 set_matrix(param, matrix);
+                set_dirty(param);
                 return D3D_OK;
 
             case D3DXPC_SCALAR:
@@ -2021,9 +2072,11 @@ static HRESULT d3dx9_base_effect_set_matrix_array(struct d3dx9_base_effect *base
         switch (param->class)
         {
             case D3DXPC_MATRIX_ROWS:
+                set_dirty(param);
                 for (i = 0; i < count; ++i)
                 {
                     set_matrix(&param->members[i], &matrix[i]);
+                    set_dirty(&param->members[i]);
                 }
                 return D3D_OK;
 
@@ -2095,9 +2148,11 @@ static HRESULT d3dx9_base_effect_set_matrix_pointer_array(struct d3dx9_base_effe
         switch (param->class)
         {
             case D3DXPC_MATRIX_ROWS:
+                set_dirty(param);
                 for (i = 0; i < count; ++i)
                 {
                     set_matrix(&param->members[i], matrix[i]);
+                    set_dirty(&param->members[i]);
                 }
                 return D3D_OK;
 
@@ -2167,6 +2222,7 @@ static HRESULT d3dx9_base_effect_set_matrix_transpose(struct d3dx9_base_effect *
         switch (param->class)
         {
             case D3DXPC_MATRIX_ROWS:
+                set_dirty(param);
                 set_matrix_transpose(param, matrix);
                 return D3D_OK;
 
@@ -2236,9 +2292,11 @@ static HRESULT d3dx9_base_effect_set_matrix_transpose_array(struct d3dx9_base_ef
         switch (param->class)
         {
             case D3DXPC_MATRIX_ROWS:
+                set_dirty(param);
                 for (i = 0; i < count; ++i)
                 {
                     set_matrix_transpose(&param->members[i], &matrix[i]);
+                    set_dirty(&param->members[i]);
                 }
                 return D3D_OK;
 
@@ -2310,9 +2368,11 @@ static HRESULT d3dx9_base_effect_set_matrix_transpose_pointer_array(struct d3dx9
         switch (param->class)
         {
             case D3DXPC_MATRIX_ROWS:
+                set_dirty(param);
                 for (i = 0; i < count; ++i)
                 {
                     set_matrix_transpose(&param->members[i], matrix[i]);
+                    set_dirty(&param->members[i]);
                 }
                 return D3D_OK;
 
@@ -2414,6 +2474,7 @@ static HRESULT d3dx9_base_effect_set_texture(struct d3dx9_base_effect *base,
         if (oltexture) IDirect3DBaseTexture9_Release(oltexture);
 
         *(struct IDirect3DBaseTexture9 **)param->data = texture;
+        set_dirty(param);
 
         return D3D_OK;
     }
@@ -5807,6 +5868,12 @@ static HRESULT d3dx9_parse_resource(struct d3dx9_base_effect *base, const char *
     return hr;
 }
 
+static BOOL param_set_dirty_flag_ptr(void *dirty_flag_ptr, struct d3dx_parameter *param)
+{
+    param->dirty_flag_ptr = (DWORD *)dirty_flag_ptr;
+    return FALSE;
+}
+
 static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *data, UINT data_size, DWORD start)
 {
     const char *ptr = data + start;
@@ -5916,6 +5983,8 @@ static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *da
         }
     }
 
+    for (i = 0; i < base->parameter_count; ++i)
+        walk_parameter_tree(&base->parameters[i], param_set_dirty_flag_ptr, &base->parameters[i].rt_flags);
     return D3D_OK;
 
 err_out:
-- 
 (draft).
---
 dlls/d3dx9_36/d3dx9_private.h |   8 +++-
 dlls/d3dx9_36/effect.c        | 101 ++++++++++++++++++++++++++++++-----------
 dlls/d3dx9_36/preshader.c     |  40 +++++++++++++---
 dlls/d3dx9_36/tests/effect.c  | 103 ++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 218 insertions(+), 34 deletions(-)
--- a/dlls/d3dx9_36/d3dx9_private.h	
+++ a/dlls/d3dx9_36/d3dx9_private.h	
@@ -206,6 +206,11 @@ struct d3dx_parameter
     DWORD *dirty_flag_ptr;
 };
 
+static inline BOOL is_param_dirty(struct d3dx_parameter *param)
+{
+    return (*param->dirty_flag_ptr & PARAMETER_FLAG_DIRTY);
+}
+
 struct d3dx9_base_effect;
 
 struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
@@ -217,6 +222,7 @@ void d3dx_free_param_eval(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
 HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval,
         const struct d3dx_parameter *param, void *param_value) DECLSPEC_HIDDEN;
 HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device,
-        struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
+        struct d3dx_param_eval *peval, BOOL update_all) DECLSPEC_HIDDEN;
+BOOL is_param_eval_input_dirty(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_D3DX9_PRIVATE_H */
--- a/dlls/d3dx9_36/effect.c	
+++ a/dlls/d3dx9_36/effect.c	
@@ -485,6 +485,8 @@ static struct d3dx_parameter *get_valid_parameter(struct d3dx9_base_effect *base
 
 static void free_state(struct d3dx_state *state)
 {
+    if (state->type == ST_ARRAY_SELECTOR)
+        *(unsigned int *)state->parameter.data = 0;
     free_parameter(&state->parameter, FALSE, FALSE);
 }
 
@@ -1356,6 +1358,20 @@ static void set_dirty(struct d3dx_parameter *param)
     *param->dirty_flag_ptr |= PARAMETER_FLAG_DIRTY;
 }
 
+static BOOL param_clear_dirty_func(void *dummy, struct d3dx_parameter *param)
+{
+    *param->dirty_flag_ptr &= ~PARAMETER_FLAG_DIRTY;
+    return FALSE;
+}
+
+static void clear_dirty_all(struct d3dx9_base_effect *base)
+{
+    unsigned int i;
+
+    for (i = 0; i < base->parameter_count; ++i)
+        walk_parameter_tree(&base->parameters[i], param_clear_dirty_func, NULL);
+}
+
 static HRESULT d3dx9_base_effect_set_value(struct d3dx9_base_effect *base,
         D3DXHANDLE parameter, const void *data, UINT bytes)
 {
@@ -2550,17 +2566,20 @@ static HRESULT d3dx9_base_effect_set_array_range(struct d3dx9_base_effect *base,
 }
 
 static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
-        struct d3dx_state *state, void **param_value, struct d3dx_parameter **out_param)
+        struct d3dx_state *state, void **param_value, struct d3dx_parameter **out_param,
+        BOOL update_all, BOOL *param_dirty)
 {
     struct d3dx_parameter *param = &state->parameter;
 
     *param_value = NULL;
     *out_param = NULL;
+    *param_dirty = FALSE;
 
     switch (state->type)
     {
         case ST_PARAMETER:
             param = param->referenced_param;
+            *param_dirty = is_param_dirty(param);
             /* fallthrough */
         case ST_CONSTANT:
             *out_param = param;
@@ -2572,23 +2591,36 @@ static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct
             static const struct d3dx_parameter array_idx_param =
                 {NULL, NULL, NULL, D3DXPC_SCALAR, D3DXPT_INT, 1, 1, 0, 0, 0, 0, sizeof(array_idx)};
             HRESULT hr;
+            struct d3dx_parameter *ref_param;
 
             if (!param->param_eval)
             {
                 FIXME("Preshader structure is null.\n");
                 return D3DERR_INVALIDCALL;
             }
-            if (FAILED(hr = d3dx_evaluate_parameter(param->param_eval, &array_idx_param, &array_idx)))
-                return hr;
-
-            param = param->referenced_param;
+            if (update_all || is_param_eval_input_dirty(param->param_eval))
+            {
+                if (FAILED(hr = d3dx_evaluate_parameter(param->param_eval, &array_idx_param, &array_idx)))
+                    return hr;
+            }
+            else
+            {
+                array_idx = *(unsigned int *)param->data;
+            }
+            ref_param = param->referenced_param;
             TRACE("Array index %u.\n", array_idx);
-            if (array_idx >= param->element_count)
+            if (array_idx >= ref_param->element_count)
             {
-                ERR("Computed array index %u is out of bound %u.\n", array_idx, param->element_count);
-                return D3DERR_INVALIDCALL;
+                WARN("Computed array index %u is out of bound %u, old index %u.\n", array_idx,
+                        param->element_count, *(unsigned int *)param->data);
+                array_idx = *(unsigned int *)param->data;
+                if (array_idx >= ref_param->element_count)
+                    return D3DERR_INVALIDCALL;
             }
-            param = &param->members[array_idx];
+            *param_dirty = (*(unsigned int *)param->data != array_idx);
+            *(unsigned int *)param->data = array_idx;
+            param = &ref_param->members[array_idx];
+            *param_dirty = *param_dirty || is_param_dirty(param);
 
             *param_value = param->data;
             *out_param = param;
@@ -2599,7 +2631,13 @@ static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct
             {
                 *out_param = param;
                 *param_value = param->data;
-                return d3dx_evaluate_parameter(param->param_eval, param, *param_value);
+                if (update_all || is_param_eval_input_dirty(param->param_eval))
+                {
+                    *param_dirty = TRUE;
+                    return d3dx_evaluate_parameter(param->param_eval, param, *param_value);
+                }
+                else
+                    return D3D_OK;
             }
             else
             {
@@ -2777,10 +2815,10 @@ static HRESULT d3dx_set_shader_const_state(IDirect3DDevice9 *device, enum SHADER
 }
 
 static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
-        struct d3dx_state *state, unsigned int parent_index);
+        struct d3dx_state *state, unsigned int parent_index, BOOL update_all);
 
 static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
-        struct d3dx_parameter *param, BOOL vs)
+        struct d3dx_parameter *param, BOOL vs, BOOL update_all)
 {
     IDirect3DDevice9 *device = effect->device;
     HRESULT hr, ret;
@@ -2794,7 +2832,7 @@ static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct
         FIXME("param_eval structure is null.\n");
         return D3DERR_INVALIDCALL;
     }
-    if (FAILED(hr = d3dx_param_eval_set_shader_constants(device, param->param_eval)))
+    if (FAILED(hr = d3dx_param_eval_set_shader_constants(device, param->param_eval, update_all)))
         return hr;
     params = param->param_eval->shader_inputs.inputs_param;
     cdesc = param->param_eval->shader_inputs.inputs;
@@ -2812,7 +2850,7 @@ static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct
             for (j = 0; j < sampler->state_count; ++j)
             {
                 if (FAILED(hr = d3dx9_apply_state(effect, pass, &sampler->states[j],
-                        cdesc[i].RegisterIndex + (vs ? D3DVERTEXTEXTURESAMPLER0 : 0))))
+                        cdesc[i].RegisterIndex + (vs ? D3DVERTEXTEXTURESAMPLER0 : 0), update_all)))
                     ret = hr;
             }
         }
@@ -2821,19 +2859,27 @@ static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct
 }
 
 static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
-        struct d3dx_state *state, unsigned int parent_index)
+        struct d3dx_state *state, unsigned int parent_index, BOOL update_all)
 {
     IDirect3DDevice9 *device = effect->device;
     struct d3dx_parameter *param;
     void *param_value;
+    BOOL param_dirty;
     HRESULT hr;
 
     TRACE("operation %u, index %u, type %u.\n", state->operation, state->index, state->type);
-    if (FAILED(hr = d3dx9_get_param_value_ptr(effect, pass, state, &param_value, &param)))
+    if (FAILED(hr = d3dx9_get_param_value_ptr(effect, pass, state, &param_value, &param,
+            update_all, &param_dirty)))
         /* Native d3dx returns D3D_OK from BeginPass or Commit involving out of bounds array
          * access and does not touch affected state. */
         return D3D_OK;
 
+    if (!(update_all || param_dirty
+            || state_table[state->operation].class == SC_VERTEXSHADER
+            || state_table[state->operation].class == SC_PIXELSHADER
+            || state_table[state->operation].class == SC_SETSAMPLER))
+        return D3D_OK;
+
     switch (state_table[state->operation].class)
     {
         case SC_RENDERSTATE:
@@ -2868,7 +2914,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
             ret = D3D_OK;
             for (i = 0; i < sampler->state_count; i++)
             {
-                if (FAILED(hr = d3dx9_apply_state(effect, pass, &sampler->states[i], state->index)))
+                if (FAILED(hr = d3dx9_apply_state(effect, pass, &sampler->states[i], state->index, update_all)))
                     ret = hr;
             }
             return ret;
@@ -2884,17 +2930,19 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
         }
         case SC_VERTEXSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DVertexShader9 **)param_value);
-            if (FAILED(hr = IDirect3DDevice9_SetVertexShader(device, *(IDirect3DVertexShader9 **)param_value)))
+            if ((update_all || param_dirty)
+                    && FAILED(hr = IDirect3DDevice9_SetVertexShader(device, *(IDirect3DVertexShader9 **)param_value)))
                 ERR("Could not set vertex shader, hr %#x.\n", hr);
             else if (*(IDirect3DVertexShader9 **)param_value)
-                hr = d3dx_set_shader_constants(effect, pass, param, TRUE);
+                hr = d3dx_set_shader_constants(effect, pass, param, TRUE, update_all || param_dirty);
             return hr;
         case SC_PIXELSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DPixelShader9 **)param_value);
-            if (FAILED(hr = IDirect3DDevice9_SetPixelShader(device, *(IDirect3DPixelShader9 **)param_value)))
+            if ((update_all || param_dirty)
+                    && FAILED(hr = IDirect3DDevice9_SetPixelShader(device, *(IDirect3DPixelShader9 **)param_value)))
                 ERR("Could not set pixel shader, hr %#x.\n", hr);
             else if (*(IDirect3DPixelShader9 **)param_value)
-                hr = d3dx_set_shader_constants(effect, pass, param, FALSE);
+                hr = d3dx_set_shader_constants(effect, pass, param, FALSE, update_all || param_dirty);
             return hr;
         case SC_TRANSFORM:
             TRACE("%s, state %u.\n", state_table[state->operation].name, state->index);
@@ -2946,7 +2994,7 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
     return D3D_OK;
 }
 
-static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass)
+static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass, BOOL update_all)
 {
     unsigned int i;
     HRESULT ret;
@@ -2958,12 +3006,13 @@ static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3
     {
         HRESULT hr;
 
-        if (FAILED(hr = d3dx9_apply_state(effect, pass, &pass->states[i], ~0u)))
+        if (FAILED(hr = d3dx9_apply_state(effect, pass, &pass->states[i], ~0u, update_all)))
         {
             WARN("Error applying state, hr %#x.\n", hr);
             ret = hr;
         }
     }
+    clear_dirty_all(&effect->base_effect);
     return ret;
 }
 
@@ -3749,7 +3798,7 @@ static HRESULT WINAPI ID3DXEffectImpl_Begin(ID3DXEffect *iface, UINT *passes, DW
                 if (FAILED(hr = IDirect3DDevice9_BeginStateBlock(effect->device)))
                     ERR("BeginStateBlock failed, hr %#x.\n", hr);
                 for (i = 0; i < technique->pass_count; i++)
-                    d3dx9_apply_pass_states(effect, &technique->passes[i]);
+                    d3dx9_apply_pass_states(effect, &technique->passes[i], TRUE);
                 if (FAILED(hr = IDirect3DDevice9_EndStateBlock(effect->device, &technique->saved_state)))
                     ERR("EndStateBlock failed, hr %#x.\n", hr);
             }
@@ -3779,7 +3828,7 @@ static HRESULT WINAPI ID3DXEffectImpl_BeginPass(ID3DXEffect *iface, UINT pass)
     if (technique && pass < technique->pass_count && !effect->active_pass)
     {
         effect->active_pass = &technique->passes[pass];
-        return d3dx9_apply_pass_states(effect, effect->active_pass);
+        return d3dx9_apply_pass_states(effect, effect->active_pass, TRUE);
     }
 
     WARN("Invalid argument supplied.\n");
@@ -3799,7 +3848,7 @@ static HRESULT WINAPI ID3DXEffectImpl_CommitChanges(ID3DXEffect *iface)
         return D3D_OK;
     }
     /* TODO: apply only changed states */
-    return d3dx9_apply_pass_states(effect, effect->active_pass);
+    return d3dx9_apply_pass_states(effect, effect->active_pass, FALSE);
 }
 
 static HRESULT WINAPI ID3DXEffectImpl_EndPass(ID3DXEffect *iface)
--- a/dlls/d3dx9_36/preshader.c	
+++ a/dlls/d3dx9_36/preshader.c	
@@ -835,7 +835,7 @@ void d3dx_free_param_eval(struct d3dx_param_eval *peval)
     HeapFree(GetProcessHeap(), 0, peval);
 }
 
-static void set_constants(struct d3dx_regstore *rs, struct d3dx_const_tab *const_tab)
+static void set_constants(struct d3dx_regstore *rs, struct d3dx_const_tab *const_tab, BOOL update_all)
 {
     unsigned int const_idx;
 
@@ -850,6 +850,9 @@ static void set_constants(struct d3dx_regstore *rs, struct d3dx_const_tab *const
         BOOL transpose;
         unsigned int count;
 
+        if (!(update_all || is_param_dirty(param)))
+            continue;
+
         transpose = (const_set->constant_class == D3DXPC_MATRIX_COLUMNS && param->class == D3DXPC_MATRIX_ROWS)
                 || (param->class == D3DXPC_MATRIX_COLUMNS && const_set->constant_class == D3DXPC_MATRIX_ROWS);
         if (const_set->constant_class == D3DXPC_MATRIX_COLUMNS)
@@ -1148,6 +1151,24 @@ static HRESULT execute_preshader(struct d3dx_preshader *pres)
     return D3D_OK;
 }
 
+static BOOL is_const_tab_input_dirty(struct d3dx_const_tab *ctab)
+{
+    unsigned int i;
+
+    for (i = 0; i < ctab->const_set_count; ++i)
+    {
+        if (is_param_dirty(ctab->const_set[i].param))
+            return TRUE;
+    }
+    return FALSE;
+}
+
+BOOL is_param_eval_input_dirty(struct d3dx_param_eval *peval)
+{
+    return is_const_tab_input_dirty(&peval->pres.inputs)
+            || is_const_tab_input_dirty(&peval->shader_inputs);
+}
+
 HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval, const struct d3dx_parameter *param, void *param_value)
 {
     HRESULT hr;
@@ -1157,7 +1178,7 @@ HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval, const struct d3dx
 
     TRACE("peval %p, param %p, param_value %p.\n", peval, param, param_value);
 
-    set_constants(&peval->pres.regs, &peval->pres.inputs);
+    set_constants(&peval->pres.regs, &peval->pres.inputs, TRUE);
 
     if (FAILED(hr = execute_preshader(&peval->pres)))
         return hr;
@@ -1246,7 +1267,8 @@ static HRESULT set_shader_constants_device(struct IDirect3DDevice9 *device, stru
     return result;
 }
 
-HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device, struct d3dx_param_eval *peval)
+HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device, struct d3dx_param_eval *peval,
+        BOOL update_all)
 {
     static const enum pres_reg_tables set_tables[] =
             {PRES_REGTAB_OCONST, PRES_REGTAB_OICONST, PRES_REGTAB_OBCONST};
@@ -1257,11 +1279,15 @@ HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device, st
 
     TRACE("device %p, peval %p, param_type %u.\n", device, peval, peval->param_type);
 
-    set_constants(rs, &pres->inputs);
-    if (FAILED(hr = execute_preshader(pres)))
-        return hr;
+    if (update_all || is_const_tab_input_dirty(&pres->inputs))
+    {
+        set_constants(rs, &pres->inputs, TRUE);
+        if (FAILED(hr = execute_preshader(pres)))
+            return hr;
+        regstore_reset_table(rs, PRES_REGTAB_CONST);
+    }
 
-    set_constants(rs, &peval->shader_inputs);
+    set_constants(rs, &peval->shader_inputs, update_all);
     result = D3D_OK;
     for (i = 0; i < ARRAY_SIZE(set_tables); ++i)
     {
--- a/dlls/d3dx9_36/tests/effect.c	
+++ a/dlls/d3dx9_36/tests/effect.c	
@@ -4284,6 +4284,108 @@ static void test_effect_isparameterused(IDirect3DDevice9 *device)
     effect->lpVtbl->Release(effect);
 }
 
+static void test_effect_commitchanges(IDirect3DDevice9 *device)
+{
+    ID3DXEffect *effect;
+    HRESULT hr;
+    D3DXHANDLE param, param_child;
+    unsigned int i, passes_count, value;
+    int ivect[4];
+    static const D3DXVECTOR4 fvect_empty = {-9999.0f, -9999.0f, -9999.0f, -9999.0f};
+    D3DXVECTOR4 fvect;
+
+    hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
+            NULL, NULL, 0, NULL, &effect, NULL);
+
+    param = effect->lpVtbl->GetParameterByName(effect, NULL, "g_iVect");
+    ok(!!param, "GetParameterByName failed.\n");
+    ivect[0] = 4;
+    ivect[1] = 3;
+    ivect[2] = 2;
+    ivect[3] = 0;
+    hr = effect->lpVtbl->SetValue(effect, param, ivect, sizeof(ivect));
+
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect->lpVtbl->Begin(effect, &passes_count, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    for (i = 0; i < 256; ++i)
+    {
+        hr = IDirect3DDevice9_SetVertexShaderConstantF(device, i, &fvect_empty.x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    }
+
+    hr = effect->lpVtbl->BeginPass(effect, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 33, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    trace("%f %f %f %f.\n", fvect.x, fvect.y, fvect.z, fvect.w);
+
+    hr = IDirect3DDevice9_GetSamplerState(device, D3DVERTEXTEXTURESAMPLER0, D3DSAMP_MINFILTER, &value);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(value == 3, "Unexpected sampler 0 minfilter %u.\n", value);
+
+    param = effect->lpVtbl->GetParameterByName(effect, NULL, "g_iVect");
+    ok(!!param, "GetParameterByName failed.\n");
+    ivect[0] = ivect[1] = ivect[2] = 1;
+    ivect[3] = 0;
+    hr = effect->lpVtbl->SetValue(effect, param, ivect, sizeof(ivect));
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    param = effect->lpVtbl->GetParameterByName(effect, NULL, "g_Selector");
+    ok(!!param, "GetParameterByName failed.\n");
+    fvect.x = fvect.y = fvect.z = fvect.w = 0.0f;
+    hr = effect->lpVtbl->SetVectorArray(effect, param, &fvect, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    param = effect->lpVtbl->GetParameterByName(effect, NULL, "arr2");
+    ok(!!param, "GetParameterByName failed.\n");
+    fvect.x = 0.0f;
+    param_child = effect->lpVtbl->GetParameterElement(effect, param, 1);
+    ok(!!param_child, "GetParameterElement failed.\n");
+    hr = effect->lpVtbl->SetFloat(effect, param_child, fvect.x);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    param = effect->lpVtbl->GetParameterByName(effect, NULL, "ts1");
+    ok(!!param, "GetParameterByName failed.\n");
+    param = effect->lpVtbl->GetParameterElement(effect, param, 0);
+    ok(!!param, "GetParameterByName failed.\n");
+
+    param_child = effect->lpVtbl->GetParameterByName(effect, param, "fv");
+    ok(!!param_child, "GetParameterByName failed.\n");
+    fvect.x = 28.0f;
+    hr = effect->lpVtbl->SetFloat(effect, param_child, fvect.x);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    for (i = 0; i < 256; ++i)
+    {
+        hr = IDirect3DDevice9_SetVertexShaderConstantF(device, i, &fvect_empty.x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    }
+
+    hr = effect->lpVtbl->CommitChanges(effect);
+
+    for (i = 0; i < 34; ++i)
+    {
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+        hr = IDirect3DDevice9_GetVertexShaderConstantF(device, i, &fvect.x, 1);
+        ok(hr == D3D_OK, "Got result %#x.\n", hr);
+        trace("%f %f %f %f.\n", fvect.x, fvect.y, fvect.z, fvect.w);
+    }
+
+    hr = IDirect3DDevice9_GetSamplerState(device, D3DVERTEXTEXTURESAMPLER0, D3DSAMP_MINFILTER, &value);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(value == 1, "Unexpected sampler 0 minfilter %u.\n", value);
+
+    hr = effect->lpVtbl->EndPass(effect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect->lpVtbl->End(effect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    effect->lpVtbl->Release(effect);
+}
+
 START_TEST(effect)
 {
     HWND wnd;
@@ -4327,6 +4429,7 @@ START_TEST(effect)
     test_effect_preshader(device);
     test_effect_preshader_ops(device);
     test_effect_isparameterused(device);
+    test_effect_commitchanges(device);
 
     count = IDirect3DDevice9_Release(device);
     ok(count == 0, "The device was not properly freed: refcount %u\n", count);
-- 
---
 dlls/d3dx9_36/d3dx9_private.h |  6 +++-
 dlls/d3dx9_36/effect.c        | 70 +++++++++++++++++++------------------------
 dlls/d3dx9_36/preshader.c     | 22 +++++++-------
 3 files changed, 46 insertions(+), 52 deletions(-)
--- a/dlls/d3dx9_36/d3dx9_private.h	
+++ a/dlls/d3dx9_36/d3dx9_private.h	
@@ -216,12 +216,16 @@ struct d3dx9_base_effect;
 struct d3dx_parameter *get_parameter_by_name(struct d3dx9_base_effect *base,
         struct d3dx_parameter *parameter, const char *name) DECLSPEC_HIDDEN;
 
+#define SET_D3D_STATE_(manager, device, method, args...) (manager ? manager->lpVtbl->method(manager, args) : \
+        device->lpVtbl->method(device, args))
+#define SET_D3D_STATE(base_effect, args...) SET_D3D_STATE_(base_effect->manager, base_effect->device, args)
+
 void d3dx_create_param_eval(struct d3dx9_base_effect *base_effect, void *byte_code,
         unsigned int byte_code_size, D3DXPARAMETER_TYPE type, struct d3dx_param_eval **peval) DECLSPEC_HIDDEN;
 void d3dx_free_param_eval(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
 HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval,
         const struct d3dx_parameter *param, void *param_value) DECLSPEC_HIDDEN;
-HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device,
+HRESULT d3dx_param_eval_set_shader_constants(ID3DXEffectStateManager *manager, struct IDirect3DDevice9 *device,
         struct d3dx_param_eval *peval, BOOL update_all) DECLSPEC_HIDDEN;
 BOOL is_param_eval_input_dirty(struct d3dx_param_eval *peval) DECLSPEC_HIDDEN;
 
--- a/dlls/d3dx9_36/effect.c	
+++ a/dlls/d3dx9_36/effect.c	
@@ -123,6 +123,9 @@ struct d3dx_pass
 
     struct d3dx_state *states;
     struct d3dx_parameter *annotations;
+
+    D3DLIGHT9 current_light[8];
+    D3DMATERIAL9 current_material;
 };
 
 struct d3dx_technique
@@ -2758,7 +2761,7 @@ static void d3dx9_set_material_parameter(enum MATERIAL_TYPE op, D3DMATERIAL9 *ma
     }
 }
 
-static HRESULT d3dx_set_shader_const_state(IDirect3DDevice9 *device, enum SHADER_CONSTANT_TYPE op, UINT index,
+static HRESULT d3dx_set_shader_const_state(struct ID3DXEffectImpl *effect, enum SHADER_CONSTANT_TYPE op, UINT index,
         struct d3dx_parameter *param, void *value_ptr)
 {
     static const struct
@@ -2799,17 +2802,17 @@ static HRESULT d3dx_set_shader_const_state(IDirect3DDevice9 *device, enum SHADER
     switch (op)
     {
         case SCT_VSFLOAT:
-            return IDirect3DDevice9_SetVertexShaderConstantF(device, index, (const float *)value_ptr, element_count);
+            return SET_D3D_STATE(effect, SetVertexShaderConstantF, index, (const float *)value_ptr, element_count);
         case SCT_VSBOOL:
-            return IDirect3DDevice9_SetVertexShaderConstantB(device, index, (const BOOL *)value_ptr, element_count);
+            return SET_D3D_STATE(effect, SetVertexShaderConstantB, index, (const BOOL *)value_ptr, element_count);
         case SCT_VSINT:
-            return IDirect3DDevice9_SetVertexShaderConstantI(device, index, (const int *)value_ptr, element_count);
+            return SET_D3D_STATE(effect, SetVertexShaderConstantI, index, (const int *)value_ptr, element_count);
         case SCT_PSFLOAT:
-            return IDirect3DDevice9_SetPixelShaderConstantF(device, index, (const float *)value_ptr, element_count);
+            return SET_D3D_STATE(effect, SetPixelShaderConstantF, index, (const float *)value_ptr, element_count);
         case SCT_PSBOOL:
-            return IDirect3DDevice9_SetPixelShaderConstantB(device, index, (const BOOL *)value_ptr, element_count);
+            return SET_D3D_STATE(effect, SetPixelShaderConstantB, index, (const BOOL *)value_ptr, element_count);
         case SCT_PSINT:
-            return IDirect3DDevice9_SetPixelShaderConstantI(device, index, (const int *)value_ptr, element_count);
+            return SET_D3D_STATE(effect, SetPixelShaderConstantI, index, (const int *)value_ptr, element_count);
     }
     return D3D_OK;
 }
@@ -2820,7 +2823,6 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
 static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
         struct d3dx_parameter *param, BOOL vs, BOOL update_all)
 {
-    IDirect3DDevice9 *device = effect->device;
     HRESULT hr, ret;
     struct d3dx_parameter **params;
     D3DXCONSTANT_DESC *cdesc;
@@ -2832,7 +2834,8 @@ static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct
         FIXME("param_eval structure is null.\n");
         return D3DERR_INVALIDCALL;
     }
-    if (FAILED(hr = d3dx_param_eval_set_shader_constants(device, param->param_eval, update_all)))
+    if (FAILED(hr = d3dx_param_eval_set_shader_constants(effect->manager, effect->device,
+            param->param_eval, update_all)))
         return hr;
     params = param->param_eval->shader_inputs.inputs_param;
     cdesc = param->param_eval->shader_inputs.inputs;
@@ -2861,7 +2864,6 @@ static HRESULT d3dx_set_shader_constants(struct ID3DXEffectImpl *effect, struct
 static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pass *pass,
         struct d3dx_state *state, unsigned int parent_index, BOOL update_all)
 {
-    IDirect3DDevice9 *device = effect->device;
     struct d3dx_parameter *param;
     void *param_value;
     BOOL param_dirty;
@@ -2885,10 +2887,10 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
         case SC_RENDERSTATE:
             TRACE("%s, operation %u, value %u.\n", state_table[state->operation].name,
                     state_table[state->operation].op, *(DWORD *)param_value);
-            return IDirect3DDevice9_SetRenderState(device, state_table[state->operation].op, *(DWORD *)param_value);
+            return SET_D3D_STATE(effect, SetRenderState, state_table[state->operation].op, *(DWORD *)param_value);
         case SC_FVF:
             TRACE("%s, value %#x.\n", state_table[state->operation].name, *(DWORD *)param_value);
-            return IDirect3DDevice9_SetFVF(device, *(DWORD *)param_value);
+            return SET_D3D_STATE(effect, SetFVF, *(DWORD *)param_value);
         case SC_TEXTURE:
         {
             UINT unit;
@@ -2896,12 +2898,12 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
             unit = parent_index == ~0u ? state->index : parent_index;
             TRACE("%s, unit %u, value %p.\n", state_table[state->operation].name, unit,
                     *(IDirect3DBaseTexture9 **)param_value);
-            return IDirect3DDevice9_SetTexture(device, unit, *(IDirect3DBaseTexture9 **)param_value);
+            return SET_D3D_STATE(effect, SetTexture, unit, *(IDirect3DBaseTexture9 **)param_value);
         }
         case SC_TEXTURESTAGE:
             TRACE("%s, stage %u, value %u.\n", state_table[state->operation].name, state->index, *(DWORD *)param_value);
-            return IDirect3DDevice9_SetTextureStageState(device, state->index,
-                    state_table[state->operation].op, *(DWORD *)param_value);
+            return SET_D3D_STATE(effect, SetTextureStageState, state->index,
+                        state_table[state->operation].op, *(DWORD *)param_value);
         case SC_SETSAMPLER:
         {
             struct d3dx_sampler *sampler;
@@ -2925,13 +2927,13 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
 
             sampler = parent_index == ~0u ? state->index : parent_index;
             TRACE("%s, sampler %u, value %u.\n", state_table[state->operation].name, sampler, *(DWORD *)param_value);
-            return IDirect3DDevice9_SetSamplerState(device, sampler, state_table[state->operation].op,
+            return SET_D3D_STATE(effect, SetSamplerState, sampler, state_table[state->operation].op,
                     *(DWORD *)param_value);
         }
         case SC_VERTEXSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DVertexShader9 **)param_value);
             if ((update_all || param_dirty)
-                    && FAILED(hr = IDirect3DDevice9_SetVertexShader(device, *(IDirect3DVertexShader9 **)param_value)))
+                    && FAILED(hr = SET_D3D_STATE(effect, SetVertexShader, *(IDirect3DVertexShader9 **)param_value)))
                 ERR("Could not set vertex shader, hr %#x.\n", hr);
             else if (*(IDirect3DVertexShader9 **)param_value)
                 hr = d3dx_set_shader_constants(effect, pass, param, TRUE, update_all || param_dirty);
@@ -2939,53 +2941,41 @@ static HRESULT d3dx9_apply_state(struct ID3DXEffectImpl *effect, struct d3dx_pas
         case SC_PIXELSHADER:
             TRACE("%s, shader %p.\n", state_table[state->operation].name, *(IDirect3DPixelShader9 **)param_value);
             if ((update_all || param_dirty)
-                    && FAILED(hr = IDirect3DDevice9_SetPixelShader(device, *(IDirect3DPixelShader9 **)param_value)))
+                    && FAILED(hr = SET_D3D_STATE(effect, SetPixelShader, *(IDirect3DPixelShader9 **)param_value)))
                 ERR("Could not set pixel shader, hr %#x.\n", hr);
             else if (*(IDirect3DPixelShader9 **)param_value)
                 hr = d3dx_set_shader_constants(effect, pass, param, FALSE, update_all || param_dirty);
             return hr;
         case SC_TRANSFORM:
             TRACE("%s, state %u.\n", state_table[state->operation].name, state->index);
-            return IDirect3DDevice9_SetTransform(device, state_table[state->operation].op + state->index,
+            return SET_D3D_STATE(effect, SetTransform, state_table[state->operation].op + state->index,
                     (D3DMATRIX *)param_value);
         case SC_LIGHTENABLE:
             TRACE("%s, index %u, value %u.\n", state_table[state->operation].name, state->index, *(BOOL *)param_value);
-            return IDirect3DDevice9_LightEnable(device, state->index, *(BOOL *)param_value);
+            return SET_D3D_STATE(effect, LightEnable, state->index, *(BOOL *)param_value);
         case SC_LIGHT:
         {
-            D3DLIGHT9 light;
-
             TRACE("%s, index %u, op %u.\n", state_table[state->operation].name, state->index,
                     state_table[state->operation].op);
-            if (FAILED(hr = IDirect3DDevice9_GetLight(device, state->index, &light)))
-            {
-                WARN("Could not get light, hr %#x.\n", hr);
-                memset(&light, 0, sizeof(light));
-            }
-            d3dx9_set_light_parameter(state_table[state->operation].op, &light, param_value);
-            return IDirect3DDevice9_SetLight(device, state->index, &light);
+            d3dx9_set_light_parameter(state_table[state->operation].op,
+                    &pass->current_light[state->index], param_value);
+            return SET_D3D_STATE(effect, SetLight, state->index, &pass->current_light[state->index]);
         }
         case SC_MATERIAL:
         {
-            D3DMATERIAL9 material;
-
             TRACE("%s, index %u, op %u.\n", state_table[state->operation].name, state->index,
                     state_table[state->operation].op);
-            if (FAILED(hr = IDirect3DDevice9_GetMaterial(device, &material)))
-            {
-                WARN("Could not get material, hr %#x.\n", hr);
-                memset(&material, 0, sizeof(material));
-            }
-            d3dx9_set_material_parameter(state_table[state->operation].op, &material, param_value);
-            return IDirect3DDevice9_SetMaterial(device, &material);
+            d3dx9_set_material_parameter(state_table[state->operation].op,
+                    &pass->current_material, param_value);
+            return SET_D3D_STATE(effect, SetMaterial, &pass->current_material);
         }
         case SC_NPATCHMODE:
             TRACE("%s, nsegments %f.\n", state_table[state->operation].name, *(float *)param_value);
-            return IDirect3DDevice9_SetNPatchMode(device, *(float *)param_value);
+            return SET_D3D_STATE(effect, SetNPatchMode, *(float *)param_value);
         case SC_SHADERCONST:
             TRACE("%s, index %u, op %u.\n", state_table[state->operation].name, state->index,
                 state_table[state->operation].op);
-            return d3dx_set_shader_const_state(device, state_table[state->operation].op, state->index,
+            return d3dx_set_shader_const_state(effect, state_table[state->operation].op, state->index,
                 param, param_value);
         default:
             FIXME("%s not handled.\n", state_table[state->operation].name);
--- a/dlls/d3dx9_36/preshader.c	
+++ a/dlls/d3dx9_36/preshader.c	
@@ -1193,8 +1193,8 @@ HRESULT d3dx_evaluate_parameter(struct d3dx_param_eval *peval, const struct d3dx
     return D3D_OK;
 }
 
-static HRESULT set_shader_constants_device(struct IDirect3DDevice9 *device, struct d3dx_regstore *rs,
-        D3DXPARAMETER_TYPE type, enum pres_reg_tables table)
+static HRESULT set_shader_constants_device(ID3DXEffectStateManager *manager, struct IDirect3DDevice9 *device,
+        struct d3dx_regstore *rs, D3DXPARAMETER_TYPE type, enum pres_reg_tables table)
 {
     unsigned int start, count;
     void *ptr;
@@ -1219,13 +1219,13 @@ static HRESULT set_shader_constants_device(struct IDirect3DDevice9 *device, stru
             switch(table)
             {
                 case PRES_REGTAB_OCONST:
-                    hr = IDirect3DDevice9_SetVertexShaderConstantF(device, start, (const float *)ptr, count);
+                    hr = SET_D3D_STATE_(manager, device, SetVertexShaderConstantF, start, (const float *)ptr, count);
                     break;
                 case PRES_REGTAB_OICONST:
-                    hr = IDirect3DDevice9_SetVertexShaderConstantI(device, start, (const int *)ptr, count);
+                    hr = SET_D3D_STATE_(manager, device, SetVertexShaderConstantI, start, (const int *)ptr, count);
                     break;
                 case PRES_REGTAB_OBCONST:
-                    hr = IDirect3DDevice9_SetVertexShaderConstantB(device, start, (const BOOL *)ptr, count);
+                    hr = SET_D3D_STATE_(manager, device, SetVertexShaderConstantB, start, (const BOOL *)ptr, count);
                     break;
                 default:
                     FIXME("Unexpected register table %u.\n", table);
@@ -1237,13 +1237,13 @@ static HRESULT set_shader_constants_device(struct IDirect3DDevice9 *device, stru
             switch(table)
             {
                 case PRES_REGTAB_OCONST:
-                    hr = IDirect3DDevice9_SetPixelShaderConstantF(device, start, (const float *)ptr, count);
+                    hr = SET_D3D_STATE_(manager, device, SetPixelShaderConstantF, start, (const float *)ptr, count);
                     break;
                 case PRES_REGTAB_OICONST:
-                    hr = IDirect3DDevice9_SetPixelShaderConstantI(device, start, (const int *)ptr, count);
+                    hr = SET_D3D_STATE_(manager, device, SetPixelShaderConstantI, start, (const int *)ptr, count);
                     break;
                 case PRES_REGTAB_OBCONST:
-                    hr = IDirect3DDevice9_SetPixelShaderConstantB(device, start, (const BOOL *)ptr, count);
+                    hr = SET_D3D_STATE_(manager, device, SetPixelShaderConstantB, start, (const BOOL *)ptr, count);
                     break;
                 default:
                     FIXME("Unexpected register table %u.\n", table);
@@ -1267,8 +1267,8 @@ static HRESULT set_shader_constants_device(struct IDirect3DDevice9 *device, stru
     return result;
 }
 
-HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device, struct d3dx_param_eval *peval,
-        BOOL update_all)
+HRESULT d3dx_param_eval_set_shader_constants(ID3DXEffectStateManager *manager, struct IDirect3DDevice9 *device,
+        struct d3dx_param_eval *peval, BOOL update_all)
 {
     static const enum pres_reg_tables set_tables[] =
             {PRES_REGTAB_OCONST, PRES_REGTAB_OICONST, PRES_REGTAB_OBCONST};
@@ -1291,7 +1291,7 @@ HRESULT d3dx_param_eval_set_shader_constants(struct IDirect3DDevice9 *device, st
     result = D3D_OK;
     for (i = 0; i < ARRAY_SIZE(set_tables); ++i)
     {
-        if (FAILED(hr = set_shader_constants_device(device, rs, peval->param_type, set_tables[i])))
+        if (FAILED(hr = set_shader_constants_device(manager, device, rs, peval->param_type, set_tables[i])))
             result = hr;
     }
     return result;
-- 
---
 dlls/d3dx9_36/d3dx9_private.h |   6 +-
 dlls/d3dx9_36/effect.c        | 405 +++++++++++++++++++++++++++++-------------
 dlls/d3dx9_36/tests/effect.c  | 285 ++++++++++++++++++++++++-----
 3 files changed, 525 insertions(+), 171 deletions(-)
--- a/dlls/d3dx9_36/d3dx9_private.h	
+++ a/dlls/d3dx9_36/d3dx9_private.h	
@@ -177,9 +177,11 @@ struct d3dx_param_eval
 };
 
 #define PARAMETER_FLAG_DIRTY 0x1u
+#define PARAMETER_FLAG_TOPLEVEL 0x2u
 
 struct d3dx_parameter
 {
+    unsigned int magic_number;
     char *name;
     char *semantic;
     void *data;
@@ -195,8 +197,6 @@ struct d3dx_parameter
     DWORD rt_flags;
     DWORD object_id;
 
-    D3DXHANDLE handle;
-
     struct d3dx_parameter *annotations;
     struct d3dx_parameter *members;
 
@@ -204,6 +204,8 @@ struct d3dx_parameter
     struct d3dx_param_eval *param_eval;
 
     DWORD *dirty_flag_ptr;
+    struct d3dx_parameter *shared_param;
+    LONG shared_refcount;
 };
 
 static inline BOOL is_param_dirty(struct d3dx_parameter *param)
--- a/dlls/d3dx9_36/effect.c	
+++ a/dlls/d3dx9_36/effect.c	
@@ -29,6 +29,10 @@ 
 
 #define INITIAL_PARAM_TABLE_SIZE 16
 
+#define PARAMETER_FLAG_SHARED 1
+
+#define PARAMETER_MAGIC_NUMBER 0xFFFF0102
+
 WINE_DEFAULT_DEBUG_CHANNEL(d3dx);
 
 enum STATE_CLASS
@@ -140,12 +144,6 @@ struct d3dx_technique
     struct IDirect3DStateBlock9 *saved_state;
 };
 
-struct param_table
-{
-    struct d3dx_parameter **table;
-    unsigned int count, size;
-};
-
 struct d3dx9_base_effect
 {
     struct ID3DXEffectImpl *effect;
@@ -158,7 +156,7 @@ struct d3dx9_base_effect
     struct d3dx_technique *techniques;
     struct d3dx_object *objects;
 
-    struct param_table param_table;
+    struct ID3DXEffectPoolImpl *pool;
 };
 
 struct ID3DXEffectImpl
@@ -177,6 +175,16 @@ struct ID3DXEffectImpl
     DWORD flags;
 };
 
+struct ID3DXEffectPoolImpl
+{
+    ID3DXEffectPool ID3DXEffectPool_iface;
+    LONG ref;
+
+    unsigned int parameter_count;
+    unsigned int table_size;
+    struct d3dx_parameter **parameters;
+};
+
 struct ID3DXEffectCompilerImpl
 {
     ID3DXEffectCompiler ID3DXEffectCompiler_iface;
@@ -417,7 +425,7 @@ static void skip_dword_unknown(const char **ptr, unsigned int count)
 
 static inline D3DXHANDLE get_parameter_handle(struct d3dx_parameter *parameter)
 {
-    return parameter ? parameter->handle : NULL;
+    return (D3DXHANDLE) parameter;
 }
 
 static inline D3DXHANDLE get_technique_handle(struct d3dx_technique *technique)
@@ -478,10 +486,10 @@ static struct d3dx_pass *get_valid_pass(struct d3dx9_base_effect *base, D3DXHAND
 
 static struct d3dx_parameter *get_valid_parameter(struct d3dx9_base_effect *base, D3DXHANDLE parameter)
 {
-    struct d3dx_parameter **handle_param = (struct d3dx_parameter **)parameter;
+    struct d3dx_parameter *handle_param = (struct d3dx_parameter *)parameter;
 
-    if (handle_param >= base->param_table.table && handle_param < base->param_table.table + base->param_table.count)
-        return *handle_param;
+    if (handle_param && handle_param->magic_number == PARAMETER_MAGIC_NUMBER)
+        return handle_param;
 
     return get_parameter_by_name(base, NULL, parameter);
 }
@@ -509,37 +517,12 @@ static void free_sampler(struct d3dx_sampler *sampler)
     HeapFree(GetProcessHeap(), 0, sampler->states);
 }
 
-static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL child)
-{
-    unsigned int i;
-
-    TRACE("Free parameter %p, name %s, type %s, child %s\n", param, param->name,
-            debug_d3dxparameter_type(param->type), child ? "yes" : "no");
-
-    if (param->param_eval)
-    {
-        d3dx_free_param_eval(param->param_eval);
-        param->param_eval = NULL;
-    }
-
-    if (param->annotations)
-    {
-        for (i = 0; i < param->annotation_count; ++i)
-            free_parameter(&param->annotations[i], FALSE, FALSE);
-        HeapFree(GetProcessHeap(), 0, param->annotations);
-        param->annotations = NULL;
-    }
-
-    if (param->members)
-    {
-        unsigned int count = param->element_count ? param->element_count : param->member_count;
-
-        for (i = 0; i < count; ++i)
-            free_parameter(&param->members[i], param->element_count != 0, TRUE);
-        HeapFree(GetProcessHeap(), 0, param->members);
-        param->members = NULL;
-    }
+static void d3dx_pool_release_shared_parameter(struct d3dx_parameter *param);
 
+static void free_parameter_data(struct d3dx_parameter *param, BOOL child)
+{
+    if (!param->data)
+        return;
     if (param->class == D3DXPC_OBJECT && !param->element_count)
     {
         switch (param->type)
@@ -571,12 +554,47 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
                 break;
         }
     }
-
     if (!child)
-    {
         HeapFree(GetProcessHeap(), 0, param->data);
+}
+
+static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL child)
+{
+    unsigned int i;
+
+    TRACE("Free parameter %p, name %s, type %s, child %s\n", param, param->name,
+            debug_d3dxparameter_type(param->type), child ? "yes" : "no");
+
+    if (param->param_eval)
+    {
+        d3dx_free_param_eval(param->param_eval);
+        param->param_eval = NULL;
+    }
+
+    if (param->annotations)
+    {
+        for (i = 0; i < param->annotation_count; ++i)
+            free_parameter(&param->annotations[i], FALSE, FALSE);
+        HeapFree(GetProcessHeap(), 0, param->annotations);
+        param->annotations = NULL;
+    }
+
+    if (param->shared_param)
+        d3dx_pool_release_shared_parameter(param);
+
+    if (param->members)
+    {
+        unsigned int count = param->element_count ? param->element_count : param->member_count;
+
+        for (i = 0; i < count; ++i)
+            free_parameter(&param->members[i], param->element_count != 0, TRUE);
+        HeapFree(GetProcessHeap(), 0, param->members);
+        param->members = NULL;
     }
 
+    if (!param->shared_param)
+        free_parameter_data(param, child);
+
     /* only the parent has to release name and semantic */
     if (!element)
     {
@@ -585,6 +603,58 @@ static void free_parameter(struct d3dx_parameter *param, BOOL element, BOOL chil
     }
 }
 
+static HRESULT copy_parameter_structure(struct d3dx_parameter *src, struct d3dx_parameter *dest,
+        struct d3dx_parameter *dest_parent, BOOL element)
+{
+    *dest = *src;
+    if (element)
+    {
+        dest->name = dest_parent->name;
+        dest->semantic = dest_parent->semantic;
+    }
+    else
+    {
+        if (src->name)
+        {
+            dest->name = HeapAlloc(GetProcessHeap(), 0, strlen(src->name) + 1);
+            strcpy(dest->name, src->name);
+        }
+        if (src->semantic)
+        {
+            dest->semantic = HeapAlloc(GetProcessHeap(), 0, strlen(src->semantic) + 1);
+            strcpy(dest->semantic, src->semantic);
+        }
+    }
+    dest->param_eval = NULL;
+    dest->annotations = NULL;
+    dest->data = NULL;
+    dest->referenced_param = NULL;
+    dest->shared_param = NULL;
+    dest->shared_refcount = 0;
+
+    dest->element_count = src->element_count;
+    dest->member_count = src->member_count;
+    if (src->members)
+    {
+        unsigned int i;
+        unsigned int count = src->element_count ? src->element_count : src->member_count;
+
+        dest->members = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, count * sizeof(*dest->members));
+        if (!dest->members)
+        {
+            ERR("Out of memory.\n");
+            return E_OUTOFMEMORY;
+        }
+        for (i = 0; i < count; ++i)
+        {
+            if (FAILED(copy_parameter_structure(&src->members[i], &dest->members[i],
+                    dest, src->element_count != 0)))
+                return E_OUTOFMEMORY;
+        }
+    }
+    return D3D_OK;
+}
+
 static void free_pass(struct d3dx_pass *pass)
 {
     unsigned int i;
@@ -655,8 +725,6 @@ static void d3dx9_base_effect_cleanup(struct d3dx9_base_effect *base)
 
     TRACE("base %p.\n", base);
 
-    HeapFree(GetProcessHeap(), 0, base->param_table.table);
-
     if (base->parameters)
     {
         for (i = 0; i < base->parameter_count; ++i)
@@ -2592,7 +2660,7 @@ static HRESULT d3dx9_get_param_value_ptr(struct ID3DXEffectImpl *effect, struct
         {
             unsigned int array_idx;
             static const struct d3dx_parameter array_idx_param =
-                {NULL, NULL, NULL, D3DXPC_SCALAR, D3DXPT_INT, 1, 1, 0, 0, 0, 0, sizeof(array_idx)};
+                {PARAMETER_MAGIC_NUMBER, NULL, NULL, NULL, D3DXPC_SCALAR, D3DXPT_INT, 1, 1, 0, 0, 0, 0, sizeof(array_idx)};
             HRESULT hr;
             struct d3dx_parameter *ref_param;
 
@@ -3006,6 +3074,112 @@ static HRESULT d3dx9_apply_pass_states(struct ID3DXEffectImpl *effect, struct d3
     return ret;
 }
 
+static void param_set_data_pointer(struct d3dx_parameter *param, unsigned char *data, BOOL child, BOOL free_data)
+{
+    unsigned int i, count;
+    unsigned char *member_data;
+
+    count = param->element_count ? param->element_count : param->member_count;
+    member_data = data;
+    for (i = 0; i < count; ++i)
+    {
+        param_set_data_pointer(&param->members[i], member_data, TRUE, free_data);
+        member_data += param->members[i].bytes;
+    }
+    if (free_data)
+        free_parameter_data(param, child);
+    param->data = data;
+}
+
+static BOOL d3dx_pool_get_shared_parameter(struct ID3DXEffectPoolImpl *pool, struct d3dx_parameter *param,
+        struct d3dx_parameter **shared_param)
+{
+    unsigned int i;
+    BOOL ret;
+    LONG new_refcount;
+
+    *shared_param = NULL;
+    if (!(param->flags & PARAMETER_FLAG_SHARED) || !pool)
+        return FALSE;
+
+    for (i = 0; i < pool->parameter_count; i++)
+        if (pool->parameters[i] && (pool->parameters[i]->flags & PARAMETER_FLAG_SHARED)
+                && !strcmp(param->name, pool->parameters[i]->name))
+            break;
+    if (i == pool->parameter_count)
+    {
+        if (pool->parameter_count >= pool->table_size)
+        {
+            struct d3dx_parameter ** new_alloc;
+            unsigned int new_size;
+
+            if (!pool->table_size)
+            {
+                new_size = INITIAL_PARAM_TABLE_SIZE;
+                new_alloc = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pool->parameters) * new_size);
+                if (!new_alloc)
+                {
+                    ERR("Out of memory.\n");
+                    return FALSE;
+                }
+            }
+            else
+            {
+                new_size = pool->table_size * 2;
+                new_alloc = HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, pool->parameters, sizeof(*pool->parameters) * new_size);
+                if (!new_alloc)
+                {
+                    ERR("Out of memory.\n");
+                    return FALSE;
+                }
+            }
+            pool->parameters = new_alloc;
+            pool->table_size = new_size;
+        }
+        pool->parameters[i] = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(struct d3dx_parameter));
+        copy_parameter_structure(param, pool->parameters[i], NULL, FALSE);
+        param_set_data_pointer(pool->parameters[i], (unsigned char *)param->data, FALSE, FALSE);
+        pool->parameter_count++;
+        ret = FALSE;
+    }
+    else
+        ret = TRUE;
+    new_refcount = InterlockedIncrement(&pool->parameters[i]->shared_refcount);
+    *shared_param = pool->parameters[i];
+    TRACE("name %s, parameter idx %u, new refcount %u.\n", param->name, i,
+            new_refcount);
+    return ret;
+}
+
+static BOOL param_zero_data_func(void *dummy, struct d3dx_parameter *param)
+{
+    param->data = NULL;
+    return FALSE;
+}
+
+static void d3dx_pool_release_shared_parameter(struct d3dx_parameter *param)
+{
+    struct d3dx_parameter *pshared = param->shared_param;
+
+    if (pshared)
+    {
+        LONG new_refcount = InterlockedDecrement(&pshared->shared_refcount);
+
+        TRACE("param %p, pshared %p, refcount %u.\n", param, pshared, new_refcount);
+        if (!new_refcount)
+        {
+            free_parameter(pshared, FALSE, FALSE);
+            memset(pshared, 0, sizeof(*pshared));
+        }
+        walk_parameter_tree(param, param_zero_data_func, NULL);
+    }
+}
+
+static inline struct ID3DXEffectPoolImpl *impl_from_ID3DXEffectPool(ID3DXEffectPool *iface)
+{
+    return CONTAINING_RECORD(iface, struct ID3DXEffectPoolImpl, ID3DXEffectPool_iface);
+}
+
 static inline struct ID3DXEffectImpl *impl_from_ID3DXEffect(ID3DXEffect *iface)
 {
     return CONTAINING_RECORD(iface, struct ID3DXEffectImpl, ID3DXEffect_iface);
@@ -3730,7 +3904,9 @@ static BOOL walk_parameter_dep(struct d3dx_parameter *param, walk_parameter_dep_
 
 static BOOL compare_param_ptr(void *param_comp, struct d3dx_parameter *param)
 {
-    return param_comp == param;
+    struct d3dx_parameter *par = (struct d3dx_parameter *)param_comp;
+
+    return par->name && param->name && !strcmp(par->name, param->name);
 }
 
 static BOOL WINAPI ID3DXEffectImpl_IsParameterUsed(ID3DXEffect* iface, D3DXHANDLE parameter, D3DXHANDLE technique)
@@ -3743,7 +3919,7 @@ static BOOL WINAPI ID3DXEffectImpl_IsParameterUsed(ID3DXEffect* iface, D3DXHANDL
 
     TRACE("iface %p, parameter %p, technique %p.\n", iface, parameter, technique);
     TRACE("param %p, name %s, tech %p.\n", param, param ? debugstr_a(param->name) : "", tech);
-    if (!tech || !param)
+    if (!tech || !param || !(param->rt_flags & PARAMETER_FLAG_TOPLEVEL))
         return FALSE;
 
     for (i = 0; i < tech->pass_count; ++i)
@@ -5057,59 +5233,28 @@ static HRESULT d3dx9_copy_data(struct d3dx9_base_effect *base, unsigned int obje
     return D3D_OK;
 }
 
-static void add_param_to_table(struct d3dx9_base_effect *base, struct d3dx_parameter *param)
+static void sync_shared_parameters(struct d3dx9_base_effect *base)
 {
-    struct param_table *table = &base->param_table;
+    unsigned int i;
 
-    if (table->count >= table->size)
-    {
-        unsigned int new_size;
-        struct d3dx_parameter **new_alloc;
+    if (!base->pool)
+        return;
 
-        if (!table->size)
+    for (i = 0; i < base->parameter_count; i++)
+        if (base->parameters[i].flags & PARAMETER_FLAG_SHARED
+                && !is_param_type_sampler(base->parameters[i].type)
+                /* && base->parameters[i].type != D3DXPT_VERTEXSHADER
+                && base->parameters[i].type != D3DXPT_PIXELSHADER */)
         {
-            new_size = INITIAL_PARAM_TABLE_SIZE;
-            new_alloc = HeapAlloc(GetProcessHeap(), 0, sizeof(*table->table) * new_size);
-            if (!new_alloc)
-            {
-                ERR("Out of memory.\n");
-                return;
-            }
-        }
-        else
-        {
-            new_size = table->size * 2;
-            new_alloc = HeapReAlloc(GetProcessHeap(), 0, table->table, sizeof(*table->table) * new_size);
-            if (!new_alloc)
+            struct d3dx_parameter *shared_param;
+
+            if (d3dx_pool_get_shared_parameter(base->pool, &base->parameters[i], &shared_param))
             {
-                ERR("Out of memory.\n");
-                return;
+                /* parameter found in shared table */
+                param_set_data_pointer(&base->parameters[i], (unsigned char *)shared_param->data, FALSE, TRUE);
             }
+            base->parameters[i].shared_param = shared_param;
         }
-        table->table = new_alloc;
-        table->size = new_size;
-    }
-
-    table->table[table->count++] = param;
-}
-
-static void sync_param_handles(struct d3dx9_base_effect *base)
-{
-    struct param_table *table = &base->param_table;
-    struct d3dx_parameter **new_alloc;
-    unsigned int i;
-
-    if (table->count)
-    {
-        new_alloc = HeapReAlloc(GetProcessHeap(), 0, table->table, sizeof(*table->table) * table->count);
-        if (new_alloc)
-            table->table = new_alloc;
-        else
-            ERR("Out of memory.\n");
-    }
-
-    for (i = 0; i < table->count; ++i)
-        table->table[i]->handle = (D3DXHANDLE)&table->table[i];
 }
 
 static HRESULT d3dx9_parse_effect_typedef(struct d3dx9_base_effect *base, struct d3dx_parameter *param,
@@ -5246,7 +5391,7 @@ static HRESULT d3dx9_parse_effect_typedef(struct d3dx9_base_effect *base, struct
         {
             *ptr = save_ptr;
 
-            add_param_to_table(base, &param->members[i]);
+            param->members[i].magic_number = PARAMETER_MAGIC_NUMBER;
             hr = d3dx9_parse_effect_typedef(base, &param->members[i], data, ptr, param, flags);
             if (hr != D3D_OK)
             {
@@ -5271,7 +5416,7 @@ static HRESULT d3dx9_parse_effect_typedef(struct d3dx9_base_effect *base, struct
 
         for (i = 0; i < param->member_count; ++i)
         {
-            add_param_to_table(base, &param->members[i]);
+            param->members[i].magic_number = PARAMETER_MAGIC_NUMBER;
             hr = d3dx9_parse_effect_typedef(base, &param->members[i], data, ptr, NULL, flags);
             if (hr != D3D_OK)
             {
@@ -5429,7 +5574,7 @@ static HRESULT d3dx9_parse_effect_parameter(struct d3dx9_base_effect *base, stru
 
         for (i = 0; i < param->annotation_count; ++i)
         {
-            add_param_to_table(base, &param->annotations[i]);
+            param->annotations[i].magic_number = PARAMETER_MAGIC_NUMBER;
             hr = d3dx9_parse_effect_annotation(base, &param->annotations[i], data, ptr, objects);
             if (hr != D3D_OK)
             {
@@ -5491,7 +5636,7 @@ static HRESULT d3dx9_parse_effect_pass(struct d3dx9_base_effect *base, struct d3
 
         for (i = 0; i < pass->annotation_count; ++i)
         {
-            add_param_to_table(base, &pass->annotations[i]);
+            pass->annotations[i].magic_number = PARAMETER_MAGIC_NUMBER;
             hr = d3dx9_parse_effect_annotation(base, &pass->annotations[i], data, ptr, objects);
             if (hr != D3D_OK)
             {
@@ -5587,7 +5732,7 @@ static HRESULT d3dx9_parse_effect_technique(struct d3dx9_base_effect *base, stru
 
         for (i = 0; i < technique->annotation_count; ++i)
         {
-            add_param_to_table(base, &technique->annotations[i]);
+            technique->annotations[i].magic_number = PARAMETER_MAGIC_NUMBER;
             hr = d3dx9_parse_effect_annotation(base, &technique->annotations[i], data, ptr, objects);
             if (hr != D3D_OK)
             {
@@ -5952,7 +6097,7 @@ static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *da
 
         for (i = 0; i < base->parameter_count; ++i)
         {
-            add_param_to_table(base, &base->parameters[i]);
+            base->parameters[i].magic_number = PARAMETER_MAGIC_NUMBER;
             hr = d3dx9_parse_effect_parameter(base, &base->parameters[i], data, &ptr, base->objects);
             if (hr != D3D_OK)
             {
@@ -5985,8 +6130,6 @@ static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *da
         }
     }
 
-    sync_param_handles(base);
-
     read_dword(&ptr, &stringcount);
     TRACE("String count: %u\n", stringcount);
 
@@ -6022,8 +6165,14 @@ static HRESULT d3dx9_parse_effect(struct d3dx9_base_effect *base, const char *da
         }
     }
 
+    sync_shared_parameters(base);
     for (i = 0; i < base->parameter_count; ++i)
-        walk_parameter_tree(&base->parameters[i], param_set_dirty_flag_ptr, &base->parameters[i].rt_flags);
+    {
+        walk_parameter_tree(&base->parameters[i], param_set_dirty_flag_ptr,
+                base->parameters[i].shared_param ? &base->parameters[i].shared_param->rt_flags
+                : &base->parameters[i].rt_flags);
+        base->parameters[i].rt_flags |= PARAMETER_FLAG_TOPLEVEL;
+    }
     return D3D_OK;
 
 err_out:
@@ -6061,16 +6210,17 @@ err_out:
 
 static HRESULT d3dx9_base_effect_init(struct d3dx9_base_effect *base,
         const char *data, SIZE_T data_size, const D3D_SHADER_MACRO *defines, ID3DInclude *include,
-        UINT eflags, ID3DBlob **errors, struct ID3DXEffectImpl *effect)
+        UINT eflags, ID3DBlob **errors, struct ID3DXEffectImpl *effect, struct ID3DXEffectPoolImpl *pool)
 {
     DWORD tag, offset;
     const char *ptr = data;
     HRESULT hr;
     ID3DBlob *bytecode = NULL, *temp_errors = NULL;
 
-    TRACE("base %p, data %p, data_size %lu, effect %p\n", base, data, data_size, effect);
+    TRACE("base %p, data %p, data_size %lu, effect %p, pool %p\n", base, data, data_size, effect, pool);
 
     base->effect = effect;
+    base->pool = pool;
 
     read_dword(&ptr, &tag);
     TRACE("Tag: %x\n", tag);
@@ -6143,9 +6293,13 @@ static HRESULT d3dx9_effect_init(struct ID3DXEffectImpl *effect, struct IDirect3
         UINT eflags, ID3DBlob **error_messages, struct ID3DXEffectPool *pool)
 {
     HRESULT hr;
+    struct ID3DXEffectPoolImpl *pool_impl = NULL;
 
     TRACE("effect %p, device %p, data %p, data_size %lu, pool %p\n", effect, device, data, data_size, pool);
 
+    if (pool)
+        pool_impl = impl_from_ID3DXEffectPool(pool);
+
     effect->ID3DXEffect_iface.lpVtbl = &ID3DXEffect_Vtbl;
     effect->ref = 1;
 
@@ -6156,7 +6310,7 @@ static HRESULT d3dx9_effect_init(struct ID3DXEffectImpl *effect, struct IDirect3
     effect->device = device;
 
     if (FAILED(hr = d3dx9_base_effect_init(&effect->base_effect, data, data_size, defines, include,
-            eflags, error_messages, effect)))
+            eflags, error_messages, effect, pool_impl)))
     {
         FIXME("Failed to parse effect, hr %#x.\n", hr);
         free_effect(effect);
@@ -6243,7 +6397,7 @@ static HRESULT d3dx9_effect_compiler_init(struct ID3DXEffectCompilerImpl *compil
     compiler->ref = 1;
 
     if (FAILED(hr = d3dx9_base_effect_init(&compiler->base_effect, data, data_size, defines,
-            include, eflags, error_messages, NULL)))
+            include, eflags, error_messages, NULL, NULL)))
     {
         FIXME("Failed to parse effect, hr %#x.\n", hr);
         free_effect_compiler(compiler);
@@ -6288,17 +6442,6 @@ HRESULT WINAPI D3DXCreateEffectCompiler(const char *srcdata, UINT srcdatalen, co
     return D3D_OK;
 }
 
-struct ID3DXEffectPoolImpl
-{
-    ID3DXEffectPool ID3DXEffectPool_iface;
-    LONG ref;
-};
-
-static inline struct ID3DXEffectPoolImpl *impl_from_ID3DXEffectPool(ID3DXEffectPool *iface)
-{
-    return CONTAINING_RECORD(iface, struct ID3DXEffectPoolImpl, ID3DXEffectPool_iface);
-}
-
 /*** IUnknown methods ***/
 static HRESULT WINAPI ID3DXEffectPoolImpl_QueryInterface(ID3DXEffectPool *iface, REFIID riid, void **object)
 {
@@ -6326,16 +6469,32 @@ static ULONG WINAPI ID3DXEffectPoolImpl_AddRef(ID3DXEffectPool *iface)
     return InterlockedIncrement(&This->ref);
 }
 
+void free_effect_pool(struct ID3DXEffectPoolImpl *pool)
+{
+    unsigned int i;
+
+    for (i = 0; i < pool->parameter_count; ++i)
+    {
+        if (pool->parameters[i]->magic_number)
+            free_parameter(pool->parameters[i], FALSE, FALSE);
+        HeapFree(GetProcessHeap(), 0, pool->parameters[i]);
+        pool->parameters[i] = NULL;
+    }
+    HeapFree(GetProcessHeap(), 0, pool->parameters);
+    pool->parameters = NULL;
+
+    HeapFree(GetProcessHeap(), 0, pool);
+}
+
 static ULONG WINAPI ID3DXEffectPoolImpl_Release(ID3DXEffectPool *iface)
 {
-    struct ID3DXEffectPoolImpl *This = impl_from_ID3DXEffectPool(iface);
-    ULONG ref = InterlockedDecrement(&This->ref);
+    struct ID3DXEffectPoolImpl *pool = impl_from_ID3DXEffectPool(iface);
+    ULONG ref = InterlockedDecrement(&pool->ref);
 
-    TRACE("(%p)->(): Release from %u\n", This, ref + 1);
+    TRACE("(%p)->(): Release from %u\n", pool, ref + 1);
 
     if (!ref)
-        HeapFree(GetProcessHeap(), 0, This);
-
+        free_effect_pool(pool);
     return ref;
 }
 
--- a/dlls/d3dx9_36/tests/effect.c	
+++ a/dlls/d3dx9_36/tests/effect.c	
@@ -3356,11 +3356,11 @@ static const DWORD test_effect_preshader_effect_blob[] =
     0x00000404, 0x00000000, 0x00000000, 0x00000428, 0x00000444, 0x00000000, 0x00000000, 0x0000046c,
     0x00000488, 0x00000000, 0x00000000, 0x000004ac, 0x000004c8, 0x00000000, 0x00000000, 0x000004f0,
     0x0000050c, 0x00000000, 0x00000000, 0x00000534, 0x00000550, 0x00000000, 0x00000000, 0x00000578,
-    0x000005e4, 0x00000000, 0x00000000, 0x00000624, 0x00000690, 0x00000000, 0x00000000, 0x000006f0,
+    0x000005e4, 0x00000000, 0x00000000, 0x00000624, 0x00000690, 0x00000001, 0x00000000, 0x000006f0,
     0x00000774, 0x00000000, 0x00000000, 0x000007dc, 0x000007f8, 0x00000000, 0x00000000, 0x00000808,
-    0x00000824, 0x00000000, 0x00000000, 0x00000838, 0x0000084c, 0x00000000, 0x00000000, 0x0000085c,
+    0x00000824, 0x00000001, 0x00000000, 0x00000838, 0x0000084c, 0x00000000, 0x00000000, 0x0000085c,
     0x00000870, 0x00000000, 0x00000000, 0x00000880, 0x000008ec, 0x00000000, 0x00000000, 0x00000930,
-    0x00000944, 0x00000000, 0x00000000, 0x00000954, 0x00000968, 0x00000000, 0x00000000, 0x00000ee8,
+    0x00000944, 0x00000001, 0x00000000, 0x00000954, 0x00000968, 0x00000000, 0x00000000, 0x00000ee8,
     0x00000000, 0x00000002, 0x00000ec0, 0x00000000, 0x00000024, 0x00000092, 0x00000000, 0x0000097c,
     0x00000978, 0x00000093, 0x00000000, 0x00000994, 0x00000990, 0x00000091, 0x00000000, 0x000009ac,
     0x000009a8, 0x00000091, 0x00000001, 0x000009cc, 0x000009c8, 0x00000091, 0x00000002, 0x000009ec,
@@ -3813,45 +3813,46 @@ static const DWORD test_effect_preshader_effect_blob[] =
 #define TEST_EFFECT_PRESHADER_VSHADER_POS 2458
 #define TEST_EFFECT_PRESHADER_VSHADER_LEN 13
 
+static const D3DXVECTOR4 test_effect_preshader_fconstsv[] =
+{
+    {0.0f,   0.0f,  0.0f,  0.0f},
+    {0.0f,   0.0f,  0.0f,  0.0f},
+    {0.0f,   0.0f,  0.0f,  0.0f},
+    {1.0f,   2.0f,  3.0f,  0.0f},
+    {4.0f,   0.0f,  0.0f,  0.0f},
+    {5.0f,   6.0f,  7.0f,  8.0f},
+    {1.0f,   2.0f,  3.0f,  0.0f},
+    {4.0f,   0.0f,  0.0f,  0.0f},
+    {5.0f,   6.0f,  7.0f,  8.0f},
+    {9.0f,  10.0f, 11.0f,  0.0f},
+    {12.0f,  0.0f,  0.0f,  0.0f},
+    {13.0f, 14.0f, 15.0f, 16.0f},
+    {11.0f, 12.0f, 13.0f,  0.0f},
+    {21.0f, 22.0f, 23.0f,  0.0f},
+    {31.0f, 32.0f, 33.0f,  0.0f},
+    {41.0f, 42.0f, 43.0f,  0.0f},
+    {11.0f, 21.0f, 31.0f,  0.0f},
+    {12.0f, 22.0f, 32.0f,  0.0f},
+    {13.0f, 23.0f, 33.0f,  0.0f},
+    {14.0f, 24.0f, 34.0f,  0.0f},
+    {11.0f, 12.0f, 13.0f, 14.0f},
+    {21.0f, 22.0f, 23.0f, 24.0f},
+    {31.0f, 32.0f, 33.0f, 34.0f},
+    {11.0f, 21.0f, 31.0f, 41.0f},
+    {12.0f, 22.0f, 32.0f, 42.0f},
+    {13.0f, 23.0f, 33.0f, 43.0f},
+    {9.0f,  10.0f, 11.0f,  0.0f},
+    {12.0f,  0.0f,  0.0f,  0.0f},
+    {13.0f, 14.0f, 15.0f, 16.0f},
+    {92.0f,  0.0f,  0.0f,  0.0f},
+    {93.0f,  0.0f,  0.0f,  0.0f},
+    {0.0f,   0.0f,  0.0f,  0.0f},
+    {91.0f,  0.0f,  0.0f,  0.0f},
+    {4.0f,   5.0f,  6.0f,  7.0f},
+};
+
 static void test_effect_preshader(IDirect3DDevice9 *device)
 {
-    static const D3DXVECTOR4 test_effect_preshader_fconstsv[] =
-    {
-        {0.0f,   0.0f,  0.0f,  0.0f},
-        {0.0f,   0.0f,  0.0f,  0.0f},
-        {0.0f,   0.0f,  0.0f,  0.0f},
-        {1.0f,   2.0f,  3.0f,  0.0f},
-        {4.0f,   0.0f,  0.0f,  0.0f},
-        {5.0f,   6.0f,  7.0f,  8.0f},
-        {1.0f,   2.0f,  3.0f,  0.0f},
-        {4.0f,   0.0f,  0.0f,  0.0f},
-        {5.0f,   6.0f,  7.0f,  8.0f},
-        {9.0f,  10.0f, 11.0f,  0.0f},
-        {12.0f,  0.0f,  0.0f,  0.0f},
-        {13.0f, 14.0f, 15.0f, 16.0f},
-        {11.0f, 12.0f, 13.0f,  0.0f},
-        {21.0f, 22.0f, 23.0f,  0.0f},
-        {31.0f, 32.0f, 33.0f,  0.0f},
-        {41.0f, 42.0f, 43.0f,  0.0f},
-        {11.0f, 21.0f, 31.0f,  0.0f},
-        {12.0f, 22.0f, 32.0f,  0.0f},
-        {13.0f, 23.0f, 33.0f,  0.0f},
-        {14.0f, 24.0f, 34.0f,  0.0f},
-        {11.0f, 12.0f, 13.0f, 14.0f},
-        {21.0f, 22.0f, 23.0f, 24.0f},
-        {31.0f, 32.0f, 33.0f, 34.0f},
-        {11.0f, 21.0f, 31.0f, 41.0f},
-        {12.0f, 22.0f, 32.0f, 42.0f},
-        {13.0f, 23.0f, 33.0f, 43.0f},
-        {9.0f,  10.0f, 11.0f,  0.0f},
-        {12.0f,  0.0f,  0.0f,  0.0f},
-        {13.0f, 14.0f, 15.0f, 16.0f},
-        {92.0f,  0.0f,  0.0f,  0.0f},
-        {93.0f,  0.0f,  0.0f,  0.0f},
-        {0.0f,   0.0f,  0.0f,  0.0f},
-        {91.0f,  0.0f,  0.0f,  0.0f},
-        {4.0f,   5.0f,  6.0f,  7.0f},
-    };
     static const D3DXVECTOR4 test_effect_preshader_fconstsp[] =
     {
         {11.0f, 21.0f,  0.0f, 0.0f},
@@ -4225,12 +4226,18 @@ static void test_isparameterused_children(ID3DXEffect *effect, D3DXHANDLE tech,
     }
 }
 
-static void test_isparameterused_param_with_children(ID3DXEffect *effect, D3DXHANDLE tech, const char *name,
-        BOOL expected_result)
+static void test_isparameterused_param_with_children(ID3DXEffect *effect, ID3DXEffect *effect2, D3DXHANDLE tech,
+        const char *name, BOOL expected_result)
 {
     D3DXHANDLE param;
 
-    param = effect->lpVtbl->GetParameterByName(effect, NULL, name);
+    ok(!effect->lpVtbl->IsParameterUsed(effect, (D3DXHANDLE)name, tech) == !expected_result,
+            "Unexpected IsParameterUsed() result for %s.\n", name);
+
+    if (effect2)
+        param = effect2->lpVtbl->GetParameterByName(effect2, NULL, name);
+    else
+        param = effect->lpVtbl->GetParameterByName(effect, NULL, name);
     ok(!!param, "GetParameterByName failed for %s.\n", name);
 
     ok(!effect->lpVtbl->IsParameterUsed(effect, param, tech) == !expected_result,
@@ -4265,22 +4272,43 @@ static void test_effect_isparameterused(IDirect3DDevice9 *device)
         {"ts2", TRUE},
         {"ts3", TRUE},
     };
-    ID3DXEffect *effect;
+    ID3DXEffect *effect, *effect2;
     HRESULT hr;
     D3DXHANDLE tech;
     unsigned int i;
+    ID3DXEffectPool *pool;
+
+    hr = D3DXCreateEffectPool(&pool);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
 
     hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
-            NULL, NULL, 0, NULL, &effect, NULL);
+            NULL, NULL, 0, pool, &effect, NULL);
     ok(hr == D3D_OK, "Got result %#x.\n", hr);
 
     tech = effect->lpVtbl->GetTechniqueByName(effect, "tech0");
     ok(!!tech, "GetTechniqueByName failed.\n");
 
     for (i = 0; i < ARRAY_SIZE(check_parameters); ++i)
-        test_isparameterused_param_with_children(effect, tech, check_parameters[i].name,
+        test_isparameterused_param_with_children(effect, NULL, tech, check_parameters[i].name,
                 check_parameters[i].expected_result);
 
+    hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
+            NULL, NULL, 0, pool, &effect2, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    for (i = 0; i < ARRAY_SIZE(check_parameters); ++i)
+        test_isparameterused_param_with_children(effect, effect2, tech, check_parameters[i].name,
+                check_parameters[i].expected_result);
+
+    effect2->lpVtbl->Release(effect2);
+
+    hr = D3DXCreateEffect(device, test_effect_states_effect_blob, sizeof(test_effect_states_effect_blob),
+            NULL, NULL, 0, pool, &effect2, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    test_isparameterused_param_with_children(effect, effect2, tech, "sampler1", TRUE);
+    effect2->lpVtbl->Release(effect2);
+
     effect->lpVtbl->Release(effect);
 }
 
@@ -4386,6 +4414,170 @@ static void test_effect_commitchanges(IDirect3DDevice9 *device)
     effect->lpVtbl->Release(effect);
 }
 
+void test_effect_shared_parameters(IDirect3DDevice9 *device)
+{
+    ID3DXEffect *effect1, *effect2;
+    ID3DXEffectPool *pool;
+    HRESULT hr;
+    D3DXHANDLE param, param_child, param2, param_child2;
+    unsigned int i, passes_count, value;
+    int ivect[4];
+    static const D3DXVECTOR4 fvect_empty = {-9999.0f, -9999.0f, -9999.0f, -9999.0f};
+    D3DXVECTOR4 fvect;
+    float fval[2];
+    struct IDirect3DVertexShader9 *vshader1, *vshader2;
+
+    hr = D3DXCreateEffectPool(&pool);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
+            NULL, NULL, 0, pool, &effect2, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    effect2->lpVtbl->Release(effect2);
+    hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
+            NULL, NULL, 0, pool, &effect2, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = D3DXCreateEffect(device, test_effect_preshader_effect_blob, sizeof(test_effect_preshader_effect_blob),
+            NULL, NULL, 0, pool, &effect1, NULL);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    param = effect1->lpVtbl->GetParameterByName(effect1, NULL, "vs_arr2");
+    ok(!!param, "GetParameterByName failed.\n");
+    param_child = effect1->lpVtbl->GetParameterElement(effect1, param, 0);
+    ok(!!param_child, "GetParameterElement failed.\n");
+    hr = effect1->lpVtbl->GetVertexShader(effect1, param_child, &vshader1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    param2 = effect2->lpVtbl->GetParameterByName(effect2, NULL, "vs_arr2");
+    ok(!!param2, "GetParameterByName failed.\n");
+    param_child2 = effect2->lpVtbl->GetParameterElement(effect2, param2, 0);
+    ok(!!param_child2, "GetParameterElement failed.\n");
+    hr = effect2->lpVtbl->GetVertexShader(effect2, param_child2, &vshader2);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    ok(vshader1 == vshader2, "Shared shader objects differ.\n");
+
+    IDirect3DVertexShader9_Release(vshader1);
+    IDirect3DVertexShader9_Release(vshader2);
+
+    param = effect1->lpVtbl->GetParameterByName(effect1, NULL, "arr1");
+    ok(!!param, "GetParameterByName failed.\n");
+    param2 = effect2->lpVtbl->GetParameterByName(effect2, NULL, "arr1");
+    ok(!!param, "GetParameterByName failed.\n");
+    fval[0] = 1.0f;
+    hr = effect1->lpVtbl->SetFloatArray(effect1, param, fval, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    fval[0] = 0.0f;
+    hr = effect2->lpVtbl->GetFloatArray(effect2, param, fval, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fval[0] == 1.0f, "Unexpected value %f.\n", fval[0]);
+    fval[0] = 0.0f;
+    hr = effect2->lpVtbl->GetFloatArray(effect2, param2, fval, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fval[0] == 91.0f, "Unexpected value %f.\n", fval[0]);
+
+    hr = effect2->lpVtbl->GetFloatArray(effect2, param, fval, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fval[0] == 1.0f, "Unexpected value %f.\n", fval[0]);
+
+    param_child = effect1->lpVtbl->GetParameterElement(effect1, param, 0);
+    ok(!!param_child, "GetParameterElement failed.\n");
+    param_child2 = effect1->lpVtbl->GetParameterElement(effect2, param, 0);
+    ok(!!param_child2, "GetParameterElement failed.\n");
+    ok(param_child == param_child2, "Parameter handles do not match.\n");
+
+    trace("param %p, param_child %p, param_child2 %p.\n", param, param_child, param_child2);
+    fval[0] = 2.0f;
+    hr = effect1->lpVtbl->SetFloat(effect1, param_child, fval[0]);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    fval[0] = 0.0f;
+    hr = effect2->lpVtbl->GetFloat(effect2, param_child, &fval[0]);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fval[0] == 2.0f, "Unexpected value %f.\n", fval[0]);
+
+    param = effect1->lpVtbl->GetParameterByName(effect1, NULL, "arr2");
+    ok(!!param, "GetParameterByName failed.\n");
+    param2 = effect2->lpVtbl->GetParameterByName(effect2, NULL, "arr2");
+    ok(!!param, "GetParameterByName failed.\n");
+    ok(param != param2, "Parameter handles should differ.\n");
+    param_child = effect1->lpVtbl->GetParameterElement(effect1, param, 0);
+    ok(!!param_child, "GetParameterElement failed.\n");
+    param_child2 = effect1->lpVtbl->GetParameterElement(effect2, param2, 0);
+    ok(!!param_child2, "GetParameterElement failed.\n");
+    ok(param_child != param_child2, "Parameter handles should differ.\n");
+
+    fval[0] = 33.0f;
+    hr = effect1->lpVtbl->SetFloatArray(effect1, param, fval, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    fval[0] = 0.0f;
+    hr = effect1->lpVtbl->GetFloatArray(effect1, param, fval, 2);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fval[0] == 33.0f, "Unexpected value %f.\n", fval[0]);
+    fval[0] = 0.0f;
+    hr = effect2->lpVtbl->GetFloatArray(effect2, param2, fval, 2);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fval[0] == 33.0f, "Unexpected value %f.\n", fval[0]);
+
+    hr = effect1->lpVtbl->Begin(effect1, &passes_count, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = effect1->lpVtbl->BeginPass(effect1, 0);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 29, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fvect.x == 33.0f, "Unexpected value %f.\n", fvect.x);
+    fval[0] = 28.0f;
+    fval[1] = -1.0f;
+    hr = effect1->lpVtbl->SetFloatArray(effect2, param2, fval, 2);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect1->lpVtbl->CommitChanges(effect1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 29, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fvect.x == 28.0f, "Unexpected value %f.\n", fvect.x);
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 30, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fvect.x == -1.0f, "Unexpected value %f.\n", fvect.x);
+
+    fval[0] = -2.0f;
+    hr = effect2->lpVtbl->SetFloat(effect2, param_child2, fval[0]);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect1->lpVtbl->CommitChanges(effect1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 29, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fvect.x == -2.0f, "Unexpected value %f.\n", fvect.x);
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 30, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fvect.x == -1.0f, "Unexpected value %f.\n", fvect.x);
+
+    param2 = effect2->lpVtbl->GetParameterByName(effect2, NULL, "g_Pos1");
+    ok(!!param2, "GetParameterByName failed.\n");
+    fvect.x = fvect.y = fvect.z = fvect.w = 1111.0f;
+    hr = effect2->lpVtbl->SetVector(effect1, param2, &fvect);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect1->lpVtbl->CommitChanges(effect1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = IDirect3DDevice9_GetVertexShaderConstantF(device, 33, &fvect.x, 1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    ok(fvect.x == 4.0f && fvect.y == 5.0f && fvect.z == 6.0f && fvect.w == 7.0f,
+            "Nonshared constant changed for shared shader.\n");
+
+    hr = effect1->lpVtbl->EndPass(effect1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+    hr = effect1->lpVtbl->End(effect1);
+    ok(hr == D3D_OK, "Got result %#x.\n", hr);
+
+    effect1->lpVtbl->Release(effect1);
+    effect2->lpVtbl->Release(effect2);
+
+    pool->lpVtbl->Release(pool);
+}
 START_TEST(effect)
 {
     HWND wnd;
@@ -4430,6 +4622,7 @@ START_TEST(effect)
     test_effect_preshader_ops(device);
     test_effect_isparameterused(device);
     test_effect_commitchanges(device);
+    test_effect_shared_parameters(device);
 
     count = IDirect3DDevice9_Release(device);
     ok(count == 0, "The device was not properly freed: refcount %u\n", count);
-- 
